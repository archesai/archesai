// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.30.0
// source: executors.sql

package repositories

import (
	"context"

	"github.com/google/uuid"
)

const countExecutors = `-- name: CountExecutors :one
SELECT
  COUNT(*)
FROM
  executor
`

func (q *Queries) CountExecutors(ctx context.Context) (int64, error) {
	row := q.db.QueryRow(ctx, countExecutors)
	var count int64
	err := row.Scan(&count)
	return count, err
}

const createExecutor = `-- name: CreateExecutor :one
INSERT INTO
  executor (id, cpu_shares, dependencies, description, env, execute_code, extra_files, is_active, language, memory_mb, name, organization_id, schema_in, schema_out, timeout, version)
VALUES
  (
    $1,
    $2,
    $3,
    $4,
    $5,
    $6,
    $7,
    $8,
    $9,
    $10,
    $11,
    $12,
    $13,
    $14,
    $15,
    $16
  )
RETURNING
  id, created_at, updated_at, cpu_shares, dependencies, description, env, execute_code, extra_files, is_active, language, memory_mb, name, organization_id, schema_in, schema_out, timeout, version
`

type CreateExecutorParams struct {
	ID             uuid.UUID
	CPUShares      int32
	Dependencies   *string
	Description    string
	Env            *string
	ExecuteCode    string
	ExtraFiles     *string
	IsActive       bool
	Language       string
	MemoryMB       int32
	Name           string
	OrganizationID uuid.UUID
	SchemaIn       *string
	SchemaOut      *string
	Timeout        int32
	Version        int32
}

func (q *Queries) CreateExecutor(ctx context.Context, arg CreateExecutorParams) (Executor, error) {
	row := q.db.QueryRow(ctx, createExecutor,
		arg.ID,
		arg.CPUShares,
		arg.Dependencies,
		arg.Description,
		arg.Env,
		arg.ExecuteCode,
		arg.ExtraFiles,
		arg.IsActive,
		arg.Language,
		arg.MemoryMB,
		arg.Name,
		arg.OrganizationID,
		arg.SchemaIn,
		arg.SchemaOut,
		arg.Timeout,
		arg.Version,
	)
	var i Executor
	err := row.Scan(
		&i.ID,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.CPUShares,
		&i.Dependencies,
		&i.Description,
		&i.Env,
		&i.ExecuteCode,
		&i.ExtraFiles,
		&i.IsActive,
		&i.Language,
		&i.MemoryMB,
		&i.Name,
		&i.OrganizationID,
		&i.SchemaIn,
		&i.SchemaOut,
		&i.Timeout,
		&i.Version,
	)
	return i, err
}

const deleteExecutor = `-- name: DeleteExecutor :exec
DELETE FROM executor
WHERE
  id = $1
`

type DeleteExecutorParams struct {
	ID uuid.UUID
}

func (q *Queries) DeleteExecutor(ctx context.Context, arg DeleteExecutorParams) error {
	_, err := q.db.Exec(ctx, deleteExecutor, arg.ID)
	return err
}

const getExecutor = `-- name: GetExecutor :one
SELECT
  id, created_at, updated_at, cpu_shares, dependencies, description, env, execute_code, extra_files, is_active, language, memory_mb, name, organization_id, schema_in, schema_out, timeout, version
FROM
  executor
WHERE
  id = $1
LIMIT
  1
`

type GetExecutorParams struct {
	ID uuid.UUID
}

func (q *Queries) GetExecutor(ctx context.Context, arg GetExecutorParams) (Executor, error) {
	row := q.db.QueryRow(ctx, getExecutor, arg.ID)
	var i Executor
	err := row.Scan(
		&i.ID,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.CPUShares,
		&i.Dependencies,
		&i.Description,
		&i.Env,
		&i.ExecuteCode,
		&i.ExtraFiles,
		&i.IsActive,
		&i.Language,
		&i.MemoryMB,
		&i.Name,
		&i.OrganizationID,
		&i.SchemaIn,
		&i.SchemaOut,
		&i.Timeout,
		&i.Version,
	)
	return i, err
}

const listExecutors = `-- name: ListExecutors :many
SELECT
  id, created_at, updated_at, cpu_shares, dependencies, description, env, execute_code, extra_files, is_active, language, memory_mb, name, organization_id, schema_in, schema_out, timeout, version
FROM
  executor
ORDER BY
  created_at DESC
LIMIT
  $2
OFFSET
  $1
`

type ListExecutorsParams struct {
	Offset int32
	Limit  int32
}

func (q *Queries) ListExecutors(ctx context.Context, arg ListExecutorsParams) ([]Executor, error) {
	rows, err := q.db.Query(ctx, listExecutors, arg.Offset, arg.Limit)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Executor
	for rows.Next() {
		var i Executor
		if err := rows.Scan(
			&i.ID,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.CPUShares,
			&i.Dependencies,
			&i.Description,
			&i.Env,
			&i.ExecuteCode,
			&i.ExtraFiles,
			&i.IsActive,
			&i.Language,
			&i.MemoryMB,
			&i.Name,
			&i.OrganizationID,
			&i.SchemaIn,
			&i.SchemaOut,
			&i.Timeout,
			&i.Version,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listExecutorsByOrganization = `-- name: ListExecutorsByOrganization :many
SELECT
  id, created_at, updated_at, cpu_shares, dependencies, description, env, execute_code, extra_files, is_active, language, memory_mb, name, organization_id, schema_in, schema_out, timeout, version
FROM
  executor
WHERE
  organization_id = $1
ORDER BY
  created_at DESC
`

type ListExecutorsByOrganizationParams struct {
	OrganizationID uuid.UUID
}

func (q *Queries) ListExecutorsByOrganization(ctx context.Context, arg ListExecutorsByOrganizationParams) ([]Executor, error) {
	rows, err := q.db.Query(ctx, listExecutorsByOrganization, arg.OrganizationID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Executor
	for rows.Next() {
		var i Executor
		if err := rows.Scan(
			&i.ID,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.CPUShares,
			&i.Dependencies,
			&i.Description,
			&i.Env,
			&i.ExecuteCode,
			&i.ExtraFiles,
			&i.IsActive,
			&i.Language,
			&i.MemoryMB,
			&i.Name,
			&i.OrganizationID,
			&i.SchemaIn,
			&i.SchemaOut,
			&i.Timeout,
			&i.Version,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const updateExecutor = `-- name: UpdateExecutor :one
UPDATE executor
SET
  cpu_shares = COALESCE($1, cpu_shares),
  dependencies = COALESCE($2, dependencies),
  description = COALESCE($3, description),
  env = COALESCE($4, env),
  execute_code = COALESCE($5, execute_code),
  extra_files = COALESCE($6, extra_files),
  is_active = COALESCE($7, is_active),
  language = COALESCE($8, language),
  memory_mb = COALESCE($9, memory_mb),
  name = COALESCE($10, name),
  organization_id = COALESCE($11, organization_id),
  schema_in = COALESCE($12, schema_in),
  schema_out = COALESCE($13, schema_out),
  timeout = COALESCE($14, timeout),
  version = COALESCE($15, version)
WHERE
  id = $16
RETURNING
  id, created_at, updated_at, cpu_shares, dependencies, description, env, execute_code, extra_files, is_active, language, memory_mb, name, organization_id, schema_in, schema_out, timeout, version
`

type UpdateExecutorParams struct {
	CPUShares      *int32
	Dependencies   *string
	Description    *string
	Env            *string
	ExecuteCode    *string
	ExtraFiles     *string
	IsActive       *bool
	Language       *string
	MemoryMB       *int32
	Name           *string
	OrganizationID *uuid.UUID
	SchemaIn       *string
	SchemaOut      *string
	Timeout        *int32
	Version        *int32
	ID             uuid.UUID
}

func (q *Queries) UpdateExecutor(ctx context.Context, arg UpdateExecutorParams) (Executor, error) {
	row := q.db.QueryRow(ctx, updateExecutor,
		arg.CPUShares,
		arg.Dependencies,
		arg.Description,
		arg.Env,
		arg.ExecuteCode,
		arg.ExtraFiles,
		arg.IsActive,
		arg.Language,
		arg.MemoryMB,
		arg.Name,
		arg.OrganizationID,
		arg.SchemaIn,
		arg.SchemaOut,
		arg.Timeout,
		arg.Version,
		arg.ID,
	)
	var i Executor
	err := row.Scan(
		&i.ID,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.CPUShares,
		&i.Dependencies,
		&i.Description,
		&i.Env,
		&i.ExecuteCode,
		&i.ExtraFiles,
		&i.IsActive,
		&i.Language,
		&i.MemoryMB,
		&i.Name,
		&i.OrganizationID,
		&i.SchemaIn,
		&i.SchemaOut,
		&i.Timeout,
		&i.Version,
	)
	return i, err
}
