// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.30.0
// source: apikeys.sql

package repositories

import (
	"context"
	"time"

	"github.com/google/uuid"
)

const countAPIKeys = `-- name: CountAPIKeys :one
SELECT
  COUNT(*)
FROM
  api_key
`

func (q *Queries) CountAPIKeys(ctx context.Context) (int64, error) {
	row := q.db.QueryRow(ctx, countAPIKeys)
	var count int64
	err := row.Scan(&count)
	return count, err
}

const createAPIKey = `-- name: CreateAPIKey :one
INSERT INTO
  api_key (id, expires_at, key_hash, last_used_at, name, organization_id, prefix, rate_limit, scopes, user_id)
VALUES
  (
    $1,
    $2,
    $3,
    $4,
    $5,
    $6,
    $7,
    $8,
    $9,
    $10
  )
RETURNING
  id, created_at, updated_at, expires_at, key_hash, last_used_at, name, organization_id, prefix, rate_limit, scopes, user_id
`

type CreateAPIKeyParams struct {
	ID             uuid.UUID
	ExpiresAt      *time.Time
	KeyHash        string
	LastUsedAt     *time.Time
	Name           *string
	OrganizationID uuid.UUID
	Prefix         *string
	RateLimit      int32
	Scopes         []string
	UserID         uuid.UUID
}

func (q *Queries) CreateAPIKey(ctx context.Context, arg CreateAPIKeyParams) (APIKey, error) {
	row := q.db.QueryRow(ctx, createAPIKey,
		arg.ID,
		arg.ExpiresAt,
		arg.KeyHash,
		arg.LastUsedAt,
		arg.Name,
		arg.OrganizationID,
		arg.Prefix,
		arg.RateLimit,
		arg.Scopes,
		arg.UserID,
	)
	var i APIKey
	err := row.Scan(
		&i.ID,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.ExpiresAt,
		&i.KeyHash,
		&i.LastUsedAt,
		&i.Name,
		&i.OrganizationID,
		&i.Prefix,
		&i.RateLimit,
		&i.Scopes,
		&i.UserID,
	)
	return i, err
}

const deleteAPIKey = `-- name: DeleteAPIKey :exec
DELETE FROM api_key
WHERE
  id = $1
`

type DeleteAPIKeyParams struct {
	ID uuid.UUID
}

func (q *Queries) DeleteAPIKey(ctx context.Context, arg DeleteAPIKeyParams) error {
	_, err := q.db.Exec(ctx, deleteAPIKey, arg.ID)
	return err
}

const getAPIKey = `-- name: GetAPIKey :one
SELECT
  id, created_at, updated_at, expires_at, key_hash, last_used_at, name, organization_id, prefix, rate_limit, scopes, user_id
FROM
  api_key
WHERE
  id = $1
LIMIT
  1
`

type GetAPIKeyParams struct {
	ID uuid.UUID
}

func (q *Queries) GetAPIKey(ctx context.Context, arg GetAPIKeyParams) (APIKey, error) {
	row := q.db.QueryRow(ctx, getAPIKey, arg.ID)
	var i APIKey
	err := row.Scan(
		&i.ID,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.ExpiresAt,
		&i.KeyHash,
		&i.LastUsedAt,
		&i.Name,
		&i.OrganizationID,
		&i.Prefix,
		&i.RateLimit,
		&i.Scopes,
		&i.UserID,
	)
	return i, err
}

const listAPIKeys = `-- name: ListAPIKeys :many
SELECT
  id, created_at, updated_at, expires_at, key_hash, last_used_at, name, organization_id, prefix, rate_limit, scopes, user_id
FROM
  api_key
ORDER BY
  created_at DESC
LIMIT
  $2
OFFSET
  $1
`

type ListAPIKeysParams struct {
	Offset int32
	Limit  int32
}

func (q *Queries) ListAPIKeys(ctx context.Context, arg ListAPIKeysParams) ([]APIKey, error) {
	rows, err := q.db.Query(ctx, listAPIKeys, arg.Offset, arg.Limit)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []APIKey
	for rows.Next() {
		var i APIKey
		if err := rows.Scan(
			&i.ID,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.ExpiresAt,
			&i.KeyHash,
			&i.LastUsedAt,
			&i.Name,
			&i.OrganizationID,
			&i.Prefix,
			&i.RateLimit,
			&i.Scopes,
			&i.UserID,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const updateAPIKey = `-- name: UpdateAPIKey :one
UPDATE api_key
SET
  expires_at = COALESCE($1, expires_at),
  key_hash = COALESCE($2, key_hash),
  last_used_at = COALESCE($3, last_used_at),
  name = COALESCE($4, name),
  organization_id = COALESCE($5, organization_id),
  prefix = COALESCE($6, prefix),
  rate_limit = COALESCE($7, rate_limit),
  scopes = COALESCE($8, scopes),
  user_id = COALESCE($9, user_id)
WHERE
  id = $10
RETURNING
  id, created_at, updated_at, expires_at, key_hash, last_used_at, name, organization_id, prefix, rate_limit, scopes, user_id
`

type UpdateAPIKeyParams struct {
	ExpiresAt      *time.Time
	KeyHash        *string
	LastUsedAt     *time.Time
	Name           *string
	OrganizationID *uuid.UUID
	Prefix         *string
	RateLimit      *int32
	Scopes         []string
	UserID         *uuid.UUID
	ID             uuid.UUID
}

func (q *Queries) UpdateAPIKey(ctx context.Context, arg UpdateAPIKeyParams) (APIKey, error) {
	row := q.db.QueryRow(ctx, updateAPIKey,
		arg.ExpiresAt,
		arg.KeyHash,
		arg.LastUsedAt,
		arg.Name,
		arg.OrganizationID,
		arg.Prefix,
		arg.RateLimit,
		arg.Scopes,
		arg.UserID,
		arg.ID,
	)
	var i APIKey
	err := row.Scan(
		&i.ID,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.ExpiresAt,
		&i.KeyHash,
		&i.LastUsedAt,
		&i.Name,
		&i.OrganizationID,
		&i.Prefix,
		&i.RateLimit,
		&i.Scopes,
		&i.UserID,
	)
	return i, err
}
