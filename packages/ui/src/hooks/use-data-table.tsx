'use no memo'

import type {
  AccessorKeyColumnDef,
  PaginationState,
  RowSelectionState,
  TableOptions,
  Updater,
  VisibilityState
} from '@tanstack/react-table'

import { useCallback, useMemo, useState } from 'react'
import { getCoreRowModel, useReactTable } from '@tanstack/react-table'

import type { BaseEntity } from '@archesai/schemas'

import { DataTableColumnHeader } from '#components/datatable/components/data-table-column-header'
import { Checkbox } from '#components/shadcn/checkbox'
import { useFilterState } from '#hooks/use-filter-state'
import { toSentenceCase } from '#lib/utils'

interface useDataTableProps<TEntity extends BaseEntity>
  extends Omit<
    TableOptions<TEntity>,
    | 'getCoreRowModel'
    | 'manualFiltering'
    | 'manualPagination'
    | 'manualSorting'
    | 'onPaginationChange'
    | 'onSortingChange'
    | 'state'
  > {
  columns: AccessorKeyColumnDef<TEntity>[]
  pageCount?: number
}

export function useDataTable<TData extends BaseEntity>(
  props: useDataTableProps<TData>
) {
  const { columns, pageCount, ...tableProps } = props

  // Get filter state management
  const filterState = useFilterState<TData>()

  // Local table state
  const [rowSelection, setRowSelection] = useState<RowSelectionState>({})
  const [columnVisibility, setColumnVisibility] = useState<VisibilityState>({})

  // Convert filter state to TanStack Table format
  const pagination: PaginationState = useMemo(
    () => ({
      pageIndex: filterState.pageNumber - 1,
      pageSize: filterState.pageSize
    }),
    [filterState.pageNumber, filterState.pageSize]
  )

  const onPaginationChange = useCallback(
    (updaterOrValue: Updater<PaginationState>) => {
      if (typeof updaterOrValue === 'function') {
        const newPagination = updaterOrValue(pagination)
        filterState.setPage(newPagination.pageIndex + 1)
        filterState.setPageSize(newPagination.pageSize)
      } else {
        filterState.setPage(updaterOrValue.pageIndex + 1)
        filterState.setPageSize(updaterOrValue.pageSize)
      }
    },
    [pagination, filterState]
  )

  // Auto-generate column headers
  const autoGeneratedColumns = useMemo(
    () =>
      columns.map((column) => ({
        ...column,
        header:
          column.header ??
          (({ column: col }) => (
            <DataTableColumnHeader
              column={col}
              title={toSentenceCase(column.accessorKey.toString())}
            />
          ))
      })),
    [columns]
  )

  // Create table
  const table = useReactTable({
    ...tableProps,
    columns: [
      // Checkbox column
      {
        cell: ({ row }) => (
          <Checkbox
            aria-label='Select row'
            checked={row.getIsSelected()}
            className='translate-y-0.5'
            onCheckedChange={(value) => {
              row.toggleSelected(!!value)
            }}
          />
        ),
        enableHiding: false,
        enableSorting: false,
        header: ({ table }) => (
          <Checkbox
            aria-label='Select all'
            checked={
              table.getIsAllPageRowsSelected() ||
              (table.getIsSomePageRowsSelected() && 'indeterminate')
            }
            className='translate-y-0.5'
            onCheckedChange={(value) => {
              table.toggleAllPageRowsSelected(!!value)
            }}
          />
        ),
        id: 'select',
        size: 40
      },
      // Data columns
      ...autoGeneratedColumns
    ],
    enableRowSelection: true,
    getCoreRowModel: getCoreRowModel(),
    manualFiltering: true,
    manualPagination: true,
    manualSorting: true,
    onColumnVisibilityChange: setColumnVisibility,
    onPaginationChange,
    onRowSelectionChange: setRowSelection,
    onSortingChange: (updaterOrValue) => {
      if (typeof updaterOrValue === 'function') {
        filterState.setSorting(updaterOrValue(filterState.sorting))
      } else {
        filterState.setSorting(updaterOrValue)
      }
    },
    pageCount,
    state: {
      columnVisibility,
      pagination,
      rowSelection,
      sorting: filterState.sorting
    }
  })

  // Computed state helpers
  const computed = useMemo(
    () => ({
      hasFilters: filterState.hasFilters,
      hasSelection: Object.keys(rowSelection).length > 0,
      hasSorting: filterState.hasSorting,
      isEmpty: table.getRowModel().rows.length === 0,
      selectedRowCount: table.getSelectedRowModel().rows.length,
      totalRowCount: table.getRowCount()
    }),
    [filterState.hasFilters, filterState.hasSorting, rowSelection, table]
  )

  // Table action helpers
  const actions = useMemo(
    () => ({
      clearSelection: () => {
        table.resetRowSelection()
      },
      selectAll: () => {
        table.toggleAllRowsSelected(true)
      },
      toggleRowSelection: (rowId: string, selected?: boolean) => {
        table.getRow(rowId).toggleSelected(selected)
      }
    }),
    [table]
  )

  return {
    addCondition: filterState.addCondition,

    addGroup: filterState.addGroup,
    addSort: filterState.addSort,

    filter: filterState.filter,
    // Pagination (handled automatically)
    pageNumber: filterState.pageNumber,
    pageSize: filterState.pageSize,
    removeCondition: filterState.removeCondition,
    resetAll: filterState.resetAll,
    // Reset operations
    resetFilters: filterState.resetFilters,

    resetPagination: filterState.resetPagination,
    resetSorting: filterState.resetSorting,
    // Filter state (your SearchQuery DTO)
    searchQuery: filterState.searchQuery,
    setCondition: filterState.setCondition,

    // Filter actions
    setFilter: filterState.setFilter,
    setPage: filterState.setPage,
    setPageSize: filterState.setPageSize,

    setSorting: filterState.setSorting,
    // Sorting (handled automatically)
    sorting: filterState.sorting,
    table,
    wrapInGroup: filterState.wrapInGroup,

    // Computed state
    ...computed,

    // Table actions
    ...actions
  }
}
