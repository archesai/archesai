/**
 * Generated by orval v7.8.0 üç∫
 * Do not edit manually.
 * Arches AI API
 * The Arches AI API
 * OpenAPI spec version: v1
 */
import type {
  DataTag,
  DefinedInitialDataOptions,
  DefinedUseQueryResult,
  MutationFunction,
  QueryClient,
  QueryFunction,
  QueryKey,
  UndefinedInitialDataOptions,
  UseMutationOptions,
  UseMutationResult,
  UseQueryOptions,
  UseQueryResult
} from '@tanstack/react-query'

import { useMutation, useQuery } from '@tanstack/react-query'

import type {
  AcceptInvitation200,
  AcceptInvitation401,
  AcceptInvitation403,
  AcceptInvitation404,
  ConfirmEmailChange401,
  ConfirmEmailChange404,
  ConfirmEmailChangeBody,
  ConfirmEmailVerification401,
  ConfirmEmailVerification404,
  ConfirmEmailVerificationBody,
  ConfirmPasswordReset401,
  ConfirmPasswordReset404,
  ConfirmPasswordResetBody,
  CreateApiToken201,
  CreateApiTokenBody,
  CreateCheckoutSession200,
  CreateCheckoutSessionBody,
  CreateContent201,
  CreateContentBody,
  CreateFile201,
  CreateFileBody,
  CreateInvitation201,
  CreateInvitationBody,
  CreateLabel201,
  CreateLabelBody,
  CreateMember201,
  CreateMemberBody,
  CreateOrganization201,
  CreateOrganizationBody,
  CreatePipeline201,
  CreatePipelineBody,
  CreatePortalBody,
  CreateRun201,
  CreateRunBody,
  CreateTool201,
  CreateToolBody,
  CreateUser201,
  CreateUserBody,
  DeleteApiToken200,
  DeleteApiToken404,
  DeleteContent200,
  DeleteContent404,
  DeleteFile200,
  DeleteFile404,
  DeleteInvitation200,
  DeleteInvitation404,
  DeleteLabel200,
  DeleteLabel404,
  DeleteMember200,
  DeleteMember404,
  DeleteOrganization200,
  DeleteOrganization404,
  DeletePaymentMethod200,
  DeletePipeline200,
  DeletePipeline404,
  DeleteRun200,
  DeleteRun404,
  DeleteTool200,
  DeleteTool404,
  DeleteUser200,
  DeleteUser404,
  FindManyApiTokens200,
  FindManyApiTokensParams,
  FindManyContents200,
  FindManyContentsParams,
  FindManyFiles200,
  FindManyFilesParams,
  FindManyInvitations200,
  FindManyInvitationsParams,
  FindManyLabels200,
  FindManyLabelsParams,
  FindManyMembers200,
  FindManyMembersParams,
  FindManyOrganizations200,
  FindManyOrganizationsParams,
  FindManyPipelines200,
  FindManyPipelinesParams,
  FindManyRuns200,
  FindManyRunsParams,
  FindManyTools200,
  FindManyToolsParams,
  FindManyUsers200,
  FindManyUsersParams,
  FindOnePaymentMethod200,
  GetConfig200,
  GetOneApiToken200,
  GetOneApiToken404,
  GetOneContent200,
  GetOneContent404,
  GetOneFile200,
  GetOneFile404,
  GetOneInvitation200,
  GetOneInvitation404,
  GetOneLabel200,
  GetOneLabel404,
  GetOneMember200,
  GetOneMember404,
  GetOneOrganization200,
  GetOneOrganization404,
  GetOnePipeline200,
  GetOnePipeline404,
  GetOneRun200,
  GetOneRun404,
  GetOneTool200,
  GetOneTool404,
  GetOneUser200,
  GetOneUser404,
  GetPlans200,
  Login401,
  LoginBody,
  Logout401,
  Refresh401,
  Register401,
  RegisterBody,
  RequestEmailChangeBody,
  RequestPasswordResetBody,
  UpdateApiToken200,
  UpdateApiToken404,
  UpdateApiTokenBody,
  UpdateContent200,
  UpdateContent404,
  UpdateContentBody,
  UpdateFile200,
  UpdateFile404,
  UpdateFileBody,
  UpdateInvitation200,
  UpdateInvitation404,
  UpdateInvitationBody,
  UpdateLabel200,
  UpdateLabel404,
  UpdateLabelBody,
  UpdateMember200,
  UpdateMember404,
  UpdateMemberBody,
  UpdateOrganization200,
  UpdateOrganization404,
  UpdateOrganizationBody,
  UpdatePipeline200,
  UpdatePipeline404,
  UpdatePipelineBody,
  UpdateRun200,
  UpdateRun404,
  UpdateRunBody,
  UpdateSubscriptionBody,
  UpdateTool200,
  UpdateTool404,
  UpdateToolBody,
  UpdateUser200,
  UpdateUser404,
  UpdateUserBody
} from '#generated/orval.schemas'

type AwaitedInput<T> = PromiseLike<T> | T

type Awaited<O> = O extends AwaitedInput<infer T> ? T : never

/**
 * Get the configuration of the application
 * @summary Get the configuration
 */
export type getConfigResponse200 = {
  data: GetConfig200
  status: 200
}

export type getConfigResponseComposite = getConfigResponse200

export type getConfigResponse = getConfigResponseComposite & {
  headers: Headers
}

export const getGetConfigUrl = () => {
  return `http://0.0.0.0:3001/config`
}

export const getConfig = async (
  options?: RequestInit
): Promise<getConfigResponse> => {
  const res = await fetch(getGetConfigUrl(), {
    ...options,
    method: 'GET'
  })

  const body = [204, 205, 304].includes(res.status) ? null : await res.text()
  const data: getConfigResponse['data'] = body ? JSON.parse(body) : {}

  return { data, status: res.status, headers: res.headers } as getConfigResponse
}

export const getGetConfigQueryKey = () => {
  return [`http://0.0.0.0:3001/config`] as const
}

export const getGetConfigQueryOptions = <
  TData = Awaited<ReturnType<typeof getConfig>>,
  TError = unknown
>(options?: {
  query?: Partial<
    UseQueryOptions<Awaited<ReturnType<typeof getConfig>>, TError, TData>
  >
  fetch?: RequestInit
}) => {
  const { query: queryOptions, fetch: fetchOptions } = options ?? {}

  const queryKey = queryOptions?.queryKey ?? getGetConfigQueryKey()

  const queryFn: QueryFunction<Awaited<ReturnType<typeof getConfig>>> = ({
    signal
  }) => getConfig({ ...(signal ? { signal } : {}), ...fetchOptions })

  return { queryKey, queryFn, ...queryOptions } as UseQueryOptions<
    Awaited<ReturnType<typeof getConfig>>,
    TError,
    TData
  > & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type GetConfigQueryResult = NonNullable<
  Awaited<ReturnType<typeof getConfig>>
>
export type GetConfigQueryError = unknown

export function useGetConfig<
  TData = Awaited<ReturnType<typeof getConfig>>,
  TError = unknown
>(
  options: {
    query: Partial<
      UseQueryOptions<Awaited<ReturnType<typeof getConfig>>, TError, TData>
    > &
      Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof getConfig>>,
          TError,
          Awaited<ReturnType<typeof getConfig>>
        >,
        'initialData'
      >
    fetch?: RequestInit
  },
  queryClient?: QueryClient
): DefinedUseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>
}
export function useGetConfig<
  TData = Awaited<ReturnType<typeof getConfig>>,
  TError = unknown
>(
  options?: {
    query?: Partial<
      UseQueryOptions<Awaited<ReturnType<typeof getConfig>>, TError, TData>
    > &
      Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof getConfig>>,
          TError,
          Awaited<ReturnType<typeof getConfig>>
        >,
        'initialData'
      >
    fetch?: RequestInit
  },
  queryClient?: QueryClient
): UseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>
}
export function useGetConfig<
  TData = Awaited<ReturnType<typeof getConfig>>,
  TError = unknown
>(
  options?: {
    query?: Partial<
      UseQueryOptions<Awaited<ReturnType<typeof getConfig>>, TError, TData>
    >
    fetch?: RequestInit
  },
  queryClient?: QueryClient
): UseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>
}
/**
 * @summary Get the configuration
 */

export function useGetConfig<
  TData = Awaited<ReturnType<typeof getConfig>>,
  TError = unknown
>(
  options?: {
    query?: Partial<
      UseQueryOptions<Awaited<ReturnType<typeof getConfig>>, TError, TData>
    >
    fetch?: RequestInit
  },
  queryClient?: QueryClient
): UseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>
} {
  const queryOptions = getGetConfigQueryOptions(options)

  const query = useQuery(queryOptions, queryClient) as UseQueryResult<
    TData,
    TError
  > & { queryKey: DataTag<QueryKey, TData, TError> }

  query.queryKey = queryOptions.queryKey

  return query
}

/**
 * Create a new file
 * @summary Create a new file
 */
export type createFileResponse201 = {
  data: CreateFile201
  status: 201
}

export type createFileResponseComposite = createFileResponse201

export type createFileResponse = createFileResponseComposite & {
  headers: Headers
}

export const getCreateFileUrl = () => {
  return `http://0.0.0.0:3001/files`
}

export const createFile = async (
  createFileBody: CreateFileBody,
  options?: RequestInit
): Promise<createFileResponse> => {
  const res = await fetch(getCreateFileUrl(), {
    ...options,
    method: 'POST',
    headers: { 'Content-Type': 'application/json', ...options?.headers },
    body: JSON.stringify(createFileBody)
  })

  const body = [204, 205, 304].includes(res.status) ? null : await res.text()
  const data: createFileResponse['data'] = body ? JSON.parse(body) : {}

  return {
    data,
    status: res.status,
    headers: res.headers
  } as createFileResponse
}

export const getCreateFileMutationOptions = <
  TError = unknown,
  TContext = unknown
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof createFile>>,
    TError,
    { data: CreateFileBody },
    TContext
  >
  fetch?: RequestInit
}): UseMutationOptions<
  Awaited<ReturnType<typeof createFile>>,
  TError,
  { data: CreateFileBody },
  TContext
> => {
  const mutationKey = ['createFile']
  const { mutation: mutationOptions, fetch: fetchOptions } =
    options ?
      (
        options.mutation &&
        'mutationKey' in options.mutation &&
        options.mutation.mutationKey
      ) ?
        options
      : { ...options, mutation: { ...options.mutation, mutationKey } }
    : { mutation: { mutationKey }, fetch: undefined }

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof createFile>>,
    { data: CreateFileBody }
  > = (props) => {
    const { data } = props ?? {}

    return createFile(data, fetchOptions)
  }

  return { mutationFn, ...mutationOptions }
}

export type CreateFileMutationResult = NonNullable<
  Awaited<ReturnType<typeof createFile>>
>
export type CreateFileMutationBody = CreateFileBody
export type CreateFileMutationError = unknown

/**
 * @summary Create a new file
 */
export const useCreateFile = <TError = unknown, TContext = unknown>(
  options?: {
    mutation?: UseMutationOptions<
      Awaited<ReturnType<typeof createFile>>,
      TError,
      { data: CreateFileBody },
      TContext
    >
    fetch?: RequestInit
  },
  queryClient?: QueryClient
): UseMutationResult<
  Awaited<ReturnType<typeof createFile>>,
  TError,
  { data: CreateFileBody },
  TContext
> => {
  const mutationOptions = getCreateFileMutationOptions(options)

  return useMutation(mutationOptions, queryClient)
}

/**
 * Find many files
 * @summary Find many files
 */
export type findManyFilesResponse200 = {
  data: FindManyFiles200
  status: 200
}

export type findManyFilesResponseComposite = findManyFilesResponse200

export type findManyFilesResponse = findManyFilesResponseComposite & {
  headers: Headers
}

export const getFindManyFilesUrl = (params?: FindManyFilesParams) => {
  const normalizedParams = new URLSearchParams()

  Object.entries(params || {}).forEach(([key, value]) => {
    if (value !== undefined) {
      normalizedParams.append(key, value === null ? 'null' : value.toString())
    }
  })

  const stringifiedParams = normalizedParams.toString()

  return stringifiedParams.length > 0 ?
      `http://0.0.0.0:3001/files?${stringifiedParams}`
    : `http://0.0.0.0:3001/files`
}

export const findManyFiles = async (
  params?: FindManyFilesParams,
  options?: RequestInit
): Promise<findManyFilesResponse> => {
  const res = await fetch(getFindManyFilesUrl(params), {
    ...options,
    method: 'GET'
  })

  const body = [204, 205, 304].includes(res.status) ? null : await res.text()
  const data: findManyFilesResponse['data'] = body ? JSON.parse(body) : {}

  return {
    data,
    status: res.status,
    headers: res.headers
  } as findManyFilesResponse
}

export const getFindManyFilesQueryKey = (params?: FindManyFilesParams) => {
  return [`http://0.0.0.0:3001/files`, ...(params ? [params] : [])] as const
}

export const getFindManyFilesQueryOptions = <
  TData = Awaited<ReturnType<typeof findManyFiles>>,
  TError = unknown
>(
  params?: FindManyFilesParams,
  options?: {
    query?: Partial<
      UseQueryOptions<Awaited<ReturnType<typeof findManyFiles>>, TError, TData>
    >
    fetch?: RequestInit
  }
) => {
  const { query: queryOptions, fetch: fetchOptions } = options ?? {}

  const queryKey = queryOptions?.queryKey ?? getFindManyFilesQueryKey(params)

  const queryFn: QueryFunction<Awaited<ReturnType<typeof findManyFiles>>> = ({
    signal
  }) =>
    findManyFiles(params, { ...(signal ? { signal } : {}), ...fetchOptions })

  return { queryKey, queryFn, ...queryOptions } as UseQueryOptions<
    Awaited<ReturnType<typeof findManyFiles>>,
    TError,
    TData
  > & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type FindManyFilesQueryResult = NonNullable<
  Awaited<ReturnType<typeof findManyFiles>>
>
export type FindManyFilesQueryError = unknown

export function useFindManyFiles<
  TData = Awaited<ReturnType<typeof findManyFiles>>,
  TError = unknown
>(
  params: undefined | FindManyFilesParams,
  options: {
    query: Partial<
      UseQueryOptions<Awaited<ReturnType<typeof findManyFiles>>, TError, TData>
    > &
      Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof findManyFiles>>,
          TError,
          Awaited<ReturnType<typeof findManyFiles>>
        >,
        'initialData'
      >
    fetch?: RequestInit
  },
  queryClient?: QueryClient
): DefinedUseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>
}
export function useFindManyFiles<
  TData = Awaited<ReturnType<typeof findManyFiles>>,
  TError = unknown
>(
  params?: FindManyFilesParams,
  options?: {
    query?: Partial<
      UseQueryOptions<Awaited<ReturnType<typeof findManyFiles>>, TError, TData>
    > &
      Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof findManyFiles>>,
          TError,
          Awaited<ReturnType<typeof findManyFiles>>
        >,
        'initialData'
      >
    fetch?: RequestInit
  },
  queryClient?: QueryClient
): UseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>
}
export function useFindManyFiles<
  TData = Awaited<ReturnType<typeof findManyFiles>>,
  TError = unknown
>(
  params?: FindManyFilesParams,
  options?: {
    query?: Partial<
      UseQueryOptions<Awaited<ReturnType<typeof findManyFiles>>, TError, TData>
    >
    fetch?: RequestInit
  },
  queryClient?: QueryClient
): UseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>
}
/**
 * @summary Find many files
 */

export function useFindManyFiles<
  TData = Awaited<ReturnType<typeof findManyFiles>>,
  TError = unknown
>(
  params?: FindManyFilesParams,
  options?: {
    query?: Partial<
      UseQueryOptions<Awaited<ReturnType<typeof findManyFiles>>, TError, TData>
    >
    fetch?: RequestInit
  },
  queryClient?: QueryClient
): UseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>
} {
  const queryOptions = getFindManyFilesQueryOptions(params, options)

  const query = useQuery(queryOptions, queryClient) as UseQueryResult<
    TData,
    TError
  > & { queryKey: DataTag<QueryKey, TData, TError> }

  query.queryKey = queryOptions.queryKey

  return query
}

/**
 * Delete a file
 * @summary Delete a file
 */
export type deleteFileResponse200 = {
  data: DeleteFile200
  status: 200
}

export type deleteFileResponse404 = {
  data: DeleteFile404
  status: 404
}

export type deleteFileResponseComposite =
  | deleteFileResponse200
  | deleteFileResponse404

export type deleteFileResponse = deleteFileResponseComposite & {
  headers: Headers
}

export const getDeleteFileUrl = (id: string) => {
  return `http://0.0.0.0:3001/files/${id}`
}

export const deleteFile = async (
  id: string,
  options?: RequestInit
): Promise<deleteFileResponse> => {
  const res = await fetch(getDeleteFileUrl(id), {
    ...options,
    method: 'DELETE'
  })

  const body = [204, 205, 304].includes(res.status) ? null : await res.text()
  const data: deleteFileResponse['data'] = body ? JSON.parse(body) : {}

  return {
    data,
    status: res.status,
    headers: res.headers
  } as deleteFileResponse
}

export const getDeleteFileMutationOptions = <
  TError = DeleteFile404,
  TContext = unknown
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof deleteFile>>,
    TError,
    { id: string },
    TContext
  >
  fetch?: RequestInit
}): UseMutationOptions<
  Awaited<ReturnType<typeof deleteFile>>,
  TError,
  { id: string },
  TContext
> => {
  const mutationKey = ['deleteFile']
  const { mutation: mutationOptions, fetch: fetchOptions } =
    options ?
      (
        options.mutation &&
        'mutationKey' in options.mutation &&
        options.mutation.mutationKey
      ) ?
        options
      : { ...options, mutation: { ...options.mutation, mutationKey } }
    : { mutation: { mutationKey }, fetch: undefined }

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof deleteFile>>,
    { id: string }
  > = (props) => {
    const { id } = props ?? {}

    return deleteFile(id, fetchOptions)
  }

  return { mutationFn, ...mutationOptions }
}

export type DeleteFileMutationResult = NonNullable<
  Awaited<ReturnType<typeof deleteFile>>
>

export type DeleteFileMutationError = DeleteFile404

/**
 * @summary Delete a file
 */
export const useDeleteFile = <TError = DeleteFile404, TContext = unknown>(
  options?: {
    mutation?: UseMutationOptions<
      Awaited<ReturnType<typeof deleteFile>>,
      TError,
      { id: string },
      TContext
    >
    fetch?: RequestInit
  },
  queryClient?: QueryClient
): UseMutationResult<
  Awaited<ReturnType<typeof deleteFile>>,
  TError,
  { id: string },
  TContext
> => {
  const mutationOptions = getDeleteFileMutationOptions(options)

  return useMutation(mutationOptions, queryClient)
}

/**
 * Find a file
 * @summary Find a file
 */
export type getOneFileResponse200 = {
  data: GetOneFile200
  status: 200
}

export type getOneFileResponse404 = {
  data: GetOneFile404
  status: 404
}

export type getOneFileResponseComposite =
  | getOneFileResponse200
  | getOneFileResponse404

export type getOneFileResponse = getOneFileResponseComposite & {
  headers: Headers
}

export const getGetOneFileUrl = (id: string) => {
  return `http://0.0.0.0:3001/files/${id}`
}

export const getOneFile = async (
  id: string,
  options?: RequestInit
): Promise<getOneFileResponse> => {
  const res = await fetch(getGetOneFileUrl(id), {
    ...options,
    method: 'GET'
  })

  const body = [204, 205, 304].includes(res.status) ? null : await res.text()
  const data: getOneFileResponse['data'] = body ? JSON.parse(body) : {}

  return {
    data,
    status: res.status,
    headers: res.headers
  } as getOneFileResponse
}

export const getGetOneFileQueryKey = (id: string) => {
  return [`http://0.0.0.0:3001/files/${id}`] as const
}

export const getGetOneFileQueryOptions = <
  TData = Awaited<ReturnType<typeof getOneFile>>,
  TError = GetOneFile404
>(
  id: string,
  options?: {
    query?: Partial<
      UseQueryOptions<Awaited<ReturnType<typeof getOneFile>>, TError, TData>
    >
    fetch?: RequestInit
  }
) => {
  const { query: queryOptions, fetch: fetchOptions } = options ?? {}

  const queryKey = queryOptions?.queryKey ?? getGetOneFileQueryKey(id)

  const queryFn: QueryFunction<Awaited<ReturnType<typeof getOneFile>>> = ({
    signal
  }) => getOneFile(id, { ...(signal ? { signal } : {}), ...fetchOptions })

  return {
    queryKey,
    queryFn,
    enabled: !!id,
    ...queryOptions
  } as UseQueryOptions<
    Awaited<ReturnType<typeof getOneFile>>,
    TError,
    TData
  > & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type GetOneFileQueryResult = NonNullable<
  Awaited<ReturnType<typeof getOneFile>>
>
export type GetOneFileQueryError = GetOneFile404

export function useGetOneFile<
  TData = Awaited<ReturnType<typeof getOneFile>>,
  TError = GetOneFile404
>(
  id: string,
  options: {
    query: Partial<
      UseQueryOptions<Awaited<ReturnType<typeof getOneFile>>, TError, TData>
    > &
      Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof getOneFile>>,
          TError,
          Awaited<ReturnType<typeof getOneFile>>
        >,
        'initialData'
      >
    fetch?: RequestInit
  },
  queryClient?: QueryClient
): DefinedUseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>
}
export function useGetOneFile<
  TData = Awaited<ReturnType<typeof getOneFile>>,
  TError = GetOneFile404
>(
  id: string,
  options?: {
    query?: Partial<
      UseQueryOptions<Awaited<ReturnType<typeof getOneFile>>, TError, TData>
    > &
      Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof getOneFile>>,
          TError,
          Awaited<ReturnType<typeof getOneFile>>
        >,
        'initialData'
      >
    fetch?: RequestInit
  },
  queryClient?: QueryClient
): UseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>
}
export function useGetOneFile<
  TData = Awaited<ReturnType<typeof getOneFile>>,
  TError = GetOneFile404
>(
  id: string,
  options?: {
    query?: Partial<
      UseQueryOptions<Awaited<ReturnType<typeof getOneFile>>, TError, TData>
    >
    fetch?: RequestInit
  },
  queryClient?: QueryClient
): UseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>
}
/**
 * @summary Find a file
 */

export function useGetOneFile<
  TData = Awaited<ReturnType<typeof getOneFile>>,
  TError = GetOneFile404
>(
  id: string,
  options?: {
    query?: Partial<
      UseQueryOptions<Awaited<ReturnType<typeof getOneFile>>, TError, TData>
    >
    fetch?: RequestInit
  },
  queryClient?: QueryClient
): UseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>
} {
  const queryOptions = getGetOneFileQueryOptions(id, options)

  const query = useQuery(queryOptions, queryClient) as UseQueryResult<
    TData,
    TError
  > & { queryKey: DataTag<QueryKey, TData, TError> }

  query.queryKey = queryOptions.queryKey

  return query
}

/**
 * Update a file
 * @summary Update a file
 */
export type updateFileResponse200 = {
  data: UpdateFile200
  status: 200
}

export type updateFileResponse404 = {
  data: UpdateFile404
  status: 404
}

export type updateFileResponseComposite =
  | updateFileResponse200
  | updateFileResponse404

export type updateFileResponse = updateFileResponseComposite & {
  headers: Headers
}

export const getUpdateFileUrl = (id: string) => {
  return `http://0.0.0.0:3001/files/${id}`
}

export const updateFile = async (
  id: string,
  updateFileBody: UpdateFileBody,
  options?: RequestInit
): Promise<updateFileResponse> => {
  const res = await fetch(getUpdateFileUrl(id), {
    ...options,
    method: 'PATCH',
    headers: { 'Content-Type': 'application/json', ...options?.headers },
    body: JSON.stringify(updateFileBody)
  })

  const body = [204, 205, 304].includes(res.status) ? null : await res.text()
  const data: updateFileResponse['data'] = body ? JSON.parse(body) : {}

  return {
    data,
    status: res.status,
    headers: res.headers
  } as updateFileResponse
}

export const getUpdateFileMutationOptions = <
  TError = UpdateFile404,
  TContext = unknown
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof updateFile>>,
    TError,
    { id: string; data: UpdateFileBody },
    TContext
  >
  fetch?: RequestInit
}): UseMutationOptions<
  Awaited<ReturnType<typeof updateFile>>,
  TError,
  { id: string; data: UpdateFileBody },
  TContext
> => {
  const mutationKey = ['updateFile']
  const { mutation: mutationOptions, fetch: fetchOptions } =
    options ?
      (
        options.mutation &&
        'mutationKey' in options.mutation &&
        options.mutation.mutationKey
      ) ?
        options
      : { ...options, mutation: { ...options.mutation, mutationKey } }
    : { mutation: { mutationKey }, fetch: undefined }

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof updateFile>>,
    { id: string; data: UpdateFileBody }
  > = (props) => {
    const { id, data } = props ?? {}

    return updateFile(id, data, fetchOptions)
  }

  return { mutationFn, ...mutationOptions }
}

export type UpdateFileMutationResult = NonNullable<
  Awaited<ReturnType<typeof updateFile>>
>
export type UpdateFileMutationBody = UpdateFileBody
export type UpdateFileMutationError = UpdateFile404

/**
 * @summary Update a file
 */
export const useUpdateFile = <TError = UpdateFile404, TContext = unknown>(
  options?: {
    mutation?: UseMutationOptions<
      Awaited<ReturnType<typeof updateFile>>,
      TError,
      { id: string; data: UpdateFileBody },
      TContext
    >
    fetch?: RequestInit
  },
  queryClient?: QueryClient
): UseMutationResult<
  Awaited<ReturnType<typeof updateFile>>,
  TError,
  { id: string; data: UpdateFileBody },
  TContext
> => {
  const mutationOptions = getUpdateFileMutationOptions(options)

  return useMutation(mutationOptions, queryClient)
}

/**
 * Create a new pipeline
 * @summary Create a new pipeline
 */
export type createPipelineResponse201 = {
  data: CreatePipeline201
  status: 201
}

export type createPipelineResponseComposite = createPipelineResponse201

export type createPipelineResponse = createPipelineResponseComposite & {
  headers: Headers
}

export const getCreatePipelineUrl = () => {
  return `http://0.0.0.0:3001/pipelines`
}

export const createPipeline = async (
  createPipelineBody: CreatePipelineBody,
  options?: RequestInit
): Promise<createPipelineResponse> => {
  const res = await fetch(getCreatePipelineUrl(), {
    ...options,
    method: 'POST',
    headers: { 'Content-Type': 'application/json', ...options?.headers },
    body: JSON.stringify(createPipelineBody)
  })

  const body = [204, 205, 304].includes(res.status) ? null : await res.text()
  const data: createPipelineResponse['data'] = body ? JSON.parse(body) : {}

  return {
    data,
    status: res.status,
    headers: res.headers
  } as createPipelineResponse
}

export const getCreatePipelineMutationOptions = <
  TError = unknown,
  TContext = unknown
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof createPipeline>>,
    TError,
    { data: CreatePipelineBody },
    TContext
  >
  fetch?: RequestInit
}): UseMutationOptions<
  Awaited<ReturnType<typeof createPipeline>>,
  TError,
  { data: CreatePipelineBody },
  TContext
> => {
  const mutationKey = ['createPipeline']
  const { mutation: mutationOptions, fetch: fetchOptions } =
    options ?
      (
        options.mutation &&
        'mutationKey' in options.mutation &&
        options.mutation.mutationKey
      ) ?
        options
      : { ...options, mutation: { ...options.mutation, mutationKey } }
    : { mutation: { mutationKey }, fetch: undefined }

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof createPipeline>>,
    { data: CreatePipelineBody }
  > = (props) => {
    const { data } = props ?? {}

    return createPipeline(data, fetchOptions)
  }

  return { mutationFn, ...mutationOptions }
}

export type CreatePipelineMutationResult = NonNullable<
  Awaited<ReturnType<typeof createPipeline>>
>
export type CreatePipelineMutationBody = CreatePipelineBody
export type CreatePipelineMutationError = unknown

/**
 * @summary Create a new pipeline
 */
export const useCreatePipeline = <TError = unknown, TContext = unknown>(
  options?: {
    mutation?: UseMutationOptions<
      Awaited<ReturnType<typeof createPipeline>>,
      TError,
      { data: CreatePipelineBody },
      TContext
    >
    fetch?: RequestInit
  },
  queryClient?: QueryClient
): UseMutationResult<
  Awaited<ReturnType<typeof createPipeline>>,
  TError,
  { data: CreatePipelineBody },
  TContext
> => {
  const mutationOptions = getCreatePipelineMutationOptions(options)

  return useMutation(mutationOptions, queryClient)
}

/**
 * Find many pipelines
 * @summary Find many pipelines
 */
export type findManyPipelinesResponse200 = {
  data: FindManyPipelines200
  status: 200
}

export type findManyPipelinesResponseComposite = findManyPipelinesResponse200

export type findManyPipelinesResponse = findManyPipelinesResponseComposite & {
  headers: Headers
}

export const getFindManyPipelinesUrl = (params?: FindManyPipelinesParams) => {
  const normalizedParams = new URLSearchParams()

  Object.entries(params || {}).forEach(([key, value]) => {
    if (value !== undefined) {
      normalizedParams.append(key, value === null ? 'null' : value.toString())
    }
  })

  const stringifiedParams = normalizedParams.toString()

  return stringifiedParams.length > 0 ?
      `http://0.0.0.0:3001/pipelines?${stringifiedParams}`
    : `http://0.0.0.0:3001/pipelines`
}

export const findManyPipelines = async (
  params?: FindManyPipelinesParams,
  options?: RequestInit
): Promise<findManyPipelinesResponse> => {
  const res = await fetch(getFindManyPipelinesUrl(params), {
    ...options,
    method: 'GET'
  })

  const body = [204, 205, 304].includes(res.status) ? null : await res.text()
  const data: findManyPipelinesResponse['data'] = body ? JSON.parse(body) : {}

  return {
    data,
    status: res.status,
    headers: res.headers
  } as findManyPipelinesResponse
}

export const getFindManyPipelinesQueryKey = (
  params?: FindManyPipelinesParams
) => {
  return [`http://0.0.0.0:3001/pipelines`, ...(params ? [params] : [])] as const
}

export const getFindManyPipelinesQueryOptions = <
  TData = Awaited<ReturnType<typeof findManyPipelines>>,
  TError = unknown
>(
  params?: FindManyPipelinesParams,
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof findManyPipelines>>,
        TError,
        TData
      >
    >
    fetch?: RequestInit
  }
) => {
  const { query: queryOptions, fetch: fetchOptions } = options ?? {}

  const queryKey =
    queryOptions?.queryKey ?? getFindManyPipelinesQueryKey(params)

  const queryFn: QueryFunction<
    Awaited<ReturnType<typeof findManyPipelines>>
  > = ({ signal }) =>
    findManyPipelines(params, {
      ...(signal ? { signal } : {}),
      ...fetchOptions
    })

  return { queryKey, queryFn, ...queryOptions } as UseQueryOptions<
    Awaited<ReturnType<typeof findManyPipelines>>,
    TError,
    TData
  > & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type FindManyPipelinesQueryResult = NonNullable<
  Awaited<ReturnType<typeof findManyPipelines>>
>
export type FindManyPipelinesQueryError = unknown

export function useFindManyPipelines<
  TData = Awaited<ReturnType<typeof findManyPipelines>>,
  TError = unknown
>(
  params: undefined | FindManyPipelinesParams,
  options: {
    query: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof findManyPipelines>>,
        TError,
        TData
      >
    > &
      Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof findManyPipelines>>,
          TError,
          Awaited<ReturnType<typeof findManyPipelines>>
        >,
        'initialData'
      >
    fetch?: RequestInit
  },
  queryClient?: QueryClient
): DefinedUseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>
}
export function useFindManyPipelines<
  TData = Awaited<ReturnType<typeof findManyPipelines>>,
  TError = unknown
>(
  params?: FindManyPipelinesParams,
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof findManyPipelines>>,
        TError,
        TData
      >
    > &
      Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof findManyPipelines>>,
          TError,
          Awaited<ReturnType<typeof findManyPipelines>>
        >,
        'initialData'
      >
    fetch?: RequestInit
  },
  queryClient?: QueryClient
): UseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>
}
export function useFindManyPipelines<
  TData = Awaited<ReturnType<typeof findManyPipelines>>,
  TError = unknown
>(
  params?: FindManyPipelinesParams,
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof findManyPipelines>>,
        TError,
        TData
      >
    >
    fetch?: RequestInit
  },
  queryClient?: QueryClient
): UseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>
}
/**
 * @summary Find many pipelines
 */

export function useFindManyPipelines<
  TData = Awaited<ReturnType<typeof findManyPipelines>>,
  TError = unknown
>(
  params?: FindManyPipelinesParams,
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof findManyPipelines>>,
        TError,
        TData
      >
    >
    fetch?: RequestInit
  },
  queryClient?: QueryClient
): UseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>
} {
  const queryOptions = getFindManyPipelinesQueryOptions(params, options)

  const query = useQuery(queryOptions, queryClient) as UseQueryResult<
    TData,
    TError
  > & { queryKey: DataTag<QueryKey, TData, TError> }

  query.queryKey = queryOptions.queryKey

  return query
}

/**
 * Delete a pipeline
 * @summary Delete a pipeline
 */
export type deletePipelineResponse200 = {
  data: DeletePipeline200
  status: 200
}

export type deletePipelineResponse404 = {
  data: DeletePipeline404
  status: 404
}

export type deletePipelineResponseComposite =
  | deletePipelineResponse200
  | deletePipelineResponse404

export type deletePipelineResponse = deletePipelineResponseComposite & {
  headers: Headers
}

export const getDeletePipelineUrl = (id: string) => {
  return `http://0.0.0.0:3001/pipelines/${id}`
}

export const deletePipeline = async (
  id: string,
  options?: RequestInit
): Promise<deletePipelineResponse> => {
  const res = await fetch(getDeletePipelineUrl(id), {
    ...options,
    method: 'DELETE'
  })

  const body = [204, 205, 304].includes(res.status) ? null : await res.text()
  const data: deletePipelineResponse['data'] = body ? JSON.parse(body) : {}

  return {
    data,
    status: res.status,
    headers: res.headers
  } as deletePipelineResponse
}

export const getDeletePipelineMutationOptions = <
  TError = DeletePipeline404,
  TContext = unknown
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof deletePipeline>>,
    TError,
    { id: string },
    TContext
  >
  fetch?: RequestInit
}): UseMutationOptions<
  Awaited<ReturnType<typeof deletePipeline>>,
  TError,
  { id: string },
  TContext
> => {
  const mutationKey = ['deletePipeline']
  const { mutation: mutationOptions, fetch: fetchOptions } =
    options ?
      (
        options.mutation &&
        'mutationKey' in options.mutation &&
        options.mutation.mutationKey
      ) ?
        options
      : { ...options, mutation: { ...options.mutation, mutationKey } }
    : { mutation: { mutationKey }, fetch: undefined }

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof deletePipeline>>,
    { id: string }
  > = (props) => {
    const { id } = props ?? {}

    return deletePipeline(id, fetchOptions)
  }

  return { mutationFn, ...mutationOptions }
}

export type DeletePipelineMutationResult = NonNullable<
  Awaited<ReturnType<typeof deletePipeline>>
>

export type DeletePipelineMutationError = DeletePipeline404

/**
 * @summary Delete a pipeline
 */
export const useDeletePipeline = <
  TError = DeletePipeline404,
  TContext = unknown
>(
  options?: {
    mutation?: UseMutationOptions<
      Awaited<ReturnType<typeof deletePipeline>>,
      TError,
      { id: string },
      TContext
    >
    fetch?: RequestInit
  },
  queryClient?: QueryClient
): UseMutationResult<
  Awaited<ReturnType<typeof deletePipeline>>,
  TError,
  { id: string },
  TContext
> => {
  const mutationOptions = getDeletePipelineMutationOptions(options)

  return useMutation(mutationOptions, queryClient)
}

/**
 * Find a pipeline
 * @summary Find a pipeline
 */
export type getOnePipelineResponse200 = {
  data: GetOnePipeline200
  status: 200
}

export type getOnePipelineResponse404 = {
  data: GetOnePipeline404
  status: 404
}

export type getOnePipelineResponseComposite =
  | getOnePipelineResponse200
  | getOnePipelineResponse404

export type getOnePipelineResponse = getOnePipelineResponseComposite & {
  headers: Headers
}

export const getGetOnePipelineUrl = (id: string) => {
  return `http://0.0.0.0:3001/pipelines/${id}`
}

export const getOnePipeline = async (
  id: string,
  options?: RequestInit
): Promise<getOnePipelineResponse> => {
  const res = await fetch(getGetOnePipelineUrl(id), {
    ...options,
    method: 'GET'
  })

  const body = [204, 205, 304].includes(res.status) ? null : await res.text()
  const data: getOnePipelineResponse['data'] = body ? JSON.parse(body) : {}

  return {
    data,
    status: res.status,
    headers: res.headers
  } as getOnePipelineResponse
}

export const getGetOnePipelineQueryKey = (id: string) => {
  return [`http://0.0.0.0:3001/pipelines/${id}`] as const
}

export const getGetOnePipelineQueryOptions = <
  TData = Awaited<ReturnType<typeof getOnePipeline>>,
  TError = GetOnePipeline404
>(
  id: string,
  options?: {
    query?: Partial<
      UseQueryOptions<Awaited<ReturnType<typeof getOnePipeline>>, TError, TData>
    >
    fetch?: RequestInit
  }
) => {
  const { query: queryOptions, fetch: fetchOptions } = options ?? {}

  const queryKey = queryOptions?.queryKey ?? getGetOnePipelineQueryKey(id)

  const queryFn: QueryFunction<Awaited<ReturnType<typeof getOnePipeline>>> = ({
    signal
  }) => getOnePipeline(id, { ...(signal ? { signal } : {}), ...fetchOptions })

  return {
    queryKey,
    queryFn,
    enabled: !!id,
    ...queryOptions
  } as UseQueryOptions<
    Awaited<ReturnType<typeof getOnePipeline>>,
    TError,
    TData
  > & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type GetOnePipelineQueryResult = NonNullable<
  Awaited<ReturnType<typeof getOnePipeline>>
>
export type GetOnePipelineQueryError = GetOnePipeline404

export function useGetOnePipeline<
  TData = Awaited<ReturnType<typeof getOnePipeline>>,
  TError = GetOnePipeline404
>(
  id: string,
  options: {
    query: Partial<
      UseQueryOptions<Awaited<ReturnType<typeof getOnePipeline>>, TError, TData>
    > &
      Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof getOnePipeline>>,
          TError,
          Awaited<ReturnType<typeof getOnePipeline>>
        >,
        'initialData'
      >
    fetch?: RequestInit
  },
  queryClient?: QueryClient
): DefinedUseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>
}
export function useGetOnePipeline<
  TData = Awaited<ReturnType<typeof getOnePipeline>>,
  TError = GetOnePipeline404
>(
  id: string,
  options?: {
    query?: Partial<
      UseQueryOptions<Awaited<ReturnType<typeof getOnePipeline>>, TError, TData>
    > &
      Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof getOnePipeline>>,
          TError,
          Awaited<ReturnType<typeof getOnePipeline>>
        >,
        'initialData'
      >
    fetch?: RequestInit
  },
  queryClient?: QueryClient
): UseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>
}
export function useGetOnePipeline<
  TData = Awaited<ReturnType<typeof getOnePipeline>>,
  TError = GetOnePipeline404
>(
  id: string,
  options?: {
    query?: Partial<
      UseQueryOptions<Awaited<ReturnType<typeof getOnePipeline>>, TError, TData>
    >
    fetch?: RequestInit
  },
  queryClient?: QueryClient
): UseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>
}
/**
 * @summary Find a pipeline
 */

export function useGetOnePipeline<
  TData = Awaited<ReturnType<typeof getOnePipeline>>,
  TError = GetOnePipeline404
>(
  id: string,
  options?: {
    query?: Partial<
      UseQueryOptions<Awaited<ReturnType<typeof getOnePipeline>>, TError, TData>
    >
    fetch?: RequestInit
  },
  queryClient?: QueryClient
): UseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>
} {
  const queryOptions = getGetOnePipelineQueryOptions(id, options)

  const query = useQuery(queryOptions, queryClient) as UseQueryResult<
    TData,
    TError
  > & { queryKey: DataTag<QueryKey, TData, TError> }

  query.queryKey = queryOptions.queryKey

  return query
}

/**
 * Update a pipeline
 * @summary Update a pipeline
 */
export type updatePipelineResponse200 = {
  data: UpdatePipeline200
  status: 200
}

export type updatePipelineResponse404 = {
  data: UpdatePipeline404
  status: 404
}

export type updatePipelineResponseComposite =
  | updatePipelineResponse200
  | updatePipelineResponse404

export type updatePipelineResponse = updatePipelineResponseComposite & {
  headers: Headers
}

export const getUpdatePipelineUrl = (id: string) => {
  return `http://0.0.0.0:3001/pipelines/${id}`
}

export const updatePipeline = async (
  id: string,
  updatePipelineBody: UpdatePipelineBody,
  options?: RequestInit
): Promise<updatePipelineResponse> => {
  const res = await fetch(getUpdatePipelineUrl(id), {
    ...options,
    method: 'PATCH',
    headers: { 'Content-Type': 'application/json', ...options?.headers },
    body: JSON.stringify(updatePipelineBody)
  })

  const body = [204, 205, 304].includes(res.status) ? null : await res.text()
  const data: updatePipelineResponse['data'] = body ? JSON.parse(body) : {}

  return {
    data,
    status: res.status,
    headers: res.headers
  } as updatePipelineResponse
}

export const getUpdatePipelineMutationOptions = <
  TError = UpdatePipeline404,
  TContext = unknown
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof updatePipeline>>,
    TError,
    { id: string; data: UpdatePipelineBody },
    TContext
  >
  fetch?: RequestInit
}): UseMutationOptions<
  Awaited<ReturnType<typeof updatePipeline>>,
  TError,
  { id: string; data: UpdatePipelineBody },
  TContext
> => {
  const mutationKey = ['updatePipeline']
  const { mutation: mutationOptions, fetch: fetchOptions } =
    options ?
      (
        options.mutation &&
        'mutationKey' in options.mutation &&
        options.mutation.mutationKey
      ) ?
        options
      : { ...options, mutation: { ...options.mutation, mutationKey } }
    : { mutation: { mutationKey }, fetch: undefined }

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof updatePipeline>>,
    { id: string; data: UpdatePipelineBody }
  > = (props) => {
    const { id, data } = props ?? {}

    return updatePipeline(id, data, fetchOptions)
  }

  return { mutationFn, ...mutationOptions }
}

export type UpdatePipelineMutationResult = NonNullable<
  Awaited<ReturnType<typeof updatePipeline>>
>
export type UpdatePipelineMutationBody = UpdatePipelineBody
export type UpdatePipelineMutationError = UpdatePipeline404

/**
 * @summary Update a pipeline
 */
export const useUpdatePipeline = <
  TError = UpdatePipeline404,
  TContext = unknown
>(
  options?: {
    mutation?: UseMutationOptions<
      Awaited<ReturnType<typeof updatePipeline>>,
      TError,
      { id: string; data: UpdatePipelineBody },
      TContext
    >
    fetch?: RequestInit
  },
  queryClient?: QueryClient
): UseMutationResult<
  Awaited<ReturnType<typeof updatePipeline>>,
  TError,
  { id: string; data: UpdatePipelineBody },
  TContext
> => {
  const mutationOptions = getUpdatePipelineMutationOptions(options)

  return useMutation(mutationOptions, queryClient)
}

/**
 * Create a new tool
 * @summary Create a new tool
 */
export type createToolResponse201 = {
  data: CreateTool201
  status: 201
}

export type createToolResponseComposite = createToolResponse201

export type createToolResponse = createToolResponseComposite & {
  headers: Headers
}

export const getCreateToolUrl = () => {
  return `http://0.0.0.0:3001/tools`
}

export const createTool = async (
  createToolBody: CreateToolBody,
  options?: RequestInit
): Promise<createToolResponse> => {
  const res = await fetch(getCreateToolUrl(), {
    ...options,
    method: 'POST',
    headers: { 'Content-Type': 'application/json', ...options?.headers },
    body: JSON.stringify(createToolBody)
  })

  const body = [204, 205, 304].includes(res.status) ? null : await res.text()
  const data: createToolResponse['data'] = body ? JSON.parse(body) : {}

  return {
    data,
    status: res.status,
    headers: res.headers
  } as createToolResponse
}

export const getCreateToolMutationOptions = <
  TError = unknown,
  TContext = unknown
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof createTool>>,
    TError,
    { data: CreateToolBody },
    TContext
  >
  fetch?: RequestInit
}): UseMutationOptions<
  Awaited<ReturnType<typeof createTool>>,
  TError,
  { data: CreateToolBody },
  TContext
> => {
  const mutationKey = ['createTool']
  const { mutation: mutationOptions, fetch: fetchOptions } =
    options ?
      (
        options.mutation &&
        'mutationKey' in options.mutation &&
        options.mutation.mutationKey
      ) ?
        options
      : { ...options, mutation: { ...options.mutation, mutationKey } }
    : { mutation: { mutationKey }, fetch: undefined }

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof createTool>>,
    { data: CreateToolBody }
  > = (props) => {
    const { data } = props ?? {}

    return createTool(data, fetchOptions)
  }

  return { mutationFn, ...mutationOptions }
}

export type CreateToolMutationResult = NonNullable<
  Awaited<ReturnType<typeof createTool>>
>
export type CreateToolMutationBody = CreateToolBody
export type CreateToolMutationError = unknown

/**
 * @summary Create a new tool
 */
export const useCreateTool = <TError = unknown, TContext = unknown>(
  options?: {
    mutation?: UseMutationOptions<
      Awaited<ReturnType<typeof createTool>>,
      TError,
      { data: CreateToolBody },
      TContext
    >
    fetch?: RequestInit
  },
  queryClient?: QueryClient
): UseMutationResult<
  Awaited<ReturnType<typeof createTool>>,
  TError,
  { data: CreateToolBody },
  TContext
> => {
  const mutationOptions = getCreateToolMutationOptions(options)

  return useMutation(mutationOptions, queryClient)
}

/**
 * Find many tools
 * @summary Find many tools
 */
export type findManyToolsResponse200 = {
  data: FindManyTools200
  status: 200
}

export type findManyToolsResponseComposite = findManyToolsResponse200

export type findManyToolsResponse = findManyToolsResponseComposite & {
  headers: Headers
}

export const getFindManyToolsUrl = (params?: FindManyToolsParams) => {
  const normalizedParams = new URLSearchParams()

  Object.entries(params || {}).forEach(([key, value]) => {
    if (value !== undefined) {
      normalizedParams.append(key, value === null ? 'null' : value.toString())
    }
  })

  const stringifiedParams = normalizedParams.toString()

  return stringifiedParams.length > 0 ?
      `http://0.0.0.0:3001/tools?${stringifiedParams}`
    : `http://0.0.0.0:3001/tools`
}

export const findManyTools = async (
  params?: FindManyToolsParams,
  options?: RequestInit
): Promise<findManyToolsResponse> => {
  const res = await fetch(getFindManyToolsUrl(params), {
    ...options,
    method: 'GET'
  })

  const body = [204, 205, 304].includes(res.status) ? null : await res.text()
  const data: findManyToolsResponse['data'] = body ? JSON.parse(body) : {}

  return {
    data,
    status: res.status,
    headers: res.headers
  } as findManyToolsResponse
}

export const getFindManyToolsQueryKey = (params?: FindManyToolsParams) => {
  return [`http://0.0.0.0:3001/tools`, ...(params ? [params] : [])] as const
}

export const getFindManyToolsQueryOptions = <
  TData = Awaited<ReturnType<typeof findManyTools>>,
  TError = unknown
>(
  params?: FindManyToolsParams,
  options?: {
    query?: Partial<
      UseQueryOptions<Awaited<ReturnType<typeof findManyTools>>, TError, TData>
    >
    fetch?: RequestInit
  }
) => {
  const { query: queryOptions, fetch: fetchOptions } = options ?? {}

  const queryKey = queryOptions?.queryKey ?? getFindManyToolsQueryKey(params)

  const queryFn: QueryFunction<Awaited<ReturnType<typeof findManyTools>>> = ({
    signal
  }) =>
    findManyTools(params, { ...(signal ? { signal } : {}), ...fetchOptions })

  return { queryKey, queryFn, ...queryOptions } as UseQueryOptions<
    Awaited<ReturnType<typeof findManyTools>>,
    TError,
    TData
  > & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type FindManyToolsQueryResult = NonNullable<
  Awaited<ReturnType<typeof findManyTools>>
>
export type FindManyToolsQueryError = unknown

export function useFindManyTools<
  TData = Awaited<ReturnType<typeof findManyTools>>,
  TError = unknown
>(
  params: undefined | FindManyToolsParams,
  options: {
    query: Partial<
      UseQueryOptions<Awaited<ReturnType<typeof findManyTools>>, TError, TData>
    > &
      Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof findManyTools>>,
          TError,
          Awaited<ReturnType<typeof findManyTools>>
        >,
        'initialData'
      >
    fetch?: RequestInit
  },
  queryClient?: QueryClient
): DefinedUseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>
}
export function useFindManyTools<
  TData = Awaited<ReturnType<typeof findManyTools>>,
  TError = unknown
>(
  params?: FindManyToolsParams,
  options?: {
    query?: Partial<
      UseQueryOptions<Awaited<ReturnType<typeof findManyTools>>, TError, TData>
    > &
      Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof findManyTools>>,
          TError,
          Awaited<ReturnType<typeof findManyTools>>
        >,
        'initialData'
      >
    fetch?: RequestInit
  },
  queryClient?: QueryClient
): UseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>
}
export function useFindManyTools<
  TData = Awaited<ReturnType<typeof findManyTools>>,
  TError = unknown
>(
  params?: FindManyToolsParams,
  options?: {
    query?: Partial<
      UseQueryOptions<Awaited<ReturnType<typeof findManyTools>>, TError, TData>
    >
    fetch?: RequestInit
  },
  queryClient?: QueryClient
): UseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>
}
/**
 * @summary Find many tools
 */

export function useFindManyTools<
  TData = Awaited<ReturnType<typeof findManyTools>>,
  TError = unknown
>(
  params?: FindManyToolsParams,
  options?: {
    query?: Partial<
      UseQueryOptions<Awaited<ReturnType<typeof findManyTools>>, TError, TData>
    >
    fetch?: RequestInit
  },
  queryClient?: QueryClient
): UseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>
} {
  const queryOptions = getFindManyToolsQueryOptions(params, options)

  const query = useQuery(queryOptions, queryClient) as UseQueryResult<
    TData,
    TError
  > & { queryKey: DataTag<QueryKey, TData, TError> }

  query.queryKey = queryOptions.queryKey

  return query
}

/**
 * Delete a tool
 * @summary Delete a tool
 */
export type deleteToolResponse200 = {
  data: DeleteTool200
  status: 200
}

export type deleteToolResponse404 = {
  data: DeleteTool404
  status: 404
}

export type deleteToolResponseComposite =
  | deleteToolResponse200
  | deleteToolResponse404

export type deleteToolResponse = deleteToolResponseComposite & {
  headers: Headers
}

export const getDeleteToolUrl = (id: string) => {
  return `http://0.0.0.0:3001/tools/${id}`
}

export const deleteTool = async (
  id: string,
  options?: RequestInit
): Promise<deleteToolResponse> => {
  const res = await fetch(getDeleteToolUrl(id), {
    ...options,
    method: 'DELETE'
  })

  const body = [204, 205, 304].includes(res.status) ? null : await res.text()
  const data: deleteToolResponse['data'] = body ? JSON.parse(body) : {}

  return {
    data,
    status: res.status,
    headers: res.headers
  } as deleteToolResponse
}

export const getDeleteToolMutationOptions = <
  TError = DeleteTool404,
  TContext = unknown
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof deleteTool>>,
    TError,
    { id: string },
    TContext
  >
  fetch?: RequestInit
}): UseMutationOptions<
  Awaited<ReturnType<typeof deleteTool>>,
  TError,
  { id: string },
  TContext
> => {
  const mutationKey = ['deleteTool']
  const { mutation: mutationOptions, fetch: fetchOptions } =
    options ?
      (
        options.mutation &&
        'mutationKey' in options.mutation &&
        options.mutation.mutationKey
      ) ?
        options
      : { ...options, mutation: { ...options.mutation, mutationKey } }
    : { mutation: { mutationKey }, fetch: undefined }

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof deleteTool>>,
    { id: string }
  > = (props) => {
    const { id } = props ?? {}

    return deleteTool(id, fetchOptions)
  }

  return { mutationFn, ...mutationOptions }
}

export type DeleteToolMutationResult = NonNullable<
  Awaited<ReturnType<typeof deleteTool>>
>

export type DeleteToolMutationError = DeleteTool404

/**
 * @summary Delete a tool
 */
export const useDeleteTool = <TError = DeleteTool404, TContext = unknown>(
  options?: {
    mutation?: UseMutationOptions<
      Awaited<ReturnType<typeof deleteTool>>,
      TError,
      { id: string },
      TContext
    >
    fetch?: RequestInit
  },
  queryClient?: QueryClient
): UseMutationResult<
  Awaited<ReturnType<typeof deleteTool>>,
  TError,
  { id: string },
  TContext
> => {
  const mutationOptions = getDeleteToolMutationOptions(options)

  return useMutation(mutationOptions, queryClient)
}

/**
 * Find a tool
 * @summary Find a tool
 */
export type getOneToolResponse200 = {
  data: GetOneTool200
  status: 200
}

export type getOneToolResponse404 = {
  data: GetOneTool404
  status: 404
}

export type getOneToolResponseComposite =
  | getOneToolResponse200
  | getOneToolResponse404

export type getOneToolResponse = getOneToolResponseComposite & {
  headers: Headers
}

export const getGetOneToolUrl = (id: string) => {
  return `http://0.0.0.0:3001/tools/${id}`
}

export const getOneTool = async (
  id: string,
  options?: RequestInit
): Promise<getOneToolResponse> => {
  const res = await fetch(getGetOneToolUrl(id), {
    ...options,
    method: 'GET'
  })

  const body = [204, 205, 304].includes(res.status) ? null : await res.text()
  const data: getOneToolResponse['data'] = body ? JSON.parse(body) : {}

  return {
    data,
    status: res.status,
    headers: res.headers
  } as getOneToolResponse
}

export const getGetOneToolQueryKey = (id: string) => {
  return [`http://0.0.0.0:3001/tools/${id}`] as const
}

export const getGetOneToolQueryOptions = <
  TData = Awaited<ReturnType<typeof getOneTool>>,
  TError = GetOneTool404
>(
  id: string,
  options?: {
    query?: Partial<
      UseQueryOptions<Awaited<ReturnType<typeof getOneTool>>, TError, TData>
    >
    fetch?: RequestInit
  }
) => {
  const { query: queryOptions, fetch: fetchOptions } = options ?? {}

  const queryKey = queryOptions?.queryKey ?? getGetOneToolQueryKey(id)

  const queryFn: QueryFunction<Awaited<ReturnType<typeof getOneTool>>> = ({
    signal
  }) => getOneTool(id, { ...(signal ? { signal } : {}), ...fetchOptions })

  return {
    queryKey,
    queryFn,
    enabled: !!id,
    ...queryOptions
  } as UseQueryOptions<
    Awaited<ReturnType<typeof getOneTool>>,
    TError,
    TData
  > & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type GetOneToolQueryResult = NonNullable<
  Awaited<ReturnType<typeof getOneTool>>
>
export type GetOneToolQueryError = GetOneTool404

export function useGetOneTool<
  TData = Awaited<ReturnType<typeof getOneTool>>,
  TError = GetOneTool404
>(
  id: string,
  options: {
    query: Partial<
      UseQueryOptions<Awaited<ReturnType<typeof getOneTool>>, TError, TData>
    > &
      Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof getOneTool>>,
          TError,
          Awaited<ReturnType<typeof getOneTool>>
        >,
        'initialData'
      >
    fetch?: RequestInit
  },
  queryClient?: QueryClient
): DefinedUseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>
}
export function useGetOneTool<
  TData = Awaited<ReturnType<typeof getOneTool>>,
  TError = GetOneTool404
>(
  id: string,
  options?: {
    query?: Partial<
      UseQueryOptions<Awaited<ReturnType<typeof getOneTool>>, TError, TData>
    > &
      Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof getOneTool>>,
          TError,
          Awaited<ReturnType<typeof getOneTool>>
        >,
        'initialData'
      >
    fetch?: RequestInit
  },
  queryClient?: QueryClient
): UseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>
}
export function useGetOneTool<
  TData = Awaited<ReturnType<typeof getOneTool>>,
  TError = GetOneTool404
>(
  id: string,
  options?: {
    query?: Partial<
      UseQueryOptions<Awaited<ReturnType<typeof getOneTool>>, TError, TData>
    >
    fetch?: RequestInit
  },
  queryClient?: QueryClient
): UseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>
}
/**
 * @summary Find a tool
 */

export function useGetOneTool<
  TData = Awaited<ReturnType<typeof getOneTool>>,
  TError = GetOneTool404
>(
  id: string,
  options?: {
    query?: Partial<
      UseQueryOptions<Awaited<ReturnType<typeof getOneTool>>, TError, TData>
    >
    fetch?: RequestInit
  },
  queryClient?: QueryClient
): UseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>
} {
  const queryOptions = getGetOneToolQueryOptions(id, options)

  const query = useQuery(queryOptions, queryClient) as UseQueryResult<
    TData,
    TError
  > & { queryKey: DataTag<QueryKey, TData, TError> }

  query.queryKey = queryOptions.queryKey

  return query
}

/**
 * Update a tool
 * @summary Update a tool
 */
export type updateToolResponse200 = {
  data: UpdateTool200
  status: 200
}

export type updateToolResponse404 = {
  data: UpdateTool404
  status: 404
}

export type updateToolResponseComposite =
  | updateToolResponse200
  | updateToolResponse404

export type updateToolResponse = updateToolResponseComposite & {
  headers: Headers
}

export const getUpdateToolUrl = (id: string) => {
  return `http://0.0.0.0:3001/tools/${id}`
}

export const updateTool = async (
  id: string,
  updateToolBody: UpdateToolBody,
  options?: RequestInit
): Promise<updateToolResponse> => {
  const res = await fetch(getUpdateToolUrl(id), {
    ...options,
    method: 'PATCH',
    headers: { 'Content-Type': 'application/json', ...options?.headers },
    body: JSON.stringify(updateToolBody)
  })

  const body = [204, 205, 304].includes(res.status) ? null : await res.text()
  const data: updateToolResponse['data'] = body ? JSON.parse(body) : {}

  return {
    data,
    status: res.status,
    headers: res.headers
  } as updateToolResponse
}

export const getUpdateToolMutationOptions = <
  TError = UpdateTool404,
  TContext = unknown
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof updateTool>>,
    TError,
    { id: string; data: UpdateToolBody },
    TContext
  >
  fetch?: RequestInit
}): UseMutationOptions<
  Awaited<ReturnType<typeof updateTool>>,
  TError,
  { id: string; data: UpdateToolBody },
  TContext
> => {
  const mutationKey = ['updateTool']
  const { mutation: mutationOptions, fetch: fetchOptions } =
    options ?
      (
        options.mutation &&
        'mutationKey' in options.mutation &&
        options.mutation.mutationKey
      ) ?
        options
      : { ...options, mutation: { ...options.mutation, mutationKey } }
    : { mutation: { mutationKey }, fetch: undefined }

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof updateTool>>,
    { id: string; data: UpdateToolBody }
  > = (props) => {
    const { id, data } = props ?? {}

    return updateTool(id, data, fetchOptions)
  }

  return { mutationFn, ...mutationOptions }
}

export type UpdateToolMutationResult = NonNullable<
  Awaited<ReturnType<typeof updateTool>>
>
export type UpdateToolMutationBody = UpdateToolBody
export type UpdateToolMutationError = UpdateTool404

/**
 * @summary Update a tool
 */
export const useUpdateTool = <TError = UpdateTool404, TContext = unknown>(
  options?: {
    mutation?: UseMutationOptions<
      Awaited<ReturnType<typeof updateTool>>,
      TError,
      { id: string; data: UpdateToolBody },
      TContext
    >
    fetch?: RequestInit
  },
  queryClient?: QueryClient
): UseMutationResult<
  Awaited<ReturnType<typeof updateTool>>,
  TError,
  { id: string; data: UpdateToolBody },
  TContext
> => {
  const mutationOptions = getUpdateToolMutationOptions(options)

  return useMutation(mutationOptions, queryClient)
}

/**
 * Create a new content
 * @summary Create a new content
 */
export type createContentResponse201 = {
  data: CreateContent201
  status: 201
}

export type createContentResponseComposite = createContentResponse201

export type createContentResponse = createContentResponseComposite & {
  headers: Headers
}

export const getCreateContentUrl = () => {
  return `http://0.0.0.0:3001/contents`
}

export const createContent = async (
  createContentBody: CreateContentBody,
  options?: RequestInit
): Promise<createContentResponse> => {
  const res = await fetch(getCreateContentUrl(), {
    ...options,
    method: 'POST',
    headers: { 'Content-Type': 'application/json', ...options?.headers },
    body: JSON.stringify(createContentBody)
  })

  const body = [204, 205, 304].includes(res.status) ? null : await res.text()
  const data: createContentResponse['data'] = body ? JSON.parse(body) : {}

  return {
    data,
    status: res.status,
    headers: res.headers
  } as createContentResponse
}

export const getCreateContentMutationOptions = <
  TError = unknown,
  TContext = unknown
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof createContent>>,
    TError,
    { data: CreateContentBody },
    TContext
  >
  fetch?: RequestInit
}): UseMutationOptions<
  Awaited<ReturnType<typeof createContent>>,
  TError,
  { data: CreateContentBody },
  TContext
> => {
  const mutationKey = ['createContent']
  const { mutation: mutationOptions, fetch: fetchOptions } =
    options ?
      (
        options.mutation &&
        'mutationKey' in options.mutation &&
        options.mutation.mutationKey
      ) ?
        options
      : { ...options, mutation: { ...options.mutation, mutationKey } }
    : { mutation: { mutationKey }, fetch: undefined }

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof createContent>>,
    { data: CreateContentBody }
  > = (props) => {
    const { data } = props ?? {}

    return createContent(data, fetchOptions)
  }

  return { mutationFn, ...mutationOptions }
}

export type CreateContentMutationResult = NonNullable<
  Awaited<ReturnType<typeof createContent>>
>
export type CreateContentMutationBody = CreateContentBody
export type CreateContentMutationError = unknown

/**
 * @summary Create a new content
 */
export const useCreateContent = <TError = unknown, TContext = unknown>(
  options?: {
    mutation?: UseMutationOptions<
      Awaited<ReturnType<typeof createContent>>,
      TError,
      { data: CreateContentBody },
      TContext
    >
    fetch?: RequestInit
  },
  queryClient?: QueryClient
): UseMutationResult<
  Awaited<ReturnType<typeof createContent>>,
  TError,
  { data: CreateContentBody },
  TContext
> => {
  const mutationOptions = getCreateContentMutationOptions(options)

  return useMutation(mutationOptions, queryClient)
}

/**
 * Find many contents
 * @summary Find many contents
 */
export type findManyContentsResponse200 = {
  data: FindManyContents200
  status: 200
}

export type findManyContentsResponseComposite = findManyContentsResponse200

export type findManyContentsResponse = findManyContentsResponseComposite & {
  headers: Headers
}

export const getFindManyContentsUrl = (params?: FindManyContentsParams) => {
  const normalizedParams = new URLSearchParams()

  Object.entries(params || {}).forEach(([key, value]) => {
    if (value !== undefined) {
      normalizedParams.append(key, value === null ? 'null' : value.toString())
    }
  })

  const stringifiedParams = normalizedParams.toString()

  return stringifiedParams.length > 0 ?
      `http://0.0.0.0:3001/contents?${stringifiedParams}`
    : `http://0.0.0.0:3001/contents`
}

export const findManyContents = async (
  params?: FindManyContentsParams,
  options?: RequestInit
): Promise<findManyContentsResponse> => {
  const res = await fetch(getFindManyContentsUrl(params), {
    ...options,
    method: 'GET'
  })

  const body = [204, 205, 304].includes(res.status) ? null : await res.text()
  const data: findManyContentsResponse['data'] = body ? JSON.parse(body) : {}

  return {
    data,
    status: res.status,
    headers: res.headers
  } as findManyContentsResponse
}

export const getFindManyContentsQueryKey = (
  params?: FindManyContentsParams
) => {
  return [`http://0.0.0.0:3001/contents`, ...(params ? [params] : [])] as const
}

export const getFindManyContentsQueryOptions = <
  TData = Awaited<ReturnType<typeof findManyContents>>,
  TError = unknown
>(
  params?: FindManyContentsParams,
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof findManyContents>>,
        TError,
        TData
      >
    >
    fetch?: RequestInit
  }
) => {
  const { query: queryOptions, fetch: fetchOptions } = options ?? {}

  const queryKey = queryOptions?.queryKey ?? getFindManyContentsQueryKey(params)

  const queryFn: QueryFunction<
    Awaited<ReturnType<typeof findManyContents>>
  > = ({ signal }) =>
    findManyContents(params, { ...(signal ? { signal } : {}), ...fetchOptions })

  return { queryKey, queryFn, ...queryOptions } as UseQueryOptions<
    Awaited<ReturnType<typeof findManyContents>>,
    TError,
    TData
  > & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type FindManyContentsQueryResult = NonNullable<
  Awaited<ReturnType<typeof findManyContents>>
>
export type FindManyContentsQueryError = unknown

export function useFindManyContents<
  TData = Awaited<ReturnType<typeof findManyContents>>,
  TError = unknown
>(
  params: undefined | FindManyContentsParams,
  options: {
    query: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof findManyContents>>,
        TError,
        TData
      >
    > &
      Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof findManyContents>>,
          TError,
          Awaited<ReturnType<typeof findManyContents>>
        >,
        'initialData'
      >
    fetch?: RequestInit
  },
  queryClient?: QueryClient
): DefinedUseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>
}
export function useFindManyContents<
  TData = Awaited<ReturnType<typeof findManyContents>>,
  TError = unknown
>(
  params?: FindManyContentsParams,
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof findManyContents>>,
        TError,
        TData
      >
    > &
      Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof findManyContents>>,
          TError,
          Awaited<ReturnType<typeof findManyContents>>
        >,
        'initialData'
      >
    fetch?: RequestInit
  },
  queryClient?: QueryClient
): UseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>
}
export function useFindManyContents<
  TData = Awaited<ReturnType<typeof findManyContents>>,
  TError = unknown
>(
  params?: FindManyContentsParams,
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof findManyContents>>,
        TError,
        TData
      >
    >
    fetch?: RequestInit
  },
  queryClient?: QueryClient
): UseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>
}
/**
 * @summary Find many contents
 */

export function useFindManyContents<
  TData = Awaited<ReturnType<typeof findManyContents>>,
  TError = unknown
>(
  params?: FindManyContentsParams,
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof findManyContents>>,
        TError,
        TData
      >
    >
    fetch?: RequestInit
  },
  queryClient?: QueryClient
): UseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>
} {
  const queryOptions = getFindManyContentsQueryOptions(params, options)

  const query = useQuery(queryOptions, queryClient) as UseQueryResult<
    TData,
    TError
  > & { queryKey: DataTag<QueryKey, TData, TError> }

  query.queryKey = queryOptions.queryKey

  return query
}

/**
 * Delete a content
 * @summary Delete a content
 */
export type deleteContentResponse200 = {
  data: DeleteContent200
  status: 200
}

export type deleteContentResponse404 = {
  data: DeleteContent404
  status: 404
}

export type deleteContentResponseComposite =
  | deleteContentResponse200
  | deleteContentResponse404

export type deleteContentResponse = deleteContentResponseComposite & {
  headers: Headers
}

export const getDeleteContentUrl = (id: string) => {
  return `http://0.0.0.0:3001/contents/${id}`
}

export const deleteContent = async (
  id: string,
  options?: RequestInit
): Promise<deleteContentResponse> => {
  const res = await fetch(getDeleteContentUrl(id), {
    ...options,
    method: 'DELETE'
  })

  const body = [204, 205, 304].includes(res.status) ? null : await res.text()
  const data: deleteContentResponse['data'] = body ? JSON.parse(body) : {}

  return {
    data,
    status: res.status,
    headers: res.headers
  } as deleteContentResponse
}

export const getDeleteContentMutationOptions = <
  TError = DeleteContent404,
  TContext = unknown
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof deleteContent>>,
    TError,
    { id: string },
    TContext
  >
  fetch?: RequestInit
}): UseMutationOptions<
  Awaited<ReturnType<typeof deleteContent>>,
  TError,
  { id: string },
  TContext
> => {
  const mutationKey = ['deleteContent']
  const { mutation: mutationOptions, fetch: fetchOptions } =
    options ?
      (
        options.mutation &&
        'mutationKey' in options.mutation &&
        options.mutation.mutationKey
      ) ?
        options
      : { ...options, mutation: { ...options.mutation, mutationKey } }
    : { mutation: { mutationKey }, fetch: undefined }

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof deleteContent>>,
    { id: string }
  > = (props) => {
    const { id } = props ?? {}

    return deleteContent(id, fetchOptions)
  }

  return { mutationFn, ...mutationOptions }
}

export type DeleteContentMutationResult = NonNullable<
  Awaited<ReturnType<typeof deleteContent>>
>

export type DeleteContentMutationError = DeleteContent404

/**
 * @summary Delete a content
 */
export const useDeleteContent = <TError = DeleteContent404, TContext = unknown>(
  options?: {
    mutation?: UseMutationOptions<
      Awaited<ReturnType<typeof deleteContent>>,
      TError,
      { id: string },
      TContext
    >
    fetch?: RequestInit
  },
  queryClient?: QueryClient
): UseMutationResult<
  Awaited<ReturnType<typeof deleteContent>>,
  TError,
  { id: string },
  TContext
> => {
  const mutationOptions = getDeleteContentMutationOptions(options)

  return useMutation(mutationOptions, queryClient)
}

/**
 * Find a content
 * @summary Find a content
 */
export type getOneContentResponse200 = {
  data: GetOneContent200
  status: 200
}

export type getOneContentResponse404 = {
  data: GetOneContent404
  status: 404
}

export type getOneContentResponseComposite =
  | getOneContentResponse200
  | getOneContentResponse404

export type getOneContentResponse = getOneContentResponseComposite & {
  headers: Headers
}

export const getGetOneContentUrl = (id: string) => {
  return `http://0.0.0.0:3001/contents/${id}`
}

export const getOneContent = async (
  id: string,
  options?: RequestInit
): Promise<getOneContentResponse> => {
  const res = await fetch(getGetOneContentUrl(id), {
    ...options,
    method: 'GET'
  })

  const body = [204, 205, 304].includes(res.status) ? null : await res.text()
  const data: getOneContentResponse['data'] = body ? JSON.parse(body) : {}

  return {
    data,
    status: res.status,
    headers: res.headers
  } as getOneContentResponse
}

export const getGetOneContentQueryKey = (id: string) => {
  return [`http://0.0.0.0:3001/contents/${id}`] as const
}

export const getGetOneContentQueryOptions = <
  TData = Awaited<ReturnType<typeof getOneContent>>,
  TError = GetOneContent404
>(
  id: string,
  options?: {
    query?: Partial<
      UseQueryOptions<Awaited<ReturnType<typeof getOneContent>>, TError, TData>
    >
    fetch?: RequestInit
  }
) => {
  const { query: queryOptions, fetch: fetchOptions } = options ?? {}

  const queryKey = queryOptions?.queryKey ?? getGetOneContentQueryKey(id)

  const queryFn: QueryFunction<Awaited<ReturnType<typeof getOneContent>>> = ({
    signal
  }) => getOneContent(id, { ...(signal ? { signal } : {}), ...fetchOptions })

  return {
    queryKey,
    queryFn,
    enabled: !!id,
    ...queryOptions
  } as UseQueryOptions<
    Awaited<ReturnType<typeof getOneContent>>,
    TError,
    TData
  > & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type GetOneContentQueryResult = NonNullable<
  Awaited<ReturnType<typeof getOneContent>>
>
export type GetOneContentQueryError = GetOneContent404

export function useGetOneContent<
  TData = Awaited<ReturnType<typeof getOneContent>>,
  TError = GetOneContent404
>(
  id: string,
  options: {
    query: Partial<
      UseQueryOptions<Awaited<ReturnType<typeof getOneContent>>, TError, TData>
    > &
      Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof getOneContent>>,
          TError,
          Awaited<ReturnType<typeof getOneContent>>
        >,
        'initialData'
      >
    fetch?: RequestInit
  },
  queryClient?: QueryClient
): DefinedUseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>
}
export function useGetOneContent<
  TData = Awaited<ReturnType<typeof getOneContent>>,
  TError = GetOneContent404
>(
  id: string,
  options?: {
    query?: Partial<
      UseQueryOptions<Awaited<ReturnType<typeof getOneContent>>, TError, TData>
    > &
      Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof getOneContent>>,
          TError,
          Awaited<ReturnType<typeof getOneContent>>
        >,
        'initialData'
      >
    fetch?: RequestInit
  },
  queryClient?: QueryClient
): UseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>
}
export function useGetOneContent<
  TData = Awaited<ReturnType<typeof getOneContent>>,
  TError = GetOneContent404
>(
  id: string,
  options?: {
    query?: Partial<
      UseQueryOptions<Awaited<ReturnType<typeof getOneContent>>, TError, TData>
    >
    fetch?: RequestInit
  },
  queryClient?: QueryClient
): UseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>
}
/**
 * @summary Find a content
 */

export function useGetOneContent<
  TData = Awaited<ReturnType<typeof getOneContent>>,
  TError = GetOneContent404
>(
  id: string,
  options?: {
    query?: Partial<
      UseQueryOptions<Awaited<ReturnType<typeof getOneContent>>, TError, TData>
    >
    fetch?: RequestInit
  },
  queryClient?: QueryClient
): UseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>
} {
  const queryOptions = getGetOneContentQueryOptions(id, options)

  const query = useQuery(queryOptions, queryClient) as UseQueryResult<
    TData,
    TError
  > & { queryKey: DataTag<QueryKey, TData, TError> }

  query.queryKey = queryOptions.queryKey

  return query
}

/**
 * Update a content
 * @summary Update a content
 */
export type updateContentResponse200 = {
  data: UpdateContent200
  status: 200
}

export type updateContentResponse404 = {
  data: UpdateContent404
  status: 404
}

export type updateContentResponseComposite =
  | updateContentResponse200
  | updateContentResponse404

export type updateContentResponse = updateContentResponseComposite & {
  headers: Headers
}

export const getUpdateContentUrl = (id: string) => {
  return `http://0.0.0.0:3001/contents/${id}`
}

export const updateContent = async (
  id: string,
  updateContentBody: UpdateContentBody,
  options?: RequestInit
): Promise<updateContentResponse> => {
  const res = await fetch(getUpdateContentUrl(id), {
    ...options,
    method: 'PATCH',
    headers: { 'Content-Type': 'application/json', ...options?.headers },
    body: JSON.stringify(updateContentBody)
  })

  const body = [204, 205, 304].includes(res.status) ? null : await res.text()
  const data: updateContentResponse['data'] = body ? JSON.parse(body) : {}

  return {
    data,
    status: res.status,
    headers: res.headers
  } as updateContentResponse
}

export const getUpdateContentMutationOptions = <
  TError = UpdateContent404,
  TContext = unknown
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof updateContent>>,
    TError,
    { id: string; data: UpdateContentBody },
    TContext
  >
  fetch?: RequestInit
}): UseMutationOptions<
  Awaited<ReturnType<typeof updateContent>>,
  TError,
  { id: string; data: UpdateContentBody },
  TContext
> => {
  const mutationKey = ['updateContent']
  const { mutation: mutationOptions, fetch: fetchOptions } =
    options ?
      (
        options.mutation &&
        'mutationKey' in options.mutation &&
        options.mutation.mutationKey
      ) ?
        options
      : { ...options, mutation: { ...options.mutation, mutationKey } }
    : { mutation: { mutationKey }, fetch: undefined }

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof updateContent>>,
    { id: string; data: UpdateContentBody }
  > = (props) => {
    const { id, data } = props ?? {}

    return updateContent(id, data, fetchOptions)
  }

  return { mutationFn, ...mutationOptions }
}

export type UpdateContentMutationResult = NonNullable<
  Awaited<ReturnType<typeof updateContent>>
>
export type UpdateContentMutationBody = UpdateContentBody
export type UpdateContentMutationError = UpdateContent404

/**
 * @summary Update a content
 */
export const useUpdateContent = <TError = UpdateContent404, TContext = unknown>(
  options?: {
    mutation?: UseMutationOptions<
      Awaited<ReturnType<typeof updateContent>>,
      TError,
      { id: string; data: UpdateContentBody },
      TContext
    >
    fetch?: RequestInit
  },
  queryClient?: QueryClient
): UseMutationResult<
  Awaited<ReturnType<typeof updateContent>>,
  TError,
  { id: string; data: UpdateContentBody },
  TContext
> => {
  const mutationOptions = getUpdateContentMutationOptions(options)

  return useMutation(mutationOptions, queryClient)
}

/**
 * Create a new run
 * @summary Create a new run
 */
export type createRunResponse201 = {
  data: CreateRun201
  status: 201
}

export type createRunResponseComposite = createRunResponse201

export type createRunResponse = createRunResponseComposite & {
  headers: Headers
}

export const getCreateRunUrl = () => {
  return `http://0.0.0.0:3001/runs`
}

export const createRun = async (
  createRunBody: CreateRunBody,
  options?: RequestInit
): Promise<createRunResponse> => {
  const res = await fetch(getCreateRunUrl(), {
    ...options,
    method: 'POST',
    headers: { 'Content-Type': 'application/json', ...options?.headers },
    body: JSON.stringify(createRunBody)
  })

  const body = [204, 205, 304].includes(res.status) ? null : await res.text()
  const data: createRunResponse['data'] = body ? JSON.parse(body) : {}

  return { data, status: res.status, headers: res.headers } as createRunResponse
}

export const getCreateRunMutationOptions = <
  TError = unknown,
  TContext = unknown
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof createRun>>,
    TError,
    { data: CreateRunBody },
    TContext
  >
  fetch?: RequestInit
}): UseMutationOptions<
  Awaited<ReturnType<typeof createRun>>,
  TError,
  { data: CreateRunBody },
  TContext
> => {
  const mutationKey = ['createRun']
  const { mutation: mutationOptions, fetch: fetchOptions } =
    options ?
      (
        options.mutation &&
        'mutationKey' in options.mutation &&
        options.mutation.mutationKey
      ) ?
        options
      : { ...options, mutation: { ...options.mutation, mutationKey } }
    : { mutation: { mutationKey }, fetch: undefined }

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof createRun>>,
    { data: CreateRunBody }
  > = (props) => {
    const { data } = props ?? {}

    return createRun(data, fetchOptions)
  }

  return { mutationFn, ...mutationOptions }
}

export type CreateRunMutationResult = NonNullable<
  Awaited<ReturnType<typeof createRun>>
>
export type CreateRunMutationBody = CreateRunBody
export type CreateRunMutationError = unknown

/**
 * @summary Create a new run
 */
export const useCreateRun = <TError = unknown, TContext = unknown>(
  options?: {
    mutation?: UseMutationOptions<
      Awaited<ReturnType<typeof createRun>>,
      TError,
      { data: CreateRunBody },
      TContext
    >
    fetch?: RequestInit
  },
  queryClient?: QueryClient
): UseMutationResult<
  Awaited<ReturnType<typeof createRun>>,
  TError,
  { data: CreateRunBody },
  TContext
> => {
  const mutationOptions = getCreateRunMutationOptions(options)

  return useMutation(mutationOptions, queryClient)
}

/**
 * Find many runs
 * @summary Find many runs
 */
export type findManyRunsResponse200 = {
  data: FindManyRuns200
  status: 200
}

export type findManyRunsResponseComposite = findManyRunsResponse200

export type findManyRunsResponse = findManyRunsResponseComposite & {
  headers: Headers
}

export const getFindManyRunsUrl = (params?: FindManyRunsParams) => {
  const normalizedParams = new URLSearchParams()

  Object.entries(params || {}).forEach(([key, value]) => {
    if (value !== undefined) {
      normalizedParams.append(key, value === null ? 'null' : value.toString())
    }
  })

  const stringifiedParams = normalizedParams.toString()

  return stringifiedParams.length > 0 ?
      `http://0.0.0.0:3001/runs?${stringifiedParams}`
    : `http://0.0.0.0:3001/runs`
}

export const findManyRuns = async (
  params?: FindManyRunsParams,
  options?: RequestInit
): Promise<findManyRunsResponse> => {
  const res = await fetch(getFindManyRunsUrl(params), {
    ...options,
    method: 'GET'
  })

  const body = [204, 205, 304].includes(res.status) ? null : await res.text()
  const data: findManyRunsResponse['data'] = body ? JSON.parse(body) : {}

  return {
    data,
    status: res.status,
    headers: res.headers
  } as findManyRunsResponse
}

export const getFindManyRunsQueryKey = (params?: FindManyRunsParams) => {
  return [`http://0.0.0.0:3001/runs`, ...(params ? [params] : [])] as const
}

export const getFindManyRunsQueryOptions = <
  TData = Awaited<ReturnType<typeof findManyRuns>>,
  TError = unknown
>(
  params?: FindManyRunsParams,
  options?: {
    query?: Partial<
      UseQueryOptions<Awaited<ReturnType<typeof findManyRuns>>, TError, TData>
    >
    fetch?: RequestInit
  }
) => {
  const { query: queryOptions, fetch: fetchOptions } = options ?? {}

  const queryKey = queryOptions?.queryKey ?? getFindManyRunsQueryKey(params)

  const queryFn: QueryFunction<Awaited<ReturnType<typeof findManyRuns>>> = ({
    signal
  }) => findManyRuns(params, { ...(signal ? { signal } : {}), ...fetchOptions })

  return { queryKey, queryFn, ...queryOptions } as UseQueryOptions<
    Awaited<ReturnType<typeof findManyRuns>>,
    TError,
    TData
  > & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type FindManyRunsQueryResult = NonNullable<
  Awaited<ReturnType<typeof findManyRuns>>
>
export type FindManyRunsQueryError = unknown

export function useFindManyRuns<
  TData = Awaited<ReturnType<typeof findManyRuns>>,
  TError = unknown
>(
  params: undefined | FindManyRunsParams,
  options: {
    query: Partial<
      UseQueryOptions<Awaited<ReturnType<typeof findManyRuns>>, TError, TData>
    > &
      Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof findManyRuns>>,
          TError,
          Awaited<ReturnType<typeof findManyRuns>>
        >,
        'initialData'
      >
    fetch?: RequestInit
  },
  queryClient?: QueryClient
): DefinedUseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>
}
export function useFindManyRuns<
  TData = Awaited<ReturnType<typeof findManyRuns>>,
  TError = unknown
>(
  params?: FindManyRunsParams,
  options?: {
    query?: Partial<
      UseQueryOptions<Awaited<ReturnType<typeof findManyRuns>>, TError, TData>
    > &
      Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof findManyRuns>>,
          TError,
          Awaited<ReturnType<typeof findManyRuns>>
        >,
        'initialData'
      >
    fetch?: RequestInit
  },
  queryClient?: QueryClient
): UseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>
}
export function useFindManyRuns<
  TData = Awaited<ReturnType<typeof findManyRuns>>,
  TError = unknown
>(
  params?: FindManyRunsParams,
  options?: {
    query?: Partial<
      UseQueryOptions<Awaited<ReturnType<typeof findManyRuns>>, TError, TData>
    >
    fetch?: RequestInit
  },
  queryClient?: QueryClient
): UseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>
}
/**
 * @summary Find many runs
 */

export function useFindManyRuns<
  TData = Awaited<ReturnType<typeof findManyRuns>>,
  TError = unknown
>(
  params?: FindManyRunsParams,
  options?: {
    query?: Partial<
      UseQueryOptions<Awaited<ReturnType<typeof findManyRuns>>, TError, TData>
    >
    fetch?: RequestInit
  },
  queryClient?: QueryClient
): UseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>
} {
  const queryOptions = getFindManyRunsQueryOptions(params, options)

  const query = useQuery(queryOptions, queryClient) as UseQueryResult<
    TData,
    TError
  > & { queryKey: DataTag<QueryKey, TData, TError> }

  query.queryKey = queryOptions.queryKey

  return query
}

/**
 * Delete a run
 * @summary Delete a run
 */
export type deleteRunResponse200 = {
  data: DeleteRun200
  status: 200
}

export type deleteRunResponse404 = {
  data: DeleteRun404
  status: 404
}

export type deleteRunResponseComposite =
  | deleteRunResponse200
  | deleteRunResponse404

export type deleteRunResponse = deleteRunResponseComposite & {
  headers: Headers
}

export const getDeleteRunUrl = (id: string) => {
  return `http://0.0.0.0:3001/runs/${id}`
}

export const deleteRun = async (
  id: string,
  options?: RequestInit
): Promise<deleteRunResponse> => {
  const res = await fetch(getDeleteRunUrl(id), {
    ...options,
    method: 'DELETE'
  })

  const body = [204, 205, 304].includes(res.status) ? null : await res.text()
  const data: deleteRunResponse['data'] = body ? JSON.parse(body) : {}

  return { data, status: res.status, headers: res.headers } as deleteRunResponse
}

export const getDeleteRunMutationOptions = <
  TError = DeleteRun404,
  TContext = unknown
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof deleteRun>>,
    TError,
    { id: string },
    TContext
  >
  fetch?: RequestInit
}): UseMutationOptions<
  Awaited<ReturnType<typeof deleteRun>>,
  TError,
  { id: string },
  TContext
> => {
  const mutationKey = ['deleteRun']
  const { mutation: mutationOptions, fetch: fetchOptions } =
    options ?
      (
        options.mutation &&
        'mutationKey' in options.mutation &&
        options.mutation.mutationKey
      ) ?
        options
      : { ...options, mutation: { ...options.mutation, mutationKey } }
    : { mutation: { mutationKey }, fetch: undefined }

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof deleteRun>>,
    { id: string }
  > = (props) => {
    const { id } = props ?? {}

    return deleteRun(id, fetchOptions)
  }

  return { mutationFn, ...mutationOptions }
}

export type DeleteRunMutationResult = NonNullable<
  Awaited<ReturnType<typeof deleteRun>>
>

export type DeleteRunMutationError = DeleteRun404

/**
 * @summary Delete a run
 */
export const useDeleteRun = <TError = DeleteRun404, TContext = unknown>(
  options?: {
    mutation?: UseMutationOptions<
      Awaited<ReturnType<typeof deleteRun>>,
      TError,
      { id: string },
      TContext
    >
    fetch?: RequestInit
  },
  queryClient?: QueryClient
): UseMutationResult<
  Awaited<ReturnType<typeof deleteRun>>,
  TError,
  { id: string },
  TContext
> => {
  const mutationOptions = getDeleteRunMutationOptions(options)

  return useMutation(mutationOptions, queryClient)
}

/**
 * Find a run
 * @summary Find a run
 */
export type getOneRunResponse200 = {
  data: GetOneRun200
  status: 200
}

export type getOneRunResponse404 = {
  data: GetOneRun404
  status: 404
}

export type getOneRunResponseComposite =
  | getOneRunResponse200
  | getOneRunResponse404

export type getOneRunResponse = getOneRunResponseComposite & {
  headers: Headers
}

export const getGetOneRunUrl = (id: string) => {
  return `http://0.0.0.0:3001/runs/${id}`
}

export const getOneRun = async (
  id: string,
  options?: RequestInit
): Promise<getOneRunResponse> => {
  const res = await fetch(getGetOneRunUrl(id), {
    ...options,
    method: 'GET'
  })

  const body = [204, 205, 304].includes(res.status) ? null : await res.text()
  const data: getOneRunResponse['data'] = body ? JSON.parse(body) : {}

  return { data, status: res.status, headers: res.headers } as getOneRunResponse
}

export const getGetOneRunQueryKey = (id: string) => {
  return [`http://0.0.0.0:3001/runs/${id}`] as const
}

export const getGetOneRunQueryOptions = <
  TData = Awaited<ReturnType<typeof getOneRun>>,
  TError = GetOneRun404
>(
  id: string,
  options?: {
    query?: Partial<
      UseQueryOptions<Awaited<ReturnType<typeof getOneRun>>, TError, TData>
    >
    fetch?: RequestInit
  }
) => {
  const { query: queryOptions, fetch: fetchOptions } = options ?? {}

  const queryKey = queryOptions?.queryKey ?? getGetOneRunQueryKey(id)

  const queryFn: QueryFunction<Awaited<ReturnType<typeof getOneRun>>> = ({
    signal
  }) => getOneRun(id, { ...(signal ? { signal } : {}), ...fetchOptions })

  return {
    queryKey,
    queryFn,
    enabled: !!id,
    ...queryOptions
  } as UseQueryOptions<Awaited<ReturnType<typeof getOneRun>>, TError, TData> & {
    queryKey: DataTag<QueryKey, TData, TError>
  }
}

export type GetOneRunQueryResult = NonNullable<
  Awaited<ReturnType<typeof getOneRun>>
>
export type GetOneRunQueryError = GetOneRun404

export function useGetOneRun<
  TData = Awaited<ReturnType<typeof getOneRun>>,
  TError = GetOneRun404
>(
  id: string,
  options: {
    query: Partial<
      UseQueryOptions<Awaited<ReturnType<typeof getOneRun>>, TError, TData>
    > &
      Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof getOneRun>>,
          TError,
          Awaited<ReturnType<typeof getOneRun>>
        >,
        'initialData'
      >
    fetch?: RequestInit
  },
  queryClient?: QueryClient
): DefinedUseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>
}
export function useGetOneRun<
  TData = Awaited<ReturnType<typeof getOneRun>>,
  TError = GetOneRun404
>(
  id: string,
  options?: {
    query?: Partial<
      UseQueryOptions<Awaited<ReturnType<typeof getOneRun>>, TError, TData>
    > &
      Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof getOneRun>>,
          TError,
          Awaited<ReturnType<typeof getOneRun>>
        >,
        'initialData'
      >
    fetch?: RequestInit
  },
  queryClient?: QueryClient
): UseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>
}
export function useGetOneRun<
  TData = Awaited<ReturnType<typeof getOneRun>>,
  TError = GetOneRun404
>(
  id: string,
  options?: {
    query?: Partial<
      UseQueryOptions<Awaited<ReturnType<typeof getOneRun>>, TError, TData>
    >
    fetch?: RequestInit
  },
  queryClient?: QueryClient
): UseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>
}
/**
 * @summary Find a run
 */

export function useGetOneRun<
  TData = Awaited<ReturnType<typeof getOneRun>>,
  TError = GetOneRun404
>(
  id: string,
  options?: {
    query?: Partial<
      UseQueryOptions<Awaited<ReturnType<typeof getOneRun>>, TError, TData>
    >
    fetch?: RequestInit
  },
  queryClient?: QueryClient
): UseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>
} {
  const queryOptions = getGetOneRunQueryOptions(id, options)

  const query = useQuery(queryOptions, queryClient) as UseQueryResult<
    TData,
    TError
  > & { queryKey: DataTag<QueryKey, TData, TError> }

  query.queryKey = queryOptions.queryKey

  return query
}

/**
 * Update a run
 * @summary Update a run
 */
export type updateRunResponse200 = {
  data: UpdateRun200
  status: 200
}

export type updateRunResponse404 = {
  data: UpdateRun404
  status: 404
}

export type updateRunResponseComposite =
  | updateRunResponse200
  | updateRunResponse404

export type updateRunResponse = updateRunResponseComposite & {
  headers: Headers
}

export const getUpdateRunUrl = (id: string) => {
  return `http://0.0.0.0:3001/runs/${id}`
}

export const updateRun = async (
  id: string,
  updateRunBody: UpdateRunBody,
  options?: RequestInit
): Promise<updateRunResponse> => {
  const res = await fetch(getUpdateRunUrl(id), {
    ...options,
    method: 'PATCH',
    headers: { 'Content-Type': 'application/json', ...options?.headers },
    body: JSON.stringify(updateRunBody)
  })

  const body = [204, 205, 304].includes(res.status) ? null : await res.text()
  const data: updateRunResponse['data'] = body ? JSON.parse(body) : {}

  return { data, status: res.status, headers: res.headers } as updateRunResponse
}

export const getUpdateRunMutationOptions = <
  TError = UpdateRun404,
  TContext = unknown
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof updateRun>>,
    TError,
    { id: string; data: UpdateRunBody },
    TContext
  >
  fetch?: RequestInit
}): UseMutationOptions<
  Awaited<ReturnType<typeof updateRun>>,
  TError,
  { id: string; data: UpdateRunBody },
  TContext
> => {
  const mutationKey = ['updateRun']
  const { mutation: mutationOptions, fetch: fetchOptions } =
    options ?
      (
        options.mutation &&
        'mutationKey' in options.mutation &&
        options.mutation.mutationKey
      ) ?
        options
      : { ...options, mutation: { ...options.mutation, mutationKey } }
    : { mutation: { mutationKey }, fetch: undefined }

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof updateRun>>,
    { id: string; data: UpdateRunBody }
  > = (props) => {
    const { id, data } = props ?? {}

    return updateRun(id, data, fetchOptions)
  }

  return { mutationFn, ...mutationOptions }
}

export type UpdateRunMutationResult = NonNullable<
  Awaited<ReturnType<typeof updateRun>>
>
export type UpdateRunMutationBody = UpdateRunBody
export type UpdateRunMutationError = UpdateRun404

/**
 * @summary Update a run
 */
export const useUpdateRun = <TError = UpdateRun404, TContext = unknown>(
  options?: {
    mutation?: UseMutationOptions<
      Awaited<ReturnType<typeof updateRun>>,
      TError,
      { id: string; data: UpdateRunBody },
      TContext
    >
    fetch?: RequestInit
  },
  queryClient?: QueryClient
): UseMutationResult<
  Awaited<ReturnType<typeof updateRun>>,
  TError,
  { id: string; data: UpdateRunBody },
  TContext
> => {
  const mutationOptions = getUpdateRunMutationOptions(options)

  return useMutation(mutationOptions, queryClient)
}

/**
 * Create a new label
 * @summary Create a new label
 */
export type createLabelResponse201 = {
  data: CreateLabel201
  status: 201
}

export type createLabelResponseComposite = createLabelResponse201

export type createLabelResponse = createLabelResponseComposite & {
  headers: Headers
}

export const getCreateLabelUrl = () => {
  return `http://0.0.0.0:3001/labels`
}

export const createLabel = async (
  createLabelBody: CreateLabelBody,
  options?: RequestInit
): Promise<createLabelResponse> => {
  const res = await fetch(getCreateLabelUrl(), {
    ...options,
    method: 'POST',
    headers: { 'Content-Type': 'application/json', ...options?.headers },
    body: JSON.stringify(createLabelBody)
  })

  const body = [204, 205, 304].includes(res.status) ? null : await res.text()
  const data: createLabelResponse['data'] = body ? JSON.parse(body) : {}

  return {
    data,
    status: res.status,
    headers: res.headers
  } as createLabelResponse
}

export const getCreateLabelMutationOptions = <
  TError = unknown,
  TContext = unknown
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof createLabel>>,
    TError,
    { data: CreateLabelBody },
    TContext
  >
  fetch?: RequestInit
}): UseMutationOptions<
  Awaited<ReturnType<typeof createLabel>>,
  TError,
  { data: CreateLabelBody },
  TContext
> => {
  const mutationKey = ['createLabel']
  const { mutation: mutationOptions, fetch: fetchOptions } =
    options ?
      (
        options.mutation &&
        'mutationKey' in options.mutation &&
        options.mutation.mutationKey
      ) ?
        options
      : { ...options, mutation: { ...options.mutation, mutationKey } }
    : { mutation: { mutationKey }, fetch: undefined }

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof createLabel>>,
    { data: CreateLabelBody }
  > = (props) => {
    const { data } = props ?? {}

    return createLabel(data, fetchOptions)
  }

  return { mutationFn, ...mutationOptions }
}

export type CreateLabelMutationResult = NonNullable<
  Awaited<ReturnType<typeof createLabel>>
>
export type CreateLabelMutationBody = CreateLabelBody
export type CreateLabelMutationError = unknown

/**
 * @summary Create a new label
 */
export const useCreateLabel = <TError = unknown, TContext = unknown>(
  options?: {
    mutation?: UseMutationOptions<
      Awaited<ReturnType<typeof createLabel>>,
      TError,
      { data: CreateLabelBody },
      TContext
    >
    fetch?: RequestInit
  },
  queryClient?: QueryClient
): UseMutationResult<
  Awaited<ReturnType<typeof createLabel>>,
  TError,
  { data: CreateLabelBody },
  TContext
> => {
  const mutationOptions = getCreateLabelMutationOptions(options)

  return useMutation(mutationOptions, queryClient)
}

/**
 * Find many labels
 * @summary Find many labels
 */
export type findManyLabelsResponse200 = {
  data: FindManyLabels200
  status: 200
}

export type findManyLabelsResponseComposite = findManyLabelsResponse200

export type findManyLabelsResponse = findManyLabelsResponseComposite & {
  headers: Headers
}

export const getFindManyLabelsUrl = (params?: FindManyLabelsParams) => {
  const normalizedParams = new URLSearchParams()

  Object.entries(params || {}).forEach(([key, value]) => {
    if (value !== undefined) {
      normalizedParams.append(key, value === null ? 'null' : value.toString())
    }
  })

  const stringifiedParams = normalizedParams.toString()

  return stringifiedParams.length > 0 ?
      `http://0.0.0.0:3001/labels?${stringifiedParams}`
    : `http://0.0.0.0:3001/labels`
}

export const findManyLabels = async (
  params?: FindManyLabelsParams,
  options?: RequestInit
): Promise<findManyLabelsResponse> => {
  const res = await fetch(getFindManyLabelsUrl(params), {
    ...options,
    method: 'GET'
  })

  const body = [204, 205, 304].includes(res.status) ? null : await res.text()
  const data: findManyLabelsResponse['data'] = body ? JSON.parse(body) : {}

  return {
    data,
    status: res.status,
    headers: res.headers
  } as findManyLabelsResponse
}

export const getFindManyLabelsQueryKey = (params?: FindManyLabelsParams) => {
  return [`http://0.0.0.0:3001/labels`, ...(params ? [params] : [])] as const
}

export const getFindManyLabelsQueryOptions = <
  TData = Awaited<ReturnType<typeof findManyLabels>>,
  TError = unknown
>(
  params?: FindManyLabelsParams,
  options?: {
    query?: Partial<
      UseQueryOptions<Awaited<ReturnType<typeof findManyLabels>>, TError, TData>
    >
    fetch?: RequestInit
  }
) => {
  const { query: queryOptions, fetch: fetchOptions } = options ?? {}

  const queryKey = queryOptions?.queryKey ?? getFindManyLabelsQueryKey(params)

  const queryFn: QueryFunction<Awaited<ReturnType<typeof findManyLabels>>> = ({
    signal
  }) =>
    findManyLabels(params, { ...(signal ? { signal } : {}), ...fetchOptions })

  return { queryKey, queryFn, ...queryOptions } as UseQueryOptions<
    Awaited<ReturnType<typeof findManyLabels>>,
    TError,
    TData
  > & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type FindManyLabelsQueryResult = NonNullable<
  Awaited<ReturnType<typeof findManyLabels>>
>
export type FindManyLabelsQueryError = unknown

export function useFindManyLabels<
  TData = Awaited<ReturnType<typeof findManyLabels>>,
  TError = unknown
>(
  params: undefined | FindManyLabelsParams,
  options: {
    query: Partial<
      UseQueryOptions<Awaited<ReturnType<typeof findManyLabels>>, TError, TData>
    > &
      Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof findManyLabels>>,
          TError,
          Awaited<ReturnType<typeof findManyLabels>>
        >,
        'initialData'
      >
    fetch?: RequestInit
  },
  queryClient?: QueryClient
): DefinedUseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>
}
export function useFindManyLabels<
  TData = Awaited<ReturnType<typeof findManyLabels>>,
  TError = unknown
>(
  params?: FindManyLabelsParams,
  options?: {
    query?: Partial<
      UseQueryOptions<Awaited<ReturnType<typeof findManyLabels>>, TError, TData>
    > &
      Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof findManyLabels>>,
          TError,
          Awaited<ReturnType<typeof findManyLabels>>
        >,
        'initialData'
      >
    fetch?: RequestInit
  },
  queryClient?: QueryClient
): UseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>
}
export function useFindManyLabels<
  TData = Awaited<ReturnType<typeof findManyLabels>>,
  TError = unknown
>(
  params?: FindManyLabelsParams,
  options?: {
    query?: Partial<
      UseQueryOptions<Awaited<ReturnType<typeof findManyLabels>>, TError, TData>
    >
    fetch?: RequestInit
  },
  queryClient?: QueryClient
): UseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>
}
/**
 * @summary Find many labels
 */

export function useFindManyLabels<
  TData = Awaited<ReturnType<typeof findManyLabels>>,
  TError = unknown
>(
  params?: FindManyLabelsParams,
  options?: {
    query?: Partial<
      UseQueryOptions<Awaited<ReturnType<typeof findManyLabels>>, TError, TData>
    >
    fetch?: RequestInit
  },
  queryClient?: QueryClient
): UseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>
} {
  const queryOptions = getFindManyLabelsQueryOptions(params, options)

  const query = useQuery(queryOptions, queryClient) as UseQueryResult<
    TData,
    TError
  > & { queryKey: DataTag<QueryKey, TData, TError> }

  query.queryKey = queryOptions.queryKey

  return query
}

/**
 * Delete a label
 * @summary Delete a label
 */
export type deleteLabelResponse200 = {
  data: DeleteLabel200
  status: 200
}

export type deleteLabelResponse404 = {
  data: DeleteLabel404
  status: 404
}

export type deleteLabelResponseComposite =
  | deleteLabelResponse200
  | deleteLabelResponse404

export type deleteLabelResponse = deleteLabelResponseComposite & {
  headers: Headers
}

export const getDeleteLabelUrl = (id: string) => {
  return `http://0.0.0.0:3001/labels/${id}`
}

export const deleteLabel = async (
  id: string,
  options?: RequestInit
): Promise<deleteLabelResponse> => {
  const res = await fetch(getDeleteLabelUrl(id), {
    ...options,
    method: 'DELETE'
  })

  const body = [204, 205, 304].includes(res.status) ? null : await res.text()
  const data: deleteLabelResponse['data'] = body ? JSON.parse(body) : {}

  return {
    data,
    status: res.status,
    headers: res.headers
  } as deleteLabelResponse
}

export const getDeleteLabelMutationOptions = <
  TError = DeleteLabel404,
  TContext = unknown
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof deleteLabel>>,
    TError,
    { id: string },
    TContext
  >
  fetch?: RequestInit
}): UseMutationOptions<
  Awaited<ReturnType<typeof deleteLabel>>,
  TError,
  { id: string },
  TContext
> => {
  const mutationKey = ['deleteLabel']
  const { mutation: mutationOptions, fetch: fetchOptions } =
    options ?
      (
        options.mutation &&
        'mutationKey' in options.mutation &&
        options.mutation.mutationKey
      ) ?
        options
      : { ...options, mutation: { ...options.mutation, mutationKey } }
    : { mutation: { mutationKey }, fetch: undefined }

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof deleteLabel>>,
    { id: string }
  > = (props) => {
    const { id } = props ?? {}

    return deleteLabel(id, fetchOptions)
  }

  return { mutationFn, ...mutationOptions }
}

export type DeleteLabelMutationResult = NonNullable<
  Awaited<ReturnType<typeof deleteLabel>>
>

export type DeleteLabelMutationError = DeleteLabel404

/**
 * @summary Delete a label
 */
export const useDeleteLabel = <TError = DeleteLabel404, TContext = unknown>(
  options?: {
    mutation?: UseMutationOptions<
      Awaited<ReturnType<typeof deleteLabel>>,
      TError,
      { id: string },
      TContext
    >
    fetch?: RequestInit
  },
  queryClient?: QueryClient
): UseMutationResult<
  Awaited<ReturnType<typeof deleteLabel>>,
  TError,
  { id: string },
  TContext
> => {
  const mutationOptions = getDeleteLabelMutationOptions(options)

  return useMutation(mutationOptions, queryClient)
}

/**
 * Find a label
 * @summary Find a label
 */
export type getOneLabelResponse200 = {
  data: GetOneLabel200
  status: 200
}

export type getOneLabelResponse404 = {
  data: GetOneLabel404
  status: 404
}

export type getOneLabelResponseComposite =
  | getOneLabelResponse200
  | getOneLabelResponse404

export type getOneLabelResponse = getOneLabelResponseComposite & {
  headers: Headers
}

export const getGetOneLabelUrl = (id: string) => {
  return `http://0.0.0.0:3001/labels/${id}`
}

export const getOneLabel = async (
  id: string,
  options?: RequestInit
): Promise<getOneLabelResponse> => {
  const res = await fetch(getGetOneLabelUrl(id), {
    ...options,
    method: 'GET'
  })

  const body = [204, 205, 304].includes(res.status) ? null : await res.text()
  const data: getOneLabelResponse['data'] = body ? JSON.parse(body) : {}

  return {
    data,
    status: res.status,
    headers: res.headers
  } as getOneLabelResponse
}

export const getGetOneLabelQueryKey = (id: string) => {
  return [`http://0.0.0.0:3001/labels/${id}`] as const
}

export const getGetOneLabelQueryOptions = <
  TData = Awaited<ReturnType<typeof getOneLabel>>,
  TError = GetOneLabel404
>(
  id: string,
  options?: {
    query?: Partial<
      UseQueryOptions<Awaited<ReturnType<typeof getOneLabel>>, TError, TData>
    >
    fetch?: RequestInit
  }
) => {
  const { query: queryOptions, fetch: fetchOptions } = options ?? {}

  const queryKey = queryOptions?.queryKey ?? getGetOneLabelQueryKey(id)

  const queryFn: QueryFunction<Awaited<ReturnType<typeof getOneLabel>>> = ({
    signal
  }) => getOneLabel(id, { ...(signal ? { signal } : {}), ...fetchOptions })

  return {
    queryKey,
    queryFn,
    enabled: !!id,
    ...queryOptions
  } as UseQueryOptions<
    Awaited<ReturnType<typeof getOneLabel>>,
    TError,
    TData
  > & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type GetOneLabelQueryResult = NonNullable<
  Awaited<ReturnType<typeof getOneLabel>>
>
export type GetOneLabelQueryError = GetOneLabel404

export function useGetOneLabel<
  TData = Awaited<ReturnType<typeof getOneLabel>>,
  TError = GetOneLabel404
>(
  id: string,
  options: {
    query: Partial<
      UseQueryOptions<Awaited<ReturnType<typeof getOneLabel>>, TError, TData>
    > &
      Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof getOneLabel>>,
          TError,
          Awaited<ReturnType<typeof getOneLabel>>
        >,
        'initialData'
      >
    fetch?: RequestInit
  },
  queryClient?: QueryClient
): DefinedUseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>
}
export function useGetOneLabel<
  TData = Awaited<ReturnType<typeof getOneLabel>>,
  TError = GetOneLabel404
>(
  id: string,
  options?: {
    query?: Partial<
      UseQueryOptions<Awaited<ReturnType<typeof getOneLabel>>, TError, TData>
    > &
      Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof getOneLabel>>,
          TError,
          Awaited<ReturnType<typeof getOneLabel>>
        >,
        'initialData'
      >
    fetch?: RequestInit
  },
  queryClient?: QueryClient
): UseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>
}
export function useGetOneLabel<
  TData = Awaited<ReturnType<typeof getOneLabel>>,
  TError = GetOneLabel404
>(
  id: string,
  options?: {
    query?: Partial<
      UseQueryOptions<Awaited<ReturnType<typeof getOneLabel>>, TError, TData>
    >
    fetch?: RequestInit
  },
  queryClient?: QueryClient
): UseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>
}
/**
 * @summary Find a label
 */

export function useGetOneLabel<
  TData = Awaited<ReturnType<typeof getOneLabel>>,
  TError = GetOneLabel404
>(
  id: string,
  options?: {
    query?: Partial<
      UseQueryOptions<Awaited<ReturnType<typeof getOneLabel>>, TError, TData>
    >
    fetch?: RequestInit
  },
  queryClient?: QueryClient
): UseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>
} {
  const queryOptions = getGetOneLabelQueryOptions(id, options)

  const query = useQuery(queryOptions, queryClient) as UseQueryResult<
    TData,
    TError
  > & { queryKey: DataTag<QueryKey, TData, TError> }

  query.queryKey = queryOptions.queryKey

  return query
}

/**
 * Update a label
 * @summary Update a label
 */
export type updateLabelResponse200 = {
  data: UpdateLabel200
  status: 200
}

export type updateLabelResponse404 = {
  data: UpdateLabel404
  status: 404
}

export type updateLabelResponseComposite =
  | updateLabelResponse200
  | updateLabelResponse404

export type updateLabelResponse = updateLabelResponseComposite & {
  headers: Headers
}

export const getUpdateLabelUrl = (id: string) => {
  return `http://0.0.0.0:3001/labels/${id}`
}

export const updateLabel = async (
  id: string,
  updateLabelBody: UpdateLabelBody,
  options?: RequestInit
): Promise<updateLabelResponse> => {
  const res = await fetch(getUpdateLabelUrl(id), {
    ...options,
    method: 'PATCH',
    headers: { 'Content-Type': 'application/json', ...options?.headers },
    body: JSON.stringify(updateLabelBody)
  })

  const body = [204, 205, 304].includes(res.status) ? null : await res.text()
  const data: updateLabelResponse['data'] = body ? JSON.parse(body) : {}

  return {
    data,
    status: res.status,
    headers: res.headers
  } as updateLabelResponse
}

export const getUpdateLabelMutationOptions = <
  TError = UpdateLabel404,
  TContext = unknown
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof updateLabel>>,
    TError,
    { id: string; data: UpdateLabelBody },
    TContext
  >
  fetch?: RequestInit
}): UseMutationOptions<
  Awaited<ReturnType<typeof updateLabel>>,
  TError,
  { id: string; data: UpdateLabelBody },
  TContext
> => {
  const mutationKey = ['updateLabel']
  const { mutation: mutationOptions, fetch: fetchOptions } =
    options ?
      (
        options.mutation &&
        'mutationKey' in options.mutation &&
        options.mutation.mutationKey
      ) ?
        options
      : { ...options, mutation: { ...options.mutation, mutationKey } }
    : { mutation: { mutationKey }, fetch: undefined }

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof updateLabel>>,
    { id: string; data: UpdateLabelBody }
  > = (props) => {
    const { id, data } = props ?? {}

    return updateLabel(id, data, fetchOptions)
  }

  return { mutationFn, ...mutationOptions }
}

export type UpdateLabelMutationResult = NonNullable<
  Awaited<ReturnType<typeof updateLabel>>
>
export type UpdateLabelMutationBody = UpdateLabelBody
export type UpdateLabelMutationError = UpdateLabel404

/**
 * @summary Update a label
 */
export const useUpdateLabel = <TError = UpdateLabel404, TContext = unknown>(
  options?: {
    mutation?: UseMutationOptions<
      Awaited<ReturnType<typeof updateLabel>>,
      TError,
      { id: string; data: UpdateLabelBody },
      TContext
    >
    fetch?: RequestInit
  },
  queryClient?: QueryClient
): UseMutationResult<
  Awaited<ReturnType<typeof updateLabel>>,
  TError,
  { id: string; data: UpdateLabelBody },
  TContext
> => {
  const mutationOptions = getUpdateLabelMutationOptions(options)

  return useMutation(mutationOptions, queryClient)
}

/**
 * Create a new organization
 * @summary Create a new organization
 */
export type createOrganizationResponse201 = {
  data: CreateOrganization201
  status: 201
}

export type createOrganizationResponseComposite = createOrganizationResponse201

export type createOrganizationResponse = createOrganizationResponseComposite & {
  headers: Headers
}

export const getCreateOrganizationUrl = () => {
  return `http://0.0.0.0:3001/organizations`
}

export const createOrganization = async (
  createOrganizationBody: CreateOrganizationBody,
  options?: RequestInit
): Promise<createOrganizationResponse> => {
  const res = await fetch(getCreateOrganizationUrl(), {
    ...options,
    method: 'POST',
    headers: { 'Content-Type': 'application/json', ...options?.headers },
    body: JSON.stringify(createOrganizationBody)
  })

  const body = [204, 205, 304].includes(res.status) ? null : await res.text()
  const data: createOrganizationResponse['data'] = body ? JSON.parse(body) : {}

  return {
    data,
    status: res.status,
    headers: res.headers
  } as createOrganizationResponse
}

export const getCreateOrganizationMutationOptions = <
  TError = unknown,
  TContext = unknown
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof createOrganization>>,
    TError,
    { data: CreateOrganizationBody },
    TContext
  >
  fetch?: RequestInit
}): UseMutationOptions<
  Awaited<ReturnType<typeof createOrganization>>,
  TError,
  { data: CreateOrganizationBody },
  TContext
> => {
  const mutationKey = ['createOrganization']
  const { mutation: mutationOptions, fetch: fetchOptions } =
    options ?
      (
        options.mutation &&
        'mutationKey' in options.mutation &&
        options.mutation.mutationKey
      ) ?
        options
      : { ...options, mutation: { ...options.mutation, mutationKey } }
    : { mutation: { mutationKey }, fetch: undefined }

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof createOrganization>>,
    { data: CreateOrganizationBody }
  > = (props) => {
    const { data } = props ?? {}

    return createOrganization(data, fetchOptions)
  }

  return { mutationFn, ...mutationOptions }
}

export type CreateOrganizationMutationResult = NonNullable<
  Awaited<ReturnType<typeof createOrganization>>
>
export type CreateOrganizationMutationBody = CreateOrganizationBody
export type CreateOrganizationMutationError = unknown

/**
 * @summary Create a new organization
 */
export const useCreateOrganization = <TError = unknown, TContext = unknown>(
  options?: {
    mutation?: UseMutationOptions<
      Awaited<ReturnType<typeof createOrganization>>,
      TError,
      { data: CreateOrganizationBody },
      TContext
    >
    fetch?: RequestInit
  },
  queryClient?: QueryClient
): UseMutationResult<
  Awaited<ReturnType<typeof createOrganization>>,
  TError,
  { data: CreateOrganizationBody },
  TContext
> => {
  const mutationOptions = getCreateOrganizationMutationOptions(options)

  return useMutation(mutationOptions, queryClient)
}

/**
 * Find many organizations
 * @summary Find many organizations
 */
export type findManyOrganizationsResponse200 = {
  data: FindManyOrganizations200
  status: 200
}

export type findManyOrganizationsResponseComposite =
  findManyOrganizationsResponse200

export type findManyOrganizationsResponse =
  findManyOrganizationsResponseComposite & {
    headers: Headers
  }

export const getFindManyOrganizationsUrl = (
  params?: FindManyOrganizationsParams
) => {
  const normalizedParams = new URLSearchParams()

  Object.entries(params || {}).forEach(([key, value]) => {
    if (value !== undefined) {
      normalizedParams.append(key, value === null ? 'null' : value.toString())
    }
  })

  const stringifiedParams = normalizedParams.toString()

  return stringifiedParams.length > 0 ?
      `http://0.0.0.0:3001/organizations?${stringifiedParams}`
    : `http://0.0.0.0:3001/organizations`
}

export const findManyOrganizations = async (
  params?: FindManyOrganizationsParams,
  options?: RequestInit
): Promise<findManyOrganizationsResponse> => {
  const res = await fetch(getFindManyOrganizationsUrl(params), {
    ...options,
    method: 'GET'
  })

  const body = [204, 205, 304].includes(res.status) ? null : await res.text()
  const data: findManyOrganizationsResponse['data'] =
    body ? JSON.parse(body) : {}

  return {
    data,
    status: res.status,
    headers: res.headers
  } as findManyOrganizationsResponse
}

export const getFindManyOrganizationsQueryKey = (
  params?: FindManyOrganizationsParams
) => {
  return [
    `http://0.0.0.0:3001/organizations`,
    ...(params ? [params] : [])
  ] as const
}

export const getFindManyOrganizationsQueryOptions = <
  TData = Awaited<ReturnType<typeof findManyOrganizations>>,
  TError = unknown
>(
  params?: FindManyOrganizationsParams,
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof findManyOrganizations>>,
        TError,
        TData
      >
    >
    fetch?: RequestInit
  }
) => {
  const { query: queryOptions, fetch: fetchOptions } = options ?? {}

  const queryKey =
    queryOptions?.queryKey ?? getFindManyOrganizationsQueryKey(params)

  const queryFn: QueryFunction<
    Awaited<ReturnType<typeof findManyOrganizations>>
  > = ({ signal }) =>
    findManyOrganizations(params, {
      ...(signal ? { signal } : {}),
      ...fetchOptions
    })

  return { queryKey, queryFn, ...queryOptions } as UseQueryOptions<
    Awaited<ReturnType<typeof findManyOrganizations>>,
    TError,
    TData
  > & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type FindManyOrganizationsQueryResult = NonNullable<
  Awaited<ReturnType<typeof findManyOrganizations>>
>
export type FindManyOrganizationsQueryError = unknown

export function useFindManyOrganizations<
  TData = Awaited<ReturnType<typeof findManyOrganizations>>,
  TError = unknown
>(
  params: undefined | FindManyOrganizationsParams,
  options: {
    query: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof findManyOrganizations>>,
        TError,
        TData
      >
    > &
      Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof findManyOrganizations>>,
          TError,
          Awaited<ReturnType<typeof findManyOrganizations>>
        >,
        'initialData'
      >
    fetch?: RequestInit
  },
  queryClient?: QueryClient
): DefinedUseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>
}
export function useFindManyOrganizations<
  TData = Awaited<ReturnType<typeof findManyOrganizations>>,
  TError = unknown
>(
  params?: FindManyOrganizationsParams,
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof findManyOrganizations>>,
        TError,
        TData
      >
    > &
      Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof findManyOrganizations>>,
          TError,
          Awaited<ReturnType<typeof findManyOrganizations>>
        >,
        'initialData'
      >
    fetch?: RequestInit
  },
  queryClient?: QueryClient
): UseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>
}
export function useFindManyOrganizations<
  TData = Awaited<ReturnType<typeof findManyOrganizations>>,
  TError = unknown
>(
  params?: FindManyOrganizationsParams,
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof findManyOrganizations>>,
        TError,
        TData
      >
    >
    fetch?: RequestInit
  },
  queryClient?: QueryClient
): UseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>
}
/**
 * @summary Find many organizations
 */

export function useFindManyOrganizations<
  TData = Awaited<ReturnType<typeof findManyOrganizations>>,
  TError = unknown
>(
  params?: FindManyOrganizationsParams,
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof findManyOrganizations>>,
        TError,
        TData
      >
    >
    fetch?: RequestInit
  },
  queryClient?: QueryClient
): UseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>
} {
  const queryOptions = getFindManyOrganizationsQueryOptions(params, options)

  const query = useQuery(queryOptions, queryClient) as UseQueryResult<
    TData,
    TError
  > & { queryKey: DataTag<QueryKey, TData, TError> }

  query.queryKey = queryOptions.queryKey

  return query
}

/**
 * Delete an organization
 * @summary Delete an organization
 */
export type deleteOrganizationResponse200 = {
  data: DeleteOrganization200
  status: 200
}

export type deleteOrganizationResponse404 = {
  data: DeleteOrganization404
  status: 404
}

export type deleteOrganizationResponseComposite =
  | deleteOrganizationResponse200
  | deleteOrganizationResponse404

export type deleteOrganizationResponse = deleteOrganizationResponseComposite & {
  headers: Headers
}

export const getDeleteOrganizationUrl = (id: string) => {
  return `http://0.0.0.0:3001/organizations/${id}`
}

export const deleteOrganization = async (
  id: string,
  options?: RequestInit
): Promise<deleteOrganizationResponse> => {
  const res = await fetch(getDeleteOrganizationUrl(id), {
    ...options,
    method: 'DELETE'
  })

  const body = [204, 205, 304].includes(res.status) ? null : await res.text()
  const data: deleteOrganizationResponse['data'] = body ? JSON.parse(body) : {}

  return {
    data,
    status: res.status,
    headers: res.headers
  } as deleteOrganizationResponse
}

export const getDeleteOrganizationMutationOptions = <
  TError = DeleteOrganization404,
  TContext = unknown
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof deleteOrganization>>,
    TError,
    { id: string },
    TContext
  >
  fetch?: RequestInit
}): UseMutationOptions<
  Awaited<ReturnType<typeof deleteOrganization>>,
  TError,
  { id: string },
  TContext
> => {
  const mutationKey = ['deleteOrganization']
  const { mutation: mutationOptions, fetch: fetchOptions } =
    options ?
      (
        options.mutation &&
        'mutationKey' in options.mutation &&
        options.mutation.mutationKey
      ) ?
        options
      : { ...options, mutation: { ...options.mutation, mutationKey } }
    : { mutation: { mutationKey }, fetch: undefined }

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof deleteOrganization>>,
    { id: string }
  > = (props) => {
    const { id } = props ?? {}

    return deleteOrganization(id, fetchOptions)
  }

  return { mutationFn, ...mutationOptions }
}

export type DeleteOrganizationMutationResult = NonNullable<
  Awaited<ReturnType<typeof deleteOrganization>>
>

export type DeleteOrganizationMutationError = DeleteOrganization404

/**
 * @summary Delete an organization
 */
export const useDeleteOrganization = <
  TError = DeleteOrganization404,
  TContext = unknown
>(
  options?: {
    mutation?: UseMutationOptions<
      Awaited<ReturnType<typeof deleteOrganization>>,
      TError,
      { id: string },
      TContext
    >
    fetch?: RequestInit
  },
  queryClient?: QueryClient
): UseMutationResult<
  Awaited<ReturnType<typeof deleteOrganization>>,
  TError,
  { id: string },
  TContext
> => {
  const mutationOptions = getDeleteOrganizationMutationOptions(options)

  return useMutation(mutationOptions, queryClient)
}

/**
 * Find an organization
 * @summary Find an organization
 */
export type getOneOrganizationResponse200 = {
  data: GetOneOrganization200
  status: 200
}

export type getOneOrganizationResponse404 = {
  data: GetOneOrganization404
  status: 404
}

export type getOneOrganizationResponseComposite =
  | getOneOrganizationResponse200
  | getOneOrganizationResponse404

export type getOneOrganizationResponse = getOneOrganizationResponseComposite & {
  headers: Headers
}

export const getGetOneOrganizationUrl = (id: string) => {
  return `http://0.0.0.0:3001/organizations/${id}`
}

export const getOneOrganization = async (
  id: string,
  options?: RequestInit
): Promise<getOneOrganizationResponse> => {
  const res = await fetch(getGetOneOrganizationUrl(id), {
    ...options,
    method: 'GET'
  })

  const body = [204, 205, 304].includes(res.status) ? null : await res.text()
  const data: getOneOrganizationResponse['data'] = body ? JSON.parse(body) : {}

  return {
    data,
    status: res.status,
    headers: res.headers
  } as getOneOrganizationResponse
}

export const getGetOneOrganizationQueryKey = (id: string) => {
  return [`http://0.0.0.0:3001/organizations/${id}`] as const
}

export const getGetOneOrganizationQueryOptions = <
  TData = Awaited<ReturnType<typeof getOneOrganization>>,
  TError = GetOneOrganization404
>(
  id: string,
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof getOneOrganization>>,
        TError,
        TData
      >
    >
    fetch?: RequestInit
  }
) => {
  const { query: queryOptions, fetch: fetchOptions } = options ?? {}

  const queryKey = queryOptions?.queryKey ?? getGetOneOrganizationQueryKey(id)

  const queryFn: QueryFunction<
    Awaited<ReturnType<typeof getOneOrganization>>
  > = ({ signal }) =>
    getOneOrganization(id, { ...(signal ? { signal } : {}), ...fetchOptions })

  return {
    queryKey,
    queryFn,
    enabled: !!id,
    ...queryOptions
  } as UseQueryOptions<
    Awaited<ReturnType<typeof getOneOrganization>>,
    TError,
    TData
  > & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type GetOneOrganizationQueryResult = NonNullable<
  Awaited<ReturnType<typeof getOneOrganization>>
>
export type GetOneOrganizationQueryError = GetOneOrganization404

export function useGetOneOrganization<
  TData = Awaited<ReturnType<typeof getOneOrganization>>,
  TError = GetOneOrganization404
>(
  id: string,
  options: {
    query: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof getOneOrganization>>,
        TError,
        TData
      >
    > &
      Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof getOneOrganization>>,
          TError,
          Awaited<ReturnType<typeof getOneOrganization>>
        >,
        'initialData'
      >
    fetch?: RequestInit
  },
  queryClient?: QueryClient
): DefinedUseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>
}
export function useGetOneOrganization<
  TData = Awaited<ReturnType<typeof getOneOrganization>>,
  TError = GetOneOrganization404
>(
  id: string,
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof getOneOrganization>>,
        TError,
        TData
      >
    > &
      Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof getOneOrganization>>,
          TError,
          Awaited<ReturnType<typeof getOneOrganization>>
        >,
        'initialData'
      >
    fetch?: RequestInit
  },
  queryClient?: QueryClient
): UseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>
}
export function useGetOneOrganization<
  TData = Awaited<ReturnType<typeof getOneOrganization>>,
  TError = GetOneOrganization404
>(
  id: string,
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof getOneOrganization>>,
        TError,
        TData
      >
    >
    fetch?: RequestInit
  },
  queryClient?: QueryClient
): UseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>
}
/**
 * @summary Find an organization
 */

export function useGetOneOrganization<
  TData = Awaited<ReturnType<typeof getOneOrganization>>,
  TError = GetOneOrganization404
>(
  id: string,
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof getOneOrganization>>,
        TError,
        TData
      >
    >
    fetch?: RequestInit
  },
  queryClient?: QueryClient
): UseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>
} {
  const queryOptions = getGetOneOrganizationQueryOptions(id, options)

  const query = useQuery(queryOptions, queryClient) as UseQueryResult<
    TData,
    TError
  > & { queryKey: DataTag<QueryKey, TData, TError> }

  query.queryKey = queryOptions.queryKey

  return query
}

/**
 * Update an organization
 * @summary Update an organization
 */
export type updateOrganizationResponse200 = {
  data: UpdateOrganization200
  status: 200
}

export type updateOrganizationResponse404 = {
  data: UpdateOrganization404
  status: 404
}

export type updateOrganizationResponseComposite =
  | updateOrganizationResponse200
  | updateOrganizationResponse404

export type updateOrganizationResponse = updateOrganizationResponseComposite & {
  headers: Headers
}

export const getUpdateOrganizationUrl = (id: string) => {
  return `http://0.0.0.0:3001/organizations/${id}`
}

export const updateOrganization = async (
  id: string,
  updateOrganizationBody: UpdateOrganizationBody,
  options?: RequestInit
): Promise<updateOrganizationResponse> => {
  const res = await fetch(getUpdateOrganizationUrl(id), {
    ...options,
    method: 'PATCH',
    headers: { 'Content-Type': 'application/json', ...options?.headers },
    body: JSON.stringify(updateOrganizationBody)
  })

  const body = [204, 205, 304].includes(res.status) ? null : await res.text()
  const data: updateOrganizationResponse['data'] = body ? JSON.parse(body) : {}

  return {
    data,
    status: res.status,
    headers: res.headers
  } as updateOrganizationResponse
}

export const getUpdateOrganizationMutationOptions = <
  TError = UpdateOrganization404,
  TContext = unknown
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof updateOrganization>>,
    TError,
    { id: string; data: UpdateOrganizationBody },
    TContext
  >
  fetch?: RequestInit
}): UseMutationOptions<
  Awaited<ReturnType<typeof updateOrganization>>,
  TError,
  { id: string; data: UpdateOrganizationBody },
  TContext
> => {
  const mutationKey = ['updateOrganization']
  const { mutation: mutationOptions, fetch: fetchOptions } =
    options ?
      (
        options.mutation &&
        'mutationKey' in options.mutation &&
        options.mutation.mutationKey
      ) ?
        options
      : { ...options, mutation: { ...options.mutation, mutationKey } }
    : { mutation: { mutationKey }, fetch: undefined }

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof updateOrganization>>,
    { id: string; data: UpdateOrganizationBody }
  > = (props) => {
    const { id, data } = props ?? {}

    return updateOrganization(id, data, fetchOptions)
  }

  return { mutationFn, ...mutationOptions }
}

export type UpdateOrganizationMutationResult = NonNullable<
  Awaited<ReturnType<typeof updateOrganization>>
>
export type UpdateOrganizationMutationBody = UpdateOrganizationBody
export type UpdateOrganizationMutationError = UpdateOrganization404

/**
 * @summary Update an organization
 */
export const useUpdateOrganization = <
  TError = UpdateOrganization404,
  TContext = unknown
>(
  options?: {
    mutation?: UseMutationOptions<
      Awaited<ReturnType<typeof updateOrganization>>,
      TError,
      { id: string; data: UpdateOrganizationBody },
      TContext
    >
    fetch?: RequestInit
  },
  queryClient?: QueryClient
): UseMutationResult<
  Awaited<ReturnType<typeof updateOrganization>>,
  TError,
  { id: string; data: UpdateOrganizationBody },
  TContext
> => {
  const mutationOptions = getUpdateOrganizationMutationOptions(options)

  return useMutation(mutationOptions, queryClient)
}

/**
 * Create a new user
 * @summary Create a new user
 */
export type createUserResponse201 = {
  data: CreateUser201
  status: 201
}

export type createUserResponseComposite = createUserResponse201

export type createUserResponse = createUserResponseComposite & {
  headers: Headers
}

export const getCreateUserUrl = () => {
  return `http://0.0.0.0:3001/users`
}

export const createUser = async (
  createUserBody: CreateUserBody,
  options?: RequestInit
): Promise<createUserResponse> => {
  const res = await fetch(getCreateUserUrl(), {
    ...options,
    method: 'POST',
    headers: { 'Content-Type': 'application/json', ...options?.headers },
    body: JSON.stringify(createUserBody)
  })

  const body = [204, 205, 304].includes(res.status) ? null : await res.text()
  const data: createUserResponse['data'] = body ? JSON.parse(body) : {}

  return {
    data,
    status: res.status,
    headers: res.headers
  } as createUserResponse
}

export const getCreateUserMutationOptions = <
  TError = unknown,
  TContext = unknown
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof createUser>>,
    TError,
    { data: CreateUserBody },
    TContext
  >
  fetch?: RequestInit
}): UseMutationOptions<
  Awaited<ReturnType<typeof createUser>>,
  TError,
  { data: CreateUserBody },
  TContext
> => {
  const mutationKey = ['createUser']
  const { mutation: mutationOptions, fetch: fetchOptions } =
    options ?
      (
        options.mutation &&
        'mutationKey' in options.mutation &&
        options.mutation.mutationKey
      ) ?
        options
      : { ...options, mutation: { ...options.mutation, mutationKey } }
    : { mutation: { mutationKey }, fetch: undefined }

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof createUser>>,
    { data: CreateUserBody }
  > = (props) => {
    const { data } = props ?? {}

    return createUser(data, fetchOptions)
  }

  return { mutationFn, ...mutationOptions }
}

export type CreateUserMutationResult = NonNullable<
  Awaited<ReturnType<typeof createUser>>
>
export type CreateUserMutationBody = CreateUserBody
export type CreateUserMutationError = unknown

/**
 * @summary Create a new user
 */
export const useCreateUser = <TError = unknown, TContext = unknown>(
  options?: {
    mutation?: UseMutationOptions<
      Awaited<ReturnType<typeof createUser>>,
      TError,
      { data: CreateUserBody },
      TContext
    >
    fetch?: RequestInit
  },
  queryClient?: QueryClient
): UseMutationResult<
  Awaited<ReturnType<typeof createUser>>,
  TError,
  { data: CreateUserBody },
  TContext
> => {
  const mutationOptions = getCreateUserMutationOptions(options)

  return useMutation(mutationOptions, queryClient)
}

/**
 * Find many users
 * @summary Find many users
 */
export type findManyUsersResponse200 = {
  data: FindManyUsers200
  status: 200
}

export type findManyUsersResponseComposite = findManyUsersResponse200

export type findManyUsersResponse = findManyUsersResponseComposite & {
  headers: Headers
}

export const getFindManyUsersUrl = (params?: FindManyUsersParams) => {
  const normalizedParams = new URLSearchParams()

  Object.entries(params || {}).forEach(([key, value]) => {
    if (value !== undefined) {
      normalizedParams.append(key, value === null ? 'null' : value.toString())
    }
  })

  const stringifiedParams = normalizedParams.toString()

  return stringifiedParams.length > 0 ?
      `http://0.0.0.0:3001/users?${stringifiedParams}`
    : `http://0.0.0.0:3001/users`
}

export const findManyUsers = async (
  params?: FindManyUsersParams,
  options?: RequestInit
): Promise<findManyUsersResponse> => {
  const res = await fetch(getFindManyUsersUrl(params), {
    ...options,
    method: 'GET'
  })

  const body = [204, 205, 304].includes(res.status) ? null : await res.text()
  const data: findManyUsersResponse['data'] = body ? JSON.parse(body) : {}

  return {
    data,
    status: res.status,
    headers: res.headers
  } as findManyUsersResponse
}

export const getFindManyUsersQueryKey = (params?: FindManyUsersParams) => {
  return [`http://0.0.0.0:3001/users`, ...(params ? [params] : [])] as const
}

export const getFindManyUsersQueryOptions = <
  TData = Awaited<ReturnType<typeof findManyUsers>>,
  TError = unknown
>(
  params?: FindManyUsersParams,
  options?: {
    query?: Partial<
      UseQueryOptions<Awaited<ReturnType<typeof findManyUsers>>, TError, TData>
    >
    fetch?: RequestInit
  }
) => {
  const { query: queryOptions, fetch: fetchOptions } = options ?? {}

  const queryKey = queryOptions?.queryKey ?? getFindManyUsersQueryKey(params)

  const queryFn: QueryFunction<Awaited<ReturnType<typeof findManyUsers>>> = ({
    signal
  }) =>
    findManyUsers(params, { ...(signal ? { signal } : {}), ...fetchOptions })

  return { queryKey, queryFn, ...queryOptions } as UseQueryOptions<
    Awaited<ReturnType<typeof findManyUsers>>,
    TError,
    TData
  > & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type FindManyUsersQueryResult = NonNullable<
  Awaited<ReturnType<typeof findManyUsers>>
>
export type FindManyUsersQueryError = unknown

export function useFindManyUsers<
  TData = Awaited<ReturnType<typeof findManyUsers>>,
  TError = unknown
>(
  params: undefined | FindManyUsersParams,
  options: {
    query: Partial<
      UseQueryOptions<Awaited<ReturnType<typeof findManyUsers>>, TError, TData>
    > &
      Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof findManyUsers>>,
          TError,
          Awaited<ReturnType<typeof findManyUsers>>
        >,
        'initialData'
      >
    fetch?: RequestInit
  },
  queryClient?: QueryClient
): DefinedUseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>
}
export function useFindManyUsers<
  TData = Awaited<ReturnType<typeof findManyUsers>>,
  TError = unknown
>(
  params?: FindManyUsersParams,
  options?: {
    query?: Partial<
      UseQueryOptions<Awaited<ReturnType<typeof findManyUsers>>, TError, TData>
    > &
      Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof findManyUsers>>,
          TError,
          Awaited<ReturnType<typeof findManyUsers>>
        >,
        'initialData'
      >
    fetch?: RequestInit
  },
  queryClient?: QueryClient
): UseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>
}
export function useFindManyUsers<
  TData = Awaited<ReturnType<typeof findManyUsers>>,
  TError = unknown
>(
  params?: FindManyUsersParams,
  options?: {
    query?: Partial<
      UseQueryOptions<Awaited<ReturnType<typeof findManyUsers>>, TError, TData>
    >
    fetch?: RequestInit
  },
  queryClient?: QueryClient
): UseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>
}
/**
 * @summary Find many users
 */

export function useFindManyUsers<
  TData = Awaited<ReturnType<typeof findManyUsers>>,
  TError = unknown
>(
  params?: FindManyUsersParams,
  options?: {
    query?: Partial<
      UseQueryOptions<Awaited<ReturnType<typeof findManyUsers>>, TError, TData>
    >
    fetch?: RequestInit
  },
  queryClient?: QueryClient
): UseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>
} {
  const queryOptions = getFindManyUsersQueryOptions(params, options)

  const query = useQuery(queryOptions, queryClient) as UseQueryResult<
    TData,
    TError
  > & { queryKey: DataTag<QueryKey, TData, TError> }

  query.queryKey = queryOptions.queryKey

  return query
}

/**
 * Delete an user
 * @summary Delete an user
 */
export type deleteUserResponse200 = {
  data: DeleteUser200
  status: 200
}

export type deleteUserResponse404 = {
  data: DeleteUser404
  status: 404
}

export type deleteUserResponseComposite =
  | deleteUserResponse200
  | deleteUserResponse404

export type deleteUserResponse = deleteUserResponseComposite & {
  headers: Headers
}

export const getDeleteUserUrl = (id: string) => {
  return `http://0.0.0.0:3001/users/${id}`
}

export const deleteUser = async (
  id: string,
  options?: RequestInit
): Promise<deleteUserResponse> => {
  const res = await fetch(getDeleteUserUrl(id), {
    ...options,
    method: 'DELETE'
  })

  const body = [204, 205, 304].includes(res.status) ? null : await res.text()
  const data: deleteUserResponse['data'] = body ? JSON.parse(body) : {}

  return {
    data,
    status: res.status,
    headers: res.headers
  } as deleteUserResponse
}

export const getDeleteUserMutationOptions = <
  TError = DeleteUser404,
  TContext = unknown
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof deleteUser>>,
    TError,
    { id: string },
    TContext
  >
  fetch?: RequestInit
}): UseMutationOptions<
  Awaited<ReturnType<typeof deleteUser>>,
  TError,
  { id: string },
  TContext
> => {
  const mutationKey = ['deleteUser']
  const { mutation: mutationOptions, fetch: fetchOptions } =
    options ?
      (
        options.mutation &&
        'mutationKey' in options.mutation &&
        options.mutation.mutationKey
      ) ?
        options
      : { ...options, mutation: { ...options.mutation, mutationKey } }
    : { mutation: { mutationKey }, fetch: undefined }

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof deleteUser>>,
    { id: string }
  > = (props) => {
    const { id } = props ?? {}

    return deleteUser(id, fetchOptions)
  }

  return { mutationFn, ...mutationOptions }
}

export type DeleteUserMutationResult = NonNullable<
  Awaited<ReturnType<typeof deleteUser>>
>

export type DeleteUserMutationError = DeleteUser404

/**
 * @summary Delete an user
 */
export const useDeleteUser = <TError = DeleteUser404, TContext = unknown>(
  options?: {
    mutation?: UseMutationOptions<
      Awaited<ReturnType<typeof deleteUser>>,
      TError,
      { id: string },
      TContext
    >
    fetch?: RequestInit
  },
  queryClient?: QueryClient
): UseMutationResult<
  Awaited<ReturnType<typeof deleteUser>>,
  TError,
  { id: string },
  TContext
> => {
  const mutationOptions = getDeleteUserMutationOptions(options)

  return useMutation(mutationOptions, queryClient)
}

/**
 * Find an user
 * @summary Find an user
 */
export type getOneUserResponse200 = {
  data: GetOneUser200
  status: 200
}

export type getOneUserResponse404 = {
  data: GetOneUser404
  status: 404
}

export type getOneUserResponseComposite =
  | getOneUserResponse200
  | getOneUserResponse404

export type getOneUserResponse = getOneUserResponseComposite & {
  headers: Headers
}

export const getGetOneUserUrl = (id: string) => {
  return `http://0.0.0.0:3001/users/${id}`
}

export const getOneUser = async (
  id: string,
  options?: RequestInit
): Promise<getOneUserResponse> => {
  const res = await fetch(getGetOneUserUrl(id), {
    ...options,
    method: 'GET'
  })

  const body = [204, 205, 304].includes(res.status) ? null : await res.text()
  const data: getOneUserResponse['data'] = body ? JSON.parse(body) : {}

  return {
    data,
    status: res.status,
    headers: res.headers
  } as getOneUserResponse
}

export const getGetOneUserQueryKey = (id: string) => {
  return [`http://0.0.0.0:3001/users/${id}`] as const
}

export const getGetOneUserQueryOptions = <
  TData = Awaited<ReturnType<typeof getOneUser>>,
  TError = GetOneUser404
>(
  id: string,
  options?: {
    query?: Partial<
      UseQueryOptions<Awaited<ReturnType<typeof getOneUser>>, TError, TData>
    >
    fetch?: RequestInit
  }
) => {
  const { query: queryOptions, fetch: fetchOptions } = options ?? {}

  const queryKey = queryOptions?.queryKey ?? getGetOneUserQueryKey(id)

  const queryFn: QueryFunction<Awaited<ReturnType<typeof getOneUser>>> = ({
    signal
  }) => getOneUser(id, { ...(signal ? { signal } : {}), ...fetchOptions })

  return {
    queryKey,
    queryFn,
    enabled: !!id,
    ...queryOptions
  } as UseQueryOptions<
    Awaited<ReturnType<typeof getOneUser>>,
    TError,
    TData
  > & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type GetOneUserQueryResult = NonNullable<
  Awaited<ReturnType<typeof getOneUser>>
>
export type GetOneUserQueryError = GetOneUser404

export function useGetOneUser<
  TData = Awaited<ReturnType<typeof getOneUser>>,
  TError = GetOneUser404
>(
  id: string,
  options: {
    query: Partial<
      UseQueryOptions<Awaited<ReturnType<typeof getOneUser>>, TError, TData>
    > &
      Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof getOneUser>>,
          TError,
          Awaited<ReturnType<typeof getOneUser>>
        >,
        'initialData'
      >
    fetch?: RequestInit
  },
  queryClient?: QueryClient
): DefinedUseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>
}
export function useGetOneUser<
  TData = Awaited<ReturnType<typeof getOneUser>>,
  TError = GetOneUser404
>(
  id: string,
  options?: {
    query?: Partial<
      UseQueryOptions<Awaited<ReturnType<typeof getOneUser>>, TError, TData>
    > &
      Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof getOneUser>>,
          TError,
          Awaited<ReturnType<typeof getOneUser>>
        >,
        'initialData'
      >
    fetch?: RequestInit
  },
  queryClient?: QueryClient
): UseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>
}
export function useGetOneUser<
  TData = Awaited<ReturnType<typeof getOneUser>>,
  TError = GetOneUser404
>(
  id: string,
  options?: {
    query?: Partial<
      UseQueryOptions<Awaited<ReturnType<typeof getOneUser>>, TError, TData>
    >
    fetch?: RequestInit
  },
  queryClient?: QueryClient
): UseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>
}
/**
 * @summary Find an user
 */

export function useGetOneUser<
  TData = Awaited<ReturnType<typeof getOneUser>>,
  TError = GetOneUser404
>(
  id: string,
  options?: {
    query?: Partial<
      UseQueryOptions<Awaited<ReturnType<typeof getOneUser>>, TError, TData>
    >
    fetch?: RequestInit
  },
  queryClient?: QueryClient
): UseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>
} {
  const queryOptions = getGetOneUserQueryOptions(id, options)

  const query = useQuery(queryOptions, queryClient) as UseQueryResult<
    TData,
    TError
  > & { queryKey: DataTag<QueryKey, TData, TError> }

  query.queryKey = queryOptions.queryKey

  return query
}

/**
 * Update an user
 * @summary Update an user
 */
export type updateUserResponse200 = {
  data: UpdateUser200
  status: 200
}

export type updateUserResponse404 = {
  data: UpdateUser404
  status: 404
}

export type updateUserResponseComposite =
  | updateUserResponse200
  | updateUserResponse404

export type updateUserResponse = updateUserResponseComposite & {
  headers: Headers
}

export const getUpdateUserUrl = (id: string) => {
  return `http://0.0.0.0:3001/users/${id}`
}

export const updateUser = async (
  id: string,
  updateUserBody: UpdateUserBody,
  options?: RequestInit
): Promise<updateUserResponse> => {
  const res = await fetch(getUpdateUserUrl(id), {
    ...options,
    method: 'PATCH',
    headers: { 'Content-Type': 'application/json', ...options?.headers },
    body: JSON.stringify(updateUserBody)
  })

  const body = [204, 205, 304].includes(res.status) ? null : await res.text()
  const data: updateUserResponse['data'] = body ? JSON.parse(body) : {}

  return {
    data,
    status: res.status,
    headers: res.headers
  } as updateUserResponse
}

export const getUpdateUserMutationOptions = <
  TError = UpdateUser404,
  TContext = unknown
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof updateUser>>,
    TError,
    { id: string; data: UpdateUserBody },
    TContext
  >
  fetch?: RequestInit
}): UseMutationOptions<
  Awaited<ReturnType<typeof updateUser>>,
  TError,
  { id: string; data: UpdateUserBody },
  TContext
> => {
  const mutationKey = ['updateUser']
  const { mutation: mutationOptions, fetch: fetchOptions } =
    options ?
      (
        options.mutation &&
        'mutationKey' in options.mutation &&
        options.mutation.mutationKey
      ) ?
        options
      : { ...options, mutation: { ...options.mutation, mutationKey } }
    : { mutation: { mutationKey }, fetch: undefined }

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof updateUser>>,
    { id: string; data: UpdateUserBody }
  > = (props) => {
    const { id, data } = props ?? {}

    return updateUser(id, data, fetchOptions)
  }

  return { mutationFn, ...mutationOptions }
}

export type UpdateUserMutationResult = NonNullable<
  Awaited<ReturnType<typeof updateUser>>
>
export type UpdateUserMutationBody = UpdateUserBody
export type UpdateUserMutationError = UpdateUser404

/**
 * @summary Update an user
 */
export const useUpdateUser = <TError = UpdateUser404, TContext = unknown>(
  options?: {
    mutation?: UseMutationOptions<
      Awaited<ReturnType<typeof updateUser>>,
      TError,
      { id: string; data: UpdateUserBody },
      TContext
    >
    fetch?: RequestInit
  },
  queryClient?: QueryClient
): UseMutationResult<
  Awaited<ReturnType<typeof updateUser>>,
  TError,
  { id: string; data: UpdateUserBody },
  TContext
> => {
  const mutationOptions = getUpdateUserMutationOptions(options)

  return useMutation(mutationOptions, queryClient)
}

/**
 * Create a new member
 * @summary Create a new member
 */
export type createMemberResponse201 = {
  data: CreateMember201
  status: 201
}

export type createMemberResponseComposite = createMemberResponse201

export type createMemberResponse = createMemberResponseComposite & {
  headers: Headers
}

export const getCreateMemberUrl = () => {
  return `http://0.0.0.0:3001/members`
}

export const createMember = async (
  createMemberBody: CreateMemberBody,
  options?: RequestInit
): Promise<createMemberResponse> => {
  const res = await fetch(getCreateMemberUrl(), {
    ...options,
    method: 'POST',
    headers: { 'Content-Type': 'application/json', ...options?.headers },
    body: JSON.stringify(createMemberBody)
  })

  const body = [204, 205, 304].includes(res.status) ? null : await res.text()
  const data: createMemberResponse['data'] = body ? JSON.parse(body) : {}

  return {
    data,
    status: res.status,
    headers: res.headers
  } as createMemberResponse
}

export const getCreateMemberMutationOptions = <
  TError = unknown,
  TContext = unknown
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof createMember>>,
    TError,
    { data: CreateMemberBody },
    TContext
  >
  fetch?: RequestInit
}): UseMutationOptions<
  Awaited<ReturnType<typeof createMember>>,
  TError,
  { data: CreateMemberBody },
  TContext
> => {
  const mutationKey = ['createMember']
  const { mutation: mutationOptions, fetch: fetchOptions } =
    options ?
      (
        options.mutation &&
        'mutationKey' in options.mutation &&
        options.mutation.mutationKey
      ) ?
        options
      : { ...options, mutation: { ...options.mutation, mutationKey } }
    : { mutation: { mutationKey }, fetch: undefined }

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof createMember>>,
    { data: CreateMemberBody }
  > = (props) => {
    const { data } = props ?? {}

    return createMember(data, fetchOptions)
  }

  return { mutationFn, ...mutationOptions }
}

export type CreateMemberMutationResult = NonNullable<
  Awaited<ReturnType<typeof createMember>>
>
export type CreateMemberMutationBody = CreateMemberBody
export type CreateMemberMutationError = unknown

/**
 * @summary Create a new member
 */
export const useCreateMember = <TError = unknown, TContext = unknown>(
  options?: {
    mutation?: UseMutationOptions<
      Awaited<ReturnType<typeof createMember>>,
      TError,
      { data: CreateMemberBody },
      TContext
    >
    fetch?: RequestInit
  },
  queryClient?: QueryClient
): UseMutationResult<
  Awaited<ReturnType<typeof createMember>>,
  TError,
  { data: CreateMemberBody },
  TContext
> => {
  const mutationOptions = getCreateMemberMutationOptions(options)

  return useMutation(mutationOptions, queryClient)
}

/**
 * Find many members
 * @summary Find many members
 */
export type findManyMembersResponse200 = {
  data: FindManyMembers200
  status: 200
}

export type findManyMembersResponseComposite = findManyMembersResponse200

export type findManyMembersResponse = findManyMembersResponseComposite & {
  headers: Headers
}

export const getFindManyMembersUrl = (params?: FindManyMembersParams) => {
  const normalizedParams = new URLSearchParams()

  Object.entries(params || {}).forEach(([key, value]) => {
    if (value !== undefined) {
      normalizedParams.append(key, value === null ? 'null' : value.toString())
    }
  })

  const stringifiedParams = normalizedParams.toString()

  return stringifiedParams.length > 0 ?
      `http://0.0.0.0:3001/members?${stringifiedParams}`
    : `http://0.0.0.0:3001/members`
}

export const findManyMembers = async (
  params?: FindManyMembersParams,
  options?: RequestInit
): Promise<findManyMembersResponse> => {
  const res = await fetch(getFindManyMembersUrl(params), {
    ...options,
    method: 'GET'
  })

  const body = [204, 205, 304].includes(res.status) ? null : await res.text()
  const data: findManyMembersResponse['data'] = body ? JSON.parse(body) : {}

  return {
    data,
    status: res.status,
    headers: res.headers
  } as findManyMembersResponse
}

export const getFindManyMembersQueryKey = (params?: FindManyMembersParams) => {
  return [`http://0.0.0.0:3001/members`, ...(params ? [params] : [])] as const
}

export const getFindManyMembersQueryOptions = <
  TData = Awaited<ReturnType<typeof findManyMembers>>,
  TError = unknown
>(
  params?: FindManyMembersParams,
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof findManyMembers>>,
        TError,
        TData
      >
    >
    fetch?: RequestInit
  }
) => {
  const { query: queryOptions, fetch: fetchOptions } = options ?? {}

  const queryKey = queryOptions?.queryKey ?? getFindManyMembersQueryKey(params)

  const queryFn: QueryFunction<Awaited<ReturnType<typeof findManyMembers>>> = ({
    signal
  }) =>
    findManyMembers(params, { ...(signal ? { signal } : {}), ...fetchOptions })

  return { queryKey, queryFn, ...queryOptions } as UseQueryOptions<
    Awaited<ReturnType<typeof findManyMembers>>,
    TError,
    TData
  > & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type FindManyMembersQueryResult = NonNullable<
  Awaited<ReturnType<typeof findManyMembers>>
>
export type FindManyMembersQueryError = unknown

export function useFindManyMembers<
  TData = Awaited<ReturnType<typeof findManyMembers>>,
  TError = unknown
>(
  params: undefined | FindManyMembersParams,
  options: {
    query: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof findManyMembers>>,
        TError,
        TData
      >
    > &
      Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof findManyMembers>>,
          TError,
          Awaited<ReturnType<typeof findManyMembers>>
        >,
        'initialData'
      >
    fetch?: RequestInit
  },
  queryClient?: QueryClient
): DefinedUseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>
}
export function useFindManyMembers<
  TData = Awaited<ReturnType<typeof findManyMembers>>,
  TError = unknown
>(
  params?: FindManyMembersParams,
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof findManyMembers>>,
        TError,
        TData
      >
    > &
      Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof findManyMembers>>,
          TError,
          Awaited<ReturnType<typeof findManyMembers>>
        >,
        'initialData'
      >
    fetch?: RequestInit
  },
  queryClient?: QueryClient
): UseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>
}
export function useFindManyMembers<
  TData = Awaited<ReturnType<typeof findManyMembers>>,
  TError = unknown
>(
  params?: FindManyMembersParams,
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof findManyMembers>>,
        TError,
        TData
      >
    >
    fetch?: RequestInit
  },
  queryClient?: QueryClient
): UseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>
}
/**
 * @summary Find many members
 */

export function useFindManyMembers<
  TData = Awaited<ReturnType<typeof findManyMembers>>,
  TError = unknown
>(
  params?: FindManyMembersParams,
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof findManyMembers>>,
        TError,
        TData
      >
    >
    fetch?: RequestInit
  },
  queryClient?: QueryClient
): UseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>
} {
  const queryOptions = getFindManyMembersQueryOptions(params, options)

  const query = useQuery(queryOptions, queryClient) as UseQueryResult<
    TData,
    TError
  > & { queryKey: DataTag<QueryKey, TData, TError> }

  query.queryKey = queryOptions.queryKey

  return query
}

/**
 * Delete a member
 * @summary Delete a member
 */
export type deleteMemberResponse200 = {
  data: DeleteMember200
  status: 200
}

export type deleteMemberResponse404 = {
  data: DeleteMember404
  status: 404
}

export type deleteMemberResponseComposite =
  | deleteMemberResponse200
  | deleteMemberResponse404

export type deleteMemberResponse = deleteMemberResponseComposite & {
  headers: Headers
}

export const getDeleteMemberUrl = (id: string) => {
  return `http://0.0.0.0:3001/members/${id}`
}

export const deleteMember = async (
  id: string,
  options?: RequestInit
): Promise<deleteMemberResponse> => {
  const res = await fetch(getDeleteMemberUrl(id), {
    ...options,
    method: 'DELETE'
  })

  const body = [204, 205, 304].includes(res.status) ? null : await res.text()
  const data: deleteMemberResponse['data'] = body ? JSON.parse(body) : {}

  return {
    data,
    status: res.status,
    headers: res.headers
  } as deleteMemberResponse
}

export const getDeleteMemberMutationOptions = <
  TError = DeleteMember404,
  TContext = unknown
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof deleteMember>>,
    TError,
    { id: string },
    TContext
  >
  fetch?: RequestInit
}): UseMutationOptions<
  Awaited<ReturnType<typeof deleteMember>>,
  TError,
  { id: string },
  TContext
> => {
  const mutationKey = ['deleteMember']
  const { mutation: mutationOptions, fetch: fetchOptions } =
    options ?
      (
        options.mutation &&
        'mutationKey' in options.mutation &&
        options.mutation.mutationKey
      ) ?
        options
      : { ...options, mutation: { ...options.mutation, mutationKey } }
    : { mutation: { mutationKey }, fetch: undefined }

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof deleteMember>>,
    { id: string }
  > = (props) => {
    const { id } = props ?? {}

    return deleteMember(id, fetchOptions)
  }

  return { mutationFn, ...mutationOptions }
}

export type DeleteMemberMutationResult = NonNullable<
  Awaited<ReturnType<typeof deleteMember>>
>

export type DeleteMemberMutationError = DeleteMember404

/**
 * @summary Delete a member
 */
export const useDeleteMember = <TError = DeleteMember404, TContext = unknown>(
  options?: {
    mutation?: UseMutationOptions<
      Awaited<ReturnType<typeof deleteMember>>,
      TError,
      { id: string },
      TContext
    >
    fetch?: RequestInit
  },
  queryClient?: QueryClient
): UseMutationResult<
  Awaited<ReturnType<typeof deleteMember>>,
  TError,
  { id: string },
  TContext
> => {
  const mutationOptions = getDeleteMemberMutationOptions(options)

  return useMutation(mutationOptions, queryClient)
}

/**
 * Find a member
 * @summary Find a member
 */
export type getOneMemberResponse200 = {
  data: GetOneMember200
  status: 200
}

export type getOneMemberResponse404 = {
  data: GetOneMember404
  status: 404
}

export type getOneMemberResponseComposite =
  | getOneMemberResponse200
  | getOneMemberResponse404

export type getOneMemberResponse = getOneMemberResponseComposite & {
  headers: Headers
}

export const getGetOneMemberUrl = (id: string) => {
  return `http://0.0.0.0:3001/members/${id}`
}

export const getOneMember = async (
  id: string,
  options?: RequestInit
): Promise<getOneMemberResponse> => {
  const res = await fetch(getGetOneMemberUrl(id), {
    ...options,
    method: 'GET'
  })

  const body = [204, 205, 304].includes(res.status) ? null : await res.text()
  const data: getOneMemberResponse['data'] = body ? JSON.parse(body) : {}

  return {
    data,
    status: res.status,
    headers: res.headers
  } as getOneMemberResponse
}

export const getGetOneMemberQueryKey = (id: string) => {
  return [`http://0.0.0.0:3001/members/${id}`] as const
}

export const getGetOneMemberQueryOptions = <
  TData = Awaited<ReturnType<typeof getOneMember>>,
  TError = GetOneMember404
>(
  id: string,
  options?: {
    query?: Partial<
      UseQueryOptions<Awaited<ReturnType<typeof getOneMember>>, TError, TData>
    >
    fetch?: RequestInit
  }
) => {
  const { query: queryOptions, fetch: fetchOptions } = options ?? {}

  const queryKey = queryOptions?.queryKey ?? getGetOneMemberQueryKey(id)

  const queryFn: QueryFunction<Awaited<ReturnType<typeof getOneMember>>> = ({
    signal
  }) => getOneMember(id, { ...(signal ? { signal } : {}), ...fetchOptions })

  return {
    queryKey,
    queryFn,
    enabled: !!id,
    ...queryOptions
  } as UseQueryOptions<
    Awaited<ReturnType<typeof getOneMember>>,
    TError,
    TData
  > & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type GetOneMemberQueryResult = NonNullable<
  Awaited<ReturnType<typeof getOneMember>>
>
export type GetOneMemberQueryError = GetOneMember404

export function useGetOneMember<
  TData = Awaited<ReturnType<typeof getOneMember>>,
  TError = GetOneMember404
>(
  id: string,
  options: {
    query: Partial<
      UseQueryOptions<Awaited<ReturnType<typeof getOneMember>>, TError, TData>
    > &
      Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof getOneMember>>,
          TError,
          Awaited<ReturnType<typeof getOneMember>>
        >,
        'initialData'
      >
    fetch?: RequestInit
  },
  queryClient?: QueryClient
): DefinedUseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>
}
export function useGetOneMember<
  TData = Awaited<ReturnType<typeof getOneMember>>,
  TError = GetOneMember404
>(
  id: string,
  options?: {
    query?: Partial<
      UseQueryOptions<Awaited<ReturnType<typeof getOneMember>>, TError, TData>
    > &
      Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof getOneMember>>,
          TError,
          Awaited<ReturnType<typeof getOneMember>>
        >,
        'initialData'
      >
    fetch?: RequestInit
  },
  queryClient?: QueryClient
): UseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>
}
export function useGetOneMember<
  TData = Awaited<ReturnType<typeof getOneMember>>,
  TError = GetOneMember404
>(
  id: string,
  options?: {
    query?: Partial<
      UseQueryOptions<Awaited<ReturnType<typeof getOneMember>>, TError, TData>
    >
    fetch?: RequestInit
  },
  queryClient?: QueryClient
): UseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>
}
/**
 * @summary Find a member
 */

export function useGetOneMember<
  TData = Awaited<ReturnType<typeof getOneMember>>,
  TError = GetOneMember404
>(
  id: string,
  options?: {
    query?: Partial<
      UseQueryOptions<Awaited<ReturnType<typeof getOneMember>>, TError, TData>
    >
    fetch?: RequestInit
  },
  queryClient?: QueryClient
): UseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>
} {
  const queryOptions = getGetOneMemberQueryOptions(id, options)

  const query = useQuery(queryOptions, queryClient) as UseQueryResult<
    TData,
    TError
  > & { queryKey: DataTag<QueryKey, TData, TError> }

  query.queryKey = queryOptions.queryKey

  return query
}

/**
 * Update a member
 * @summary Update a member
 */
export type updateMemberResponse200 = {
  data: UpdateMember200
  status: 200
}

export type updateMemberResponse404 = {
  data: UpdateMember404
  status: 404
}

export type updateMemberResponseComposite =
  | updateMemberResponse200
  | updateMemberResponse404

export type updateMemberResponse = updateMemberResponseComposite & {
  headers: Headers
}

export const getUpdateMemberUrl = (id: string) => {
  return `http://0.0.0.0:3001/members/${id}`
}

export const updateMember = async (
  id: string,
  updateMemberBody: UpdateMemberBody,
  options?: RequestInit
): Promise<updateMemberResponse> => {
  const res = await fetch(getUpdateMemberUrl(id), {
    ...options,
    method: 'PATCH',
    headers: { 'Content-Type': 'application/json', ...options?.headers },
    body: JSON.stringify(updateMemberBody)
  })

  const body = [204, 205, 304].includes(res.status) ? null : await res.text()
  const data: updateMemberResponse['data'] = body ? JSON.parse(body) : {}

  return {
    data,
    status: res.status,
    headers: res.headers
  } as updateMemberResponse
}

export const getUpdateMemberMutationOptions = <
  TError = UpdateMember404,
  TContext = unknown
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof updateMember>>,
    TError,
    { id: string; data: UpdateMemberBody },
    TContext
  >
  fetch?: RequestInit
}): UseMutationOptions<
  Awaited<ReturnType<typeof updateMember>>,
  TError,
  { id: string; data: UpdateMemberBody },
  TContext
> => {
  const mutationKey = ['updateMember']
  const { mutation: mutationOptions, fetch: fetchOptions } =
    options ?
      (
        options.mutation &&
        'mutationKey' in options.mutation &&
        options.mutation.mutationKey
      ) ?
        options
      : { ...options, mutation: { ...options.mutation, mutationKey } }
    : { mutation: { mutationKey }, fetch: undefined }

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof updateMember>>,
    { id: string; data: UpdateMemberBody }
  > = (props) => {
    const { id, data } = props ?? {}

    return updateMember(id, data, fetchOptions)
  }

  return { mutationFn, ...mutationOptions }
}

export type UpdateMemberMutationResult = NonNullable<
  Awaited<ReturnType<typeof updateMember>>
>
export type UpdateMemberMutationBody = UpdateMemberBody
export type UpdateMemberMutationError = UpdateMember404

/**
 * @summary Update a member
 */
export const useUpdateMember = <TError = UpdateMember404, TContext = unknown>(
  options?: {
    mutation?: UseMutationOptions<
      Awaited<ReturnType<typeof updateMember>>,
      TError,
      { id: string; data: UpdateMemberBody },
      TContext
    >
    fetch?: RequestInit
  },
  queryClient?: QueryClient
): UseMutationResult<
  Awaited<ReturnType<typeof updateMember>>,
  TError,
  { id: string; data: UpdateMemberBody },
  TContext
> => {
  const mutationOptions = getUpdateMemberMutationOptions(options)

  return useMutation(mutationOptions, queryClient)
}

/**
 * Create a new invitation
 * @summary Create a new invitation
 */
export type createInvitationResponse201 = {
  data: CreateInvitation201
  status: 201
}

export type createInvitationResponseComposite = createInvitationResponse201

export type createInvitationResponse = createInvitationResponseComposite & {
  headers: Headers
}

export const getCreateInvitationUrl = () => {
  return `http://0.0.0.0:3001/invitations`
}

export const createInvitation = async (
  createInvitationBody: CreateInvitationBody,
  options?: RequestInit
): Promise<createInvitationResponse> => {
  const res = await fetch(getCreateInvitationUrl(), {
    ...options,
    method: 'POST',
    headers: { 'Content-Type': 'application/json', ...options?.headers },
    body: JSON.stringify(createInvitationBody)
  })

  const body = [204, 205, 304].includes(res.status) ? null : await res.text()
  const data: createInvitationResponse['data'] = body ? JSON.parse(body) : {}

  return {
    data,
    status: res.status,
    headers: res.headers
  } as createInvitationResponse
}

export const getCreateInvitationMutationOptions = <
  TError = unknown,
  TContext = unknown
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof createInvitation>>,
    TError,
    { data: CreateInvitationBody },
    TContext
  >
  fetch?: RequestInit
}): UseMutationOptions<
  Awaited<ReturnType<typeof createInvitation>>,
  TError,
  { data: CreateInvitationBody },
  TContext
> => {
  const mutationKey = ['createInvitation']
  const { mutation: mutationOptions, fetch: fetchOptions } =
    options ?
      (
        options.mutation &&
        'mutationKey' in options.mutation &&
        options.mutation.mutationKey
      ) ?
        options
      : { ...options, mutation: { ...options.mutation, mutationKey } }
    : { mutation: { mutationKey }, fetch: undefined }

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof createInvitation>>,
    { data: CreateInvitationBody }
  > = (props) => {
    const { data } = props ?? {}

    return createInvitation(data, fetchOptions)
  }

  return { mutationFn, ...mutationOptions }
}

export type CreateInvitationMutationResult = NonNullable<
  Awaited<ReturnType<typeof createInvitation>>
>
export type CreateInvitationMutationBody = CreateInvitationBody
export type CreateInvitationMutationError = unknown

/**
 * @summary Create a new invitation
 */
export const useCreateInvitation = <TError = unknown, TContext = unknown>(
  options?: {
    mutation?: UseMutationOptions<
      Awaited<ReturnType<typeof createInvitation>>,
      TError,
      { data: CreateInvitationBody },
      TContext
    >
    fetch?: RequestInit
  },
  queryClient?: QueryClient
): UseMutationResult<
  Awaited<ReturnType<typeof createInvitation>>,
  TError,
  { data: CreateInvitationBody },
  TContext
> => {
  const mutationOptions = getCreateInvitationMutationOptions(options)

  return useMutation(mutationOptions, queryClient)
}

/**
 * Find many invitations
 * @summary Find many invitations
 */
export type findManyInvitationsResponse200 = {
  data: FindManyInvitations200
  status: 200
}

export type findManyInvitationsResponseComposite =
  findManyInvitationsResponse200

export type findManyInvitationsResponse =
  findManyInvitationsResponseComposite & {
    headers: Headers
  }

export const getFindManyInvitationsUrl = (
  params?: FindManyInvitationsParams
) => {
  const normalizedParams = new URLSearchParams()

  Object.entries(params || {}).forEach(([key, value]) => {
    if (value !== undefined) {
      normalizedParams.append(key, value === null ? 'null' : value.toString())
    }
  })

  const stringifiedParams = normalizedParams.toString()

  return stringifiedParams.length > 0 ?
      `http://0.0.0.0:3001/invitations?${stringifiedParams}`
    : `http://0.0.0.0:3001/invitations`
}

export const findManyInvitations = async (
  params?: FindManyInvitationsParams,
  options?: RequestInit
): Promise<findManyInvitationsResponse> => {
  const res = await fetch(getFindManyInvitationsUrl(params), {
    ...options,
    method: 'GET'
  })

  const body = [204, 205, 304].includes(res.status) ? null : await res.text()
  const data: findManyInvitationsResponse['data'] = body ? JSON.parse(body) : {}

  return {
    data,
    status: res.status,
    headers: res.headers
  } as findManyInvitationsResponse
}

export const getFindManyInvitationsQueryKey = (
  params?: FindManyInvitationsParams
) => {
  return [
    `http://0.0.0.0:3001/invitations`,
    ...(params ? [params] : [])
  ] as const
}

export const getFindManyInvitationsQueryOptions = <
  TData = Awaited<ReturnType<typeof findManyInvitations>>,
  TError = unknown
>(
  params?: FindManyInvitationsParams,
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof findManyInvitations>>,
        TError,
        TData
      >
    >
    fetch?: RequestInit
  }
) => {
  const { query: queryOptions, fetch: fetchOptions } = options ?? {}

  const queryKey =
    queryOptions?.queryKey ?? getFindManyInvitationsQueryKey(params)

  const queryFn: QueryFunction<
    Awaited<ReturnType<typeof findManyInvitations>>
  > = ({ signal }) =>
    findManyInvitations(params, {
      ...(signal ? { signal } : {}),
      ...fetchOptions
    })

  return { queryKey, queryFn, ...queryOptions } as UseQueryOptions<
    Awaited<ReturnType<typeof findManyInvitations>>,
    TError,
    TData
  > & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type FindManyInvitationsQueryResult = NonNullable<
  Awaited<ReturnType<typeof findManyInvitations>>
>
export type FindManyInvitationsQueryError = unknown

export function useFindManyInvitations<
  TData = Awaited<ReturnType<typeof findManyInvitations>>,
  TError = unknown
>(
  params: undefined | FindManyInvitationsParams,
  options: {
    query: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof findManyInvitations>>,
        TError,
        TData
      >
    > &
      Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof findManyInvitations>>,
          TError,
          Awaited<ReturnType<typeof findManyInvitations>>
        >,
        'initialData'
      >
    fetch?: RequestInit
  },
  queryClient?: QueryClient
): DefinedUseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>
}
export function useFindManyInvitations<
  TData = Awaited<ReturnType<typeof findManyInvitations>>,
  TError = unknown
>(
  params?: FindManyInvitationsParams,
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof findManyInvitations>>,
        TError,
        TData
      >
    > &
      Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof findManyInvitations>>,
          TError,
          Awaited<ReturnType<typeof findManyInvitations>>
        >,
        'initialData'
      >
    fetch?: RequestInit
  },
  queryClient?: QueryClient
): UseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>
}
export function useFindManyInvitations<
  TData = Awaited<ReturnType<typeof findManyInvitations>>,
  TError = unknown
>(
  params?: FindManyInvitationsParams,
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof findManyInvitations>>,
        TError,
        TData
      >
    >
    fetch?: RequestInit
  },
  queryClient?: QueryClient
): UseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>
}
/**
 * @summary Find many invitations
 */

export function useFindManyInvitations<
  TData = Awaited<ReturnType<typeof findManyInvitations>>,
  TError = unknown
>(
  params?: FindManyInvitationsParams,
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof findManyInvitations>>,
        TError,
        TData
      >
    >
    fetch?: RequestInit
  },
  queryClient?: QueryClient
): UseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>
} {
  const queryOptions = getFindManyInvitationsQueryOptions(params, options)

  const query = useQuery(queryOptions, queryClient) as UseQueryResult<
    TData,
    TError
  > & { queryKey: DataTag<QueryKey, TData, TError> }

  query.queryKey = queryOptions.queryKey

  return query
}

/**
 * Delete an invitation
 * @summary Delete an invitation
 */
export type deleteInvitationResponse200 = {
  data: DeleteInvitation200
  status: 200
}

export type deleteInvitationResponse404 = {
  data: DeleteInvitation404
  status: 404
}

export type deleteInvitationResponseComposite =
  | deleteInvitationResponse200
  | deleteInvitationResponse404

export type deleteInvitationResponse = deleteInvitationResponseComposite & {
  headers: Headers
}

export const getDeleteInvitationUrl = (id: string) => {
  return `http://0.0.0.0:3001/invitations/${id}`
}

export const deleteInvitation = async (
  id: string,
  options?: RequestInit
): Promise<deleteInvitationResponse> => {
  const res = await fetch(getDeleteInvitationUrl(id), {
    ...options,
    method: 'DELETE'
  })

  const body = [204, 205, 304].includes(res.status) ? null : await res.text()
  const data: deleteInvitationResponse['data'] = body ? JSON.parse(body) : {}

  return {
    data,
    status: res.status,
    headers: res.headers
  } as deleteInvitationResponse
}

export const getDeleteInvitationMutationOptions = <
  TError = DeleteInvitation404,
  TContext = unknown
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof deleteInvitation>>,
    TError,
    { id: string },
    TContext
  >
  fetch?: RequestInit
}): UseMutationOptions<
  Awaited<ReturnType<typeof deleteInvitation>>,
  TError,
  { id: string },
  TContext
> => {
  const mutationKey = ['deleteInvitation']
  const { mutation: mutationOptions, fetch: fetchOptions } =
    options ?
      (
        options.mutation &&
        'mutationKey' in options.mutation &&
        options.mutation.mutationKey
      ) ?
        options
      : { ...options, mutation: { ...options.mutation, mutationKey } }
    : { mutation: { mutationKey }, fetch: undefined }

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof deleteInvitation>>,
    { id: string }
  > = (props) => {
    const { id } = props ?? {}

    return deleteInvitation(id, fetchOptions)
  }

  return { mutationFn, ...mutationOptions }
}

export type DeleteInvitationMutationResult = NonNullable<
  Awaited<ReturnType<typeof deleteInvitation>>
>

export type DeleteInvitationMutationError = DeleteInvitation404

/**
 * @summary Delete an invitation
 */
export const useDeleteInvitation = <
  TError = DeleteInvitation404,
  TContext = unknown
>(
  options?: {
    mutation?: UseMutationOptions<
      Awaited<ReturnType<typeof deleteInvitation>>,
      TError,
      { id: string },
      TContext
    >
    fetch?: RequestInit
  },
  queryClient?: QueryClient
): UseMutationResult<
  Awaited<ReturnType<typeof deleteInvitation>>,
  TError,
  { id: string },
  TContext
> => {
  const mutationOptions = getDeleteInvitationMutationOptions(options)

  return useMutation(mutationOptions, queryClient)
}

/**
 * Find an invitation
 * @summary Find an invitation
 */
export type getOneInvitationResponse200 = {
  data: GetOneInvitation200
  status: 200
}

export type getOneInvitationResponse404 = {
  data: GetOneInvitation404
  status: 404
}

export type getOneInvitationResponseComposite =
  | getOneInvitationResponse200
  | getOneInvitationResponse404

export type getOneInvitationResponse = getOneInvitationResponseComposite & {
  headers: Headers
}

export const getGetOneInvitationUrl = (id: string) => {
  return `http://0.0.0.0:3001/invitations/${id}`
}

export const getOneInvitation = async (
  id: string,
  options?: RequestInit
): Promise<getOneInvitationResponse> => {
  const res = await fetch(getGetOneInvitationUrl(id), {
    ...options,
    method: 'GET'
  })

  const body = [204, 205, 304].includes(res.status) ? null : await res.text()
  const data: getOneInvitationResponse['data'] = body ? JSON.parse(body) : {}

  return {
    data,
    status: res.status,
    headers: res.headers
  } as getOneInvitationResponse
}

export const getGetOneInvitationQueryKey = (id: string) => {
  return [`http://0.0.0.0:3001/invitations/${id}`] as const
}

export const getGetOneInvitationQueryOptions = <
  TData = Awaited<ReturnType<typeof getOneInvitation>>,
  TError = GetOneInvitation404
>(
  id: string,
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof getOneInvitation>>,
        TError,
        TData
      >
    >
    fetch?: RequestInit
  }
) => {
  const { query: queryOptions, fetch: fetchOptions } = options ?? {}

  const queryKey = queryOptions?.queryKey ?? getGetOneInvitationQueryKey(id)

  const queryFn: QueryFunction<
    Awaited<ReturnType<typeof getOneInvitation>>
  > = ({ signal }) =>
    getOneInvitation(id, { ...(signal ? { signal } : {}), ...fetchOptions })

  return {
    queryKey,
    queryFn,
    enabled: !!id,
    ...queryOptions
  } as UseQueryOptions<
    Awaited<ReturnType<typeof getOneInvitation>>,
    TError,
    TData
  > & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type GetOneInvitationQueryResult = NonNullable<
  Awaited<ReturnType<typeof getOneInvitation>>
>
export type GetOneInvitationQueryError = GetOneInvitation404

export function useGetOneInvitation<
  TData = Awaited<ReturnType<typeof getOneInvitation>>,
  TError = GetOneInvitation404
>(
  id: string,
  options: {
    query: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof getOneInvitation>>,
        TError,
        TData
      >
    > &
      Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof getOneInvitation>>,
          TError,
          Awaited<ReturnType<typeof getOneInvitation>>
        >,
        'initialData'
      >
    fetch?: RequestInit
  },
  queryClient?: QueryClient
): DefinedUseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>
}
export function useGetOneInvitation<
  TData = Awaited<ReturnType<typeof getOneInvitation>>,
  TError = GetOneInvitation404
>(
  id: string,
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof getOneInvitation>>,
        TError,
        TData
      >
    > &
      Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof getOneInvitation>>,
          TError,
          Awaited<ReturnType<typeof getOneInvitation>>
        >,
        'initialData'
      >
    fetch?: RequestInit
  },
  queryClient?: QueryClient
): UseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>
}
export function useGetOneInvitation<
  TData = Awaited<ReturnType<typeof getOneInvitation>>,
  TError = GetOneInvitation404
>(
  id: string,
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof getOneInvitation>>,
        TError,
        TData
      >
    >
    fetch?: RequestInit
  },
  queryClient?: QueryClient
): UseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>
}
/**
 * @summary Find an invitation
 */

export function useGetOneInvitation<
  TData = Awaited<ReturnType<typeof getOneInvitation>>,
  TError = GetOneInvitation404
>(
  id: string,
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof getOneInvitation>>,
        TError,
        TData
      >
    >
    fetch?: RequestInit
  },
  queryClient?: QueryClient
): UseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>
} {
  const queryOptions = getGetOneInvitationQueryOptions(id, options)

  const query = useQuery(queryOptions, queryClient) as UseQueryResult<
    TData,
    TError
  > & { queryKey: DataTag<QueryKey, TData, TError> }

  query.queryKey = queryOptions.queryKey

  return query
}

/**
 * Update an invitation
 * @summary Update an invitation
 */
export type updateInvitationResponse200 = {
  data: UpdateInvitation200
  status: 200
}

export type updateInvitationResponse404 = {
  data: UpdateInvitation404
  status: 404
}

export type updateInvitationResponseComposite =
  | updateInvitationResponse200
  | updateInvitationResponse404

export type updateInvitationResponse = updateInvitationResponseComposite & {
  headers: Headers
}

export const getUpdateInvitationUrl = (id: string) => {
  return `http://0.0.0.0:3001/invitations/${id}`
}

export const updateInvitation = async (
  id: string,
  updateInvitationBody: UpdateInvitationBody,
  options?: RequestInit
): Promise<updateInvitationResponse> => {
  const res = await fetch(getUpdateInvitationUrl(id), {
    ...options,
    method: 'PATCH',
    headers: { 'Content-Type': 'application/json', ...options?.headers },
    body: JSON.stringify(updateInvitationBody)
  })

  const body = [204, 205, 304].includes(res.status) ? null : await res.text()
  const data: updateInvitationResponse['data'] = body ? JSON.parse(body) : {}

  return {
    data,
    status: res.status,
    headers: res.headers
  } as updateInvitationResponse
}

export const getUpdateInvitationMutationOptions = <
  TError = UpdateInvitation404,
  TContext = unknown
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof updateInvitation>>,
    TError,
    { id: string; data: UpdateInvitationBody },
    TContext
  >
  fetch?: RequestInit
}): UseMutationOptions<
  Awaited<ReturnType<typeof updateInvitation>>,
  TError,
  { id: string; data: UpdateInvitationBody },
  TContext
> => {
  const mutationKey = ['updateInvitation']
  const { mutation: mutationOptions, fetch: fetchOptions } =
    options ?
      (
        options.mutation &&
        'mutationKey' in options.mutation &&
        options.mutation.mutationKey
      ) ?
        options
      : { ...options, mutation: { ...options.mutation, mutationKey } }
    : { mutation: { mutationKey }, fetch: undefined }

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof updateInvitation>>,
    { id: string; data: UpdateInvitationBody }
  > = (props) => {
    const { id, data } = props ?? {}

    return updateInvitation(id, data, fetchOptions)
  }

  return { mutationFn, ...mutationOptions }
}

export type UpdateInvitationMutationResult = NonNullable<
  Awaited<ReturnType<typeof updateInvitation>>
>
export type UpdateInvitationMutationBody = UpdateInvitationBody
export type UpdateInvitationMutationError = UpdateInvitation404

/**
 * @summary Update an invitation
 */
export const useUpdateInvitation = <
  TError = UpdateInvitation404,
  TContext = unknown
>(
  options?: {
    mutation?: UseMutationOptions<
      Awaited<ReturnType<typeof updateInvitation>>,
      TError,
      { id: string; data: UpdateInvitationBody },
      TContext
    >
    fetch?: RequestInit
  },
  queryClient?: QueryClient
): UseMutationResult<
  Awaited<ReturnType<typeof updateInvitation>>,
  TError,
  { id: string; data: UpdateInvitationBody },
  TContext
> => {
  const mutationOptions = getUpdateInvitationMutationOptions(options)

  return useMutation(mutationOptions, queryClient)
}

/**
 * Accept an invitation
 * @summary Accept an invitation
 */
export type acceptInvitationResponse200 = {
  data: AcceptInvitation200
  status: 200
}

export type acceptInvitationResponse401 = {
  data: AcceptInvitation401
  status: 401
}

export type acceptInvitationResponse403 = {
  data: AcceptInvitation403
  status: 403
}

export type acceptInvitationResponse404 = {
  data: AcceptInvitation404
  status: 404
}

export type acceptInvitationResponseComposite =
  | acceptInvitationResponse200
  | acceptInvitationResponse401
  | acceptInvitationResponse403
  | acceptInvitationResponse404

export type acceptInvitationResponse = acceptInvitationResponseComposite & {
  headers: Headers
}

export const getAcceptInvitationUrl = (id: string) => {
  return `http://0.0.0.0:3001/invitations/${id}/accept`
}

export const acceptInvitation = async (
  id: string,
  options?: RequestInit
): Promise<acceptInvitationResponse> => {
  const res = await fetch(getAcceptInvitationUrl(id), {
    ...options,
    method: 'POST'
  })

  const body = [204, 205, 304].includes(res.status) ? null : await res.text()
  const data: acceptInvitationResponse['data'] = body ? JSON.parse(body) : {}

  return {
    data,
    status: res.status,
    headers: res.headers
  } as acceptInvitationResponse
}

export const getAcceptInvitationMutationOptions = <
  TError = AcceptInvitation401 | AcceptInvitation403 | AcceptInvitation404,
  TContext = unknown
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof acceptInvitation>>,
    TError,
    { id: string },
    TContext
  >
  fetch?: RequestInit
}): UseMutationOptions<
  Awaited<ReturnType<typeof acceptInvitation>>,
  TError,
  { id: string },
  TContext
> => {
  const mutationKey = ['acceptInvitation']
  const { mutation: mutationOptions, fetch: fetchOptions } =
    options ?
      (
        options.mutation &&
        'mutationKey' in options.mutation &&
        options.mutation.mutationKey
      ) ?
        options
      : { ...options, mutation: { ...options.mutation, mutationKey } }
    : { mutation: { mutationKey }, fetch: undefined }

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof acceptInvitation>>,
    { id: string }
  > = (props) => {
    const { id } = props ?? {}

    return acceptInvitation(id, fetchOptions)
  }

  return { mutationFn, ...mutationOptions }
}

export type AcceptInvitationMutationResult = NonNullable<
  Awaited<ReturnType<typeof acceptInvitation>>
>

export type AcceptInvitationMutationError =
  | AcceptInvitation401
  | AcceptInvitation403
  | AcceptInvitation404

/**
 * @summary Accept an invitation
 */
export const useAcceptInvitation = <
  TError = AcceptInvitation401 | AcceptInvitation403 | AcceptInvitation404,
  TContext = unknown
>(
  options?: {
    mutation?: UseMutationOptions<
      Awaited<ReturnType<typeof acceptInvitation>>,
      TError,
      { id: string },
      TContext
    >
    fetch?: RequestInit
  },
  queryClient?: QueryClient
): UseMutationResult<
  Awaited<ReturnType<typeof acceptInvitation>>,
  TError,
  { id: string },
  TContext
> => {
  const mutationOptions = getAcceptInvitationMutationOptions(options)

  return useMutation(mutationOptions, queryClient)
}

/**
 * Handles Stripe webhook callbacks
 * @summary Stripe webhook callback
 */
export type stripeCallbackResponse200 = {
  data: unknown
  status: 200
}

export type stripeCallbackResponseComposite = stripeCallbackResponse200

export type stripeCallbackResponse = stripeCallbackResponseComposite & {
  headers: Headers
}

export const getStripeCallbackUrl = () => {
  return `http://0.0.0.0:3001/billing/stripe/callback`
}

export const stripeCallback = async (
  options?: RequestInit
): Promise<stripeCallbackResponse> => {
  const res = await fetch(getStripeCallbackUrl(), {
    ...options,
    method: 'POST'
  })

  const body = [204, 205, 304].includes(res.status) ? null : await res.text()
  const data: stripeCallbackResponse['data'] = body ? JSON.parse(body) : {}

  return {
    data,
    status: res.status,
    headers: res.headers
  } as stripeCallbackResponse
}

export const getStripeCallbackMutationOptions = <
  TError = unknown,
  TContext = unknown
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof stripeCallback>>,
    TError,
    void,
    TContext
  >
  fetch?: RequestInit
}): UseMutationOptions<
  Awaited<ReturnType<typeof stripeCallback>>,
  TError,
  void,
  TContext
> => {
  const mutationKey = ['stripeCallback']
  const { mutation: mutationOptions, fetch: fetchOptions } =
    options ?
      (
        options.mutation &&
        'mutationKey' in options.mutation &&
        options.mutation.mutationKey
      ) ?
        options
      : { ...options, mutation: { ...options.mutation, mutationKey } }
    : { mutation: { mutationKey }, fetch: undefined }

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof stripeCallback>>,
    void
  > = () => {
    return stripeCallback(fetchOptions)
  }

  return { mutationFn, ...mutationOptions }
}

export type StripeCallbackMutationResult = NonNullable<
  Awaited<ReturnType<typeof stripeCallback>>
>

export type StripeCallbackMutationError = unknown

/**
 * @summary Stripe webhook callback
 */
export const useStripeCallback = <TError = unknown, TContext = unknown>(
  options?: {
    mutation?: UseMutationOptions<
      Awaited<ReturnType<typeof stripeCallback>>,
      TError,
      void,
      TContext
    >
    fetch?: RequestInit
  },
  queryClient?: QueryClient
): UseMutationResult<
  Awaited<ReturnType<typeof stripeCallback>>,
  TError,
  void,
  TContext
> => {
  const mutationOptions = getStripeCallbackMutationOptions(options)

  return useMutation(mutationOptions, queryClient)
}

/**
 * Create a checkout session
 * @summary Create a checkout session
 */
export type createCheckoutSessionResponse200 = {
  data: CreateCheckoutSession200
  status: 200
}

export type createCheckoutSessionResponseComposite =
  createCheckoutSessionResponse200

export type createCheckoutSessionResponse =
  createCheckoutSessionResponseComposite & {
    headers: Headers
  }

export const getCreateCheckoutSessionUrl = () => {
  return `http://0.0.0.0:3001/billing/checkout-sessions`
}

export const createCheckoutSession = async (
  createCheckoutSessionBody: CreateCheckoutSessionBody,
  options?: RequestInit
): Promise<createCheckoutSessionResponse> => {
  const res = await fetch(getCreateCheckoutSessionUrl(), {
    ...options,
    method: 'POST',
    headers: { 'Content-Type': 'application/json', ...options?.headers },
    body: JSON.stringify(createCheckoutSessionBody)
  })

  const body = [204, 205, 304].includes(res.status) ? null : await res.text()
  const data: createCheckoutSessionResponse['data'] =
    body ? JSON.parse(body) : {}

  return {
    data,
    status: res.status,
    headers: res.headers
  } as createCheckoutSessionResponse
}

export const getCreateCheckoutSessionMutationOptions = <
  TError = unknown,
  TContext = unknown
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof createCheckoutSession>>,
    TError,
    { data: CreateCheckoutSessionBody },
    TContext
  >
  fetch?: RequestInit
}): UseMutationOptions<
  Awaited<ReturnType<typeof createCheckoutSession>>,
  TError,
  { data: CreateCheckoutSessionBody },
  TContext
> => {
  const mutationKey = ['createCheckoutSession']
  const { mutation: mutationOptions, fetch: fetchOptions } =
    options ?
      (
        options.mutation &&
        'mutationKey' in options.mutation &&
        options.mutation.mutationKey
      ) ?
        options
      : { ...options, mutation: { ...options.mutation, mutationKey } }
    : { mutation: { mutationKey }, fetch: undefined }

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof createCheckoutSession>>,
    { data: CreateCheckoutSessionBody }
  > = (props) => {
    const { data } = props ?? {}

    return createCheckoutSession(data, fetchOptions)
  }

  return { mutationFn, ...mutationOptions }
}

export type CreateCheckoutSessionMutationResult = NonNullable<
  Awaited<ReturnType<typeof createCheckoutSession>>
>
export type CreateCheckoutSessionMutationBody = CreateCheckoutSessionBody
export type CreateCheckoutSessionMutationError = unknown

/**
 * @summary Create a checkout session
 */
export const useCreateCheckoutSession = <TError = unknown, TContext = unknown>(
  options?: {
    mutation?: UseMutationOptions<
      Awaited<ReturnType<typeof createCheckoutSession>>,
      TError,
      { data: CreateCheckoutSessionBody },
      TContext
    >
    fetch?: RequestInit
  },
  queryClient?: QueryClient
): UseMutationResult<
  Awaited<ReturnType<typeof createCheckoutSession>>,
  TError,
  { data: CreateCheckoutSessionBody },
  TContext
> => {
  const mutationOptions = getCreateCheckoutSessionMutationOptions(options)

  return useMutation(mutationOptions, queryClient)
}

/**
 * Delete a payment method
 * @summary Delete a payment method
 */
export type deletePaymentMethodResponse200 = {
  data: DeletePaymentMethod200
  status: 200
}

export type deletePaymentMethodResponseComposite =
  deletePaymentMethodResponse200

export type deletePaymentMethodResponse =
  deletePaymentMethodResponseComposite & {
    headers: Headers
  }

export const getDeletePaymentMethodUrl = (id: string) => {
  return `http://0.0.0.0:3001/billing/payment-methods/${id}`
}

export const deletePaymentMethod = async (
  id: string,
  options?: RequestInit
): Promise<deletePaymentMethodResponse> => {
  const res = await fetch(getDeletePaymentMethodUrl(id), {
    ...options,
    method: 'DELETE'
  })

  const body = [204, 205, 304].includes(res.status) ? null : await res.text()
  const data: deletePaymentMethodResponse['data'] = body ? JSON.parse(body) : {}

  return {
    data,
    status: res.status,
    headers: res.headers
  } as deletePaymentMethodResponse
}

export const getDeletePaymentMethodMutationOptions = <
  TError = unknown,
  TContext = unknown
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof deletePaymentMethod>>,
    TError,
    { id: string },
    TContext
  >
  fetch?: RequestInit
}): UseMutationOptions<
  Awaited<ReturnType<typeof deletePaymentMethod>>,
  TError,
  { id: string },
  TContext
> => {
  const mutationKey = ['deletePaymentMethod']
  const { mutation: mutationOptions, fetch: fetchOptions } =
    options ?
      (
        options.mutation &&
        'mutationKey' in options.mutation &&
        options.mutation.mutationKey
      ) ?
        options
      : { ...options, mutation: { ...options.mutation, mutationKey } }
    : { mutation: { mutationKey }, fetch: undefined }

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof deletePaymentMethod>>,
    { id: string }
  > = (props) => {
    const { id } = props ?? {}

    return deletePaymentMethod(id, fetchOptions)
  }

  return { mutationFn, ...mutationOptions }
}

export type DeletePaymentMethodMutationResult = NonNullable<
  Awaited<ReturnType<typeof deletePaymentMethod>>
>

export type DeletePaymentMethodMutationError = unknown

/**
 * @summary Delete a payment method
 */
export const useDeletePaymentMethod = <TError = unknown, TContext = unknown>(
  options?: {
    mutation?: UseMutationOptions<
      Awaited<ReturnType<typeof deletePaymentMethod>>,
      TError,
      { id: string },
      TContext
    >
    fetch?: RequestInit
  },
  queryClient?: QueryClient
): UseMutationResult<
  Awaited<ReturnType<typeof deletePaymentMethod>>,
  TError,
  { id: string },
  TContext
> => {
  const mutationOptions = getDeletePaymentMethodMutationOptions(options)

  return useMutation(mutationOptions, queryClient)
}

/**
 * Get a payment method
 * @summary Get a payment method
 */
export type findOnePaymentMethodResponse200 = {
  data: FindOnePaymentMethod200
  status: 200
}

export type findOnePaymentMethodResponseComposite =
  findOnePaymentMethodResponse200

export type findOnePaymentMethodResponse =
  findOnePaymentMethodResponseComposite & {
    headers: Headers
  }

export const getFindOnePaymentMethodUrl = (id: string) => {
  return `http://0.0.0.0:3001/billing/payment-methods/${id}`
}

export const findOnePaymentMethod = async (
  id: string,
  options?: RequestInit
): Promise<findOnePaymentMethodResponse> => {
  const res = await fetch(getFindOnePaymentMethodUrl(id), {
    ...options,
    method: 'GET'
  })

  const body = [204, 205, 304].includes(res.status) ? null : await res.text()
  const data: findOnePaymentMethodResponse['data'] =
    body ? JSON.parse(body) : {}

  return {
    data,
    status: res.status,
    headers: res.headers
  } as findOnePaymentMethodResponse
}

export const getFindOnePaymentMethodQueryKey = (id: string) => {
  return [`http://0.0.0.0:3001/billing/payment-methods/${id}`] as const
}

export const getFindOnePaymentMethodQueryOptions = <
  TData = Awaited<ReturnType<typeof findOnePaymentMethod>>,
  TError = unknown
>(
  id: string,
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof findOnePaymentMethod>>,
        TError,
        TData
      >
    >
    fetch?: RequestInit
  }
) => {
  const { query: queryOptions, fetch: fetchOptions } = options ?? {}

  const queryKey = queryOptions?.queryKey ?? getFindOnePaymentMethodQueryKey(id)

  const queryFn: QueryFunction<
    Awaited<ReturnType<typeof findOnePaymentMethod>>
  > = ({ signal }) =>
    findOnePaymentMethod(id, { ...(signal ? { signal } : {}), ...fetchOptions })

  return {
    queryKey,
    queryFn,
    enabled: !!id,
    ...queryOptions
  } as UseQueryOptions<
    Awaited<ReturnType<typeof findOnePaymentMethod>>,
    TError,
    TData
  > & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type FindOnePaymentMethodQueryResult = NonNullable<
  Awaited<ReturnType<typeof findOnePaymentMethod>>
>
export type FindOnePaymentMethodQueryError = unknown

export function useFindOnePaymentMethod<
  TData = Awaited<ReturnType<typeof findOnePaymentMethod>>,
  TError = unknown
>(
  id: string,
  options: {
    query: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof findOnePaymentMethod>>,
        TError,
        TData
      >
    > &
      Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof findOnePaymentMethod>>,
          TError,
          Awaited<ReturnType<typeof findOnePaymentMethod>>
        >,
        'initialData'
      >
    fetch?: RequestInit
  },
  queryClient?: QueryClient
): DefinedUseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>
}
export function useFindOnePaymentMethod<
  TData = Awaited<ReturnType<typeof findOnePaymentMethod>>,
  TError = unknown
>(
  id: string,
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof findOnePaymentMethod>>,
        TError,
        TData
      >
    > &
      Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof findOnePaymentMethod>>,
          TError,
          Awaited<ReturnType<typeof findOnePaymentMethod>>
        >,
        'initialData'
      >
    fetch?: RequestInit
  },
  queryClient?: QueryClient
): UseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>
}
export function useFindOnePaymentMethod<
  TData = Awaited<ReturnType<typeof findOnePaymentMethod>>,
  TError = unknown
>(
  id: string,
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof findOnePaymentMethod>>,
        TError,
        TData
      >
    >
    fetch?: RequestInit
  },
  queryClient?: QueryClient
): UseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>
}
/**
 * @summary Get a payment method
 */

export function useFindOnePaymentMethod<
  TData = Awaited<ReturnType<typeof findOnePaymentMethod>>,
  TError = unknown
>(
  id: string,
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof findOnePaymentMethod>>,
        TError,
        TData
      >
    >
    fetch?: RequestInit
  },
  queryClient?: QueryClient
): UseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>
} {
  const queryOptions = getFindOnePaymentMethodQueryOptions(id, options)

  const query = useQuery(queryOptions, queryClient) as UseQueryResult<
    TData,
    TError
  > & { queryKey: DataTag<QueryKey, TData, TError> }

  query.queryKey = queryOptions.queryKey

  return query
}

/**
 * Get all payment methods
 * @summary Get all payment methods
 */
export type findManyPaymentMethodsResponse200 = {
  data: unknown
  status: 200
}

export type findManyPaymentMethodsResponseComposite =
  findManyPaymentMethodsResponse200

export type findManyPaymentMethodsResponse =
  findManyPaymentMethodsResponseComposite & {
    headers: Headers
  }

export const getFindManyPaymentMethodsUrl = () => {
  return `http://0.0.0.0:3001/billing/payment-methods`
}

export const findManyPaymentMethods = async (
  options?: RequestInit
): Promise<findManyPaymentMethodsResponse> => {
  const res = await fetch(getFindManyPaymentMethodsUrl(), {
    ...options,
    method: 'GET'
  })

  const body = [204, 205, 304].includes(res.status) ? null : await res.text()
  const data: findManyPaymentMethodsResponse['data'] =
    body ? JSON.parse(body) : {}

  return {
    data,
    status: res.status,
    headers: res.headers
  } as findManyPaymentMethodsResponse
}

export const getFindManyPaymentMethodsQueryKey = () => {
  return [`http://0.0.0.0:3001/billing/payment-methods`] as const
}

export const getFindManyPaymentMethodsQueryOptions = <
  TData = Awaited<ReturnType<typeof findManyPaymentMethods>>,
  TError = unknown
>(options?: {
  query?: Partial<
    UseQueryOptions<
      Awaited<ReturnType<typeof findManyPaymentMethods>>,
      TError,
      TData
    >
  >
  fetch?: RequestInit
}) => {
  const { query: queryOptions, fetch: fetchOptions } = options ?? {}

  const queryKey = queryOptions?.queryKey ?? getFindManyPaymentMethodsQueryKey()

  const queryFn: QueryFunction<
    Awaited<ReturnType<typeof findManyPaymentMethods>>
  > = ({ signal }) =>
    findManyPaymentMethods({ ...(signal ? { signal } : {}), ...fetchOptions })

  return { queryKey, queryFn, ...queryOptions } as UseQueryOptions<
    Awaited<ReturnType<typeof findManyPaymentMethods>>,
    TError,
    TData
  > & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type FindManyPaymentMethodsQueryResult = NonNullable<
  Awaited<ReturnType<typeof findManyPaymentMethods>>
>
export type FindManyPaymentMethodsQueryError = unknown

export function useFindManyPaymentMethods<
  TData = Awaited<ReturnType<typeof findManyPaymentMethods>>,
  TError = unknown
>(
  options: {
    query: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof findManyPaymentMethods>>,
        TError,
        TData
      >
    > &
      Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof findManyPaymentMethods>>,
          TError,
          Awaited<ReturnType<typeof findManyPaymentMethods>>
        >,
        'initialData'
      >
    fetch?: RequestInit
  },
  queryClient?: QueryClient
): DefinedUseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>
}
export function useFindManyPaymentMethods<
  TData = Awaited<ReturnType<typeof findManyPaymentMethods>>,
  TError = unknown
>(
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof findManyPaymentMethods>>,
        TError,
        TData
      >
    > &
      Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof findManyPaymentMethods>>,
          TError,
          Awaited<ReturnType<typeof findManyPaymentMethods>>
        >,
        'initialData'
      >
    fetch?: RequestInit
  },
  queryClient?: QueryClient
): UseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>
}
export function useFindManyPaymentMethods<
  TData = Awaited<ReturnType<typeof findManyPaymentMethods>>,
  TError = unknown
>(
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof findManyPaymentMethods>>,
        TError,
        TData
      >
    >
    fetch?: RequestInit
  },
  queryClient?: QueryClient
): UseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>
}
/**
 * @summary Get all payment methods
 */

export function useFindManyPaymentMethods<
  TData = Awaited<ReturnType<typeof findManyPaymentMethods>>,
  TError = unknown
>(
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof findManyPaymentMethods>>,
        TError,
        TData
      >
    >
    fetch?: RequestInit
  },
  queryClient?: QueryClient
): UseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>
} {
  const queryOptions = getFindManyPaymentMethodsQueryOptions(options)

  const query = useQuery(queryOptions, queryClient) as UseQueryResult<
    TData,
    TError
  > & { queryKey: DataTag<QueryKey, TData, TError> }

  query.queryKey = queryOptions.queryKey

  return query
}

/**
 * Get all plans
 * @summary Get all plans
 */
export type getPlansResponse200 = {
  data: GetPlans200
  status: 200
}

export type getPlansResponseComposite = getPlansResponse200

export type getPlansResponse = getPlansResponseComposite & {
  headers: Headers
}

export const getGetPlansUrl = () => {
  return `http://0.0.0.0:3001/billing/plans`
}

export const getPlans = async (
  options?: RequestInit
): Promise<getPlansResponse> => {
  const res = await fetch(getGetPlansUrl(), {
    ...options,
    method: 'GET'
  })

  const body = [204, 205, 304].includes(res.status) ? null : await res.text()
  const data: getPlansResponse['data'] = body ? JSON.parse(body) : {}

  return { data, status: res.status, headers: res.headers } as getPlansResponse
}

export const getGetPlansQueryKey = () => {
  return [`http://0.0.0.0:3001/billing/plans`] as const
}

export const getGetPlansQueryOptions = <
  TData = Awaited<ReturnType<typeof getPlans>>,
  TError = unknown
>(options?: {
  query?: Partial<
    UseQueryOptions<Awaited<ReturnType<typeof getPlans>>, TError, TData>
  >
  fetch?: RequestInit
}) => {
  const { query: queryOptions, fetch: fetchOptions } = options ?? {}

  const queryKey = queryOptions?.queryKey ?? getGetPlansQueryKey()

  const queryFn: QueryFunction<Awaited<ReturnType<typeof getPlans>>> = ({
    signal
  }) => getPlans({ ...(signal ? { signal } : {}), ...fetchOptions })

  return { queryKey, queryFn, ...queryOptions } as UseQueryOptions<
    Awaited<ReturnType<typeof getPlans>>,
    TError,
    TData
  > & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type GetPlansQueryResult = NonNullable<
  Awaited<ReturnType<typeof getPlans>>
>
export type GetPlansQueryError = unknown

export function useGetPlans<
  TData = Awaited<ReturnType<typeof getPlans>>,
  TError = unknown
>(
  options: {
    query: Partial<
      UseQueryOptions<Awaited<ReturnType<typeof getPlans>>, TError, TData>
    > &
      Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof getPlans>>,
          TError,
          Awaited<ReturnType<typeof getPlans>>
        >,
        'initialData'
      >
    fetch?: RequestInit
  },
  queryClient?: QueryClient
): DefinedUseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>
}
export function useGetPlans<
  TData = Awaited<ReturnType<typeof getPlans>>,
  TError = unknown
>(
  options?: {
    query?: Partial<
      UseQueryOptions<Awaited<ReturnType<typeof getPlans>>, TError, TData>
    > &
      Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof getPlans>>,
          TError,
          Awaited<ReturnType<typeof getPlans>>
        >,
        'initialData'
      >
    fetch?: RequestInit
  },
  queryClient?: QueryClient
): UseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>
}
export function useGetPlans<
  TData = Awaited<ReturnType<typeof getPlans>>,
  TError = unknown
>(
  options?: {
    query?: Partial<
      UseQueryOptions<Awaited<ReturnType<typeof getPlans>>, TError, TData>
    >
    fetch?: RequestInit
  },
  queryClient?: QueryClient
): UseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>
}
/**
 * @summary Get all plans
 */

export function useGetPlans<
  TData = Awaited<ReturnType<typeof getPlans>>,
  TError = unknown
>(
  options?: {
    query?: Partial<
      UseQueryOptions<Awaited<ReturnType<typeof getPlans>>, TError, TData>
    >
    fetch?: RequestInit
  },
  queryClient?: QueryClient
): UseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>
} {
  const queryOptions = getGetPlansQueryOptions(options)

  const query = useQuery(queryOptions, queryClient) as UseQueryResult<
    TData,
    TError
  > & { queryKey: DataTag<QueryKey, TData, TError> }

  query.queryKey = queryOptions.queryKey

  return query
}

/**
 * Create a new portal
 * @summary Create a new portal
 */
export type createPortalResponse201 = {
  data: unknown
  status: 201
}

export type createPortalResponseComposite = createPortalResponse201

export type createPortalResponse = createPortalResponseComposite & {
  headers: Headers
}

export const getCreatePortalUrl = () => {
  return `http://0.0.0.0:3001/billing/portal`
}

export const createPortal = async (
  createPortalBody: CreatePortalBody,
  options?: RequestInit
): Promise<createPortalResponse> => {
  const res = await fetch(getCreatePortalUrl(), {
    ...options,
    method: 'POST',
    headers: { 'Content-Type': 'application/json', ...options?.headers },
    body: JSON.stringify(createPortalBody)
  })

  const body = [204, 205, 304].includes(res.status) ? null : await res.text()
  const data: createPortalResponse['data'] = body ? JSON.parse(body) : {}

  return {
    data,
    status: res.status,
    headers: res.headers
  } as createPortalResponse
}

export const getCreatePortalMutationOptions = <
  TError = unknown,
  TContext = unknown
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof createPortal>>,
    TError,
    { data: CreatePortalBody },
    TContext
  >
  fetch?: RequestInit
}): UseMutationOptions<
  Awaited<ReturnType<typeof createPortal>>,
  TError,
  { data: CreatePortalBody },
  TContext
> => {
  const mutationKey = ['createPortal']
  const { mutation: mutationOptions, fetch: fetchOptions } =
    options ?
      (
        options.mutation &&
        'mutationKey' in options.mutation &&
        options.mutation.mutationKey
      ) ?
        options
      : { ...options, mutation: { ...options.mutation, mutationKey } }
    : { mutation: { mutationKey }, fetch: undefined }

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof createPortal>>,
    { data: CreatePortalBody }
  > = (props) => {
    const { data } = props ?? {}

    return createPortal(data, fetchOptions)
  }

  return { mutationFn, ...mutationOptions }
}

export type CreatePortalMutationResult = NonNullable<
  Awaited<ReturnType<typeof createPortal>>
>
export type CreatePortalMutationBody = CreatePortalBody
export type CreatePortalMutationError = unknown

/**
 * @summary Create a new portal
 */
export const useCreatePortal = <TError = unknown, TContext = unknown>(
  options?: {
    mutation?: UseMutationOptions<
      Awaited<ReturnType<typeof createPortal>>,
      TError,
      { data: CreatePortalBody },
      TContext
    >
    fetch?: RequestInit
  },
  queryClient?: QueryClient
): UseMutationResult<
  Awaited<ReturnType<typeof createPortal>>,
  TError,
  { data: CreatePortalBody },
  TContext
> => {
  const mutationOptions = getCreatePortalMutationOptions(options)

  return useMutation(mutationOptions, queryClient)
}

/**
 * Cancel a subscription
 * @summary Cancel a subscription
 */
export type cancelSubscriptionResponse200 = {
  data: void
  status: 200
}

export type cancelSubscriptionResponseComposite = cancelSubscriptionResponse200

export type cancelSubscriptionResponse = cancelSubscriptionResponseComposite & {
  headers: Headers
}

export const getCancelSubscriptionUrl = (id: string) => {
  return `http://0.0.0.0:3001/billing/subscriptions/${id}`
}

export const cancelSubscription = async (
  id: string,
  options?: RequestInit
): Promise<cancelSubscriptionResponse> => {
  const res = await fetch(getCancelSubscriptionUrl(id), {
    ...options,
    method: 'DELETE'
  })

  const body = [204, 205, 304].includes(res.status) ? null : await res.text()
  const data: cancelSubscriptionResponse['data'] = body ? JSON.parse(body) : {}

  return {
    data,
    status: res.status,
    headers: res.headers
  } as cancelSubscriptionResponse
}

export const getCancelSubscriptionMutationOptions = <
  TError = unknown,
  TContext = unknown
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof cancelSubscription>>,
    TError,
    { id: string },
    TContext
  >
  fetch?: RequestInit
}): UseMutationOptions<
  Awaited<ReturnType<typeof cancelSubscription>>,
  TError,
  { id: string },
  TContext
> => {
  const mutationKey = ['cancelSubscription']
  const { mutation: mutationOptions, fetch: fetchOptions } =
    options ?
      (
        options.mutation &&
        'mutationKey' in options.mutation &&
        options.mutation.mutationKey
      ) ?
        options
      : { ...options, mutation: { ...options.mutation, mutationKey } }
    : { mutation: { mutationKey }, fetch: undefined }

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof cancelSubscription>>,
    { id: string }
  > = (props) => {
    const { id } = props ?? {}

    return cancelSubscription(id, fetchOptions)
  }

  return { mutationFn, ...mutationOptions }
}

export type CancelSubscriptionMutationResult = NonNullable<
  Awaited<ReturnType<typeof cancelSubscription>>
>

export type CancelSubscriptionMutationError = unknown

/**
 * @summary Cancel a subscription
 */
export const useCancelSubscription = <TError = unknown, TContext = unknown>(
  options?: {
    mutation?: UseMutationOptions<
      Awaited<ReturnType<typeof cancelSubscription>>,
      TError,
      { id: string },
      TContext
    >
    fetch?: RequestInit
  },
  queryClient?: QueryClient
): UseMutationResult<
  Awaited<ReturnType<typeof cancelSubscription>>,
  TError,
  { id: string },
  TContext
> => {
  const mutationOptions = getCancelSubscriptionMutationOptions(options)

  return useMutation(mutationOptions, queryClient)
}

/**
 * Update a subscription
 * @summary Update a subscription
 */
export type updateSubscriptionResponse200 = {
  data: void
  status: 200
}

export type updateSubscriptionResponseComposite = updateSubscriptionResponse200

export type updateSubscriptionResponse = updateSubscriptionResponseComposite & {
  headers: Headers
}

export const getUpdateSubscriptionUrl = (id: string) => {
  return `http://0.0.0.0:3001/billing/subscriptions/${id}`
}

export const updateSubscription = async (
  id: string,
  updateSubscriptionBody: UpdateSubscriptionBody,
  options?: RequestInit
): Promise<updateSubscriptionResponse> => {
  const res = await fetch(getUpdateSubscriptionUrl(id), {
    ...options,
    method: 'PATCH',
    headers: { 'Content-Type': 'application/json', ...options?.headers },
    body: JSON.stringify(updateSubscriptionBody)
  })

  const body = [204, 205, 304].includes(res.status) ? null : await res.text()
  const data: updateSubscriptionResponse['data'] = body ? JSON.parse(body) : {}

  return {
    data,
    status: res.status,
    headers: res.headers
  } as updateSubscriptionResponse
}

export const getUpdateSubscriptionMutationOptions = <
  TError = unknown,
  TContext = unknown
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof updateSubscription>>,
    TError,
    { id: string; data: UpdateSubscriptionBody },
    TContext
  >
  fetch?: RequestInit
}): UseMutationOptions<
  Awaited<ReturnType<typeof updateSubscription>>,
  TError,
  { id: string; data: UpdateSubscriptionBody },
  TContext
> => {
  const mutationKey = ['updateSubscription']
  const { mutation: mutationOptions, fetch: fetchOptions } =
    options ?
      (
        options.mutation &&
        'mutationKey' in options.mutation &&
        options.mutation.mutationKey
      ) ?
        options
      : { ...options, mutation: { ...options.mutation, mutationKey } }
    : { mutation: { mutationKey }, fetch: undefined }

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof updateSubscription>>,
    { id: string; data: UpdateSubscriptionBody }
  > = (props) => {
    const { id, data } = props ?? {}

    return updateSubscription(id, data, fetchOptions)
  }

  return { mutationFn, ...mutationOptions }
}

export type UpdateSubscriptionMutationResult = NonNullable<
  Awaited<ReturnType<typeof updateSubscription>>
>
export type UpdateSubscriptionMutationBody = UpdateSubscriptionBody
export type UpdateSubscriptionMutationError = unknown

/**
 * @summary Update a subscription
 */
export const useUpdateSubscription = <TError = unknown, TContext = unknown>(
  options?: {
    mutation?: UseMutationOptions<
      Awaited<ReturnType<typeof updateSubscription>>,
      TError,
      { id: string; data: UpdateSubscriptionBody },
      TContext
    >
    fetch?: RequestInit
  },
  queryClient?: QueryClient
): UseMutationResult<
  Awaited<ReturnType<typeof updateSubscription>>,
  TError,
  { id: string; data: UpdateSubscriptionBody },
  TContext
> => {
  const mutationOptions = getUpdateSubscriptionMutationOptions(options)

  return useMutation(mutationOptions, queryClient)
}

/**
 * Create a new api-token
 * @summary Create a new api-token
 */
export type createApiTokenResponse201 = {
  data: CreateApiToken201
  status: 201
}

export type createApiTokenResponseComposite = createApiTokenResponse201

export type createApiTokenResponse = createApiTokenResponseComposite & {
  headers: Headers
}

export const getCreateApiTokenUrl = () => {
  return `http://0.0.0.0:3001/api-tokens`
}

export const createApiToken = async (
  createApiTokenBody: CreateApiTokenBody,
  options?: RequestInit
): Promise<createApiTokenResponse> => {
  const res = await fetch(getCreateApiTokenUrl(), {
    ...options,
    method: 'POST',
    headers: { 'Content-Type': 'application/json', ...options?.headers },
    body: JSON.stringify(createApiTokenBody)
  })

  const body = [204, 205, 304].includes(res.status) ? null : await res.text()
  const data: createApiTokenResponse['data'] = body ? JSON.parse(body) : {}

  return {
    data,
    status: res.status,
    headers: res.headers
  } as createApiTokenResponse
}

export const getCreateApiTokenMutationOptions = <
  TError = unknown,
  TContext = unknown
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof createApiToken>>,
    TError,
    { data: CreateApiTokenBody },
    TContext
  >
  fetch?: RequestInit
}): UseMutationOptions<
  Awaited<ReturnType<typeof createApiToken>>,
  TError,
  { data: CreateApiTokenBody },
  TContext
> => {
  const mutationKey = ['createApiToken']
  const { mutation: mutationOptions, fetch: fetchOptions } =
    options ?
      (
        options.mutation &&
        'mutationKey' in options.mutation &&
        options.mutation.mutationKey
      ) ?
        options
      : { ...options, mutation: { ...options.mutation, mutationKey } }
    : { mutation: { mutationKey }, fetch: undefined }

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof createApiToken>>,
    { data: CreateApiTokenBody }
  > = (props) => {
    const { data } = props ?? {}

    return createApiToken(data, fetchOptions)
  }

  return { mutationFn, ...mutationOptions }
}

export type CreateApiTokenMutationResult = NonNullable<
  Awaited<ReturnType<typeof createApiToken>>
>
export type CreateApiTokenMutationBody = CreateApiTokenBody
export type CreateApiTokenMutationError = unknown

/**
 * @summary Create a new api-token
 */
export const useCreateApiToken = <TError = unknown, TContext = unknown>(
  options?: {
    mutation?: UseMutationOptions<
      Awaited<ReturnType<typeof createApiToken>>,
      TError,
      { data: CreateApiTokenBody },
      TContext
    >
    fetch?: RequestInit
  },
  queryClient?: QueryClient
): UseMutationResult<
  Awaited<ReturnType<typeof createApiToken>>,
  TError,
  { data: CreateApiTokenBody },
  TContext
> => {
  const mutationOptions = getCreateApiTokenMutationOptions(options)

  return useMutation(mutationOptions, queryClient)
}

/**
 * Find many api-tokens
 * @summary Find many api-tokens
 */
export type findManyApiTokensResponse200 = {
  data: FindManyApiTokens200
  status: 200
}

export type findManyApiTokensResponseComposite = findManyApiTokensResponse200

export type findManyApiTokensResponse = findManyApiTokensResponseComposite & {
  headers: Headers
}

export const getFindManyApiTokensUrl = (params?: FindManyApiTokensParams) => {
  const normalizedParams = new URLSearchParams()

  Object.entries(params || {}).forEach(([key, value]) => {
    if (value !== undefined) {
      normalizedParams.append(key, value === null ? 'null' : value.toString())
    }
  })

  const stringifiedParams = normalizedParams.toString()

  return stringifiedParams.length > 0 ?
      `http://0.0.0.0:3001/api-tokens?${stringifiedParams}`
    : `http://0.0.0.0:3001/api-tokens`
}

export const findManyApiTokens = async (
  params?: FindManyApiTokensParams,
  options?: RequestInit
): Promise<findManyApiTokensResponse> => {
  const res = await fetch(getFindManyApiTokensUrl(params), {
    ...options,
    method: 'GET'
  })

  const body = [204, 205, 304].includes(res.status) ? null : await res.text()
  const data: findManyApiTokensResponse['data'] = body ? JSON.parse(body) : {}

  return {
    data,
    status: res.status,
    headers: res.headers
  } as findManyApiTokensResponse
}

export const getFindManyApiTokensQueryKey = (
  params?: FindManyApiTokensParams
) => {
  return [
    `http://0.0.0.0:3001/api-tokens`,
    ...(params ? [params] : [])
  ] as const
}

export const getFindManyApiTokensQueryOptions = <
  TData = Awaited<ReturnType<typeof findManyApiTokens>>,
  TError = unknown
>(
  params?: FindManyApiTokensParams,
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof findManyApiTokens>>,
        TError,
        TData
      >
    >
    fetch?: RequestInit
  }
) => {
  const { query: queryOptions, fetch: fetchOptions } = options ?? {}

  const queryKey =
    queryOptions?.queryKey ?? getFindManyApiTokensQueryKey(params)

  const queryFn: QueryFunction<
    Awaited<ReturnType<typeof findManyApiTokens>>
  > = ({ signal }) =>
    findManyApiTokens(params, {
      ...(signal ? { signal } : {}),
      ...fetchOptions
    })

  return { queryKey, queryFn, ...queryOptions } as UseQueryOptions<
    Awaited<ReturnType<typeof findManyApiTokens>>,
    TError,
    TData
  > & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type FindManyApiTokensQueryResult = NonNullable<
  Awaited<ReturnType<typeof findManyApiTokens>>
>
export type FindManyApiTokensQueryError = unknown

export function useFindManyApiTokens<
  TData = Awaited<ReturnType<typeof findManyApiTokens>>,
  TError = unknown
>(
  params: undefined | FindManyApiTokensParams,
  options: {
    query: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof findManyApiTokens>>,
        TError,
        TData
      >
    > &
      Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof findManyApiTokens>>,
          TError,
          Awaited<ReturnType<typeof findManyApiTokens>>
        >,
        'initialData'
      >
    fetch?: RequestInit
  },
  queryClient?: QueryClient
): DefinedUseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>
}
export function useFindManyApiTokens<
  TData = Awaited<ReturnType<typeof findManyApiTokens>>,
  TError = unknown
>(
  params?: FindManyApiTokensParams,
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof findManyApiTokens>>,
        TError,
        TData
      >
    > &
      Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof findManyApiTokens>>,
          TError,
          Awaited<ReturnType<typeof findManyApiTokens>>
        >,
        'initialData'
      >
    fetch?: RequestInit
  },
  queryClient?: QueryClient
): UseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>
}
export function useFindManyApiTokens<
  TData = Awaited<ReturnType<typeof findManyApiTokens>>,
  TError = unknown
>(
  params?: FindManyApiTokensParams,
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof findManyApiTokens>>,
        TError,
        TData
      >
    >
    fetch?: RequestInit
  },
  queryClient?: QueryClient
): UseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>
}
/**
 * @summary Find many api-tokens
 */

export function useFindManyApiTokens<
  TData = Awaited<ReturnType<typeof findManyApiTokens>>,
  TError = unknown
>(
  params?: FindManyApiTokensParams,
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof findManyApiTokens>>,
        TError,
        TData
      >
    >
    fetch?: RequestInit
  },
  queryClient?: QueryClient
): UseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>
} {
  const queryOptions = getFindManyApiTokensQueryOptions(params, options)

  const query = useQuery(queryOptions, queryClient) as UseQueryResult<
    TData,
    TError
  > & { queryKey: DataTag<QueryKey, TData, TError> }

  query.queryKey = queryOptions.queryKey

  return query
}

/**
 * Delete an api-token
 * @summary Delete an api-token
 */
export type deleteApiTokenResponse200 = {
  data: DeleteApiToken200
  status: 200
}

export type deleteApiTokenResponse404 = {
  data: DeleteApiToken404
  status: 404
}

export type deleteApiTokenResponseComposite =
  | deleteApiTokenResponse200
  | deleteApiTokenResponse404

export type deleteApiTokenResponse = deleteApiTokenResponseComposite & {
  headers: Headers
}

export const getDeleteApiTokenUrl = (id: string) => {
  return `http://0.0.0.0:3001/api-tokens/${id}`
}

export const deleteApiToken = async (
  id: string,
  options?: RequestInit
): Promise<deleteApiTokenResponse> => {
  const res = await fetch(getDeleteApiTokenUrl(id), {
    ...options,
    method: 'DELETE'
  })

  const body = [204, 205, 304].includes(res.status) ? null : await res.text()
  const data: deleteApiTokenResponse['data'] = body ? JSON.parse(body) : {}

  return {
    data,
    status: res.status,
    headers: res.headers
  } as deleteApiTokenResponse
}

export const getDeleteApiTokenMutationOptions = <
  TError = DeleteApiToken404,
  TContext = unknown
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof deleteApiToken>>,
    TError,
    { id: string },
    TContext
  >
  fetch?: RequestInit
}): UseMutationOptions<
  Awaited<ReturnType<typeof deleteApiToken>>,
  TError,
  { id: string },
  TContext
> => {
  const mutationKey = ['deleteApiToken']
  const { mutation: mutationOptions, fetch: fetchOptions } =
    options ?
      (
        options.mutation &&
        'mutationKey' in options.mutation &&
        options.mutation.mutationKey
      ) ?
        options
      : { ...options, mutation: { ...options.mutation, mutationKey } }
    : { mutation: { mutationKey }, fetch: undefined }

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof deleteApiToken>>,
    { id: string }
  > = (props) => {
    const { id } = props ?? {}

    return deleteApiToken(id, fetchOptions)
  }

  return { mutationFn, ...mutationOptions }
}

export type DeleteApiTokenMutationResult = NonNullable<
  Awaited<ReturnType<typeof deleteApiToken>>
>

export type DeleteApiTokenMutationError = DeleteApiToken404

/**
 * @summary Delete an api-token
 */
export const useDeleteApiToken = <
  TError = DeleteApiToken404,
  TContext = unknown
>(
  options?: {
    mutation?: UseMutationOptions<
      Awaited<ReturnType<typeof deleteApiToken>>,
      TError,
      { id: string },
      TContext
    >
    fetch?: RequestInit
  },
  queryClient?: QueryClient
): UseMutationResult<
  Awaited<ReturnType<typeof deleteApiToken>>,
  TError,
  { id: string },
  TContext
> => {
  const mutationOptions = getDeleteApiTokenMutationOptions(options)

  return useMutation(mutationOptions, queryClient)
}

/**
 * Find an api-token
 * @summary Find an api-token
 */
export type getOneApiTokenResponse200 = {
  data: GetOneApiToken200
  status: 200
}

export type getOneApiTokenResponse404 = {
  data: GetOneApiToken404
  status: 404
}

export type getOneApiTokenResponseComposite =
  | getOneApiTokenResponse200
  | getOneApiTokenResponse404

export type getOneApiTokenResponse = getOneApiTokenResponseComposite & {
  headers: Headers
}

export const getGetOneApiTokenUrl = (id: string) => {
  return `http://0.0.0.0:3001/api-tokens/${id}`
}

export const getOneApiToken = async (
  id: string,
  options?: RequestInit
): Promise<getOneApiTokenResponse> => {
  const res = await fetch(getGetOneApiTokenUrl(id), {
    ...options,
    method: 'GET'
  })

  const body = [204, 205, 304].includes(res.status) ? null : await res.text()
  const data: getOneApiTokenResponse['data'] = body ? JSON.parse(body) : {}

  return {
    data,
    status: res.status,
    headers: res.headers
  } as getOneApiTokenResponse
}

export const getGetOneApiTokenQueryKey = (id: string) => {
  return [`http://0.0.0.0:3001/api-tokens/${id}`] as const
}

export const getGetOneApiTokenQueryOptions = <
  TData = Awaited<ReturnType<typeof getOneApiToken>>,
  TError = GetOneApiToken404
>(
  id: string,
  options?: {
    query?: Partial<
      UseQueryOptions<Awaited<ReturnType<typeof getOneApiToken>>, TError, TData>
    >
    fetch?: RequestInit
  }
) => {
  const { query: queryOptions, fetch: fetchOptions } = options ?? {}

  const queryKey = queryOptions?.queryKey ?? getGetOneApiTokenQueryKey(id)

  const queryFn: QueryFunction<Awaited<ReturnType<typeof getOneApiToken>>> = ({
    signal
  }) => getOneApiToken(id, { ...(signal ? { signal } : {}), ...fetchOptions })

  return {
    queryKey,
    queryFn,
    enabled: !!id,
    ...queryOptions
  } as UseQueryOptions<
    Awaited<ReturnType<typeof getOneApiToken>>,
    TError,
    TData
  > & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type GetOneApiTokenQueryResult = NonNullable<
  Awaited<ReturnType<typeof getOneApiToken>>
>
export type GetOneApiTokenQueryError = GetOneApiToken404

export function useGetOneApiToken<
  TData = Awaited<ReturnType<typeof getOneApiToken>>,
  TError = GetOneApiToken404
>(
  id: string,
  options: {
    query: Partial<
      UseQueryOptions<Awaited<ReturnType<typeof getOneApiToken>>, TError, TData>
    > &
      Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof getOneApiToken>>,
          TError,
          Awaited<ReturnType<typeof getOneApiToken>>
        >,
        'initialData'
      >
    fetch?: RequestInit
  },
  queryClient?: QueryClient
): DefinedUseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>
}
export function useGetOneApiToken<
  TData = Awaited<ReturnType<typeof getOneApiToken>>,
  TError = GetOneApiToken404
>(
  id: string,
  options?: {
    query?: Partial<
      UseQueryOptions<Awaited<ReturnType<typeof getOneApiToken>>, TError, TData>
    > &
      Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof getOneApiToken>>,
          TError,
          Awaited<ReturnType<typeof getOneApiToken>>
        >,
        'initialData'
      >
    fetch?: RequestInit
  },
  queryClient?: QueryClient
): UseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>
}
export function useGetOneApiToken<
  TData = Awaited<ReturnType<typeof getOneApiToken>>,
  TError = GetOneApiToken404
>(
  id: string,
  options?: {
    query?: Partial<
      UseQueryOptions<Awaited<ReturnType<typeof getOneApiToken>>, TError, TData>
    >
    fetch?: RequestInit
  },
  queryClient?: QueryClient
): UseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>
}
/**
 * @summary Find an api-token
 */

export function useGetOneApiToken<
  TData = Awaited<ReturnType<typeof getOneApiToken>>,
  TError = GetOneApiToken404
>(
  id: string,
  options?: {
    query?: Partial<
      UseQueryOptions<Awaited<ReturnType<typeof getOneApiToken>>, TError, TData>
    >
    fetch?: RequestInit
  },
  queryClient?: QueryClient
): UseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>
} {
  const queryOptions = getGetOneApiTokenQueryOptions(id, options)

  const query = useQuery(queryOptions, queryClient) as UseQueryResult<
    TData,
    TError
  > & { queryKey: DataTag<QueryKey, TData, TError> }

  query.queryKey = queryOptions.queryKey

  return query
}

/**
 * Update an api-token
 * @summary Update an api-token
 */
export type updateApiTokenResponse200 = {
  data: UpdateApiToken200
  status: 200
}

export type updateApiTokenResponse404 = {
  data: UpdateApiToken404
  status: 404
}

export type updateApiTokenResponseComposite =
  | updateApiTokenResponse200
  | updateApiTokenResponse404

export type updateApiTokenResponse = updateApiTokenResponseComposite & {
  headers: Headers
}

export const getUpdateApiTokenUrl = (id: string) => {
  return `http://0.0.0.0:3001/api-tokens/${id}`
}

export const updateApiToken = async (
  id: string,
  updateApiTokenBody: UpdateApiTokenBody,
  options?: RequestInit
): Promise<updateApiTokenResponse> => {
  const res = await fetch(getUpdateApiTokenUrl(id), {
    ...options,
    method: 'PATCH',
    headers: { 'Content-Type': 'application/json', ...options?.headers },
    body: JSON.stringify(updateApiTokenBody)
  })

  const body = [204, 205, 304].includes(res.status) ? null : await res.text()
  const data: updateApiTokenResponse['data'] = body ? JSON.parse(body) : {}

  return {
    data,
    status: res.status,
    headers: res.headers
  } as updateApiTokenResponse
}

export const getUpdateApiTokenMutationOptions = <
  TError = UpdateApiToken404,
  TContext = unknown
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof updateApiToken>>,
    TError,
    { id: string; data: UpdateApiTokenBody },
    TContext
  >
  fetch?: RequestInit
}): UseMutationOptions<
  Awaited<ReturnType<typeof updateApiToken>>,
  TError,
  { id: string; data: UpdateApiTokenBody },
  TContext
> => {
  const mutationKey = ['updateApiToken']
  const { mutation: mutationOptions, fetch: fetchOptions } =
    options ?
      (
        options.mutation &&
        'mutationKey' in options.mutation &&
        options.mutation.mutationKey
      ) ?
        options
      : { ...options, mutation: { ...options.mutation, mutationKey } }
    : { mutation: { mutationKey }, fetch: undefined }

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof updateApiToken>>,
    { id: string; data: UpdateApiTokenBody }
  > = (props) => {
    const { id, data } = props ?? {}

    return updateApiToken(id, data, fetchOptions)
  }

  return { mutationFn, ...mutationOptions }
}

export type UpdateApiTokenMutationResult = NonNullable<
  Awaited<ReturnType<typeof updateApiToken>>
>
export type UpdateApiTokenMutationBody = UpdateApiTokenBody
export type UpdateApiTokenMutationError = UpdateApiToken404

/**
 * @summary Update an api-token
 */
export const useUpdateApiToken = <
  TError = UpdateApiToken404,
  TContext = unknown
>(
  options?: {
    mutation?: UseMutationOptions<
      Awaited<ReturnType<typeof updateApiToken>>,
      TError,
      { id: string; data: UpdateApiTokenBody },
      TContext
    >
    fetch?: RequestInit
  },
  queryClient?: QueryClient
): UseMutationResult<
  Awaited<ReturnType<typeof updateApiToken>>,
  TError,
  { id: string; data: UpdateApiTokenBody },
  TContext
> => {
  const mutationOptions = getUpdateApiTokenMutationOptions(options)

  return useMutation(mutationOptions, queryClient)
}

/**
 * This endpoint will register you with your e-mail and password
 * @summary Register
 */
export type registerResponse204 = {
  data: void
  status: 204
}

export type registerResponse401 = {
  data: Register401
  status: 401
}

export type registerResponseComposite =
  | registerResponse204
  | registerResponse401

export type registerResponse = registerResponseComposite & {
  headers: Headers
}

export const getRegisterUrl = () => {
  return `http://0.0.0.0:3001/auth/register`
}

export const register = async (
  registerBody: RegisterBody,
  options?: RequestInit
): Promise<registerResponse> => {
  const res = await fetch(getRegisterUrl(), {
    ...options,
    method: 'POST',
    headers: { 'Content-Type': 'application/json', ...options?.headers },
    body: JSON.stringify(registerBody)
  })

  const body = [204, 205, 304].includes(res.status) ? null : await res.text()
  const data: registerResponse['data'] = body ? JSON.parse(body) : {}

  return { data, status: res.status, headers: res.headers } as registerResponse
}

export const getRegisterMutationOptions = <
  TError = Register401,
  TContext = unknown
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof register>>,
    TError,
    { data: RegisterBody },
    TContext
  >
  fetch?: RequestInit
}): UseMutationOptions<
  Awaited<ReturnType<typeof register>>,
  TError,
  { data: RegisterBody },
  TContext
> => {
  const mutationKey = ['register']
  const { mutation: mutationOptions, fetch: fetchOptions } =
    options ?
      (
        options.mutation &&
        'mutationKey' in options.mutation &&
        options.mutation.mutationKey
      ) ?
        options
      : { ...options, mutation: { ...options.mutation, mutationKey } }
    : { mutation: { mutationKey }, fetch: undefined }

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof register>>,
    { data: RegisterBody }
  > = (props) => {
    const { data } = props ?? {}

    return register(data, fetchOptions)
  }

  return { mutationFn, ...mutationOptions }
}

export type RegisterMutationResult = NonNullable<
  Awaited<ReturnType<typeof register>>
>
export type RegisterMutationBody = RegisterBody
export type RegisterMutationError = Register401

/**
 * @summary Register
 */
export const useRegister = <TError = Register401, TContext = unknown>(
  options?: {
    mutation?: UseMutationOptions<
      Awaited<ReturnType<typeof register>>,
      TError,
      { data: RegisterBody },
      TContext
    >
    fetch?: RequestInit
  },
  queryClient?: QueryClient
): UseMutationResult<
  Awaited<ReturnType<typeof register>>,
  TError,
  { data: RegisterBody },
  TContext
> => {
  const mutationOptions = getRegisterMutationOptions(options)

  return useMutation(mutationOptions, queryClient)
}

/**
 * This endpoint will log you in with your e-mail and password
 * @summary Login
 */
export type loginResponse204 = {
  data: void
  status: 204
}

export type loginResponse401 = {
  data: Login401
  status: 401
}

export type loginResponseComposite = loginResponse204 | loginResponse401

export type loginResponse = loginResponseComposite & {
  headers: Headers
}

export const getLoginUrl = () => {
  return `http://0.0.0.0:3001/auth/login`
}

export const login = async (
  loginBody: LoginBody,
  options?: RequestInit
): Promise<loginResponse> => {
  const res = await fetch(getLoginUrl(), {
    ...options,
    method: 'POST',
    headers: { 'Content-Type': 'application/json', ...options?.headers },
    body: JSON.stringify(loginBody)
  })

  const body = [204, 205, 304].includes(res.status) ? null : await res.text()
  const data: loginResponse['data'] = body ? JSON.parse(body) : {}

  return { data, status: res.status, headers: res.headers } as loginResponse
}

export const getLoginMutationOptions = <
  TError = Login401,
  TContext = unknown
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof login>>,
    TError,
    { data: LoginBody },
    TContext
  >
  fetch?: RequestInit
}): UseMutationOptions<
  Awaited<ReturnType<typeof login>>,
  TError,
  { data: LoginBody },
  TContext
> => {
  const mutationKey = ['login']
  const { mutation: mutationOptions, fetch: fetchOptions } =
    options ?
      (
        options.mutation &&
        'mutationKey' in options.mutation &&
        options.mutation.mutationKey
      ) ?
        options
      : { ...options, mutation: { ...options.mutation, mutationKey } }
    : { mutation: { mutationKey }, fetch: undefined }

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof login>>,
    { data: LoginBody }
  > = (props) => {
    const { data } = props ?? {}

    return login(data, fetchOptions)
  }

  return { mutationFn, ...mutationOptions }
}

export type LoginMutationResult = NonNullable<Awaited<ReturnType<typeof login>>>
export type LoginMutationBody = LoginBody
export type LoginMutationError = Login401

/**
 * @summary Login
 */
export const useLogin = <TError = Login401, TContext = unknown>(
  options?: {
    mutation?: UseMutationOptions<
      Awaited<ReturnType<typeof login>>,
      TError,
      { data: LoginBody },
      TContext
    >
    fetch?: RequestInit
  },
  queryClient?: QueryClient
): UseMutationResult<
  Awaited<ReturnType<typeof login>>,
  TError,
  { data: LoginBody },
  TContext
> => {
  const mutationOptions = getLoginMutationOptions(options)

  return useMutation(mutationOptions, queryClient)
}

/**
 * This endpoint will log you out of the current session
 * @summary Logout
 */
export type logoutResponse204 = {
  data: void
  status: 204
}

export type logoutResponse401 = {
  data: Logout401
  status: 401
}

export type logoutResponseComposite = logoutResponse204 | logoutResponse401

export type logoutResponse = logoutResponseComposite & {
  headers: Headers
}

export const getLogoutUrl = () => {
  return `http://0.0.0.0:3001/auth/logout`
}

export const logout = async (
  options?: RequestInit
): Promise<logoutResponse> => {
  const res = await fetch(getLogoutUrl(), {
    ...options,
    method: 'POST'
  })

  const body = [204, 205, 304].includes(res.status) ? null : await res.text()
  const data: logoutResponse['data'] = body ? JSON.parse(body) : {}

  return { data, status: res.status, headers: res.headers } as logoutResponse
}

export const getLogoutMutationOptions = <
  TError = Logout401,
  TContext = unknown
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof logout>>,
    TError,
    void,
    TContext
  >
  fetch?: RequestInit
}): UseMutationOptions<
  Awaited<ReturnType<typeof logout>>,
  TError,
  void,
  TContext
> => {
  const mutationKey = ['logout']
  const { mutation: mutationOptions, fetch: fetchOptions } =
    options ?
      (
        options.mutation &&
        'mutationKey' in options.mutation &&
        options.mutation.mutationKey
      ) ?
        options
      : { ...options, mutation: { ...options.mutation, mutationKey } }
    : { mutation: { mutationKey }, fetch: undefined }

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof logout>>,
    void
  > = () => {
    return logout(fetchOptions)
  }

  return { mutationFn, ...mutationOptions }
}

export type LogoutMutationResult = NonNullable<
  Awaited<ReturnType<typeof logout>>
>

export type LogoutMutationError = Logout401

/**
 * @summary Logout
 */
export const useLogout = <TError = Logout401, TContext = unknown>(
  options?: {
    mutation?: UseMutationOptions<
      Awaited<ReturnType<typeof logout>>,
      TError,
      void,
      TContext
    >
    fetch?: RequestInit
  },
  queryClient?: QueryClient
): UseMutationResult<
  Awaited<ReturnType<typeof logout>>,
  TError,
  void,
  TContext
> => {
  const mutationOptions = getLogoutMutationOptions(options)

  return useMutation(mutationOptions, queryClient)
}

/**
 * This endpoint will refresh your access token
 * @summary Refresh
 */
export type refreshResponse204 = {
  data: void
  status: 204
}

export type refreshResponse401 = {
  data: Refresh401
  status: 401
}

export type refreshResponseComposite = refreshResponse204 | refreshResponse401

export type refreshResponse = refreshResponseComposite & {
  headers: Headers
}

export const getRefreshUrl = () => {
  return `http://0.0.0.0:3001/auth/refresh`
}

export const refresh = async (
  options?: RequestInit
): Promise<refreshResponse> => {
  const res = await fetch(getRefreshUrl(), {
    ...options,
    method: 'POST'
  })

  const body = [204, 205, 304].includes(res.status) ? null : await res.text()
  const data: refreshResponse['data'] = body ? JSON.parse(body) : {}

  return { data, status: res.status, headers: res.headers } as refreshResponse
}

export const getRefreshMutationOptions = <
  TError = Refresh401,
  TContext = unknown
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof refresh>>,
    TError,
    void,
    TContext
  >
  fetch?: RequestInit
}): UseMutationOptions<
  Awaited<ReturnType<typeof refresh>>,
  TError,
  void,
  TContext
> => {
  const mutationKey = ['refresh']
  const { mutation: mutationOptions, fetch: fetchOptions } =
    options ?
      (
        options.mutation &&
        'mutationKey' in options.mutation &&
        options.mutation.mutationKey
      ) ?
        options
      : { ...options, mutation: { ...options.mutation, mutationKey } }
    : { mutation: { mutationKey }, fetch: undefined }

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof refresh>>,
    void
  > = () => {
    return refresh(fetchOptions)
  }

  return { mutationFn, ...mutationOptions }
}

export type RefreshMutationResult = NonNullable<
  Awaited<ReturnType<typeof refresh>>
>

export type RefreshMutationError = Refresh401

/**
 * @summary Refresh
 */
export const useRefresh = <TError = Refresh401, TContext = unknown>(
  options?: {
    mutation?: UseMutationOptions<
      Awaited<ReturnType<typeof refresh>>,
      TError,
      void,
      TContext
    >
    fetch?: RequestInit
  },
  queryClient?: QueryClient
): UseMutationResult<
  Awaited<ReturnType<typeof refresh>>,
  TError,
  void,
  TContext
> => {
  const mutationOptions = getRefreshMutationOptions(options)

  return useMutation(mutationOptions, queryClient)
}

/**
 * Authenticate with Firebase using OAuth
 * @summary Authenticate with Firebase
 */
export type firebaseResponse204 = {
  data: void
  status: 204
}

export type firebaseResponseComposite = firebaseResponse204

export type firebaseResponse = firebaseResponseComposite & {
  headers: Headers
}

export const getFirebaseUrl = () => {
  return `http://0.0.0.0:3001/oauth/firebase`
}

export const firebase = async (
  options?: RequestInit
): Promise<firebaseResponse> => {
  const res = await fetch(getFirebaseUrl(), {
    ...options,
    method: 'POST'
  })

  const body = [204, 205, 304].includes(res.status) ? null : await res.text()
  const data: firebaseResponse['data'] = body ? JSON.parse(body) : {}

  return { data, status: res.status, headers: res.headers } as firebaseResponse
}

export const getFirebaseMutationOptions = <
  TError = unknown,
  TContext = unknown
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof firebase>>,
    TError,
    void,
    TContext
  >
  fetch?: RequestInit
}): UseMutationOptions<
  Awaited<ReturnType<typeof firebase>>,
  TError,
  void,
  TContext
> => {
  const mutationKey = ['firebase']
  const { mutation: mutationOptions, fetch: fetchOptions } =
    options ?
      (
        options.mutation &&
        'mutationKey' in options.mutation &&
        options.mutation.mutationKey
      ) ?
        options
      : { ...options, mutation: { ...options.mutation, mutationKey } }
    : { mutation: { mutationKey }, fetch: undefined }

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof firebase>>,
    void
  > = () => {
    return firebase(fetchOptions)
  }

  return { mutationFn, ...mutationOptions }
}

export type FirebaseMutationResult = NonNullable<
  Awaited<ReturnType<typeof firebase>>
>

export type FirebaseMutationError = unknown

/**
 * @summary Authenticate with Firebase
 */
export const useFirebase = <TError = unknown, TContext = unknown>(
  options?: {
    mutation?: UseMutationOptions<
      Awaited<ReturnType<typeof firebase>>,
      TError,
      void,
      TContext
    >
    fetch?: RequestInit
  },
  queryClient?: QueryClient
): UseMutationResult<
  Awaited<ReturnType<typeof firebase>>,
  TError,
  void,
  TContext
> => {
  const mutationOptions = getFirebaseMutationOptions(options)

  return useMutation(mutationOptions, queryClient)
}

/**
 * Redirects user to Twitter for authentication.
 * @summary Redirect to Twitter OAuth
 */
export type twitterResponse204 = {
  data: void
  status: 204
}

export type twitterResponseComposite = twitterResponse204

export type twitterResponse = twitterResponseComposite & {
  headers: Headers
}

export const getTwitterUrl = () => {
  return `http://0.0.0.0:3001/oauth/twitter`
}

export const twitter = async (
  options?: RequestInit
): Promise<twitterResponse> => {
  const res = await fetch(getTwitterUrl(), {
    ...options,
    method: 'GET'
  })

  const body = [204, 205, 304].includes(res.status) ? null : await res.text()
  const data: twitterResponse['data'] = body ? JSON.parse(body) : {}

  return { data, status: res.status, headers: res.headers } as twitterResponse
}

export const getTwitterQueryKey = () => {
  return [`http://0.0.0.0:3001/oauth/twitter`] as const
}

export const getTwitterQueryOptions = <
  TData = Awaited<ReturnType<typeof twitter>>,
  TError = unknown
>(options?: {
  query?: Partial<
    UseQueryOptions<Awaited<ReturnType<typeof twitter>>, TError, TData>
  >
  fetch?: RequestInit
}) => {
  const { query: queryOptions, fetch: fetchOptions } = options ?? {}

  const queryKey = queryOptions?.queryKey ?? getTwitterQueryKey()

  const queryFn: QueryFunction<Awaited<ReturnType<typeof twitter>>> = ({
    signal
  }) => twitter({ ...(signal ? { signal } : {}), ...fetchOptions })

  return { queryKey, queryFn, ...queryOptions } as UseQueryOptions<
    Awaited<ReturnType<typeof twitter>>,
    TError,
    TData
  > & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type TwitterQueryResult = NonNullable<
  Awaited<ReturnType<typeof twitter>>
>
export type TwitterQueryError = unknown

export function useTwitter<
  TData = Awaited<ReturnType<typeof twitter>>,
  TError = unknown
>(
  options: {
    query: Partial<
      UseQueryOptions<Awaited<ReturnType<typeof twitter>>, TError, TData>
    > &
      Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof twitter>>,
          TError,
          Awaited<ReturnType<typeof twitter>>
        >,
        'initialData'
      >
    fetch?: RequestInit
  },
  queryClient?: QueryClient
): DefinedUseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>
}
export function useTwitter<
  TData = Awaited<ReturnType<typeof twitter>>,
  TError = unknown
>(
  options?: {
    query?: Partial<
      UseQueryOptions<Awaited<ReturnType<typeof twitter>>, TError, TData>
    > &
      Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof twitter>>,
          TError,
          Awaited<ReturnType<typeof twitter>>
        >,
        'initialData'
      >
    fetch?: RequestInit
  },
  queryClient?: QueryClient
): UseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>
}
export function useTwitter<
  TData = Awaited<ReturnType<typeof twitter>>,
  TError = unknown
>(
  options?: {
    query?: Partial<
      UseQueryOptions<Awaited<ReturnType<typeof twitter>>, TError, TData>
    >
    fetch?: RequestInit
  },
  queryClient?: QueryClient
): UseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>
}
/**
 * @summary Redirect to Twitter OAuth
 */

export function useTwitter<
  TData = Awaited<ReturnType<typeof twitter>>,
  TError = unknown
>(
  options?: {
    query?: Partial<
      UseQueryOptions<Awaited<ReturnType<typeof twitter>>, TError, TData>
    >
    fetch?: RequestInit
  },
  queryClient?: QueryClient
): UseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>
} {
  const queryOptions = getTwitterQueryOptions(options)

  const query = useQuery(queryOptions, queryClient) as UseQueryResult<
    TData,
    TError
  > & { queryKey: DataTag<QueryKey, TData, TError> }

  query.queryKey = queryOptions.queryKey

  return query
}

/**
 * Receives the Twitter OAuth callback after successful authentication.
 * @summary Handle Twitter OAuth callback
 */
export type twitterCallbackResponse204 = {
  data: void
  status: 204
}

export type twitterCallbackResponseComposite = twitterCallbackResponse204

export type twitterCallbackResponse = twitterCallbackResponseComposite & {
  headers: Headers
}

export const getTwitterCallbackUrl = () => {
  return `http://0.0.0.0:3001/oauth/twitter/callback`
}

export const twitterCallback = async (
  options?: RequestInit
): Promise<twitterCallbackResponse> => {
  const res = await fetch(getTwitterCallbackUrl(), {
    ...options,
    method: 'GET'
  })

  const body = [204, 205, 304].includes(res.status) ? null : await res.text()
  const data: twitterCallbackResponse['data'] = body ? JSON.parse(body) : {}

  return {
    data,
    status: res.status,
    headers: res.headers
  } as twitterCallbackResponse
}

export const getTwitterCallbackQueryKey = () => {
  return [`http://0.0.0.0:3001/oauth/twitter/callback`] as const
}

export const getTwitterCallbackQueryOptions = <
  TData = Awaited<ReturnType<typeof twitterCallback>>,
  TError = unknown
>(options?: {
  query?: Partial<
    UseQueryOptions<Awaited<ReturnType<typeof twitterCallback>>, TError, TData>
  >
  fetch?: RequestInit
}) => {
  const { query: queryOptions, fetch: fetchOptions } = options ?? {}

  const queryKey = queryOptions?.queryKey ?? getTwitterCallbackQueryKey()

  const queryFn: QueryFunction<Awaited<ReturnType<typeof twitterCallback>>> = ({
    signal
  }) => twitterCallback({ ...(signal ? { signal } : {}), ...fetchOptions })

  return { queryKey, queryFn, ...queryOptions } as UseQueryOptions<
    Awaited<ReturnType<typeof twitterCallback>>,
    TError,
    TData
  > & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type TwitterCallbackQueryResult = NonNullable<
  Awaited<ReturnType<typeof twitterCallback>>
>
export type TwitterCallbackQueryError = unknown

export function useTwitterCallback<
  TData = Awaited<ReturnType<typeof twitterCallback>>,
  TError = unknown
>(
  options: {
    query: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof twitterCallback>>,
        TError,
        TData
      >
    > &
      Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof twitterCallback>>,
          TError,
          Awaited<ReturnType<typeof twitterCallback>>
        >,
        'initialData'
      >
    fetch?: RequestInit
  },
  queryClient?: QueryClient
): DefinedUseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>
}
export function useTwitterCallback<
  TData = Awaited<ReturnType<typeof twitterCallback>>,
  TError = unknown
>(
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof twitterCallback>>,
        TError,
        TData
      >
    > &
      Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof twitterCallback>>,
          TError,
          Awaited<ReturnType<typeof twitterCallback>>
        >,
        'initialData'
      >
    fetch?: RequestInit
  },
  queryClient?: QueryClient
): UseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>
}
export function useTwitterCallback<
  TData = Awaited<ReturnType<typeof twitterCallback>>,
  TError = unknown
>(
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof twitterCallback>>,
        TError,
        TData
      >
    >
    fetch?: RequestInit
  },
  queryClient?: QueryClient
): UseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>
}
/**
 * @summary Handle Twitter OAuth callback
 */

export function useTwitterCallback<
  TData = Awaited<ReturnType<typeof twitterCallback>>,
  TError = unknown
>(
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof twitterCallback>>,
        TError,
        TData
      >
    >
    fetch?: RequestInit
  },
  queryClient?: QueryClient
): UseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>
} {
  const queryOptions = getTwitterCallbackQueryOptions(options)

  const query = useQuery(queryOptions, queryClient) as UseQueryResult<
    TData,
    TError
  > & { queryKey: DataTag<QueryKey, TData, TError> }

  query.queryKey = queryOptions.queryKey

  return query
}

/**
 * This endpoint will confirm your password change with a token
 * @summary Confirm password reset
 */
export type confirmPasswordResetResponse204 = {
  data: void
  status: 204
}

export type confirmPasswordResetResponse401 = {
  data: ConfirmPasswordReset401
  status: 401
}

export type confirmPasswordResetResponse404 = {
  data: ConfirmPasswordReset404
  status: 404
}

export type confirmPasswordResetResponseComposite =
  | confirmPasswordResetResponse204
  | confirmPasswordResetResponse401
  | confirmPasswordResetResponse404

export type confirmPasswordResetResponse =
  confirmPasswordResetResponseComposite & {
    headers: Headers
  }

export const getConfirmPasswordResetUrl = () => {
  return `http://0.0.0.0:3001/auth/password-reset/confirm`
}

export const confirmPasswordReset = async (
  confirmPasswordResetBody: ConfirmPasswordResetBody,
  options?: RequestInit
): Promise<confirmPasswordResetResponse> => {
  const res = await fetch(getConfirmPasswordResetUrl(), {
    ...options,
    method: 'POST',
    headers: { 'Content-Type': 'application/json', ...options?.headers },
    body: JSON.stringify(confirmPasswordResetBody)
  })

  const body = [204, 205, 304].includes(res.status) ? null : await res.text()
  const data: confirmPasswordResetResponse['data'] =
    body ? JSON.parse(body) : {}

  return {
    data,
    status: res.status,
    headers: res.headers
  } as confirmPasswordResetResponse
}

export const getConfirmPasswordResetMutationOptions = <
  TError = ConfirmPasswordReset401 | ConfirmPasswordReset404,
  TContext = unknown
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof confirmPasswordReset>>,
    TError,
    { data: ConfirmPasswordResetBody },
    TContext
  >
  fetch?: RequestInit
}): UseMutationOptions<
  Awaited<ReturnType<typeof confirmPasswordReset>>,
  TError,
  { data: ConfirmPasswordResetBody },
  TContext
> => {
  const mutationKey = ['confirmPasswordReset']
  const { mutation: mutationOptions, fetch: fetchOptions } =
    options ?
      (
        options.mutation &&
        'mutationKey' in options.mutation &&
        options.mutation.mutationKey
      ) ?
        options
      : { ...options, mutation: { ...options.mutation, mutationKey } }
    : { mutation: { mutationKey }, fetch: undefined }

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof confirmPasswordReset>>,
    { data: ConfirmPasswordResetBody }
  > = (props) => {
    const { data } = props ?? {}

    return confirmPasswordReset(data, fetchOptions)
  }

  return { mutationFn, ...mutationOptions }
}

export type ConfirmPasswordResetMutationResult = NonNullable<
  Awaited<ReturnType<typeof confirmPasswordReset>>
>
export type ConfirmPasswordResetMutationBody = ConfirmPasswordResetBody
export type ConfirmPasswordResetMutationError =
  | ConfirmPasswordReset401
  | ConfirmPasswordReset404

/**
 * @summary Confirm password reset
 */
export const useConfirmPasswordReset = <
  TError = ConfirmPasswordReset401 | ConfirmPasswordReset404,
  TContext = unknown
>(
  options?: {
    mutation?: UseMutationOptions<
      Awaited<ReturnType<typeof confirmPasswordReset>>,
      TError,
      { data: ConfirmPasswordResetBody },
      TContext
    >
    fetch?: RequestInit
  },
  queryClient?: QueryClient
): UseMutationResult<
  Awaited<ReturnType<typeof confirmPasswordReset>>,
  TError,
  { data: ConfirmPasswordResetBody },
  TContext
> => {
  const mutationOptions = getConfirmPasswordResetMutationOptions(options)

  return useMutation(mutationOptions, queryClient)
}

/**
 * This endpoint will request a password reset link
 * @summary Request password reset
 */
export type requestPasswordResetResponse204 = {
  data: void
  status: 204
}

export type requestPasswordResetResponseComposite =
  requestPasswordResetResponse204

export type requestPasswordResetResponse =
  requestPasswordResetResponseComposite & {
    headers: Headers
  }

export const getRequestPasswordResetUrl = () => {
  return `http://0.0.0.0:3001/auth/password-reset/request`
}

export const requestPasswordReset = async (
  requestPasswordResetBody: RequestPasswordResetBody,
  options?: RequestInit
): Promise<requestPasswordResetResponse> => {
  const res = await fetch(getRequestPasswordResetUrl(), {
    ...options,
    method: 'POST',
    headers: { 'Content-Type': 'application/json', ...options?.headers },
    body: JSON.stringify(requestPasswordResetBody)
  })

  const body = [204, 205, 304].includes(res.status) ? null : await res.text()
  const data: requestPasswordResetResponse['data'] =
    body ? JSON.parse(body) : {}

  return {
    data,
    status: res.status,
    headers: res.headers
  } as requestPasswordResetResponse
}

export const getRequestPasswordResetMutationOptions = <
  TError = unknown,
  TContext = unknown
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof requestPasswordReset>>,
    TError,
    { data: RequestPasswordResetBody },
    TContext
  >
  fetch?: RequestInit
}): UseMutationOptions<
  Awaited<ReturnType<typeof requestPasswordReset>>,
  TError,
  { data: RequestPasswordResetBody },
  TContext
> => {
  const mutationKey = ['requestPasswordReset']
  const { mutation: mutationOptions, fetch: fetchOptions } =
    options ?
      (
        options.mutation &&
        'mutationKey' in options.mutation &&
        options.mutation.mutationKey
      ) ?
        options
      : { ...options, mutation: { ...options.mutation, mutationKey } }
    : { mutation: { mutationKey }, fetch: undefined }

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof requestPasswordReset>>,
    { data: RequestPasswordResetBody }
  > = (props) => {
    const { data } = props ?? {}

    return requestPasswordReset(data, fetchOptions)
  }

  return { mutationFn, ...mutationOptions }
}

export type RequestPasswordResetMutationResult = NonNullable<
  Awaited<ReturnType<typeof requestPasswordReset>>
>
export type RequestPasswordResetMutationBody = RequestPasswordResetBody
export type RequestPasswordResetMutationError = unknown

/**
 * @summary Request password reset
 */
export const useRequestPasswordReset = <TError = unknown, TContext = unknown>(
  options?: {
    mutation?: UseMutationOptions<
      Awaited<ReturnType<typeof requestPasswordReset>>,
      TError,
      { data: RequestPasswordResetBody },
      TContext
    >
    fetch?: RequestInit
  },
  queryClient?: QueryClient
): UseMutationResult<
  Awaited<ReturnType<typeof requestPasswordReset>>,
  TError,
  { data: RequestPasswordResetBody },
  TContext
> => {
  const mutationOptions = getRequestPasswordResetMutationOptions(options)

  return useMutation(mutationOptions, queryClient)
}

/**
 * This endpoint will confirm your e-mail change with a token
 * @summary Confirm e-mail change
 */
export type confirmEmailChangeResponse204 = {
  data: void
  status: 204
}

export type confirmEmailChangeResponse401 = {
  data: ConfirmEmailChange401
  status: 401
}

export type confirmEmailChangeResponse404 = {
  data: ConfirmEmailChange404
  status: 404
}

export type confirmEmailChangeResponseComposite =
  | confirmEmailChangeResponse204
  | confirmEmailChangeResponse401
  | confirmEmailChangeResponse404

export type confirmEmailChangeResponse = confirmEmailChangeResponseComposite & {
  headers: Headers
}

export const getConfirmEmailChangeUrl = () => {
  return `http://0.0.0.0:3001/auth/email-change/confirm`
}

export const confirmEmailChange = async (
  confirmEmailChangeBody: ConfirmEmailChangeBody,
  options?: RequestInit
): Promise<confirmEmailChangeResponse> => {
  const res = await fetch(getConfirmEmailChangeUrl(), {
    ...options,
    method: 'POST',
    headers: { 'Content-Type': 'application/json', ...options?.headers },
    body: JSON.stringify(confirmEmailChangeBody)
  })

  const body = [204, 205, 304].includes(res.status) ? null : await res.text()
  const data: confirmEmailChangeResponse['data'] = body ? JSON.parse(body) : {}

  return {
    data,
    status: res.status,
    headers: res.headers
  } as confirmEmailChangeResponse
}

export const getConfirmEmailChangeMutationOptions = <
  TError = ConfirmEmailChange401 | ConfirmEmailChange404,
  TContext = unknown
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof confirmEmailChange>>,
    TError,
    { data: ConfirmEmailChangeBody },
    TContext
  >
  fetch?: RequestInit
}): UseMutationOptions<
  Awaited<ReturnType<typeof confirmEmailChange>>,
  TError,
  { data: ConfirmEmailChangeBody },
  TContext
> => {
  const mutationKey = ['confirmEmailChange']
  const { mutation: mutationOptions, fetch: fetchOptions } =
    options ?
      (
        options.mutation &&
        'mutationKey' in options.mutation &&
        options.mutation.mutationKey
      ) ?
        options
      : { ...options, mutation: { ...options.mutation, mutationKey } }
    : { mutation: { mutationKey }, fetch: undefined }

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof confirmEmailChange>>,
    { data: ConfirmEmailChangeBody }
  > = (props) => {
    const { data } = props ?? {}

    return confirmEmailChange(data, fetchOptions)
  }

  return { mutationFn, ...mutationOptions }
}

export type ConfirmEmailChangeMutationResult = NonNullable<
  Awaited<ReturnType<typeof confirmEmailChange>>
>
export type ConfirmEmailChangeMutationBody = ConfirmEmailChangeBody
export type ConfirmEmailChangeMutationError =
  | ConfirmEmailChange401
  | ConfirmEmailChange404

/**
 * @summary Confirm e-mail change
 */
export const useConfirmEmailChange = <
  TError = ConfirmEmailChange401 | ConfirmEmailChange404,
  TContext = unknown
>(
  options?: {
    mutation?: UseMutationOptions<
      Awaited<ReturnType<typeof confirmEmailChange>>,
      TError,
      { data: ConfirmEmailChangeBody },
      TContext
    >
    fetch?: RequestInit
  },
  queryClient?: QueryClient
): UseMutationResult<
  Awaited<ReturnType<typeof confirmEmailChange>>,
  TError,
  { data: ConfirmEmailChangeBody },
  TContext
> => {
  const mutationOptions = getConfirmEmailChangeMutationOptions(options)

  return useMutation(mutationOptions, queryClient)
}

/**
 * This endpoint will request your e-mail change with a token
 * @summary Request e-mail change
 */
export type requestEmailChangeResponse204 = {
  data: void
  status: 204
}

export type requestEmailChangeResponseComposite = requestEmailChangeResponse204

export type requestEmailChangeResponse = requestEmailChangeResponseComposite & {
  headers: Headers
}

export const getRequestEmailChangeUrl = () => {
  return `http://0.0.0.0:3001/auth/email-change/request`
}

export const requestEmailChange = async (
  requestEmailChangeBody: RequestEmailChangeBody,
  options?: RequestInit
): Promise<requestEmailChangeResponse> => {
  const res = await fetch(getRequestEmailChangeUrl(), {
    ...options,
    method: 'POST',
    headers: { 'Content-Type': 'application/json', ...options?.headers },
    body: JSON.stringify(requestEmailChangeBody)
  })

  const body = [204, 205, 304].includes(res.status) ? null : await res.text()
  const data: requestEmailChangeResponse['data'] = body ? JSON.parse(body) : {}

  return {
    data,
    status: res.status,
    headers: res.headers
  } as requestEmailChangeResponse
}

export const getRequestEmailChangeMutationOptions = <
  TError = unknown,
  TContext = unknown
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof requestEmailChange>>,
    TError,
    { data: RequestEmailChangeBody },
    TContext
  >
  fetch?: RequestInit
}): UseMutationOptions<
  Awaited<ReturnType<typeof requestEmailChange>>,
  TError,
  { data: RequestEmailChangeBody },
  TContext
> => {
  const mutationKey = ['requestEmailChange']
  const { mutation: mutationOptions, fetch: fetchOptions } =
    options ?
      (
        options.mutation &&
        'mutationKey' in options.mutation &&
        options.mutation.mutationKey
      ) ?
        options
      : { ...options, mutation: { ...options.mutation, mutationKey } }
    : { mutation: { mutationKey }, fetch: undefined }

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof requestEmailChange>>,
    { data: RequestEmailChangeBody }
  > = (props) => {
    const { data } = props ?? {}

    return requestEmailChange(data, fetchOptions)
  }

  return { mutationFn, ...mutationOptions }
}

export type RequestEmailChangeMutationResult = NonNullable<
  Awaited<ReturnType<typeof requestEmailChange>>
>
export type RequestEmailChangeMutationBody = RequestEmailChangeBody
export type RequestEmailChangeMutationError = unknown

/**
 * @summary Request e-mail change
 */
export const useRequestEmailChange = <TError = unknown, TContext = unknown>(
  options?: {
    mutation?: UseMutationOptions<
      Awaited<ReturnType<typeof requestEmailChange>>,
      TError,
      { data: RequestEmailChangeBody },
      TContext
    >
    fetch?: RequestInit
  },
  queryClient?: QueryClient
): UseMutationResult<
  Awaited<ReturnType<typeof requestEmailChange>>,
  TError,
  { data: RequestEmailChangeBody },
  TContext
> => {
  const mutationOptions = getRequestEmailChangeMutationOptions(options)

  return useMutation(mutationOptions, queryClient)
}

/**
 * This endpoint will confirm your e-mail with a token
 * @summary Confirm e-mail verification
 */
export type confirmEmailVerificationResponse204 = {
  data: void
  status: 204
}

export type confirmEmailVerificationResponse401 = {
  data: ConfirmEmailVerification401
  status: 401
}

export type confirmEmailVerificationResponse404 = {
  data: ConfirmEmailVerification404
  status: 404
}

export type confirmEmailVerificationResponseComposite =
  | confirmEmailVerificationResponse204
  | confirmEmailVerificationResponse401
  | confirmEmailVerificationResponse404

export type confirmEmailVerificationResponse =
  confirmEmailVerificationResponseComposite & {
    headers: Headers
  }

export const getConfirmEmailVerificationUrl = () => {
  return `http://0.0.0.0:3001/auth/email-verification/confirm`
}

export const confirmEmailVerification = async (
  confirmEmailVerificationBody: ConfirmEmailVerificationBody,
  options?: RequestInit
): Promise<confirmEmailVerificationResponse> => {
  const res = await fetch(getConfirmEmailVerificationUrl(), {
    ...options,
    method: 'POST',
    headers: { 'Content-Type': 'application/json', ...options?.headers },
    body: JSON.stringify(confirmEmailVerificationBody)
  })

  const body = [204, 205, 304].includes(res.status) ? null : await res.text()
  const data: confirmEmailVerificationResponse['data'] =
    body ? JSON.parse(body) : {}

  return {
    data,
    status: res.status,
    headers: res.headers
  } as confirmEmailVerificationResponse
}

export const getConfirmEmailVerificationMutationOptions = <
  TError = ConfirmEmailVerification401 | ConfirmEmailVerification404,
  TContext = unknown
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof confirmEmailVerification>>,
    TError,
    { data: ConfirmEmailVerificationBody },
    TContext
  >
  fetch?: RequestInit
}): UseMutationOptions<
  Awaited<ReturnType<typeof confirmEmailVerification>>,
  TError,
  { data: ConfirmEmailVerificationBody },
  TContext
> => {
  const mutationKey = ['confirmEmailVerification']
  const { mutation: mutationOptions, fetch: fetchOptions } =
    options ?
      (
        options.mutation &&
        'mutationKey' in options.mutation &&
        options.mutation.mutationKey
      ) ?
        options
      : { ...options, mutation: { ...options.mutation, mutationKey } }
    : { mutation: { mutationKey }, fetch: undefined }

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof confirmEmailVerification>>,
    { data: ConfirmEmailVerificationBody }
  > = (props) => {
    const { data } = props ?? {}

    return confirmEmailVerification(data, fetchOptions)
  }

  return { mutationFn, ...mutationOptions }
}

export type ConfirmEmailVerificationMutationResult = NonNullable<
  Awaited<ReturnType<typeof confirmEmailVerification>>
>
export type ConfirmEmailVerificationMutationBody = ConfirmEmailVerificationBody
export type ConfirmEmailVerificationMutationError =
  | ConfirmEmailVerification401
  | ConfirmEmailVerification404

/**
 * @summary Confirm e-mail verification
 */
export const useConfirmEmailVerification = <
  TError = ConfirmEmailVerification401 | ConfirmEmailVerification404,
  TContext = unknown
>(
  options?: {
    mutation?: UseMutationOptions<
      Awaited<ReturnType<typeof confirmEmailVerification>>,
      TError,
      { data: ConfirmEmailVerificationBody },
      TContext
    >
    fetch?: RequestInit
  },
  queryClient?: QueryClient
): UseMutationResult<
  Awaited<ReturnType<typeof confirmEmailVerification>>,
  TError,
  { data: ConfirmEmailVerificationBody },
  TContext
> => {
  const mutationOptions = getConfirmEmailVerificationMutationOptions(options)

  return useMutation(mutationOptions, queryClient)
}

/**
 * This endpoint will send an e-mail verification link to you. ADMIN ONLY.
 * @summary Request e-mail verification
 */
export type requestEmailVerificationResponse204 = {
  data: void
  status: 204
}

export type requestEmailVerificationResponseComposite =
  requestEmailVerificationResponse204

export type requestEmailVerificationResponse =
  requestEmailVerificationResponseComposite & {
    headers: Headers
  }

export const getRequestEmailVerificationUrl = () => {
  return `http://0.0.0.0:3001/auth/email-verification/request`
}

export const requestEmailVerification = async (
  options?: RequestInit
): Promise<requestEmailVerificationResponse> => {
  const res = await fetch(getRequestEmailVerificationUrl(), {
    ...options,
    method: 'POST'
  })

  const body = [204, 205, 304].includes(res.status) ? null : await res.text()
  const data: requestEmailVerificationResponse['data'] =
    body ? JSON.parse(body) : {}

  return {
    data,
    status: res.status,
    headers: res.headers
  } as requestEmailVerificationResponse
}

export const getRequestEmailVerificationMutationOptions = <
  TError = unknown,
  TContext = unknown
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof requestEmailVerification>>,
    TError,
    void,
    TContext
  >
  fetch?: RequestInit
}): UseMutationOptions<
  Awaited<ReturnType<typeof requestEmailVerification>>,
  TError,
  void,
  TContext
> => {
  const mutationKey = ['requestEmailVerification']
  const { mutation: mutationOptions, fetch: fetchOptions } =
    options ?
      (
        options.mutation &&
        'mutationKey' in options.mutation &&
        options.mutation.mutationKey
      ) ?
        options
      : { ...options, mutation: { ...options.mutation, mutationKey } }
    : { mutation: { mutationKey }, fetch: undefined }

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof requestEmailVerification>>,
    void
  > = () => {
    return requestEmailVerification(fetchOptions)
  }

  return { mutationFn, ...mutationOptions }
}

export type RequestEmailVerificationMutationResult = NonNullable<
  Awaited<ReturnType<typeof requestEmailVerification>>
>

export type RequestEmailVerificationMutationError = unknown

/**
 * @summary Request e-mail verification
 */
export const useRequestEmailVerification = <
  TError = unknown,
  TContext = unknown
>(
  options?: {
    mutation?: UseMutationOptions<
      Awaited<ReturnType<typeof requestEmailVerification>>,
      TError,
      void,
      TContext
    >
    fetch?: RequestInit
  },
  queryClient?: QueryClient
): UseMutationResult<
  Awaited<ReturnType<typeof requestEmailVerification>>,
  TError,
  void,
  TContext
> => {
  const mutationOptions = getRequestEmailVerificationMutationOptions(options)

  return useMutation(mutationOptions, queryClient)
}
