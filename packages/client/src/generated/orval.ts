/**
 * Generated by orval v7.10.0 🍺
 * Do not edit manually.
 * Arches AI API
 * The Arches AI API
 * OpenAPI spec version: v1
 */
import type {
  DataTag,
  DefinedInitialDataOptions,
  DefinedUseQueryResult,
  MutationFunction,
  QueryClient,
  QueryFunction,
  QueryKey,
  UndefinedInitialDataOptions,
  UseMutationOptions,
  UseMutationResult,
  UseQueryOptions,
  UseQueryResult
} from '@tanstack/react-query'

import { useMutation, useQuery } from '@tanstack/react-query'

import type {
  AcceptInvitation200,
  ConfirmEmailChangeBody,
  ConfirmEmailVerificationBody,
  ConfirmPasswordResetBody,
  CreateApiToken201,
  CreateApiTokenBody,
  CreateArtifact201,
  CreateArtifactBody,
  CreateCheckoutSession200,
  CreateCheckoutSessionBody,
  CreateFile201,
  CreateFileBody,
  CreateInvitation201,
  CreateInvitationBody,
  CreateLabel201,
  CreateLabelBody,
  CreateMember201,
  CreateMemberBody,
  CreateOrganization201,
  CreateOrganizationBody,
  CreatePipeline201,
  CreatePipelineBody,
  CreatePortalBody,
  CreateRun201,
  CreateRunBody,
  CreateTool201,
  CreateToolBody,
  CreateUser201,
  CreateUserBody,
  DeleteApiToken200,
  DeleteArtifact200,
  DeleteFile200,
  DeleteInvitation200,
  DeleteLabel200,
  DeleteMember200,
  DeleteOrganization200,
  DeletePaymentMethod200,
  DeletePipeline200,
  DeleteRun200,
  DeleteTool200,
  DeleteUser200,
  FindManyApiTokens200,
  FindManyApiTokensParams,
  FindManyArtifacts200,
  FindManyArtifactsParams,
  FindManyFiles200,
  FindManyFilesParams,
  FindManyInvitations200,
  FindManyInvitationsParams,
  FindManyLabels200,
  FindManyLabelsParams,
  FindManyMembers200,
  FindManyMembersParams,
  FindManyOrganizations200,
  FindManyOrganizationsParams,
  FindManyPipelines200,
  FindManyPipelinesParams,
  FindManyRuns200,
  FindManyRunsParams,
  FindManyTools200,
  FindManyToolsParams,
  FindManyUsers200,
  FindManyUsersParams,
  FindOnePaymentMethod200,
  ForbiddenResponse,
  GetConfig200,
  GetOneApiToken200,
  GetOneArtifact200,
  GetOneFile200,
  GetOneInvitation200,
  GetOneLabel200,
  GetOneMember200,
  GetOneOrganization200,
  GetOnePipeline200,
  GetOneRun200,
  GetOneTool200,
  GetOneUser200,
  GetPlans200,
  GetSession200,
  LoginBody,
  NoContentResponse,
  NotFoundResponse,
  RegisterBody,
  RequestEmailChangeBody,
  RequestPasswordResetBody,
  UnauthorizedResponse,
  UpdateApiToken200,
  UpdateApiTokenBody,
  UpdateArtifact200,
  UpdateArtifactBody,
  UpdateFile200,
  UpdateFileBody,
  UpdateInvitation200,
  UpdateInvitationBody,
  UpdateLabel200,
  UpdateLabelBody,
  UpdateMember200,
  UpdateMemberBody,
  UpdateOrganization200,
  UpdateOrganizationBody,
  UpdatePipeline200,
  UpdatePipelineBody,
  UpdateRun200,
  UpdateRunBody,
  UpdateSubscriptionBody,
  UpdateTool200,
  UpdateToolBody,
  UpdateUser200,
  UpdateUserBody
} from '#generated/orval.schemas'

/**
 * Get the configuration of the application
 * @summary Get the configuration
 */
export const getGetConfigUrl = () => {
  return `https://localhost:3001/config`
}

export const getConfig = async (
  options?: RequestInit
): Promise<GetConfig200> => {
  const res = await fetch(getGetConfigUrl(), {
    ...options,
    method: 'GET'
  })

  const body = [204, 205, 304].includes(res.status) ? null : await res.text()
  const data: GetConfig200 = body ? JSON.parse(body) : {}

  return data
}

export const getGetConfigQueryKey = () => {
  return [`https://localhost:3001/config`] as const
}

export const getGetConfigQueryOptions = <
  TData = Awaited<ReturnType<typeof getConfig>>,
  TError = unknown
>(options?: {
  query?: Partial<
    UseQueryOptions<Awaited<ReturnType<typeof getConfig>>, TError, TData>
  >
  fetch?: RequestInit
}) => {
  const { query: queryOptions, fetch: fetchOptions } = options ?? {}

  const queryKey = queryOptions?.queryKey ?? getGetConfigQueryKey()

  const queryFn: QueryFunction<Awaited<ReturnType<typeof getConfig>>> = ({
    signal
  }) => getConfig({ ...(signal ? { signal } : {}), ...fetchOptions })

  return { queryKey, queryFn, ...queryOptions } as UseQueryOptions<
    Awaited<ReturnType<typeof getConfig>>,
    TError,
    TData
  > & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type GetConfigQueryResult = NonNullable<
  Awaited<ReturnType<typeof getConfig>>
>
export type GetConfigQueryError = unknown

export function useGetConfig<
  TData = Awaited<ReturnType<typeof getConfig>>,
  TError = unknown
>(
  options: {
    query: Partial<
      UseQueryOptions<Awaited<ReturnType<typeof getConfig>>, TError, TData>
    > &
      Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof getConfig>>,
          TError,
          Awaited<ReturnType<typeof getConfig>>
        >,
        'initialData'
      >
    fetch?: RequestInit
  },
  queryClient?: QueryClient
): DefinedUseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>
}
export function useGetConfig<
  TData = Awaited<ReturnType<typeof getConfig>>,
  TError = unknown
>(
  options?: {
    query?: Partial<
      UseQueryOptions<Awaited<ReturnType<typeof getConfig>>, TError, TData>
    > &
      Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof getConfig>>,
          TError,
          Awaited<ReturnType<typeof getConfig>>
        >,
        'initialData'
      >
    fetch?: RequestInit
  },
  queryClient?: QueryClient
): UseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>
}
export function useGetConfig<
  TData = Awaited<ReturnType<typeof getConfig>>,
  TError = unknown
>(
  options?: {
    query?: Partial<
      UseQueryOptions<Awaited<ReturnType<typeof getConfig>>, TError, TData>
    >
    fetch?: RequestInit
  },
  queryClient?: QueryClient
): UseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>
}
/**
 * @summary Get the configuration
 */

export function useGetConfig<
  TData = Awaited<ReturnType<typeof getConfig>>,
  TError = unknown
>(
  options?: {
    query?: Partial<
      UseQueryOptions<Awaited<ReturnType<typeof getConfig>>, TError, TData>
    >
    fetch?: RequestInit
  },
  queryClient?: QueryClient
): UseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>
} {
  const queryOptions = getGetConfigQueryOptions(options)

  const query = useQuery(queryOptions, queryClient) as UseQueryResult<
    TData,
    TError
  > & { queryKey: DataTag<QueryKey, TData, TError> }

  query.queryKey = queryOptions.queryKey

  return query
}

/**
 * Create a new file
 * @summary Create a new file
 */
export const getCreateFileUrl = () => {
  return `https://localhost:3001/files`
}

export const createFile = async (
  createFileBody: CreateFileBody,
  options?: RequestInit
): Promise<CreateFile201> => {
  const res = await fetch(getCreateFileUrl(), {
    ...options,
    method: 'POST',
    headers: { 'Content-Type': 'application/json', ...options?.headers },
    body: JSON.stringify(createFileBody)
  })

  const body = [204, 205, 304].includes(res.status) ? null : await res.text()
  const data: CreateFile201 = body ? JSON.parse(body) : {}

  return data
}

export const getCreateFileMutationOptions = <
  TError = unknown,
  TContext = unknown
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof createFile>>,
    TError,
    { data: CreateFileBody },
    TContext
  >
  fetch?: RequestInit
}): UseMutationOptions<
  Awaited<ReturnType<typeof createFile>>,
  TError,
  { data: CreateFileBody },
  TContext
> => {
  const mutationKey = ['createFile']
  const { mutation: mutationOptions, fetch: fetchOptions } =
    options ?
      (
        options.mutation &&
        'mutationKey' in options.mutation &&
        options.mutation.mutationKey
      ) ?
        options
      : { ...options, mutation: { ...options.mutation, mutationKey } }
    : { mutation: { mutationKey }, fetch: undefined }

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof createFile>>,
    { data: CreateFileBody }
  > = (props) => {
    const { data } = props ?? {}

    return createFile(data, fetchOptions)
  }

  return { mutationFn, ...mutationOptions }
}

export type CreateFileMutationResult = NonNullable<
  Awaited<ReturnType<typeof createFile>>
>
export type CreateFileMutationBody = CreateFileBody
export type CreateFileMutationError = unknown

/**
 * @summary Create a new file
 */
export const useCreateFile = <TError = unknown, TContext = unknown>(
  options?: {
    mutation?: UseMutationOptions<
      Awaited<ReturnType<typeof createFile>>,
      TError,
      { data: CreateFileBody },
      TContext
    >
    fetch?: RequestInit
  },
  queryClient?: QueryClient
): UseMutationResult<
  Awaited<ReturnType<typeof createFile>>,
  TError,
  { data: CreateFileBody },
  TContext
> => {
  const mutationOptions = getCreateFileMutationOptions(options)

  return useMutation(mutationOptions, queryClient)
}

/**
 * Find many files
 * @summary Find many files
 */
export const getFindManyFilesUrl = (params?: FindManyFilesParams) => {
  const normalizedParams = new URLSearchParams()

  Object.entries(params || {}).forEach(([key, value]) => {
    if (value !== undefined) {
      normalizedParams.append(key, value === null ? 'null' : value.toString())
    }
  })

  const stringifiedParams = normalizedParams.toString()

  return stringifiedParams.length > 0 ?
      `https://localhost:3001/files?${stringifiedParams}`
    : `https://localhost:3001/files`
}

export const findManyFiles = async (
  params?: FindManyFilesParams,
  options?: RequestInit
): Promise<FindManyFiles200> => {
  const res = await fetch(getFindManyFilesUrl(params), {
    ...options,
    method: 'GET'
  })

  const body = [204, 205, 304].includes(res.status) ? null : await res.text()
  const data: FindManyFiles200 = body ? JSON.parse(body) : {}

  return data
}

export const getFindManyFilesQueryKey = (params?: FindManyFilesParams) => {
  return [`https://localhost:3001/files`, ...(params ? [params] : [])] as const
}

export const getFindManyFilesQueryOptions = <
  TData = Awaited<ReturnType<typeof findManyFiles>>,
  TError = unknown
>(
  params?: FindManyFilesParams,
  options?: {
    query?: Partial<
      UseQueryOptions<Awaited<ReturnType<typeof findManyFiles>>, TError, TData>
    >
    fetch?: RequestInit
  }
) => {
  const { query: queryOptions, fetch: fetchOptions } = options ?? {}

  const queryKey = queryOptions?.queryKey ?? getFindManyFilesQueryKey(params)

  const queryFn: QueryFunction<Awaited<ReturnType<typeof findManyFiles>>> = ({
    signal
  }) =>
    findManyFiles(params, { ...(signal ? { signal } : {}), ...fetchOptions })

  return { queryKey, queryFn, ...queryOptions } as UseQueryOptions<
    Awaited<ReturnType<typeof findManyFiles>>,
    TError,
    TData
  > & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type FindManyFilesQueryResult = NonNullable<
  Awaited<ReturnType<typeof findManyFiles>>
>
export type FindManyFilesQueryError = unknown

export function useFindManyFiles<
  TData = Awaited<ReturnType<typeof findManyFiles>>,
  TError = unknown
>(
  params: undefined | FindManyFilesParams,
  options: {
    query: Partial<
      UseQueryOptions<Awaited<ReturnType<typeof findManyFiles>>, TError, TData>
    > &
      Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof findManyFiles>>,
          TError,
          Awaited<ReturnType<typeof findManyFiles>>
        >,
        'initialData'
      >
    fetch?: RequestInit
  },
  queryClient?: QueryClient
): DefinedUseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>
}
export function useFindManyFiles<
  TData = Awaited<ReturnType<typeof findManyFiles>>,
  TError = unknown
>(
  params?: FindManyFilesParams,
  options?: {
    query?: Partial<
      UseQueryOptions<Awaited<ReturnType<typeof findManyFiles>>, TError, TData>
    > &
      Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof findManyFiles>>,
          TError,
          Awaited<ReturnType<typeof findManyFiles>>
        >,
        'initialData'
      >
    fetch?: RequestInit
  },
  queryClient?: QueryClient
): UseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>
}
export function useFindManyFiles<
  TData = Awaited<ReturnType<typeof findManyFiles>>,
  TError = unknown
>(
  params?: FindManyFilesParams,
  options?: {
    query?: Partial<
      UseQueryOptions<Awaited<ReturnType<typeof findManyFiles>>, TError, TData>
    >
    fetch?: RequestInit
  },
  queryClient?: QueryClient
): UseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>
}
/**
 * @summary Find many files
 */

export function useFindManyFiles<
  TData = Awaited<ReturnType<typeof findManyFiles>>,
  TError = unknown
>(
  params?: FindManyFilesParams,
  options?: {
    query?: Partial<
      UseQueryOptions<Awaited<ReturnType<typeof findManyFiles>>, TError, TData>
    >
    fetch?: RequestInit
  },
  queryClient?: QueryClient
): UseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>
} {
  const queryOptions = getFindManyFilesQueryOptions(params, options)

  const query = useQuery(queryOptions, queryClient) as UseQueryResult<
    TData,
    TError
  > & { queryKey: DataTag<QueryKey, TData, TError> }

  query.queryKey = queryOptions.queryKey

  return query
}

/**
 * Delete a file
 * @summary Delete a file
 */
export const getDeleteFileUrl = (id: string) => {
  return `https://localhost:3001/files/${id}`
}

export const deleteFile = async (
  id: string,
  options?: RequestInit
): Promise<DeleteFile200> => {
  const res = await fetch(getDeleteFileUrl(id), {
    ...options,
    method: 'DELETE'
  })

  const body = [204, 205, 304].includes(res.status) ? null : await res.text()
  const data: DeleteFile200 = body ? JSON.parse(body) : {}

  return data
}

export const getDeleteFileMutationOptions = <
  TError = NotFoundResponse,
  TContext = unknown
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof deleteFile>>,
    TError,
    { id: string },
    TContext
  >
  fetch?: RequestInit
}): UseMutationOptions<
  Awaited<ReturnType<typeof deleteFile>>,
  TError,
  { id: string },
  TContext
> => {
  const mutationKey = ['deleteFile']
  const { mutation: mutationOptions, fetch: fetchOptions } =
    options ?
      (
        options.mutation &&
        'mutationKey' in options.mutation &&
        options.mutation.mutationKey
      ) ?
        options
      : { ...options, mutation: { ...options.mutation, mutationKey } }
    : { mutation: { mutationKey }, fetch: undefined }

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof deleteFile>>,
    { id: string }
  > = (props) => {
    const { id } = props ?? {}

    return deleteFile(id, fetchOptions)
  }

  return { mutationFn, ...mutationOptions }
}

export type DeleteFileMutationResult = NonNullable<
  Awaited<ReturnType<typeof deleteFile>>
>

export type DeleteFileMutationError = NotFoundResponse

/**
 * @summary Delete a file
 */
export const useDeleteFile = <TError = NotFoundResponse, TContext = unknown>(
  options?: {
    mutation?: UseMutationOptions<
      Awaited<ReturnType<typeof deleteFile>>,
      TError,
      { id: string },
      TContext
    >
    fetch?: RequestInit
  },
  queryClient?: QueryClient
): UseMutationResult<
  Awaited<ReturnType<typeof deleteFile>>,
  TError,
  { id: string },
  TContext
> => {
  const mutationOptions = getDeleteFileMutationOptions(options)

  return useMutation(mutationOptions, queryClient)
}

/**
 * Find a file
 * @summary Find a file
 */
export const getGetOneFileUrl = (id: string) => {
  return `https://localhost:3001/files/${id}`
}

export const getOneFile = async (
  id: string,
  options?: RequestInit
): Promise<GetOneFile200> => {
  const res = await fetch(getGetOneFileUrl(id), {
    ...options,
    method: 'GET'
  })

  const body = [204, 205, 304].includes(res.status) ? null : await res.text()
  const data: GetOneFile200 = body ? JSON.parse(body) : {}

  return data
}

export const getGetOneFileQueryKey = (id: string) => {
  return [`https://localhost:3001/files/${id}`] as const
}

export const getGetOneFileQueryOptions = <
  TData = Awaited<ReturnType<typeof getOneFile>>,
  TError = NotFoundResponse
>(
  id: string,
  options?: {
    query?: Partial<
      UseQueryOptions<Awaited<ReturnType<typeof getOneFile>>, TError, TData>
    >
    fetch?: RequestInit
  }
) => {
  const { query: queryOptions, fetch: fetchOptions } = options ?? {}

  const queryKey = queryOptions?.queryKey ?? getGetOneFileQueryKey(id)

  const queryFn: QueryFunction<Awaited<ReturnType<typeof getOneFile>>> = ({
    signal
  }) => getOneFile(id, { ...(signal ? { signal } : {}), ...fetchOptions })

  return {
    queryKey,
    queryFn,
    enabled: !!id,
    ...queryOptions
  } as UseQueryOptions<
    Awaited<ReturnType<typeof getOneFile>>,
    TError,
    TData
  > & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type GetOneFileQueryResult = NonNullable<
  Awaited<ReturnType<typeof getOneFile>>
>
export type GetOneFileQueryError = NotFoundResponse

export function useGetOneFile<
  TData = Awaited<ReturnType<typeof getOneFile>>,
  TError = NotFoundResponse
>(
  id: string,
  options: {
    query: Partial<
      UseQueryOptions<Awaited<ReturnType<typeof getOneFile>>, TError, TData>
    > &
      Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof getOneFile>>,
          TError,
          Awaited<ReturnType<typeof getOneFile>>
        >,
        'initialData'
      >
    fetch?: RequestInit
  },
  queryClient?: QueryClient
): DefinedUseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>
}
export function useGetOneFile<
  TData = Awaited<ReturnType<typeof getOneFile>>,
  TError = NotFoundResponse
>(
  id: string,
  options?: {
    query?: Partial<
      UseQueryOptions<Awaited<ReturnType<typeof getOneFile>>, TError, TData>
    > &
      Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof getOneFile>>,
          TError,
          Awaited<ReturnType<typeof getOneFile>>
        >,
        'initialData'
      >
    fetch?: RequestInit
  },
  queryClient?: QueryClient
): UseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>
}
export function useGetOneFile<
  TData = Awaited<ReturnType<typeof getOneFile>>,
  TError = NotFoundResponse
>(
  id: string,
  options?: {
    query?: Partial<
      UseQueryOptions<Awaited<ReturnType<typeof getOneFile>>, TError, TData>
    >
    fetch?: RequestInit
  },
  queryClient?: QueryClient
): UseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>
}
/**
 * @summary Find a file
 */

export function useGetOneFile<
  TData = Awaited<ReturnType<typeof getOneFile>>,
  TError = NotFoundResponse
>(
  id: string,
  options?: {
    query?: Partial<
      UseQueryOptions<Awaited<ReturnType<typeof getOneFile>>, TError, TData>
    >
    fetch?: RequestInit
  },
  queryClient?: QueryClient
): UseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>
} {
  const queryOptions = getGetOneFileQueryOptions(id, options)

  const query = useQuery(queryOptions, queryClient) as UseQueryResult<
    TData,
    TError
  > & { queryKey: DataTag<QueryKey, TData, TError> }

  query.queryKey = queryOptions.queryKey

  return query
}

/**
 * Update a file
 * @summary Update a file
 */
export const getUpdateFileUrl = (id: string) => {
  return `https://localhost:3001/files/${id}`
}

export const updateFile = async (
  id: string,
  updateFileBody: UpdateFileBody,
  options?: RequestInit
): Promise<UpdateFile200> => {
  const res = await fetch(getUpdateFileUrl(id), {
    ...options,
    method: 'PATCH',
    headers: { 'Content-Type': 'application/json', ...options?.headers },
    body: JSON.stringify(updateFileBody)
  })

  const body = [204, 205, 304].includes(res.status) ? null : await res.text()
  const data: UpdateFile200 = body ? JSON.parse(body) : {}

  return data
}

export const getUpdateFileMutationOptions = <
  TError = NotFoundResponse,
  TContext = unknown
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof updateFile>>,
    TError,
    { id: string; data: UpdateFileBody },
    TContext
  >
  fetch?: RequestInit
}): UseMutationOptions<
  Awaited<ReturnType<typeof updateFile>>,
  TError,
  { id: string; data: UpdateFileBody },
  TContext
> => {
  const mutationKey = ['updateFile']
  const { mutation: mutationOptions, fetch: fetchOptions } =
    options ?
      (
        options.mutation &&
        'mutationKey' in options.mutation &&
        options.mutation.mutationKey
      ) ?
        options
      : { ...options, mutation: { ...options.mutation, mutationKey } }
    : { mutation: { mutationKey }, fetch: undefined }

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof updateFile>>,
    { id: string; data: UpdateFileBody }
  > = (props) => {
    const { id, data } = props ?? {}

    return updateFile(id, data, fetchOptions)
  }

  return { mutationFn, ...mutationOptions }
}

export type UpdateFileMutationResult = NonNullable<
  Awaited<ReturnType<typeof updateFile>>
>
export type UpdateFileMutationBody = UpdateFileBody
export type UpdateFileMutationError = NotFoundResponse

/**
 * @summary Update a file
 */
export const useUpdateFile = <TError = NotFoundResponse, TContext = unknown>(
  options?: {
    mutation?: UseMutationOptions<
      Awaited<ReturnType<typeof updateFile>>,
      TError,
      { id: string; data: UpdateFileBody },
      TContext
    >
    fetch?: RequestInit
  },
  queryClient?: QueryClient
): UseMutationResult<
  Awaited<ReturnType<typeof updateFile>>,
  TError,
  { id: string; data: UpdateFileBody },
  TContext
> => {
  const mutationOptions = getUpdateFileMutationOptions(options)

  return useMutation(mutationOptions, queryClient)
}

/**
 * Create a new pipeline
 * @summary Create a new pipeline
 */
export const getCreatePipelineUrl = () => {
  return `https://localhost:3001/pipelines`
}

export const createPipeline = async (
  createPipelineBody: CreatePipelineBody,
  options?: RequestInit
): Promise<CreatePipeline201> => {
  const res = await fetch(getCreatePipelineUrl(), {
    ...options,
    method: 'POST',
    headers: { 'Content-Type': 'application/json', ...options?.headers },
    body: JSON.stringify(createPipelineBody)
  })

  const body = [204, 205, 304].includes(res.status) ? null : await res.text()
  const data: CreatePipeline201 = body ? JSON.parse(body) : {}

  return data
}

export const getCreatePipelineMutationOptions = <
  TError = unknown,
  TContext = unknown
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof createPipeline>>,
    TError,
    { data: CreatePipelineBody },
    TContext
  >
  fetch?: RequestInit
}): UseMutationOptions<
  Awaited<ReturnType<typeof createPipeline>>,
  TError,
  { data: CreatePipelineBody },
  TContext
> => {
  const mutationKey = ['createPipeline']
  const { mutation: mutationOptions, fetch: fetchOptions } =
    options ?
      (
        options.mutation &&
        'mutationKey' in options.mutation &&
        options.mutation.mutationKey
      ) ?
        options
      : { ...options, mutation: { ...options.mutation, mutationKey } }
    : { mutation: { mutationKey }, fetch: undefined }

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof createPipeline>>,
    { data: CreatePipelineBody }
  > = (props) => {
    const { data } = props ?? {}

    return createPipeline(data, fetchOptions)
  }

  return { mutationFn, ...mutationOptions }
}

export type CreatePipelineMutationResult = NonNullable<
  Awaited<ReturnType<typeof createPipeline>>
>
export type CreatePipelineMutationBody = CreatePipelineBody
export type CreatePipelineMutationError = unknown

/**
 * @summary Create a new pipeline
 */
export const useCreatePipeline = <TError = unknown, TContext = unknown>(
  options?: {
    mutation?: UseMutationOptions<
      Awaited<ReturnType<typeof createPipeline>>,
      TError,
      { data: CreatePipelineBody },
      TContext
    >
    fetch?: RequestInit
  },
  queryClient?: QueryClient
): UseMutationResult<
  Awaited<ReturnType<typeof createPipeline>>,
  TError,
  { data: CreatePipelineBody },
  TContext
> => {
  const mutationOptions = getCreatePipelineMutationOptions(options)

  return useMutation(mutationOptions, queryClient)
}

/**
 * Find many pipelines
 * @summary Find many pipelines
 */
export const getFindManyPipelinesUrl = (params?: FindManyPipelinesParams) => {
  const normalizedParams = new URLSearchParams()

  Object.entries(params || {}).forEach(([key, value]) => {
    if (value !== undefined) {
      normalizedParams.append(key, value === null ? 'null' : value.toString())
    }
  })

  const stringifiedParams = normalizedParams.toString()

  return stringifiedParams.length > 0 ?
      `https://localhost:3001/pipelines?${stringifiedParams}`
    : `https://localhost:3001/pipelines`
}

export const findManyPipelines = async (
  params?: FindManyPipelinesParams,
  options?: RequestInit
): Promise<FindManyPipelines200> => {
  const res = await fetch(getFindManyPipelinesUrl(params), {
    ...options,
    method: 'GET'
  })

  const body = [204, 205, 304].includes(res.status) ? null : await res.text()
  const data: FindManyPipelines200 = body ? JSON.parse(body) : {}

  return data
}

export const getFindManyPipelinesQueryKey = (
  params?: FindManyPipelinesParams
) => {
  return [
    `https://localhost:3001/pipelines`,
    ...(params ? [params] : [])
  ] as const
}

export const getFindManyPipelinesQueryOptions = <
  TData = Awaited<ReturnType<typeof findManyPipelines>>,
  TError = unknown
>(
  params?: FindManyPipelinesParams,
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof findManyPipelines>>,
        TError,
        TData
      >
    >
    fetch?: RequestInit
  }
) => {
  const { query: queryOptions, fetch: fetchOptions } = options ?? {}

  const queryKey =
    queryOptions?.queryKey ?? getFindManyPipelinesQueryKey(params)

  const queryFn: QueryFunction<
    Awaited<ReturnType<typeof findManyPipelines>>
  > = ({ signal }) =>
    findManyPipelines(params, {
      ...(signal ? { signal } : {}),
      ...fetchOptions
    })

  return { queryKey, queryFn, ...queryOptions } as UseQueryOptions<
    Awaited<ReturnType<typeof findManyPipelines>>,
    TError,
    TData
  > & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type FindManyPipelinesQueryResult = NonNullable<
  Awaited<ReturnType<typeof findManyPipelines>>
>
export type FindManyPipelinesQueryError = unknown

export function useFindManyPipelines<
  TData = Awaited<ReturnType<typeof findManyPipelines>>,
  TError = unknown
>(
  params: undefined | FindManyPipelinesParams,
  options: {
    query: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof findManyPipelines>>,
        TError,
        TData
      >
    > &
      Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof findManyPipelines>>,
          TError,
          Awaited<ReturnType<typeof findManyPipelines>>
        >,
        'initialData'
      >
    fetch?: RequestInit
  },
  queryClient?: QueryClient
): DefinedUseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>
}
export function useFindManyPipelines<
  TData = Awaited<ReturnType<typeof findManyPipelines>>,
  TError = unknown
>(
  params?: FindManyPipelinesParams,
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof findManyPipelines>>,
        TError,
        TData
      >
    > &
      Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof findManyPipelines>>,
          TError,
          Awaited<ReturnType<typeof findManyPipelines>>
        >,
        'initialData'
      >
    fetch?: RequestInit
  },
  queryClient?: QueryClient
): UseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>
}
export function useFindManyPipelines<
  TData = Awaited<ReturnType<typeof findManyPipelines>>,
  TError = unknown
>(
  params?: FindManyPipelinesParams,
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof findManyPipelines>>,
        TError,
        TData
      >
    >
    fetch?: RequestInit
  },
  queryClient?: QueryClient
): UseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>
}
/**
 * @summary Find many pipelines
 */

export function useFindManyPipelines<
  TData = Awaited<ReturnType<typeof findManyPipelines>>,
  TError = unknown
>(
  params?: FindManyPipelinesParams,
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof findManyPipelines>>,
        TError,
        TData
      >
    >
    fetch?: RequestInit
  },
  queryClient?: QueryClient
): UseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>
} {
  const queryOptions = getFindManyPipelinesQueryOptions(params, options)

  const query = useQuery(queryOptions, queryClient) as UseQueryResult<
    TData,
    TError
  > & { queryKey: DataTag<QueryKey, TData, TError> }

  query.queryKey = queryOptions.queryKey

  return query
}

/**
 * Delete a pipeline
 * @summary Delete a pipeline
 */
export const getDeletePipelineUrl = (id: string) => {
  return `https://localhost:3001/pipelines/${id}`
}

export const deletePipeline = async (
  id: string,
  options?: RequestInit
): Promise<DeletePipeline200> => {
  const res = await fetch(getDeletePipelineUrl(id), {
    ...options,
    method: 'DELETE'
  })

  const body = [204, 205, 304].includes(res.status) ? null : await res.text()
  const data: DeletePipeline200 = body ? JSON.parse(body) : {}

  return data
}

export const getDeletePipelineMutationOptions = <
  TError = NotFoundResponse,
  TContext = unknown
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof deletePipeline>>,
    TError,
    { id: string },
    TContext
  >
  fetch?: RequestInit
}): UseMutationOptions<
  Awaited<ReturnType<typeof deletePipeline>>,
  TError,
  { id: string },
  TContext
> => {
  const mutationKey = ['deletePipeline']
  const { mutation: mutationOptions, fetch: fetchOptions } =
    options ?
      (
        options.mutation &&
        'mutationKey' in options.mutation &&
        options.mutation.mutationKey
      ) ?
        options
      : { ...options, mutation: { ...options.mutation, mutationKey } }
    : { mutation: { mutationKey }, fetch: undefined }

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof deletePipeline>>,
    { id: string }
  > = (props) => {
    const { id } = props ?? {}

    return deletePipeline(id, fetchOptions)
  }

  return { mutationFn, ...mutationOptions }
}

export type DeletePipelineMutationResult = NonNullable<
  Awaited<ReturnType<typeof deletePipeline>>
>

export type DeletePipelineMutationError = NotFoundResponse

/**
 * @summary Delete a pipeline
 */
export const useDeletePipeline = <
  TError = NotFoundResponse,
  TContext = unknown
>(
  options?: {
    mutation?: UseMutationOptions<
      Awaited<ReturnType<typeof deletePipeline>>,
      TError,
      { id: string },
      TContext
    >
    fetch?: RequestInit
  },
  queryClient?: QueryClient
): UseMutationResult<
  Awaited<ReturnType<typeof deletePipeline>>,
  TError,
  { id: string },
  TContext
> => {
  const mutationOptions = getDeletePipelineMutationOptions(options)

  return useMutation(mutationOptions, queryClient)
}

/**
 * Find a pipeline
 * @summary Find a pipeline
 */
export const getGetOnePipelineUrl = (id: string) => {
  return `https://localhost:3001/pipelines/${id}`
}

export const getOnePipeline = async (
  id: string,
  options?: RequestInit
): Promise<GetOnePipeline200> => {
  const res = await fetch(getGetOnePipelineUrl(id), {
    ...options,
    method: 'GET'
  })

  const body = [204, 205, 304].includes(res.status) ? null : await res.text()
  const data: GetOnePipeline200 = body ? JSON.parse(body) : {}

  return data
}

export const getGetOnePipelineQueryKey = (id: string) => {
  return [`https://localhost:3001/pipelines/${id}`] as const
}

export const getGetOnePipelineQueryOptions = <
  TData = Awaited<ReturnType<typeof getOnePipeline>>,
  TError = NotFoundResponse
>(
  id: string,
  options?: {
    query?: Partial<
      UseQueryOptions<Awaited<ReturnType<typeof getOnePipeline>>, TError, TData>
    >
    fetch?: RequestInit
  }
) => {
  const { query: queryOptions, fetch: fetchOptions } = options ?? {}

  const queryKey = queryOptions?.queryKey ?? getGetOnePipelineQueryKey(id)

  const queryFn: QueryFunction<Awaited<ReturnType<typeof getOnePipeline>>> = ({
    signal
  }) => getOnePipeline(id, { ...(signal ? { signal } : {}), ...fetchOptions })

  return {
    queryKey,
    queryFn,
    enabled: !!id,
    ...queryOptions
  } as UseQueryOptions<
    Awaited<ReturnType<typeof getOnePipeline>>,
    TError,
    TData
  > & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type GetOnePipelineQueryResult = NonNullable<
  Awaited<ReturnType<typeof getOnePipeline>>
>
export type GetOnePipelineQueryError = NotFoundResponse

export function useGetOnePipeline<
  TData = Awaited<ReturnType<typeof getOnePipeline>>,
  TError = NotFoundResponse
>(
  id: string,
  options: {
    query: Partial<
      UseQueryOptions<Awaited<ReturnType<typeof getOnePipeline>>, TError, TData>
    > &
      Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof getOnePipeline>>,
          TError,
          Awaited<ReturnType<typeof getOnePipeline>>
        >,
        'initialData'
      >
    fetch?: RequestInit
  },
  queryClient?: QueryClient
): DefinedUseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>
}
export function useGetOnePipeline<
  TData = Awaited<ReturnType<typeof getOnePipeline>>,
  TError = NotFoundResponse
>(
  id: string,
  options?: {
    query?: Partial<
      UseQueryOptions<Awaited<ReturnType<typeof getOnePipeline>>, TError, TData>
    > &
      Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof getOnePipeline>>,
          TError,
          Awaited<ReturnType<typeof getOnePipeline>>
        >,
        'initialData'
      >
    fetch?: RequestInit
  },
  queryClient?: QueryClient
): UseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>
}
export function useGetOnePipeline<
  TData = Awaited<ReturnType<typeof getOnePipeline>>,
  TError = NotFoundResponse
>(
  id: string,
  options?: {
    query?: Partial<
      UseQueryOptions<Awaited<ReturnType<typeof getOnePipeline>>, TError, TData>
    >
    fetch?: RequestInit
  },
  queryClient?: QueryClient
): UseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>
}
/**
 * @summary Find a pipeline
 */

export function useGetOnePipeline<
  TData = Awaited<ReturnType<typeof getOnePipeline>>,
  TError = NotFoundResponse
>(
  id: string,
  options?: {
    query?: Partial<
      UseQueryOptions<Awaited<ReturnType<typeof getOnePipeline>>, TError, TData>
    >
    fetch?: RequestInit
  },
  queryClient?: QueryClient
): UseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>
} {
  const queryOptions = getGetOnePipelineQueryOptions(id, options)

  const query = useQuery(queryOptions, queryClient) as UseQueryResult<
    TData,
    TError
  > & { queryKey: DataTag<QueryKey, TData, TError> }

  query.queryKey = queryOptions.queryKey

  return query
}

/**
 * Update a pipeline
 * @summary Update a pipeline
 */
export const getUpdatePipelineUrl = (id: string) => {
  return `https://localhost:3001/pipelines/${id}`
}

export const updatePipeline = async (
  id: string,
  updatePipelineBody: UpdatePipelineBody,
  options?: RequestInit
): Promise<UpdatePipeline200> => {
  const res = await fetch(getUpdatePipelineUrl(id), {
    ...options,
    method: 'PATCH',
    headers: { 'Content-Type': 'application/json', ...options?.headers },
    body: JSON.stringify(updatePipelineBody)
  })

  const body = [204, 205, 304].includes(res.status) ? null : await res.text()
  const data: UpdatePipeline200 = body ? JSON.parse(body) : {}

  return data
}

export const getUpdatePipelineMutationOptions = <
  TError = NotFoundResponse,
  TContext = unknown
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof updatePipeline>>,
    TError,
    { id: string; data: UpdatePipelineBody },
    TContext
  >
  fetch?: RequestInit
}): UseMutationOptions<
  Awaited<ReturnType<typeof updatePipeline>>,
  TError,
  { id: string; data: UpdatePipelineBody },
  TContext
> => {
  const mutationKey = ['updatePipeline']
  const { mutation: mutationOptions, fetch: fetchOptions } =
    options ?
      (
        options.mutation &&
        'mutationKey' in options.mutation &&
        options.mutation.mutationKey
      ) ?
        options
      : { ...options, mutation: { ...options.mutation, mutationKey } }
    : { mutation: { mutationKey }, fetch: undefined }

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof updatePipeline>>,
    { id: string; data: UpdatePipelineBody }
  > = (props) => {
    const { id, data } = props ?? {}

    return updatePipeline(id, data, fetchOptions)
  }

  return { mutationFn, ...mutationOptions }
}

export type UpdatePipelineMutationResult = NonNullable<
  Awaited<ReturnType<typeof updatePipeline>>
>
export type UpdatePipelineMutationBody = UpdatePipelineBody
export type UpdatePipelineMutationError = NotFoundResponse

/**
 * @summary Update a pipeline
 */
export const useUpdatePipeline = <
  TError = NotFoundResponse,
  TContext = unknown
>(
  options?: {
    mutation?: UseMutationOptions<
      Awaited<ReturnType<typeof updatePipeline>>,
      TError,
      { id: string; data: UpdatePipelineBody },
      TContext
    >
    fetch?: RequestInit
  },
  queryClient?: QueryClient
): UseMutationResult<
  Awaited<ReturnType<typeof updatePipeline>>,
  TError,
  { id: string; data: UpdatePipelineBody },
  TContext
> => {
  const mutationOptions = getUpdatePipelineMutationOptions(options)

  return useMutation(mutationOptions, queryClient)
}

/**
 * Create a new tool
 * @summary Create a new tool
 */
export const getCreateToolUrl = () => {
  return `https://localhost:3001/tools`
}

export const createTool = async (
  createToolBody: CreateToolBody,
  options?: RequestInit
): Promise<CreateTool201> => {
  const res = await fetch(getCreateToolUrl(), {
    ...options,
    method: 'POST',
    headers: { 'Content-Type': 'application/json', ...options?.headers },
    body: JSON.stringify(createToolBody)
  })

  const body = [204, 205, 304].includes(res.status) ? null : await res.text()
  const data: CreateTool201 = body ? JSON.parse(body) : {}

  return data
}

export const getCreateToolMutationOptions = <
  TError = unknown,
  TContext = unknown
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof createTool>>,
    TError,
    { data: CreateToolBody },
    TContext
  >
  fetch?: RequestInit
}): UseMutationOptions<
  Awaited<ReturnType<typeof createTool>>,
  TError,
  { data: CreateToolBody },
  TContext
> => {
  const mutationKey = ['createTool']
  const { mutation: mutationOptions, fetch: fetchOptions } =
    options ?
      (
        options.mutation &&
        'mutationKey' in options.mutation &&
        options.mutation.mutationKey
      ) ?
        options
      : { ...options, mutation: { ...options.mutation, mutationKey } }
    : { mutation: { mutationKey }, fetch: undefined }

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof createTool>>,
    { data: CreateToolBody }
  > = (props) => {
    const { data } = props ?? {}

    return createTool(data, fetchOptions)
  }

  return { mutationFn, ...mutationOptions }
}

export type CreateToolMutationResult = NonNullable<
  Awaited<ReturnType<typeof createTool>>
>
export type CreateToolMutationBody = CreateToolBody
export type CreateToolMutationError = unknown

/**
 * @summary Create a new tool
 */
export const useCreateTool = <TError = unknown, TContext = unknown>(
  options?: {
    mutation?: UseMutationOptions<
      Awaited<ReturnType<typeof createTool>>,
      TError,
      { data: CreateToolBody },
      TContext
    >
    fetch?: RequestInit
  },
  queryClient?: QueryClient
): UseMutationResult<
  Awaited<ReturnType<typeof createTool>>,
  TError,
  { data: CreateToolBody },
  TContext
> => {
  const mutationOptions = getCreateToolMutationOptions(options)

  return useMutation(mutationOptions, queryClient)
}

/**
 * Find many tools
 * @summary Find many tools
 */
export const getFindManyToolsUrl = (params?: FindManyToolsParams) => {
  const normalizedParams = new URLSearchParams()

  Object.entries(params || {}).forEach(([key, value]) => {
    if (value !== undefined) {
      normalizedParams.append(key, value === null ? 'null' : value.toString())
    }
  })

  const stringifiedParams = normalizedParams.toString()

  return stringifiedParams.length > 0 ?
      `https://localhost:3001/tools?${stringifiedParams}`
    : `https://localhost:3001/tools`
}

export const findManyTools = async (
  params?: FindManyToolsParams,
  options?: RequestInit
): Promise<FindManyTools200> => {
  const res = await fetch(getFindManyToolsUrl(params), {
    ...options,
    method: 'GET'
  })

  const body = [204, 205, 304].includes(res.status) ? null : await res.text()
  const data: FindManyTools200 = body ? JSON.parse(body) : {}

  return data
}

export const getFindManyToolsQueryKey = (params?: FindManyToolsParams) => {
  return [`https://localhost:3001/tools`, ...(params ? [params] : [])] as const
}

export const getFindManyToolsQueryOptions = <
  TData = Awaited<ReturnType<typeof findManyTools>>,
  TError = unknown
>(
  params?: FindManyToolsParams,
  options?: {
    query?: Partial<
      UseQueryOptions<Awaited<ReturnType<typeof findManyTools>>, TError, TData>
    >
    fetch?: RequestInit
  }
) => {
  const { query: queryOptions, fetch: fetchOptions } = options ?? {}

  const queryKey = queryOptions?.queryKey ?? getFindManyToolsQueryKey(params)

  const queryFn: QueryFunction<Awaited<ReturnType<typeof findManyTools>>> = ({
    signal
  }) =>
    findManyTools(params, { ...(signal ? { signal } : {}), ...fetchOptions })

  return { queryKey, queryFn, ...queryOptions } as UseQueryOptions<
    Awaited<ReturnType<typeof findManyTools>>,
    TError,
    TData
  > & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type FindManyToolsQueryResult = NonNullable<
  Awaited<ReturnType<typeof findManyTools>>
>
export type FindManyToolsQueryError = unknown

export function useFindManyTools<
  TData = Awaited<ReturnType<typeof findManyTools>>,
  TError = unknown
>(
  params: undefined | FindManyToolsParams,
  options: {
    query: Partial<
      UseQueryOptions<Awaited<ReturnType<typeof findManyTools>>, TError, TData>
    > &
      Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof findManyTools>>,
          TError,
          Awaited<ReturnType<typeof findManyTools>>
        >,
        'initialData'
      >
    fetch?: RequestInit
  },
  queryClient?: QueryClient
): DefinedUseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>
}
export function useFindManyTools<
  TData = Awaited<ReturnType<typeof findManyTools>>,
  TError = unknown
>(
  params?: FindManyToolsParams,
  options?: {
    query?: Partial<
      UseQueryOptions<Awaited<ReturnType<typeof findManyTools>>, TError, TData>
    > &
      Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof findManyTools>>,
          TError,
          Awaited<ReturnType<typeof findManyTools>>
        >,
        'initialData'
      >
    fetch?: RequestInit
  },
  queryClient?: QueryClient
): UseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>
}
export function useFindManyTools<
  TData = Awaited<ReturnType<typeof findManyTools>>,
  TError = unknown
>(
  params?: FindManyToolsParams,
  options?: {
    query?: Partial<
      UseQueryOptions<Awaited<ReturnType<typeof findManyTools>>, TError, TData>
    >
    fetch?: RequestInit
  },
  queryClient?: QueryClient
): UseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>
}
/**
 * @summary Find many tools
 */

export function useFindManyTools<
  TData = Awaited<ReturnType<typeof findManyTools>>,
  TError = unknown
>(
  params?: FindManyToolsParams,
  options?: {
    query?: Partial<
      UseQueryOptions<Awaited<ReturnType<typeof findManyTools>>, TError, TData>
    >
    fetch?: RequestInit
  },
  queryClient?: QueryClient
): UseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>
} {
  const queryOptions = getFindManyToolsQueryOptions(params, options)

  const query = useQuery(queryOptions, queryClient) as UseQueryResult<
    TData,
    TError
  > & { queryKey: DataTag<QueryKey, TData, TError> }

  query.queryKey = queryOptions.queryKey

  return query
}

/**
 * Delete a tool
 * @summary Delete a tool
 */
export const getDeleteToolUrl = (id: string) => {
  return `https://localhost:3001/tools/${id}`
}

export const deleteTool = async (
  id: string,
  options?: RequestInit
): Promise<DeleteTool200> => {
  const res = await fetch(getDeleteToolUrl(id), {
    ...options,
    method: 'DELETE'
  })

  const body = [204, 205, 304].includes(res.status) ? null : await res.text()
  const data: DeleteTool200 = body ? JSON.parse(body) : {}

  return data
}

export const getDeleteToolMutationOptions = <
  TError = NotFoundResponse,
  TContext = unknown
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof deleteTool>>,
    TError,
    { id: string },
    TContext
  >
  fetch?: RequestInit
}): UseMutationOptions<
  Awaited<ReturnType<typeof deleteTool>>,
  TError,
  { id: string },
  TContext
> => {
  const mutationKey = ['deleteTool']
  const { mutation: mutationOptions, fetch: fetchOptions } =
    options ?
      (
        options.mutation &&
        'mutationKey' in options.mutation &&
        options.mutation.mutationKey
      ) ?
        options
      : { ...options, mutation: { ...options.mutation, mutationKey } }
    : { mutation: { mutationKey }, fetch: undefined }

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof deleteTool>>,
    { id: string }
  > = (props) => {
    const { id } = props ?? {}

    return deleteTool(id, fetchOptions)
  }

  return { mutationFn, ...mutationOptions }
}

export type DeleteToolMutationResult = NonNullable<
  Awaited<ReturnType<typeof deleteTool>>
>

export type DeleteToolMutationError = NotFoundResponse

/**
 * @summary Delete a tool
 */
export const useDeleteTool = <TError = NotFoundResponse, TContext = unknown>(
  options?: {
    mutation?: UseMutationOptions<
      Awaited<ReturnType<typeof deleteTool>>,
      TError,
      { id: string },
      TContext
    >
    fetch?: RequestInit
  },
  queryClient?: QueryClient
): UseMutationResult<
  Awaited<ReturnType<typeof deleteTool>>,
  TError,
  { id: string },
  TContext
> => {
  const mutationOptions = getDeleteToolMutationOptions(options)

  return useMutation(mutationOptions, queryClient)
}

/**
 * Find a tool
 * @summary Find a tool
 */
export const getGetOneToolUrl = (id: string) => {
  return `https://localhost:3001/tools/${id}`
}

export const getOneTool = async (
  id: string,
  options?: RequestInit
): Promise<GetOneTool200> => {
  const res = await fetch(getGetOneToolUrl(id), {
    ...options,
    method: 'GET'
  })

  const body = [204, 205, 304].includes(res.status) ? null : await res.text()
  const data: GetOneTool200 = body ? JSON.parse(body) : {}

  return data
}

export const getGetOneToolQueryKey = (id: string) => {
  return [`https://localhost:3001/tools/${id}`] as const
}

export const getGetOneToolQueryOptions = <
  TData = Awaited<ReturnType<typeof getOneTool>>,
  TError = NotFoundResponse
>(
  id: string,
  options?: {
    query?: Partial<
      UseQueryOptions<Awaited<ReturnType<typeof getOneTool>>, TError, TData>
    >
    fetch?: RequestInit
  }
) => {
  const { query: queryOptions, fetch: fetchOptions } = options ?? {}

  const queryKey = queryOptions?.queryKey ?? getGetOneToolQueryKey(id)

  const queryFn: QueryFunction<Awaited<ReturnType<typeof getOneTool>>> = ({
    signal
  }) => getOneTool(id, { ...(signal ? { signal } : {}), ...fetchOptions })

  return {
    queryKey,
    queryFn,
    enabled: !!id,
    ...queryOptions
  } as UseQueryOptions<
    Awaited<ReturnType<typeof getOneTool>>,
    TError,
    TData
  > & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type GetOneToolQueryResult = NonNullable<
  Awaited<ReturnType<typeof getOneTool>>
>
export type GetOneToolQueryError = NotFoundResponse

export function useGetOneTool<
  TData = Awaited<ReturnType<typeof getOneTool>>,
  TError = NotFoundResponse
>(
  id: string,
  options: {
    query: Partial<
      UseQueryOptions<Awaited<ReturnType<typeof getOneTool>>, TError, TData>
    > &
      Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof getOneTool>>,
          TError,
          Awaited<ReturnType<typeof getOneTool>>
        >,
        'initialData'
      >
    fetch?: RequestInit
  },
  queryClient?: QueryClient
): DefinedUseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>
}
export function useGetOneTool<
  TData = Awaited<ReturnType<typeof getOneTool>>,
  TError = NotFoundResponse
>(
  id: string,
  options?: {
    query?: Partial<
      UseQueryOptions<Awaited<ReturnType<typeof getOneTool>>, TError, TData>
    > &
      Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof getOneTool>>,
          TError,
          Awaited<ReturnType<typeof getOneTool>>
        >,
        'initialData'
      >
    fetch?: RequestInit
  },
  queryClient?: QueryClient
): UseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>
}
export function useGetOneTool<
  TData = Awaited<ReturnType<typeof getOneTool>>,
  TError = NotFoundResponse
>(
  id: string,
  options?: {
    query?: Partial<
      UseQueryOptions<Awaited<ReturnType<typeof getOneTool>>, TError, TData>
    >
    fetch?: RequestInit
  },
  queryClient?: QueryClient
): UseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>
}
/**
 * @summary Find a tool
 */

export function useGetOneTool<
  TData = Awaited<ReturnType<typeof getOneTool>>,
  TError = NotFoundResponse
>(
  id: string,
  options?: {
    query?: Partial<
      UseQueryOptions<Awaited<ReturnType<typeof getOneTool>>, TError, TData>
    >
    fetch?: RequestInit
  },
  queryClient?: QueryClient
): UseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>
} {
  const queryOptions = getGetOneToolQueryOptions(id, options)

  const query = useQuery(queryOptions, queryClient) as UseQueryResult<
    TData,
    TError
  > & { queryKey: DataTag<QueryKey, TData, TError> }

  query.queryKey = queryOptions.queryKey

  return query
}

/**
 * Update a tool
 * @summary Update a tool
 */
export const getUpdateToolUrl = (id: string) => {
  return `https://localhost:3001/tools/${id}`
}

export const updateTool = async (
  id: string,
  updateToolBody: UpdateToolBody,
  options?: RequestInit
): Promise<UpdateTool200> => {
  const res = await fetch(getUpdateToolUrl(id), {
    ...options,
    method: 'PATCH',
    headers: { 'Content-Type': 'application/json', ...options?.headers },
    body: JSON.stringify(updateToolBody)
  })

  const body = [204, 205, 304].includes(res.status) ? null : await res.text()
  const data: UpdateTool200 = body ? JSON.parse(body) : {}

  return data
}

export const getUpdateToolMutationOptions = <
  TError = NotFoundResponse,
  TContext = unknown
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof updateTool>>,
    TError,
    { id: string; data: UpdateToolBody },
    TContext
  >
  fetch?: RequestInit
}): UseMutationOptions<
  Awaited<ReturnType<typeof updateTool>>,
  TError,
  { id: string; data: UpdateToolBody },
  TContext
> => {
  const mutationKey = ['updateTool']
  const { mutation: mutationOptions, fetch: fetchOptions } =
    options ?
      (
        options.mutation &&
        'mutationKey' in options.mutation &&
        options.mutation.mutationKey
      ) ?
        options
      : { ...options, mutation: { ...options.mutation, mutationKey } }
    : { mutation: { mutationKey }, fetch: undefined }

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof updateTool>>,
    { id: string; data: UpdateToolBody }
  > = (props) => {
    const { id, data } = props ?? {}

    return updateTool(id, data, fetchOptions)
  }

  return { mutationFn, ...mutationOptions }
}

export type UpdateToolMutationResult = NonNullable<
  Awaited<ReturnType<typeof updateTool>>
>
export type UpdateToolMutationBody = UpdateToolBody
export type UpdateToolMutationError = NotFoundResponse

/**
 * @summary Update a tool
 */
export const useUpdateTool = <TError = NotFoundResponse, TContext = unknown>(
  options?: {
    mutation?: UseMutationOptions<
      Awaited<ReturnType<typeof updateTool>>,
      TError,
      { id: string; data: UpdateToolBody },
      TContext
    >
    fetch?: RequestInit
  },
  queryClient?: QueryClient
): UseMutationResult<
  Awaited<ReturnType<typeof updateTool>>,
  TError,
  { id: string; data: UpdateToolBody },
  TContext
> => {
  const mutationOptions = getUpdateToolMutationOptions(options)

  return useMutation(mutationOptions, queryClient)
}

/**
 * Create a new artifact
 * @summary Create a new artifact
 */
export const getCreateArtifactUrl = () => {
  return `https://localhost:3001/artifacts`
}

export const createArtifact = async (
  createArtifactBody: CreateArtifactBody,
  options?: RequestInit
): Promise<CreateArtifact201> => {
  const res = await fetch(getCreateArtifactUrl(), {
    ...options,
    method: 'POST',
    headers: { 'Content-Type': 'application/json', ...options?.headers },
    body: JSON.stringify(createArtifactBody)
  })

  const body = [204, 205, 304].includes(res.status) ? null : await res.text()
  const data: CreateArtifact201 = body ? JSON.parse(body) : {}

  return data
}

export const getCreateArtifactMutationOptions = <
  TError = unknown,
  TContext = unknown
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof createArtifact>>,
    TError,
    { data: CreateArtifactBody },
    TContext
  >
  fetch?: RequestInit
}): UseMutationOptions<
  Awaited<ReturnType<typeof createArtifact>>,
  TError,
  { data: CreateArtifactBody },
  TContext
> => {
  const mutationKey = ['createArtifact']
  const { mutation: mutationOptions, fetch: fetchOptions } =
    options ?
      (
        options.mutation &&
        'mutationKey' in options.mutation &&
        options.mutation.mutationKey
      ) ?
        options
      : { ...options, mutation: { ...options.mutation, mutationKey } }
    : { mutation: { mutationKey }, fetch: undefined }

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof createArtifact>>,
    { data: CreateArtifactBody }
  > = (props) => {
    const { data } = props ?? {}

    return createArtifact(data, fetchOptions)
  }

  return { mutationFn, ...mutationOptions }
}

export type CreateArtifactMutationResult = NonNullable<
  Awaited<ReturnType<typeof createArtifact>>
>
export type CreateArtifactMutationBody = CreateArtifactBody
export type CreateArtifactMutationError = unknown

/**
 * @summary Create a new artifact
 */
export const useCreateArtifact = <TError = unknown, TContext = unknown>(
  options?: {
    mutation?: UseMutationOptions<
      Awaited<ReturnType<typeof createArtifact>>,
      TError,
      { data: CreateArtifactBody },
      TContext
    >
    fetch?: RequestInit
  },
  queryClient?: QueryClient
): UseMutationResult<
  Awaited<ReturnType<typeof createArtifact>>,
  TError,
  { data: CreateArtifactBody },
  TContext
> => {
  const mutationOptions = getCreateArtifactMutationOptions(options)

  return useMutation(mutationOptions, queryClient)
}

/**
 * Find many artifacts
 * @summary Find many artifacts
 */
export const getFindManyArtifactsUrl = (params?: FindManyArtifactsParams) => {
  const normalizedParams = new URLSearchParams()

  Object.entries(params || {}).forEach(([key, value]) => {
    if (value !== undefined) {
      normalizedParams.append(key, value === null ? 'null' : value.toString())
    }
  })

  const stringifiedParams = normalizedParams.toString()

  return stringifiedParams.length > 0 ?
      `https://localhost:3001/artifacts?${stringifiedParams}`
    : `https://localhost:3001/artifacts`
}

export const findManyArtifacts = async (
  params?: FindManyArtifactsParams,
  options?: RequestInit
): Promise<FindManyArtifacts200> => {
  const res = await fetch(getFindManyArtifactsUrl(params), {
    ...options,
    method: 'GET'
  })

  const body = [204, 205, 304].includes(res.status) ? null : await res.text()
  const data: FindManyArtifacts200 = body ? JSON.parse(body) : {}

  return data
}

export const getFindManyArtifactsQueryKey = (
  params?: FindManyArtifactsParams
) => {
  return [
    `https://localhost:3001/artifacts`,
    ...(params ? [params] : [])
  ] as const
}

export const getFindManyArtifactsQueryOptions = <
  TData = Awaited<ReturnType<typeof findManyArtifacts>>,
  TError = unknown
>(
  params?: FindManyArtifactsParams,
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof findManyArtifacts>>,
        TError,
        TData
      >
    >
    fetch?: RequestInit
  }
) => {
  const { query: queryOptions, fetch: fetchOptions } = options ?? {}

  const queryKey =
    queryOptions?.queryKey ?? getFindManyArtifactsQueryKey(params)

  const queryFn: QueryFunction<
    Awaited<ReturnType<typeof findManyArtifacts>>
  > = ({ signal }) =>
    findManyArtifacts(params, {
      ...(signal ? { signal } : {}),
      ...fetchOptions
    })

  return { queryKey, queryFn, ...queryOptions } as UseQueryOptions<
    Awaited<ReturnType<typeof findManyArtifacts>>,
    TError,
    TData
  > & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type FindManyArtifactsQueryResult = NonNullable<
  Awaited<ReturnType<typeof findManyArtifacts>>
>
export type FindManyArtifactsQueryError = unknown

export function useFindManyArtifacts<
  TData = Awaited<ReturnType<typeof findManyArtifacts>>,
  TError = unknown
>(
  params: undefined | FindManyArtifactsParams,
  options: {
    query: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof findManyArtifacts>>,
        TError,
        TData
      >
    > &
      Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof findManyArtifacts>>,
          TError,
          Awaited<ReturnType<typeof findManyArtifacts>>
        >,
        'initialData'
      >
    fetch?: RequestInit
  },
  queryClient?: QueryClient
): DefinedUseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>
}
export function useFindManyArtifacts<
  TData = Awaited<ReturnType<typeof findManyArtifacts>>,
  TError = unknown
>(
  params?: FindManyArtifactsParams,
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof findManyArtifacts>>,
        TError,
        TData
      >
    > &
      Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof findManyArtifacts>>,
          TError,
          Awaited<ReturnType<typeof findManyArtifacts>>
        >,
        'initialData'
      >
    fetch?: RequestInit
  },
  queryClient?: QueryClient
): UseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>
}
export function useFindManyArtifacts<
  TData = Awaited<ReturnType<typeof findManyArtifacts>>,
  TError = unknown
>(
  params?: FindManyArtifactsParams,
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof findManyArtifacts>>,
        TError,
        TData
      >
    >
    fetch?: RequestInit
  },
  queryClient?: QueryClient
): UseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>
}
/**
 * @summary Find many artifacts
 */

export function useFindManyArtifacts<
  TData = Awaited<ReturnType<typeof findManyArtifacts>>,
  TError = unknown
>(
  params?: FindManyArtifactsParams,
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof findManyArtifacts>>,
        TError,
        TData
      >
    >
    fetch?: RequestInit
  },
  queryClient?: QueryClient
): UseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>
} {
  const queryOptions = getFindManyArtifactsQueryOptions(params, options)

  const query = useQuery(queryOptions, queryClient) as UseQueryResult<
    TData,
    TError
  > & { queryKey: DataTag<QueryKey, TData, TError> }

  query.queryKey = queryOptions.queryKey

  return query
}

/**
 * Delete an artifact
 * @summary Delete an artifact
 */
export const getDeleteArtifactUrl = (id: string) => {
  return `https://localhost:3001/artifacts/${id}`
}

export const deleteArtifact = async (
  id: string,
  options?: RequestInit
): Promise<DeleteArtifact200> => {
  const res = await fetch(getDeleteArtifactUrl(id), {
    ...options,
    method: 'DELETE'
  })

  const body = [204, 205, 304].includes(res.status) ? null : await res.text()
  const data: DeleteArtifact200 = body ? JSON.parse(body) : {}

  return data
}

export const getDeleteArtifactMutationOptions = <
  TError = NotFoundResponse,
  TContext = unknown
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof deleteArtifact>>,
    TError,
    { id: string },
    TContext
  >
  fetch?: RequestInit
}): UseMutationOptions<
  Awaited<ReturnType<typeof deleteArtifact>>,
  TError,
  { id: string },
  TContext
> => {
  const mutationKey = ['deleteArtifact']
  const { mutation: mutationOptions, fetch: fetchOptions } =
    options ?
      (
        options.mutation &&
        'mutationKey' in options.mutation &&
        options.mutation.mutationKey
      ) ?
        options
      : { ...options, mutation: { ...options.mutation, mutationKey } }
    : { mutation: { mutationKey }, fetch: undefined }

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof deleteArtifact>>,
    { id: string }
  > = (props) => {
    const { id } = props ?? {}

    return deleteArtifact(id, fetchOptions)
  }

  return { mutationFn, ...mutationOptions }
}

export type DeleteArtifactMutationResult = NonNullable<
  Awaited<ReturnType<typeof deleteArtifact>>
>

export type DeleteArtifactMutationError = NotFoundResponse

/**
 * @summary Delete an artifact
 */
export const useDeleteArtifact = <
  TError = NotFoundResponse,
  TContext = unknown
>(
  options?: {
    mutation?: UseMutationOptions<
      Awaited<ReturnType<typeof deleteArtifact>>,
      TError,
      { id: string },
      TContext
    >
    fetch?: RequestInit
  },
  queryClient?: QueryClient
): UseMutationResult<
  Awaited<ReturnType<typeof deleteArtifact>>,
  TError,
  { id: string },
  TContext
> => {
  const mutationOptions = getDeleteArtifactMutationOptions(options)

  return useMutation(mutationOptions, queryClient)
}

/**
 * Find an artifact
 * @summary Find an artifact
 */
export const getGetOneArtifactUrl = (id: string) => {
  return `https://localhost:3001/artifacts/${id}`
}

export const getOneArtifact = async (
  id: string,
  options?: RequestInit
): Promise<GetOneArtifact200> => {
  const res = await fetch(getGetOneArtifactUrl(id), {
    ...options,
    method: 'GET'
  })

  const body = [204, 205, 304].includes(res.status) ? null : await res.text()
  const data: GetOneArtifact200 = body ? JSON.parse(body) : {}

  return data
}

export const getGetOneArtifactQueryKey = (id: string) => {
  return [`https://localhost:3001/artifacts/${id}`] as const
}

export const getGetOneArtifactQueryOptions = <
  TData = Awaited<ReturnType<typeof getOneArtifact>>,
  TError = NotFoundResponse
>(
  id: string,
  options?: {
    query?: Partial<
      UseQueryOptions<Awaited<ReturnType<typeof getOneArtifact>>, TError, TData>
    >
    fetch?: RequestInit
  }
) => {
  const { query: queryOptions, fetch: fetchOptions } = options ?? {}

  const queryKey = queryOptions?.queryKey ?? getGetOneArtifactQueryKey(id)

  const queryFn: QueryFunction<Awaited<ReturnType<typeof getOneArtifact>>> = ({
    signal
  }) => getOneArtifact(id, { ...(signal ? { signal } : {}), ...fetchOptions })

  return {
    queryKey,
    queryFn,
    enabled: !!id,
    ...queryOptions
  } as UseQueryOptions<
    Awaited<ReturnType<typeof getOneArtifact>>,
    TError,
    TData
  > & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type GetOneArtifactQueryResult = NonNullable<
  Awaited<ReturnType<typeof getOneArtifact>>
>
export type GetOneArtifactQueryError = NotFoundResponse

export function useGetOneArtifact<
  TData = Awaited<ReturnType<typeof getOneArtifact>>,
  TError = NotFoundResponse
>(
  id: string,
  options: {
    query: Partial<
      UseQueryOptions<Awaited<ReturnType<typeof getOneArtifact>>, TError, TData>
    > &
      Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof getOneArtifact>>,
          TError,
          Awaited<ReturnType<typeof getOneArtifact>>
        >,
        'initialData'
      >
    fetch?: RequestInit
  },
  queryClient?: QueryClient
): DefinedUseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>
}
export function useGetOneArtifact<
  TData = Awaited<ReturnType<typeof getOneArtifact>>,
  TError = NotFoundResponse
>(
  id: string,
  options?: {
    query?: Partial<
      UseQueryOptions<Awaited<ReturnType<typeof getOneArtifact>>, TError, TData>
    > &
      Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof getOneArtifact>>,
          TError,
          Awaited<ReturnType<typeof getOneArtifact>>
        >,
        'initialData'
      >
    fetch?: RequestInit
  },
  queryClient?: QueryClient
): UseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>
}
export function useGetOneArtifact<
  TData = Awaited<ReturnType<typeof getOneArtifact>>,
  TError = NotFoundResponse
>(
  id: string,
  options?: {
    query?: Partial<
      UseQueryOptions<Awaited<ReturnType<typeof getOneArtifact>>, TError, TData>
    >
    fetch?: RequestInit
  },
  queryClient?: QueryClient
): UseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>
}
/**
 * @summary Find an artifact
 */

export function useGetOneArtifact<
  TData = Awaited<ReturnType<typeof getOneArtifact>>,
  TError = NotFoundResponse
>(
  id: string,
  options?: {
    query?: Partial<
      UseQueryOptions<Awaited<ReturnType<typeof getOneArtifact>>, TError, TData>
    >
    fetch?: RequestInit
  },
  queryClient?: QueryClient
): UseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>
} {
  const queryOptions = getGetOneArtifactQueryOptions(id, options)

  const query = useQuery(queryOptions, queryClient) as UseQueryResult<
    TData,
    TError
  > & { queryKey: DataTag<QueryKey, TData, TError> }

  query.queryKey = queryOptions.queryKey

  return query
}

/**
 * Update an artifact
 * @summary Update an artifact
 */
export const getUpdateArtifactUrl = (id: string) => {
  return `https://localhost:3001/artifacts/${id}`
}

export const updateArtifact = async (
  id: string,
  updateArtifactBody: UpdateArtifactBody,
  options?: RequestInit
): Promise<UpdateArtifact200> => {
  const res = await fetch(getUpdateArtifactUrl(id), {
    ...options,
    method: 'PATCH',
    headers: { 'Content-Type': 'application/json', ...options?.headers },
    body: JSON.stringify(updateArtifactBody)
  })

  const body = [204, 205, 304].includes(res.status) ? null : await res.text()
  const data: UpdateArtifact200 = body ? JSON.parse(body) : {}

  return data
}

export const getUpdateArtifactMutationOptions = <
  TError = NotFoundResponse,
  TContext = unknown
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof updateArtifact>>,
    TError,
    { id: string; data: UpdateArtifactBody },
    TContext
  >
  fetch?: RequestInit
}): UseMutationOptions<
  Awaited<ReturnType<typeof updateArtifact>>,
  TError,
  { id: string; data: UpdateArtifactBody },
  TContext
> => {
  const mutationKey = ['updateArtifact']
  const { mutation: mutationOptions, fetch: fetchOptions } =
    options ?
      (
        options.mutation &&
        'mutationKey' in options.mutation &&
        options.mutation.mutationKey
      ) ?
        options
      : { ...options, mutation: { ...options.mutation, mutationKey } }
    : { mutation: { mutationKey }, fetch: undefined }

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof updateArtifact>>,
    { id: string; data: UpdateArtifactBody }
  > = (props) => {
    const { id, data } = props ?? {}

    return updateArtifact(id, data, fetchOptions)
  }

  return { mutationFn, ...mutationOptions }
}

export type UpdateArtifactMutationResult = NonNullable<
  Awaited<ReturnType<typeof updateArtifact>>
>
export type UpdateArtifactMutationBody = UpdateArtifactBody
export type UpdateArtifactMutationError = NotFoundResponse

/**
 * @summary Update an artifact
 */
export const useUpdateArtifact = <
  TError = NotFoundResponse,
  TContext = unknown
>(
  options?: {
    mutation?: UseMutationOptions<
      Awaited<ReturnType<typeof updateArtifact>>,
      TError,
      { id: string; data: UpdateArtifactBody },
      TContext
    >
    fetch?: RequestInit
  },
  queryClient?: QueryClient
): UseMutationResult<
  Awaited<ReturnType<typeof updateArtifact>>,
  TError,
  { id: string; data: UpdateArtifactBody },
  TContext
> => {
  const mutationOptions = getUpdateArtifactMutationOptions(options)

  return useMutation(mutationOptions, queryClient)
}

/**
 * Create a new run
 * @summary Create a new run
 */
export const getCreateRunUrl = () => {
  return `https://localhost:3001/runs`
}

export const createRun = async (
  createRunBody: CreateRunBody,
  options?: RequestInit
): Promise<CreateRun201> => {
  const res = await fetch(getCreateRunUrl(), {
    ...options,
    method: 'POST',
    headers: { 'Content-Type': 'application/json', ...options?.headers },
    body: JSON.stringify(createRunBody)
  })

  const body = [204, 205, 304].includes(res.status) ? null : await res.text()
  const data: CreateRun201 = body ? JSON.parse(body) : {}

  return data
}

export const getCreateRunMutationOptions = <
  TError = unknown,
  TContext = unknown
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof createRun>>,
    TError,
    { data: CreateRunBody },
    TContext
  >
  fetch?: RequestInit
}): UseMutationOptions<
  Awaited<ReturnType<typeof createRun>>,
  TError,
  { data: CreateRunBody },
  TContext
> => {
  const mutationKey = ['createRun']
  const { mutation: mutationOptions, fetch: fetchOptions } =
    options ?
      (
        options.mutation &&
        'mutationKey' in options.mutation &&
        options.mutation.mutationKey
      ) ?
        options
      : { ...options, mutation: { ...options.mutation, mutationKey } }
    : { mutation: { mutationKey }, fetch: undefined }

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof createRun>>,
    { data: CreateRunBody }
  > = (props) => {
    const { data } = props ?? {}

    return createRun(data, fetchOptions)
  }

  return { mutationFn, ...mutationOptions }
}

export type CreateRunMutationResult = NonNullable<
  Awaited<ReturnType<typeof createRun>>
>
export type CreateRunMutationBody = CreateRunBody
export type CreateRunMutationError = unknown

/**
 * @summary Create a new run
 */
export const useCreateRun = <TError = unknown, TContext = unknown>(
  options?: {
    mutation?: UseMutationOptions<
      Awaited<ReturnType<typeof createRun>>,
      TError,
      { data: CreateRunBody },
      TContext
    >
    fetch?: RequestInit
  },
  queryClient?: QueryClient
): UseMutationResult<
  Awaited<ReturnType<typeof createRun>>,
  TError,
  { data: CreateRunBody },
  TContext
> => {
  const mutationOptions = getCreateRunMutationOptions(options)

  return useMutation(mutationOptions, queryClient)
}

/**
 * Find many runs
 * @summary Find many runs
 */
export const getFindManyRunsUrl = (params?: FindManyRunsParams) => {
  const normalizedParams = new URLSearchParams()

  Object.entries(params || {}).forEach(([key, value]) => {
    if (value !== undefined) {
      normalizedParams.append(key, value === null ? 'null' : value.toString())
    }
  })

  const stringifiedParams = normalizedParams.toString()

  return stringifiedParams.length > 0 ?
      `https://localhost:3001/runs?${stringifiedParams}`
    : `https://localhost:3001/runs`
}

export const findManyRuns = async (
  params?: FindManyRunsParams,
  options?: RequestInit
): Promise<FindManyRuns200> => {
  const res = await fetch(getFindManyRunsUrl(params), {
    ...options,
    method: 'GET'
  })

  const body = [204, 205, 304].includes(res.status) ? null : await res.text()
  const data: FindManyRuns200 = body ? JSON.parse(body) : {}

  return data
}

export const getFindManyRunsQueryKey = (params?: FindManyRunsParams) => {
  return [`https://localhost:3001/runs`, ...(params ? [params] : [])] as const
}

export const getFindManyRunsQueryOptions = <
  TData = Awaited<ReturnType<typeof findManyRuns>>,
  TError = unknown
>(
  params?: FindManyRunsParams,
  options?: {
    query?: Partial<
      UseQueryOptions<Awaited<ReturnType<typeof findManyRuns>>, TError, TData>
    >
    fetch?: RequestInit
  }
) => {
  const { query: queryOptions, fetch: fetchOptions } = options ?? {}

  const queryKey = queryOptions?.queryKey ?? getFindManyRunsQueryKey(params)

  const queryFn: QueryFunction<Awaited<ReturnType<typeof findManyRuns>>> = ({
    signal
  }) => findManyRuns(params, { ...(signal ? { signal } : {}), ...fetchOptions })

  return { queryKey, queryFn, ...queryOptions } as UseQueryOptions<
    Awaited<ReturnType<typeof findManyRuns>>,
    TError,
    TData
  > & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type FindManyRunsQueryResult = NonNullable<
  Awaited<ReturnType<typeof findManyRuns>>
>
export type FindManyRunsQueryError = unknown

export function useFindManyRuns<
  TData = Awaited<ReturnType<typeof findManyRuns>>,
  TError = unknown
>(
  params: undefined | FindManyRunsParams,
  options: {
    query: Partial<
      UseQueryOptions<Awaited<ReturnType<typeof findManyRuns>>, TError, TData>
    > &
      Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof findManyRuns>>,
          TError,
          Awaited<ReturnType<typeof findManyRuns>>
        >,
        'initialData'
      >
    fetch?: RequestInit
  },
  queryClient?: QueryClient
): DefinedUseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>
}
export function useFindManyRuns<
  TData = Awaited<ReturnType<typeof findManyRuns>>,
  TError = unknown
>(
  params?: FindManyRunsParams,
  options?: {
    query?: Partial<
      UseQueryOptions<Awaited<ReturnType<typeof findManyRuns>>, TError, TData>
    > &
      Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof findManyRuns>>,
          TError,
          Awaited<ReturnType<typeof findManyRuns>>
        >,
        'initialData'
      >
    fetch?: RequestInit
  },
  queryClient?: QueryClient
): UseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>
}
export function useFindManyRuns<
  TData = Awaited<ReturnType<typeof findManyRuns>>,
  TError = unknown
>(
  params?: FindManyRunsParams,
  options?: {
    query?: Partial<
      UseQueryOptions<Awaited<ReturnType<typeof findManyRuns>>, TError, TData>
    >
    fetch?: RequestInit
  },
  queryClient?: QueryClient
): UseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>
}
/**
 * @summary Find many runs
 */

export function useFindManyRuns<
  TData = Awaited<ReturnType<typeof findManyRuns>>,
  TError = unknown
>(
  params?: FindManyRunsParams,
  options?: {
    query?: Partial<
      UseQueryOptions<Awaited<ReturnType<typeof findManyRuns>>, TError, TData>
    >
    fetch?: RequestInit
  },
  queryClient?: QueryClient
): UseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>
} {
  const queryOptions = getFindManyRunsQueryOptions(params, options)

  const query = useQuery(queryOptions, queryClient) as UseQueryResult<
    TData,
    TError
  > & { queryKey: DataTag<QueryKey, TData, TError> }

  query.queryKey = queryOptions.queryKey

  return query
}

/**
 * Delete a run
 * @summary Delete a run
 */
export const getDeleteRunUrl = (id: string) => {
  return `https://localhost:3001/runs/${id}`
}

export const deleteRun = async (
  id: string,
  options?: RequestInit
): Promise<DeleteRun200> => {
  const res = await fetch(getDeleteRunUrl(id), {
    ...options,
    method: 'DELETE'
  })

  const body = [204, 205, 304].includes(res.status) ? null : await res.text()
  const data: DeleteRun200 = body ? JSON.parse(body) : {}

  return data
}

export const getDeleteRunMutationOptions = <
  TError = NotFoundResponse,
  TContext = unknown
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof deleteRun>>,
    TError,
    { id: string },
    TContext
  >
  fetch?: RequestInit
}): UseMutationOptions<
  Awaited<ReturnType<typeof deleteRun>>,
  TError,
  { id: string },
  TContext
> => {
  const mutationKey = ['deleteRun']
  const { mutation: mutationOptions, fetch: fetchOptions } =
    options ?
      (
        options.mutation &&
        'mutationKey' in options.mutation &&
        options.mutation.mutationKey
      ) ?
        options
      : { ...options, mutation: { ...options.mutation, mutationKey } }
    : { mutation: { mutationKey }, fetch: undefined }

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof deleteRun>>,
    { id: string }
  > = (props) => {
    const { id } = props ?? {}

    return deleteRun(id, fetchOptions)
  }

  return { mutationFn, ...mutationOptions }
}

export type DeleteRunMutationResult = NonNullable<
  Awaited<ReturnType<typeof deleteRun>>
>

export type DeleteRunMutationError = NotFoundResponse

/**
 * @summary Delete a run
 */
export const useDeleteRun = <TError = NotFoundResponse, TContext = unknown>(
  options?: {
    mutation?: UseMutationOptions<
      Awaited<ReturnType<typeof deleteRun>>,
      TError,
      { id: string },
      TContext
    >
    fetch?: RequestInit
  },
  queryClient?: QueryClient
): UseMutationResult<
  Awaited<ReturnType<typeof deleteRun>>,
  TError,
  { id: string },
  TContext
> => {
  const mutationOptions = getDeleteRunMutationOptions(options)

  return useMutation(mutationOptions, queryClient)
}

/**
 * Find a run
 * @summary Find a run
 */
export const getGetOneRunUrl = (id: string) => {
  return `https://localhost:3001/runs/${id}`
}

export const getOneRun = async (
  id: string,
  options?: RequestInit
): Promise<GetOneRun200> => {
  const res = await fetch(getGetOneRunUrl(id), {
    ...options,
    method: 'GET'
  })

  const body = [204, 205, 304].includes(res.status) ? null : await res.text()
  const data: GetOneRun200 = body ? JSON.parse(body) : {}

  return data
}

export const getGetOneRunQueryKey = (id: string) => {
  return [`https://localhost:3001/runs/${id}`] as const
}

export const getGetOneRunQueryOptions = <
  TData = Awaited<ReturnType<typeof getOneRun>>,
  TError = NotFoundResponse
>(
  id: string,
  options?: {
    query?: Partial<
      UseQueryOptions<Awaited<ReturnType<typeof getOneRun>>, TError, TData>
    >
    fetch?: RequestInit
  }
) => {
  const { query: queryOptions, fetch: fetchOptions } = options ?? {}

  const queryKey = queryOptions?.queryKey ?? getGetOneRunQueryKey(id)

  const queryFn: QueryFunction<Awaited<ReturnType<typeof getOneRun>>> = ({
    signal
  }) => getOneRun(id, { ...(signal ? { signal } : {}), ...fetchOptions })

  return {
    queryKey,
    queryFn,
    enabled: !!id,
    ...queryOptions
  } as UseQueryOptions<Awaited<ReturnType<typeof getOneRun>>, TError, TData> & {
    queryKey: DataTag<QueryKey, TData, TError>
  }
}

export type GetOneRunQueryResult = NonNullable<
  Awaited<ReturnType<typeof getOneRun>>
>
export type GetOneRunQueryError = NotFoundResponse

export function useGetOneRun<
  TData = Awaited<ReturnType<typeof getOneRun>>,
  TError = NotFoundResponse
>(
  id: string,
  options: {
    query: Partial<
      UseQueryOptions<Awaited<ReturnType<typeof getOneRun>>, TError, TData>
    > &
      Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof getOneRun>>,
          TError,
          Awaited<ReturnType<typeof getOneRun>>
        >,
        'initialData'
      >
    fetch?: RequestInit
  },
  queryClient?: QueryClient
): DefinedUseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>
}
export function useGetOneRun<
  TData = Awaited<ReturnType<typeof getOneRun>>,
  TError = NotFoundResponse
>(
  id: string,
  options?: {
    query?: Partial<
      UseQueryOptions<Awaited<ReturnType<typeof getOneRun>>, TError, TData>
    > &
      Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof getOneRun>>,
          TError,
          Awaited<ReturnType<typeof getOneRun>>
        >,
        'initialData'
      >
    fetch?: RequestInit
  },
  queryClient?: QueryClient
): UseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>
}
export function useGetOneRun<
  TData = Awaited<ReturnType<typeof getOneRun>>,
  TError = NotFoundResponse
>(
  id: string,
  options?: {
    query?: Partial<
      UseQueryOptions<Awaited<ReturnType<typeof getOneRun>>, TError, TData>
    >
    fetch?: RequestInit
  },
  queryClient?: QueryClient
): UseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>
}
/**
 * @summary Find a run
 */

export function useGetOneRun<
  TData = Awaited<ReturnType<typeof getOneRun>>,
  TError = NotFoundResponse
>(
  id: string,
  options?: {
    query?: Partial<
      UseQueryOptions<Awaited<ReturnType<typeof getOneRun>>, TError, TData>
    >
    fetch?: RequestInit
  },
  queryClient?: QueryClient
): UseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>
} {
  const queryOptions = getGetOneRunQueryOptions(id, options)

  const query = useQuery(queryOptions, queryClient) as UseQueryResult<
    TData,
    TError
  > & { queryKey: DataTag<QueryKey, TData, TError> }

  query.queryKey = queryOptions.queryKey

  return query
}

/**
 * Update a run
 * @summary Update a run
 */
export const getUpdateRunUrl = (id: string) => {
  return `https://localhost:3001/runs/${id}`
}

export const updateRun = async (
  id: string,
  updateRunBody: UpdateRunBody,
  options?: RequestInit
): Promise<UpdateRun200> => {
  const res = await fetch(getUpdateRunUrl(id), {
    ...options,
    method: 'PATCH',
    headers: { 'Content-Type': 'application/json', ...options?.headers },
    body: JSON.stringify(updateRunBody)
  })

  const body = [204, 205, 304].includes(res.status) ? null : await res.text()
  const data: UpdateRun200 = body ? JSON.parse(body) : {}

  return data
}

export const getUpdateRunMutationOptions = <
  TError = NotFoundResponse,
  TContext = unknown
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof updateRun>>,
    TError,
    { id: string; data: UpdateRunBody },
    TContext
  >
  fetch?: RequestInit
}): UseMutationOptions<
  Awaited<ReturnType<typeof updateRun>>,
  TError,
  { id: string; data: UpdateRunBody },
  TContext
> => {
  const mutationKey = ['updateRun']
  const { mutation: mutationOptions, fetch: fetchOptions } =
    options ?
      (
        options.mutation &&
        'mutationKey' in options.mutation &&
        options.mutation.mutationKey
      ) ?
        options
      : { ...options, mutation: { ...options.mutation, mutationKey } }
    : { mutation: { mutationKey }, fetch: undefined }

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof updateRun>>,
    { id: string; data: UpdateRunBody }
  > = (props) => {
    const { id, data } = props ?? {}

    return updateRun(id, data, fetchOptions)
  }

  return { mutationFn, ...mutationOptions }
}

export type UpdateRunMutationResult = NonNullable<
  Awaited<ReturnType<typeof updateRun>>
>
export type UpdateRunMutationBody = UpdateRunBody
export type UpdateRunMutationError = NotFoundResponse

/**
 * @summary Update a run
 */
export const useUpdateRun = <TError = NotFoundResponse, TContext = unknown>(
  options?: {
    mutation?: UseMutationOptions<
      Awaited<ReturnType<typeof updateRun>>,
      TError,
      { id: string; data: UpdateRunBody },
      TContext
    >
    fetch?: RequestInit
  },
  queryClient?: QueryClient
): UseMutationResult<
  Awaited<ReturnType<typeof updateRun>>,
  TError,
  { id: string; data: UpdateRunBody },
  TContext
> => {
  const mutationOptions = getUpdateRunMutationOptions(options)

  return useMutation(mutationOptions, queryClient)
}

/**
 * Create a new label
 * @summary Create a new label
 */
export const getCreateLabelUrl = () => {
  return `https://localhost:3001/labels`
}

export const createLabel = async (
  createLabelBody: CreateLabelBody,
  options?: RequestInit
): Promise<CreateLabel201> => {
  const res = await fetch(getCreateLabelUrl(), {
    ...options,
    method: 'POST',
    headers: { 'Content-Type': 'application/json', ...options?.headers },
    body: JSON.stringify(createLabelBody)
  })

  const body = [204, 205, 304].includes(res.status) ? null : await res.text()
  const data: CreateLabel201 = body ? JSON.parse(body) : {}

  return data
}

export const getCreateLabelMutationOptions = <
  TError = unknown,
  TContext = unknown
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof createLabel>>,
    TError,
    { data: CreateLabelBody },
    TContext
  >
  fetch?: RequestInit
}): UseMutationOptions<
  Awaited<ReturnType<typeof createLabel>>,
  TError,
  { data: CreateLabelBody },
  TContext
> => {
  const mutationKey = ['createLabel']
  const { mutation: mutationOptions, fetch: fetchOptions } =
    options ?
      (
        options.mutation &&
        'mutationKey' in options.mutation &&
        options.mutation.mutationKey
      ) ?
        options
      : { ...options, mutation: { ...options.mutation, mutationKey } }
    : { mutation: { mutationKey }, fetch: undefined }

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof createLabel>>,
    { data: CreateLabelBody }
  > = (props) => {
    const { data } = props ?? {}

    return createLabel(data, fetchOptions)
  }

  return { mutationFn, ...mutationOptions }
}

export type CreateLabelMutationResult = NonNullable<
  Awaited<ReturnType<typeof createLabel>>
>
export type CreateLabelMutationBody = CreateLabelBody
export type CreateLabelMutationError = unknown

/**
 * @summary Create a new label
 */
export const useCreateLabel = <TError = unknown, TContext = unknown>(
  options?: {
    mutation?: UseMutationOptions<
      Awaited<ReturnType<typeof createLabel>>,
      TError,
      { data: CreateLabelBody },
      TContext
    >
    fetch?: RequestInit
  },
  queryClient?: QueryClient
): UseMutationResult<
  Awaited<ReturnType<typeof createLabel>>,
  TError,
  { data: CreateLabelBody },
  TContext
> => {
  const mutationOptions = getCreateLabelMutationOptions(options)

  return useMutation(mutationOptions, queryClient)
}

/**
 * Find many labels
 * @summary Find many labels
 */
export const getFindManyLabelsUrl = (params?: FindManyLabelsParams) => {
  const normalizedParams = new URLSearchParams()

  Object.entries(params || {}).forEach(([key, value]) => {
    if (value !== undefined) {
      normalizedParams.append(key, value === null ? 'null' : value.toString())
    }
  })

  const stringifiedParams = normalizedParams.toString()

  return stringifiedParams.length > 0 ?
      `https://localhost:3001/labels?${stringifiedParams}`
    : `https://localhost:3001/labels`
}

export const findManyLabels = async (
  params?: FindManyLabelsParams,
  options?: RequestInit
): Promise<FindManyLabels200> => {
  const res = await fetch(getFindManyLabelsUrl(params), {
    ...options,
    method: 'GET'
  })

  const body = [204, 205, 304].includes(res.status) ? null : await res.text()
  const data: FindManyLabels200 = body ? JSON.parse(body) : {}

  return data
}

export const getFindManyLabelsQueryKey = (params?: FindManyLabelsParams) => {
  return [`https://localhost:3001/labels`, ...(params ? [params] : [])] as const
}

export const getFindManyLabelsQueryOptions = <
  TData = Awaited<ReturnType<typeof findManyLabels>>,
  TError = unknown
>(
  params?: FindManyLabelsParams,
  options?: {
    query?: Partial<
      UseQueryOptions<Awaited<ReturnType<typeof findManyLabels>>, TError, TData>
    >
    fetch?: RequestInit
  }
) => {
  const { query: queryOptions, fetch: fetchOptions } = options ?? {}

  const queryKey = queryOptions?.queryKey ?? getFindManyLabelsQueryKey(params)

  const queryFn: QueryFunction<Awaited<ReturnType<typeof findManyLabels>>> = ({
    signal
  }) =>
    findManyLabels(params, { ...(signal ? { signal } : {}), ...fetchOptions })

  return { queryKey, queryFn, ...queryOptions } as UseQueryOptions<
    Awaited<ReturnType<typeof findManyLabels>>,
    TError,
    TData
  > & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type FindManyLabelsQueryResult = NonNullable<
  Awaited<ReturnType<typeof findManyLabels>>
>
export type FindManyLabelsQueryError = unknown

export function useFindManyLabels<
  TData = Awaited<ReturnType<typeof findManyLabels>>,
  TError = unknown
>(
  params: undefined | FindManyLabelsParams,
  options: {
    query: Partial<
      UseQueryOptions<Awaited<ReturnType<typeof findManyLabels>>, TError, TData>
    > &
      Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof findManyLabels>>,
          TError,
          Awaited<ReturnType<typeof findManyLabels>>
        >,
        'initialData'
      >
    fetch?: RequestInit
  },
  queryClient?: QueryClient
): DefinedUseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>
}
export function useFindManyLabels<
  TData = Awaited<ReturnType<typeof findManyLabels>>,
  TError = unknown
>(
  params?: FindManyLabelsParams,
  options?: {
    query?: Partial<
      UseQueryOptions<Awaited<ReturnType<typeof findManyLabels>>, TError, TData>
    > &
      Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof findManyLabels>>,
          TError,
          Awaited<ReturnType<typeof findManyLabels>>
        >,
        'initialData'
      >
    fetch?: RequestInit
  },
  queryClient?: QueryClient
): UseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>
}
export function useFindManyLabels<
  TData = Awaited<ReturnType<typeof findManyLabels>>,
  TError = unknown
>(
  params?: FindManyLabelsParams,
  options?: {
    query?: Partial<
      UseQueryOptions<Awaited<ReturnType<typeof findManyLabels>>, TError, TData>
    >
    fetch?: RequestInit
  },
  queryClient?: QueryClient
): UseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>
}
/**
 * @summary Find many labels
 */

export function useFindManyLabels<
  TData = Awaited<ReturnType<typeof findManyLabels>>,
  TError = unknown
>(
  params?: FindManyLabelsParams,
  options?: {
    query?: Partial<
      UseQueryOptions<Awaited<ReturnType<typeof findManyLabels>>, TError, TData>
    >
    fetch?: RequestInit
  },
  queryClient?: QueryClient
): UseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>
} {
  const queryOptions = getFindManyLabelsQueryOptions(params, options)

  const query = useQuery(queryOptions, queryClient) as UseQueryResult<
    TData,
    TError
  > & { queryKey: DataTag<QueryKey, TData, TError> }

  query.queryKey = queryOptions.queryKey

  return query
}

/**
 * Delete a label
 * @summary Delete a label
 */
export const getDeleteLabelUrl = (id: string) => {
  return `https://localhost:3001/labels/${id}`
}

export const deleteLabel = async (
  id: string,
  options?: RequestInit
): Promise<DeleteLabel200> => {
  const res = await fetch(getDeleteLabelUrl(id), {
    ...options,
    method: 'DELETE'
  })

  const body = [204, 205, 304].includes(res.status) ? null : await res.text()
  const data: DeleteLabel200 = body ? JSON.parse(body) : {}

  return data
}

export const getDeleteLabelMutationOptions = <
  TError = NotFoundResponse,
  TContext = unknown
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof deleteLabel>>,
    TError,
    { id: string },
    TContext
  >
  fetch?: RequestInit
}): UseMutationOptions<
  Awaited<ReturnType<typeof deleteLabel>>,
  TError,
  { id: string },
  TContext
> => {
  const mutationKey = ['deleteLabel']
  const { mutation: mutationOptions, fetch: fetchOptions } =
    options ?
      (
        options.mutation &&
        'mutationKey' in options.mutation &&
        options.mutation.mutationKey
      ) ?
        options
      : { ...options, mutation: { ...options.mutation, mutationKey } }
    : { mutation: { mutationKey }, fetch: undefined }

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof deleteLabel>>,
    { id: string }
  > = (props) => {
    const { id } = props ?? {}

    return deleteLabel(id, fetchOptions)
  }

  return { mutationFn, ...mutationOptions }
}

export type DeleteLabelMutationResult = NonNullable<
  Awaited<ReturnType<typeof deleteLabel>>
>

export type DeleteLabelMutationError = NotFoundResponse

/**
 * @summary Delete a label
 */
export const useDeleteLabel = <TError = NotFoundResponse, TContext = unknown>(
  options?: {
    mutation?: UseMutationOptions<
      Awaited<ReturnType<typeof deleteLabel>>,
      TError,
      { id: string },
      TContext
    >
    fetch?: RequestInit
  },
  queryClient?: QueryClient
): UseMutationResult<
  Awaited<ReturnType<typeof deleteLabel>>,
  TError,
  { id: string },
  TContext
> => {
  const mutationOptions = getDeleteLabelMutationOptions(options)

  return useMutation(mutationOptions, queryClient)
}

/**
 * Find a label
 * @summary Find a label
 */
export const getGetOneLabelUrl = (id: string) => {
  return `https://localhost:3001/labels/${id}`
}

export const getOneLabel = async (
  id: string,
  options?: RequestInit
): Promise<GetOneLabel200> => {
  const res = await fetch(getGetOneLabelUrl(id), {
    ...options,
    method: 'GET'
  })

  const body = [204, 205, 304].includes(res.status) ? null : await res.text()
  const data: GetOneLabel200 = body ? JSON.parse(body) : {}

  return data
}

export const getGetOneLabelQueryKey = (id: string) => {
  return [`https://localhost:3001/labels/${id}`] as const
}

export const getGetOneLabelQueryOptions = <
  TData = Awaited<ReturnType<typeof getOneLabel>>,
  TError = NotFoundResponse
>(
  id: string,
  options?: {
    query?: Partial<
      UseQueryOptions<Awaited<ReturnType<typeof getOneLabel>>, TError, TData>
    >
    fetch?: RequestInit
  }
) => {
  const { query: queryOptions, fetch: fetchOptions } = options ?? {}

  const queryKey = queryOptions?.queryKey ?? getGetOneLabelQueryKey(id)

  const queryFn: QueryFunction<Awaited<ReturnType<typeof getOneLabel>>> = ({
    signal
  }) => getOneLabel(id, { ...(signal ? { signal } : {}), ...fetchOptions })

  return {
    queryKey,
    queryFn,
    enabled: !!id,
    ...queryOptions
  } as UseQueryOptions<
    Awaited<ReturnType<typeof getOneLabel>>,
    TError,
    TData
  > & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type GetOneLabelQueryResult = NonNullable<
  Awaited<ReturnType<typeof getOneLabel>>
>
export type GetOneLabelQueryError = NotFoundResponse

export function useGetOneLabel<
  TData = Awaited<ReturnType<typeof getOneLabel>>,
  TError = NotFoundResponse
>(
  id: string,
  options: {
    query: Partial<
      UseQueryOptions<Awaited<ReturnType<typeof getOneLabel>>, TError, TData>
    > &
      Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof getOneLabel>>,
          TError,
          Awaited<ReturnType<typeof getOneLabel>>
        >,
        'initialData'
      >
    fetch?: RequestInit
  },
  queryClient?: QueryClient
): DefinedUseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>
}
export function useGetOneLabel<
  TData = Awaited<ReturnType<typeof getOneLabel>>,
  TError = NotFoundResponse
>(
  id: string,
  options?: {
    query?: Partial<
      UseQueryOptions<Awaited<ReturnType<typeof getOneLabel>>, TError, TData>
    > &
      Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof getOneLabel>>,
          TError,
          Awaited<ReturnType<typeof getOneLabel>>
        >,
        'initialData'
      >
    fetch?: RequestInit
  },
  queryClient?: QueryClient
): UseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>
}
export function useGetOneLabel<
  TData = Awaited<ReturnType<typeof getOneLabel>>,
  TError = NotFoundResponse
>(
  id: string,
  options?: {
    query?: Partial<
      UseQueryOptions<Awaited<ReturnType<typeof getOneLabel>>, TError, TData>
    >
    fetch?: RequestInit
  },
  queryClient?: QueryClient
): UseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>
}
/**
 * @summary Find a label
 */

export function useGetOneLabel<
  TData = Awaited<ReturnType<typeof getOneLabel>>,
  TError = NotFoundResponse
>(
  id: string,
  options?: {
    query?: Partial<
      UseQueryOptions<Awaited<ReturnType<typeof getOneLabel>>, TError, TData>
    >
    fetch?: RequestInit
  },
  queryClient?: QueryClient
): UseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>
} {
  const queryOptions = getGetOneLabelQueryOptions(id, options)

  const query = useQuery(queryOptions, queryClient) as UseQueryResult<
    TData,
    TError
  > & { queryKey: DataTag<QueryKey, TData, TError> }

  query.queryKey = queryOptions.queryKey

  return query
}

/**
 * Update a label
 * @summary Update a label
 */
export const getUpdateLabelUrl = (id: string) => {
  return `https://localhost:3001/labels/${id}`
}

export const updateLabel = async (
  id: string,
  updateLabelBody: UpdateLabelBody,
  options?: RequestInit
): Promise<UpdateLabel200> => {
  const res = await fetch(getUpdateLabelUrl(id), {
    ...options,
    method: 'PATCH',
    headers: { 'Content-Type': 'application/json', ...options?.headers },
    body: JSON.stringify(updateLabelBody)
  })

  const body = [204, 205, 304].includes(res.status) ? null : await res.text()
  const data: UpdateLabel200 = body ? JSON.parse(body) : {}

  return data
}

export const getUpdateLabelMutationOptions = <
  TError = NotFoundResponse,
  TContext = unknown
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof updateLabel>>,
    TError,
    { id: string; data: UpdateLabelBody },
    TContext
  >
  fetch?: RequestInit
}): UseMutationOptions<
  Awaited<ReturnType<typeof updateLabel>>,
  TError,
  { id: string; data: UpdateLabelBody },
  TContext
> => {
  const mutationKey = ['updateLabel']
  const { mutation: mutationOptions, fetch: fetchOptions } =
    options ?
      (
        options.mutation &&
        'mutationKey' in options.mutation &&
        options.mutation.mutationKey
      ) ?
        options
      : { ...options, mutation: { ...options.mutation, mutationKey } }
    : { mutation: { mutationKey }, fetch: undefined }

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof updateLabel>>,
    { id: string; data: UpdateLabelBody }
  > = (props) => {
    const { id, data } = props ?? {}

    return updateLabel(id, data, fetchOptions)
  }

  return { mutationFn, ...mutationOptions }
}

export type UpdateLabelMutationResult = NonNullable<
  Awaited<ReturnType<typeof updateLabel>>
>
export type UpdateLabelMutationBody = UpdateLabelBody
export type UpdateLabelMutationError = NotFoundResponse

/**
 * @summary Update a label
 */
export const useUpdateLabel = <TError = NotFoundResponse, TContext = unknown>(
  options?: {
    mutation?: UseMutationOptions<
      Awaited<ReturnType<typeof updateLabel>>,
      TError,
      { id: string; data: UpdateLabelBody },
      TContext
    >
    fetch?: RequestInit
  },
  queryClient?: QueryClient
): UseMutationResult<
  Awaited<ReturnType<typeof updateLabel>>,
  TError,
  { id: string; data: UpdateLabelBody },
  TContext
> => {
  const mutationOptions = getUpdateLabelMutationOptions(options)

  return useMutation(mutationOptions, queryClient)
}

/**
 * Create a new organization
 * @summary Create a new organization
 */
export const getCreateOrganizationUrl = () => {
  return `https://localhost:3001/organizations`
}

export const createOrganization = async (
  createOrganizationBody: CreateOrganizationBody,
  options?: RequestInit
): Promise<CreateOrganization201> => {
  const res = await fetch(getCreateOrganizationUrl(), {
    ...options,
    method: 'POST',
    headers: { 'Content-Type': 'application/json', ...options?.headers },
    body: JSON.stringify(createOrganizationBody)
  })

  const body = [204, 205, 304].includes(res.status) ? null : await res.text()
  const data: CreateOrganization201 = body ? JSON.parse(body) : {}

  return data
}

export const getCreateOrganizationMutationOptions = <
  TError = unknown,
  TContext = unknown
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof createOrganization>>,
    TError,
    { data: CreateOrganizationBody },
    TContext
  >
  fetch?: RequestInit
}): UseMutationOptions<
  Awaited<ReturnType<typeof createOrganization>>,
  TError,
  { data: CreateOrganizationBody },
  TContext
> => {
  const mutationKey = ['createOrganization']
  const { mutation: mutationOptions, fetch: fetchOptions } =
    options ?
      (
        options.mutation &&
        'mutationKey' in options.mutation &&
        options.mutation.mutationKey
      ) ?
        options
      : { ...options, mutation: { ...options.mutation, mutationKey } }
    : { mutation: { mutationKey }, fetch: undefined }

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof createOrganization>>,
    { data: CreateOrganizationBody }
  > = (props) => {
    const { data } = props ?? {}

    return createOrganization(data, fetchOptions)
  }

  return { mutationFn, ...mutationOptions }
}

export type CreateOrganizationMutationResult = NonNullable<
  Awaited<ReturnType<typeof createOrganization>>
>
export type CreateOrganizationMutationBody = CreateOrganizationBody
export type CreateOrganizationMutationError = unknown

/**
 * @summary Create a new organization
 */
export const useCreateOrganization = <TError = unknown, TContext = unknown>(
  options?: {
    mutation?: UseMutationOptions<
      Awaited<ReturnType<typeof createOrganization>>,
      TError,
      { data: CreateOrganizationBody },
      TContext
    >
    fetch?: RequestInit
  },
  queryClient?: QueryClient
): UseMutationResult<
  Awaited<ReturnType<typeof createOrganization>>,
  TError,
  { data: CreateOrganizationBody },
  TContext
> => {
  const mutationOptions = getCreateOrganizationMutationOptions(options)

  return useMutation(mutationOptions, queryClient)
}

/**
 * Find many organizations
 * @summary Find many organizations
 */
export const getFindManyOrganizationsUrl = (
  params?: FindManyOrganizationsParams
) => {
  const normalizedParams = new URLSearchParams()

  Object.entries(params || {}).forEach(([key, value]) => {
    if (value !== undefined) {
      normalizedParams.append(key, value === null ? 'null' : value.toString())
    }
  })

  const stringifiedParams = normalizedParams.toString()

  return stringifiedParams.length > 0 ?
      `https://localhost:3001/organizations?${stringifiedParams}`
    : `https://localhost:3001/organizations`
}

export const findManyOrganizations = async (
  params?: FindManyOrganizationsParams,
  options?: RequestInit
): Promise<FindManyOrganizations200> => {
  const res = await fetch(getFindManyOrganizationsUrl(params), {
    ...options,
    method: 'GET'
  })

  const body = [204, 205, 304].includes(res.status) ? null : await res.text()
  const data: FindManyOrganizations200 = body ? JSON.parse(body) : {}

  return data
}

export const getFindManyOrganizationsQueryKey = (
  params?: FindManyOrganizationsParams
) => {
  return [
    `https://localhost:3001/organizations`,
    ...(params ? [params] : [])
  ] as const
}

export const getFindManyOrganizationsQueryOptions = <
  TData = Awaited<ReturnType<typeof findManyOrganizations>>,
  TError = unknown
>(
  params?: FindManyOrganizationsParams,
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof findManyOrganizations>>,
        TError,
        TData
      >
    >
    fetch?: RequestInit
  }
) => {
  const { query: queryOptions, fetch: fetchOptions } = options ?? {}

  const queryKey =
    queryOptions?.queryKey ?? getFindManyOrganizationsQueryKey(params)

  const queryFn: QueryFunction<
    Awaited<ReturnType<typeof findManyOrganizations>>
  > = ({ signal }) =>
    findManyOrganizations(params, {
      ...(signal ? { signal } : {}),
      ...fetchOptions
    })

  return { queryKey, queryFn, ...queryOptions } as UseQueryOptions<
    Awaited<ReturnType<typeof findManyOrganizations>>,
    TError,
    TData
  > & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type FindManyOrganizationsQueryResult = NonNullable<
  Awaited<ReturnType<typeof findManyOrganizations>>
>
export type FindManyOrganizationsQueryError = unknown

export function useFindManyOrganizations<
  TData = Awaited<ReturnType<typeof findManyOrganizations>>,
  TError = unknown
>(
  params: undefined | FindManyOrganizationsParams,
  options: {
    query: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof findManyOrganizations>>,
        TError,
        TData
      >
    > &
      Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof findManyOrganizations>>,
          TError,
          Awaited<ReturnType<typeof findManyOrganizations>>
        >,
        'initialData'
      >
    fetch?: RequestInit
  },
  queryClient?: QueryClient
): DefinedUseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>
}
export function useFindManyOrganizations<
  TData = Awaited<ReturnType<typeof findManyOrganizations>>,
  TError = unknown
>(
  params?: FindManyOrganizationsParams,
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof findManyOrganizations>>,
        TError,
        TData
      >
    > &
      Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof findManyOrganizations>>,
          TError,
          Awaited<ReturnType<typeof findManyOrganizations>>
        >,
        'initialData'
      >
    fetch?: RequestInit
  },
  queryClient?: QueryClient
): UseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>
}
export function useFindManyOrganizations<
  TData = Awaited<ReturnType<typeof findManyOrganizations>>,
  TError = unknown
>(
  params?: FindManyOrganizationsParams,
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof findManyOrganizations>>,
        TError,
        TData
      >
    >
    fetch?: RequestInit
  },
  queryClient?: QueryClient
): UseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>
}
/**
 * @summary Find many organizations
 */

export function useFindManyOrganizations<
  TData = Awaited<ReturnType<typeof findManyOrganizations>>,
  TError = unknown
>(
  params?: FindManyOrganizationsParams,
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof findManyOrganizations>>,
        TError,
        TData
      >
    >
    fetch?: RequestInit
  },
  queryClient?: QueryClient
): UseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>
} {
  const queryOptions = getFindManyOrganizationsQueryOptions(params, options)

  const query = useQuery(queryOptions, queryClient) as UseQueryResult<
    TData,
    TError
  > & { queryKey: DataTag<QueryKey, TData, TError> }

  query.queryKey = queryOptions.queryKey

  return query
}

/**
 * Delete an organization
 * @summary Delete an organization
 */
export const getDeleteOrganizationUrl = (id: string) => {
  return `https://localhost:3001/organizations/${id}`
}

export const deleteOrganization = async (
  id: string,
  options?: RequestInit
): Promise<DeleteOrganization200> => {
  const res = await fetch(getDeleteOrganizationUrl(id), {
    ...options,
    method: 'DELETE'
  })

  const body = [204, 205, 304].includes(res.status) ? null : await res.text()
  const data: DeleteOrganization200 = body ? JSON.parse(body) : {}

  return data
}

export const getDeleteOrganizationMutationOptions = <
  TError = NotFoundResponse,
  TContext = unknown
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof deleteOrganization>>,
    TError,
    { id: string },
    TContext
  >
  fetch?: RequestInit
}): UseMutationOptions<
  Awaited<ReturnType<typeof deleteOrganization>>,
  TError,
  { id: string },
  TContext
> => {
  const mutationKey = ['deleteOrganization']
  const { mutation: mutationOptions, fetch: fetchOptions } =
    options ?
      (
        options.mutation &&
        'mutationKey' in options.mutation &&
        options.mutation.mutationKey
      ) ?
        options
      : { ...options, mutation: { ...options.mutation, mutationKey } }
    : { mutation: { mutationKey }, fetch: undefined }

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof deleteOrganization>>,
    { id: string }
  > = (props) => {
    const { id } = props ?? {}

    return deleteOrganization(id, fetchOptions)
  }

  return { mutationFn, ...mutationOptions }
}

export type DeleteOrganizationMutationResult = NonNullable<
  Awaited<ReturnType<typeof deleteOrganization>>
>

export type DeleteOrganizationMutationError = NotFoundResponse

/**
 * @summary Delete an organization
 */
export const useDeleteOrganization = <
  TError = NotFoundResponse,
  TContext = unknown
>(
  options?: {
    mutation?: UseMutationOptions<
      Awaited<ReturnType<typeof deleteOrganization>>,
      TError,
      { id: string },
      TContext
    >
    fetch?: RequestInit
  },
  queryClient?: QueryClient
): UseMutationResult<
  Awaited<ReturnType<typeof deleteOrganization>>,
  TError,
  { id: string },
  TContext
> => {
  const mutationOptions = getDeleteOrganizationMutationOptions(options)

  return useMutation(mutationOptions, queryClient)
}

/**
 * Find an organization
 * @summary Find an organization
 */
export const getGetOneOrganizationUrl = (id: string) => {
  return `https://localhost:3001/organizations/${id}`
}

export const getOneOrganization = async (
  id: string,
  options?: RequestInit
): Promise<GetOneOrganization200> => {
  const res = await fetch(getGetOneOrganizationUrl(id), {
    ...options,
    method: 'GET'
  })

  const body = [204, 205, 304].includes(res.status) ? null : await res.text()
  const data: GetOneOrganization200 = body ? JSON.parse(body) : {}

  return data
}

export const getGetOneOrganizationQueryKey = (id: string) => {
  return [`https://localhost:3001/organizations/${id}`] as const
}

export const getGetOneOrganizationQueryOptions = <
  TData = Awaited<ReturnType<typeof getOneOrganization>>,
  TError = NotFoundResponse
>(
  id: string,
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof getOneOrganization>>,
        TError,
        TData
      >
    >
    fetch?: RequestInit
  }
) => {
  const { query: queryOptions, fetch: fetchOptions } = options ?? {}

  const queryKey = queryOptions?.queryKey ?? getGetOneOrganizationQueryKey(id)

  const queryFn: QueryFunction<
    Awaited<ReturnType<typeof getOneOrganization>>
  > = ({ signal }) =>
    getOneOrganization(id, { ...(signal ? { signal } : {}), ...fetchOptions })

  return {
    queryKey,
    queryFn,
    enabled: !!id,
    ...queryOptions
  } as UseQueryOptions<
    Awaited<ReturnType<typeof getOneOrganization>>,
    TError,
    TData
  > & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type GetOneOrganizationQueryResult = NonNullable<
  Awaited<ReturnType<typeof getOneOrganization>>
>
export type GetOneOrganizationQueryError = NotFoundResponse

export function useGetOneOrganization<
  TData = Awaited<ReturnType<typeof getOneOrganization>>,
  TError = NotFoundResponse
>(
  id: string,
  options: {
    query: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof getOneOrganization>>,
        TError,
        TData
      >
    > &
      Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof getOneOrganization>>,
          TError,
          Awaited<ReturnType<typeof getOneOrganization>>
        >,
        'initialData'
      >
    fetch?: RequestInit
  },
  queryClient?: QueryClient
): DefinedUseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>
}
export function useGetOneOrganization<
  TData = Awaited<ReturnType<typeof getOneOrganization>>,
  TError = NotFoundResponse
>(
  id: string,
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof getOneOrganization>>,
        TError,
        TData
      >
    > &
      Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof getOneOrganization>>,
          TError,
          Awaited<ReturnType<typeof getOneOrganization>>
        >,
        'initialData'
      >
    fetch?: RequestInit
  },
  queryClient?: QueryClient
): UseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>
}
export function useGetOneOrganization<
  TData = Awaited<ReturnType<typeof getOneOrganization>>,
  TError = NotFoundResponse
>(
  id: string,
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof getOneOrganization>>,
        TError,
        TData
      >
    >
    fetch?: RequestInit
  },
  queryClient?: QueryClient
): UseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>
}
/**
 * @summary Find an organization
 */

export function useGetOneOrganization<
  TData = Awaited<ReturnType<typeof getOneOrganization>>,
  TError = NotFoundResponse
>(
  id: string,
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof getOneOrganization>>,
        TError,
        TData
      >
    >
    fetch?: RequestInit
  },
  queryClient?: QueryClient
): UseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>
} {
  const queryOptions = getGetOneOrganizationQueryOptions(id, options)

  const query = useQuery(queryOptions, queryClient) as UseQueryResult<
    TData,
    TError
  > & { queryKey: DataTag<QueryKey, TData, TError> }

  query.queryKey = queryOptions.queryKey

  return query
}

/**
 * Update an organization
 * @summary Update an organization
 */
export const getUpdateOrganizationUrl = (id: string) => {
  return `https://localhost:3001/organizations/${id}`
}

export const updateOrganization = async (
  id: string,
  updateOrganizationBody: UpdateOrganizationBody,
  options?: RequestInit
): Promise<UpdateOrganization200> => {
  const res = await fetch(getUpdateOrganizationUrl(id), {
    ...options,
    method: 'PATCH',
    headers: { 'Content-Type': 'application/json', ...options?.headers },
    body: JSON.stringify(updateOrganizationBody)
  })

  const body = [204, 205, 304].includes(res.status) ? null : await res.text()
  const data: UpdateOrganization200 = body ? JSON.parse(body) : {}

  return data
}

export const getUpdateOrganizationMutationOptions = <
  TError = NotFoundResponse,
  TContext = unknown
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof updateOrganization>>,
    TError,
    { id: string; data: UpdateOrganizationBody },
    TContext
  >
  fetch?: RequestInit
}): UseMutationOptions<
  Awaited<ReturnType<typeof updateOrganization>>,
  TError,
  { id: string; data: UpdateOrganizationBody },
  TContext
> => {
  const mutationKey = ['updateOrganization']
  const { mutation: mutationOptions, fetch: fetchOptions } =
    options ?
      (
        options.mutation &&
        'mutationKey' in options.mutation &&
        options.mutation.mutationKey
      ) ?
        options
      : { ...options, mutation: { ...options.mutation, mutationKey } }
    : { mutation: { mutationKey }, fetch: undefined }

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof updateOrganization>>,
    { id: string; data: UpdateOrganizationBody }
  > = (props) => {
    const { id, data } = props ?? {}

    return updateOrganization(id, data, fetchOptions)
  }

  return { mutationFn, ...mutationOptions }
}

export type UpdateOrganizationMutationResult = NonNullable<
  Awaited<ReturnType<typeof updateOrganization>>
>
export type UpdateOrganizationMutationBody = UpdateOrganizationBody
export type UpdateOrganizationMutationError = NotFoundResponse

/**
 * @summary Update an organization
 */
export const useUpdateOrganization = <
  TError = NotFoundResponse,
  TContext = unknown
>(
  options?: {
    mutation?: UseMutationOptions<
      Awaited<ReturnType<typeof updateOrganization>>,
      TError,
      { id: string; data: UpdateOrganizationBody },
      TContext
    >
    fetch?: RequestInit
  },
  queryClient?: QueryClient
): UseMutationResult<
  Awaited<ReturnType<typeof updateOrganization>>,
  TError,
  { id: string; data: UpdateOrganizationBody },
  TContext
> => {
  const mutationOptions = getUpdateOrganizationMutationOptions(options)

  return useMutation(mutationOptions, queryClient)
}

/**
 * Create a new user
 * @summary Create a new user
 */
export const getCreateUserUrl = () => {
  return `https://localhost:3001/users`
}

export const createUser = async (
  createUserBody: CreateUserBody,
  options?: RequestInit
): Promise<CreateUser201> => {
  const res = await fetch(getCreateUserUrl(), {
    ...options,
    method: 'POST',
    headers: { 'Content-Type': 'application/json', ...options?.headers },
    body: JSON.stringify(createUserBody)
  })

  const body = [204, 205, 304].includes(res.status) ? null : await res.text()
  const data: CreateUser201 = body ? JSON.parse(body) : {}

  return data
}

export const getCreateUserMutationOptions = <
  TError = unknown,
  TContext = unknown
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof createUser>>,
    TError,
    { data: CreateUserBody },
    TContext
  >
  fetch?: RequestInit
}): UseMutationOptions<
  Awaited<ReturnType<typeof createUser>>,
  TError,
  { data: CreateUserBody },
  TContext
> => {
  const mutationKey = ['createUser']
  const { mutation: mutationOptions, fetch: fetchOptions } =
    options ?
      (
        options.mutation &&
        'mutationKey' in options.mutation &&
        options.mutation.mutationKey
      ) ?
        options
      : { ...options, mutation: { ...options.mutation, mutationKey } }
    : { mutation: { mutationKey }, fetch: undefined }

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof createUser>>,
    { data: CreateUserBody }
  > = (props) => {
    const { data } = props ?? {}

    return createUser(data, fetchOptions)
  }

  return { mutationFn, ...mutationOptions }
}

export type CreateUserMutationResult = NonNullable<
  Awaited<ReturnType<typeof createUser>>
>
export type CreateUserMutationBody = CreateUserBody
export type CreateUserMutationError = unknown

/**
 * @summary Create a new user
 */
export const useCreateUser = <TError = unknown, TContext = unknown>(
  options?: {
    mutation?: UseMutationOptions<
      Awaited<ReturnType<typeof createUser>>,
      TError,
      { data: CreateUserBody },
      TContext
    >
    fetch?: RequestInit
  },
  queryClient?: QueryClient
): UseMutationResult<
  Awaited<ReturnType<typeof createUser>>,
  TError,
  { data: CreateUserBody },
  TContext
> => {
  const mutationOptions = getCreateUserMutationOptions(options)

  return useMutation(mutationOptions, queryClient)
}

/**
 * Find many users
 * @summary Find many users
 */
export const getFindManyUsersUrl = (params?: FindManyUsersParams) => {
  const normalizedParams = new URLSearchParams()

  Object.entries(params || {}).forEach(([key, value]) => {
    if (value !== undefined) {
      normalizedParams.append(key, value === null ? 'null' : value.toString())
    }
  })

  const stringifiedParams = normalizedParams.toString()

  return stringifiedParams.length > 0 ?
      `https://localhost:3001/users?${stringifiedParams}`
    : `https://localhost:3001/users`
}

export const findManyUsers = async (
  params?: FindManyUsersParams,
  options?: RequestInit
): Promise<FindManyUsers200> => {
  const res = await fetch(getFindManyUsersUrl(params), {
    ...options,
    method: 'GET'
  })

  const body = [204, 205, 304].includes(res.status) ? null : await res.text()
  const data: FindManyUsers200 = body ? JSON.parse(body) : {}

  return data
}

export const getFindManyUsersQueryKey = (params?: FindManyUsersParams) => {
  return [`https://localhost:3001/users`, ...(params ? [params] : [])] as const
}

export const getFindManyUsersQueryOptions = <
  TData = Awaited<ReturnType<typeof findManyUsers>>,
  TError = unknown
>(
  params?: FindManyUsersParams,
  options?: {
    query?: Partial<
      UseQueryOptions<Awaited<ReturnType<typeof findManyUsers>>, TError, TData>
    >
    fetch?: RequestInit
  }
) => {
  const { query: queryOptions, fetch: fetchOptions } = options ?? {}

  const queryKey = queryOptions?.queryKey ?? getFindManyUsersQueryKey(params)

  const queryFn: QueryFunction<Awaited<ReturnType<typeof findManyUsers>>> = ({
    signal
  }) =>
    findManyUsers(params, { ...(signal ? { signal } : {}), ...fetchOptions })

  return { queryKey, queryFn, ...queryOptions } as UseQueryOptions<
    Awaited<ReturnType<typeof findManyUsers>>,
    TError,
    TData
  > & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type FindManyUsersQueryResult = NonNullable<
  Awaited<ReturnType<typeof findManyUsers>>
>
export type FindManyUsersQueryError = unknown

export function useFindManyUsers<
  TData = Awaited<ReturnType<typeof findManyUsers>>,
  TError = unknown
>(
  params: undefined | FindManyUsersParams,
  options: {
    query: Partial<
      UseQueryOptions<Awaited<ReturnType<typeof findManyUsers>>, TError, TData>
    > &
      Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof findManyUsers>>,
          TError,
          Awaited<ReturnType<typeof findManyUsers>>
        >,
        'initialData'
      >
    fetch?: RequestInit
  },
  queryClient?: QueryClient
): DefinedUseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>
}
export function useFindManyUsers<
  TData = Awaited<ReturnType<typeof findManyUsers>>,
  TError = unknown
>(
  params?: FindManyUsersParams,
  options?: {
    query?: Partial<
      UseQueryOptions<Awaited<ReturnType<typeof findManyUsers>>, TError, TData>
    > &
      Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof findManyUsers>>,
          TError,
          Awaited<ReturnType<typeof findManyUsers>>
        >,
        'initialData'
      >
    fetch?: RequestInit
  },
  queryClient?: QueryClient
): UseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>
}
export function useFindManyUsers<
  TData = Awaited<ReturnType<typeof findManyUsers>>,
  TError = unknown
>(
  params?: FindManyUsersParams,
  options?: {
    query?: Partial<
      UseQueryOptions<Awaited<ReturnType<typeof findManyUsers>>, TError, TData>
    >
    fetch?: RequestInit
  },
  queryClient?: QueryClient
): UseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>
}
/**
 * @summary Find many users
 */

export function useFindManyUsers<
  TData = Awaited<ReturnType<typeof findManyUsers>>,
  TError = unknown
>(
  params?: FindManyUsersParams,
  options?: {
    query?: Partial<
      UseQueryOptions<Awaited<ReturnType<typeof findManyUsers>>, TError, TData>
    >
    fetch?: RequestInit
  },
  queryClient?: QueryClient
): UseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>
} {
  const queryOptions = getFindManyUsersQueryOptions(params, options)

  const query = useQuery(queryOptions, queryClient) as UseQueryResult<
    TData,
    TError
  > & { queryKey: DataTag<QueryKey, TData, TError> }

  query.queryKey = queryOptions.queryKey

  return query
}

/**
 * Delete an user
 * @summary Delete an user
 */
export const getDeleteUserUrl = (id: string) => {
  return `https://localhost:3001/users/${id}`
}

export const deleteUser = async (
  id: string,
  options?: RequestInit
): Promise<DeleteUser200> => {
  const res = await fetch(getDeleteUserUrl(id), {
    ...options,
    method: 'DELETE'
  })

  const body = [204, 205, 304].includes(res.status) ? null : await res.text()
  const data: DeleteUser200 = body ? JSON.parse(body) : {}

  return data
}

export const getDeleteUserMutationOptions = <
  TError = NotFoundResponse,
  TContext = unknown
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof deleteUser>>,
    TError,
    { id: string },
    TContext
  >
  fetch?: RequestInit
}): UseMutationOptions<
  Awaited<ReturnType<typeof deleteUser>>,
  TError,
  { id: string },
  TContext
> => {
  const mutationKey = ['deleteUser']
  const { mutation: mutationOptions, fetch: fetchOptions } =
    options ?
      (
        options.mutation &&
        'mutationKey' in options.mutation &&
        options.mutation.mutationKey
      ) ?
        options
      : { ...options, mutation: { ...options.mutation, mutationKey } }
    : { mutation: { mutationKey }, fetch: undefined }

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof deleteUser>>,
    { id: string }
  > = (props) => {
    const { id } = props ?? {}

    return deleteUser(id, fetchOptions)
  }

  return { mutationFn, ...mutationOptions }
}

export type DeleteUserMutationResult = NonNullable<
  Awaited<ReturnType<typeof deleteUser>>
>

export type DeleteUserMutationError = NotFoundResponse

/**
 * @summary Delete an user
 */
export const useDeleteUser = <TError = NotFoundResponse, TContext = unknown>(
  options?: {
    mutation?: UseMutationOptions<
      Awaited<ReturnType<typeof deleteUser>>,
      TError,
      { id: string },
      TContext
    >
    fetch?: RequestInit
  },
  queryClient?: QueryClient
): UseMutationResult<
  Awaited<ReturnType<typeof deleteUser>>,
  TError,
  { id: string },
  TContext
> => {
  const mutationOptions = getDeleteUserMutationOptions(options)

  return useMutation(mutationOptions, queryClient)
}

/**
 * Find an user
 * @summary Find an user
 */
export const getGetOneUserUrl = (id: string) => {
  return `https://localhost:3001/users/${id}`
}

export const getOneUser = async (
  id: string,
  options?: RequestInit
): Promise<GetOneUser200> => {
  const res = await fetch(getGetOneUserUrl(id), {
    ...options,
    method: 'GET'
  })

  const body = [204, 205, 304].includes(res.status) ? null : await res.text()
  const data: GetOneUser200 = body ? JSON.parse(body) : {}

  return data
}

export const getGetOneUserQueryKey = (id: string) => {
  return [`https://localhost:3001/users/${id}`] as const
}

export const getGetOneUserQueryOptions = <
  TData = Awaited<ReturnType<typeof getOneUser>>,
  TError = NotFoundResponse
>(
  id: string,
  options?: {
    query?: Partial<
      UseQueryOptions<Awaited<ReturnType<typeof getOneUser>>, TError, TData>
    >
    fetch?: RequestInit
  }
) => {
  const { query: queryOptions, fetch: fetchOptions } = options ?? {}

  const queryKey = queryOptions?.queryKey ?? getGetOneUserQueryKey(id)

  const queryFn: QueryFunction<Awaited<ReturnType<typeof getOneUser>>> = ({
    signal
  }) => getOneUser(id, { ...(signal ? { signal } : {}), ...fetchOptions })

  return {
    queryKey,
    queryFn,
    enabled: !!id,
    ...queryOptions
  } as UseQueryOptions<
    Awaited<ReturnType<typeof getOneUser>>,
    TError,
    TData
  > & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type GetOneUserQueryResult = NonNullable<
  Awaited<ReturnType<typeof getOneUser>>
>
export type GetOneUserQueryError = NotFoundResponse

export function useGetOneUser<
  TData = Awaited<ReturnType<typeof getOneUser>>,
  TError = NotFoundResponse
>(
  id: string,
  options: {
    query: Partial<
      UseQueryOptions<Awaited<ReturnType<typeof getOneUser>>, TError, TData>
    > &
      Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof getOneUser>>,
          TError,
          Awaited<ReturnType<typeof getOneUser>>
        >,
        'initialData'
      >
    fetch?: RequestInit
  },
  queryClient?: QueryClient
): DefinedUseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>
}
export function useGetOneUser<
  TData = Awaited<ReturnType<typeof getOneUser>>,
  TError = NotFoundResponse
>(
  id: string,
  options?: {
    query?: Partial<
      UseQueryOptions<Awaited<ReturnType<typeof getOneUser>>, TError, TData>
    > &
      Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof getOneUser>>,
          TError,
          Awaited<ReturnType<typeof getOneUser>>
        >,
        'initialData'
      >
    fetch?: RequestInit
  },
  queryClient?: QueryClient
): UseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>
}
export function useGetOneUser<
  TData = Awaited<ReturnType<typeof getOneUser>>,
  TError = NotFoundResponse
>(
  id: string,
  options?: {
    query?: Partial<
      UseQueryOptions<Awaited<ReturnType<typeof getOneUser>>, TError, TData>
    >
    fetch?: RequestInit
  },
  queryClient?: QueryClient
): UseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>
}
/**
 * @summary Find an user
 */

export function useGetOneUser<
  TData = Awaited<ReturnType<typeof getOneUser>>,
  TError = NotFoundResponse
>(
  id: string,
  options?: {
    query?: Partial<
      UseQueryOptions<Awaited<ReturnType<typeof getOneUser>>, TError, TData>
    >
    fetch?: RequestInit
  },
  queryClient?: QueryClient
): UseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>
} {
  const queryOptions = getGetOneUserQueryOptions(id, options)

  const query = useQuery(queryOptions, queryClient) as UseQueryResult<
    TData,
    TError
  > & { queryKey: DataTag<QueryKey, TData, TError> }

  query.queryKey = queryOptions.queryKey

  return query
}

/**
 * Update an user
 * @summary Update an user
 */
export const getUpdateUserUrl = (id: string) => {
  return `https://localhost:3001/users/${id}`
}

export const updateUser = async (
  id: string,
  updateUserBody: UpdateUserBody,
  options?: RequestInit
): Promise<UpdateUser200> => {
  const res = await fetch(getUpdateUserUrl(id), {
    ...options,
    method: 'PATCH',
    headers: { 'Content-Type': 'application/json', ...options?.headers },
    body: JSON.stringify(updateUserBody)
  })

  const body = [204, 205, 304].includes(res.status) ? null : await res.text()
  const data: UpdateUser200 = body ? JSON.parse(body) : {}

  return data
}

export const getUpdateUserMutationOptions = <
  TError = NotFoundResponse,
  TContext = unknown
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof updateUser>>,
    TError,
    { id: string; data: UpdateUserBody },
    TContext
  >
  fetch?: RequestInit
}): UseMutationOptions<
  Awaited<ReturnType<typeof updateUser>>,
  TError,
  { id: string; data: UpdateUserBody },
  TContext
> => {
  const mutationKey = ['updateUser']
  const { mutation: mutationOptions, fetch: fetchOptions } =
    options ?
      (
        options.mutation &&
        'mutationKey' in options.mutation &&
        options.mutation.mutationKey
      ) ?
        options
      : { ...options, mutation: { ...options.mutation, mutationKey } }
    : { mutation: { mutationKey }, fetch: undefined }

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof updateUser>>,
    { id: string; data: UpdateUserBody }
  > = (props) => {
    const { id, data } = props ?? {}

    return updateUser(id, data, fetchOptions)
  }

  return { mutationFn, ...mutationOptions }
}

export type UpdateUserMutationResult = NonNullable<
  Awaited<ReturnType<typeof updateUser>>
>
export type UpdateUserMutationBody = UpdateUserBody
export type UpdateUserMutationError = NotFoundResponse

/**
 * @summary Update an user
 */
export const useUpdateUser = <TError = NotFoundResponse, TContext = unknown>(
  options?: {
    mutation?: UseMutationOptions<
      Awaited<ReturnType<typeof updateUser>>,
      TError,
      { id: string; data: UpdateUserBody },
      TContext
    >
    fetch?: RequestInit
  },
  queryClient?: QueryClient
): UseMutationResult<
  Awaited<ReturnType<typeof updateUser>>,
  TError,
  { id: string; data: UpdateUserBody },
  TContext
> => {
  const mutationOptions = getUpdateUserMutationOptions(options)

  return useMutation(mutationOptions, queryClient)
}

/**
 * Create a new member
 * @summary Create a new member
 */
export const getCreateMemberUrl = () => {
  return `https://localhost:3001/members`
}

export const createMember = async (
  createMemberBody: CreateMemberBody,
  options?: RequestInit
): Promise<CreateMember201> => {
  const res = await fetch(getCreateMemberUrl(), {
    ...options,
    method: 'POST',
    headers: { 'Content-Type': 'application/json', ...options?.headers },
    body: JSON.stringify(createMemberBody)
  })

  const body = [204, 205, 304].includes(res.status) ? null : await res.text()
  const data: CreateMember201 = body ? JSON.parse(body) : {}

  return data
}

export const getCreateMemberMutationOptions = <
  TError = unknown,
  TContext = unknown
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof createMember>>,
    TError,
    { data: CreateMemberBody },
    TContext
  >
  fetch?: RequestInit
}): UseMutationOptions<
  Awaited<ReturnType<typeof createMember>>,
  TError,
  { data: CreateMemberBody },
  TContext
> => {
  const mutationKey = ['createMember']
  const { mutation: mutationOptions, fetch: fetchOptions } =
    options ?
      (
        options.mutation &&
        'mutationKey' in options.mutation &&
        options.mutation.mutationKey
      ) ?
        options
      : { ...options, mutation: { ...options.mutation, mutationKey } }
    : { mutation: { mutationKey }, fetch: undefined }

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof createMember>>,
    { data: CreateMemberBody }
  > = (props) => {
    const { data } = props ?? {}

    return createMember(data, fetchOptions)
  }

  return { mutationFn, ...mutationOptions }
}

export type CreateMemberMutationResult = NonNullable<
  Awaited<ReturnType<typeof createMember>>
>
export type CreateMemberMutationBody = CreateMemberBody
export type CreateMemberMutationError = unknown

/**
 * @summary Create a new member
 */
export const useCreateMember = <TError = unknown, TContext = unknown>(
  options?: {
    mutation?: UseMutationOptions<
      Awaited<ReturnType<typeof createMember>>,
      TError,
      { data: CreateMemberBody },
      TContext
    >
    fetch?: RequestInit
  },
  queryClient?: QueryClient
): UseMutationResult<
  Awaited<ReturnType<typeof createMember>>,
  TError,
  { data: CreateMemberBody },
  TContext
> => {
  const mutationOptions = getCreateMemberMutationOptions(options)

  return useMutation(mutationOptions, queryClient)
}

/**
 * Find many members
 * @summary Find many members
 */
export const getFindManyMembersUrl = (params?: FindManyMembersParams) => {
  const normalizedParams = new URLSearchParams()

  Object.entries(params || {}).forEach(([key, value]) => {
    if (value !== undefined) {
      normalizedParams.append(key, value === null ? 'null' : value.toString())
    }
  })

  const stringifiedParams = normalizedParams.toString()

  return stringifiedParams.length > 0 ?
      `https://localhost:3001/members?${stringifiedParams}`
    : `https://localhost:3001/members`
}

export const findManyMembers = async (
  params?: FindManyMembersParams,
  options?: RequestInit
): Promise<FindManyMembers200> => {
  const res = await fetch(getFindManyMembersUrl(params), {
    ...options,
    method: 'GET'
  })

  const body = [204, 205, 304].includes(res.status) ? null : await res.text()
  const data: FindManyMembers200 = body ? JSON.parse(body) : {}

  return data
}

export const getFindManyMembersQueryKey = (params?: FindManyMembersParams) => {
  return [
    `https://localhost:3001/members`,
    ...(params ? [params] : [])
  ] as const
}

export const getFindManyMembersQueryOptions = <
  TData = Awaited<ReturnType<typeof findManyMembers>>,
  TError = unknown
>(
  params?: FindManyMembersParams,
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof findManyMembers>>,
        TError,
        TData
      >
    >
    fetch?: RequestInit
  }
) => {
  const { query: queryOptions, fetch: fetchOptions } = options ?? {}

  const queryKey = queryOptions?.queryKey ?? getFindManyMembersQueryKey(params)

  const queryFn: QueryFunction<Awaited<ReturnType<typeof findManyMembers>>> = ({
    signal
  }) =>
    findManyMembers(params, { ...(signal ? { signal } : {}), ...fetchOptions })

  return { queryKey, queryFn, ...queryOptions } as UseQueryOptions<
    Awaited<ReturnType<typeof findManyMembers>>,
    TError,
    TData
  > & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type FindManyMembersQueryResult = NonNullable<
  Awaited<ReturnType<typeof findManyMembers>>
>
export type FindManyMembersQueryError = unknown

export function useFindManyMembers<
  TData = Awaited<ReturnType<typeof findManyMembers>>,
  TError = unknown
>(
  params: undefined | FindManyMembersParams,
  options: {
    query: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof findManyMembers>>,
        TError,
        TData
      >
    > &
      Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof findManyMembers>>,
          TError,
          Awaited<ReturnType<typeof findManyMembers>>
        >,
        'initialData'
      >
    fetch?: RequestInit
  },
  queryClient?: QueryClient
): DefinedUseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>
}
export function useFindManyMembers<
  TData = Awaited<ReturnType<typeof findManyMembers>>,
  TError = unknown
>(
  params?: FindManyMembersParams,
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof findManyMembers>>,
        TError,
        TData
      >
    > &
      Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof findManyMembers>>,
          TError,
          Awaited<ReturnType<typeof findManyMembers>>
        >,
        'initialData'
      >
    fetch?: RequestInit
  },
  queryClient?: QueryClient
): UseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>
}
export function useFindManyMembers<
  TData = Awaited<ReturnType<typeof findManyMembers>>,
  TError = unknown
>(
  params?: FindManyMembersParams,
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof findManyMembers>>,
        TError,
        TData
      >
    >
    fetch?: RequestInit
  },
  queryClient?: QueryClient
): UseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>
}
/**
 * @summary Find many members
 */

export function useFindManyMembers<
  TData = Awaited<ReturnType<typeof findManyMembers>>,
  TError = unknown
>(
  params?: FindManyMembersParams,
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof findManyMembers>>,
        TError,
        TData
      >
    >
    fetch?: RequestInit
  },
  queryClient?: QueryClient
): UseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>
} {
  const queryOptions = getFindManyMembersQueryOptions(params, options)

  const query = useQuery(queryOptions, queryClient) as UseQueryResult<
    TData,
    TError
  > & { queryKey: DataTag<QueryKey, TData, TError> }

  query.queryKey = queryOptions.queryKey

  return query
}

/**
 * Delete a member
 * @summary Delete a member
 */
export const getDeleteMemberUrl = (id: string) => {
  return `https://localhost:3001/members/${id}`
}

export const deleteMember = async (
  id: string,
  options?: RequestInit
): Promise<DeleteMember200> => {
  const res = await fetch(getDeleteMemberUrl(id), {
    ...options,
    method: 'DELETE'
  })

  const body = [204, 205, 304].includes(res.status) ? null : await res.text()
  const data: DeleteMember200 = body ? JSON.parse(body) : {}

  return data
}

export const getDeleteMemberMutationOptions = <
  TError = NotFoundResponse,
  TContext = unknown
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof deleteMember>>,
    TError,
    { id: string },
    TContext
  >
  fetch?: RequestInit
}): UseMutationOptions<
  Awaited<ReturnType<typeof deleteMember>>,
  TError,
  { id: string },
  TContext
> => {
  const mutationKey = ['deleteMember']
  const { mutation: mutationOptions, fetch: fetchOptions } =
    options ?
      (
        options.mutation &&
        'mutationKey' in options.mutation &&
        options.mutation.mutationKey
      ) ?
        options
      : { ...options, mutation: { ...options.mutation, mutationKey } }
    : { mutation: { mutationKey }, fetch: undefined }

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof deleteMember>>,
    { id: string }
  > = (props) => {
    const { id } = props ?? {}

    return deleteMember(id, fetchOptions)
  }

  return { mutationFn, ...mutationOptions }
}

export type DeleteMemberMutationResult = NonNullable<
  Awaited<ReturnType<typeof deleteMember>>
>

export type DeleteMemberMutationError = NotFoundResponse

/**
 * @summary Delete a member
 */
export const useDeleteMember = <TError = NotFoundResponse, TContext = unknown>(
  options?: {
    mutation?: UseMutationOptions<
      Awaited<ReturnType<typeof deleteMember>>,
      TError,
      { id: string },
      TContext
    >
    fetch?: RequestInit
  },
  queryClient?: QueryClient
): UseMutationResult<
  Awaited<ReturnType<typeof deleteMember>>,
  TError,
  { id: string },
  TContext
> => {
  const mutationOptions = getDeleteMemberMutationOptions(options)

  return useMutation(mutationOptions, queryClient)
}

/**
 * Find a member
 * @summary Find a member
 */
export const getGetOneMemberUrl = (id: string) => {
  return `https://localhost:3001/members/${id}`
}

export const getOneMember = async (
  id: string,
  options?: RequestInit
): Promise<GetOneMember200> => {
  const res = await fetch(getGetOneMemberUrl(id), {
    ...options,
    method: 'GET'
  })

  const body = [204, 205, 304].includes(res.status) ? null : await res.text()
  const data: GetOneMember200 = body ? JSON.parse(body) : {}

  return data
}

export const getGetOneMemberQueryKey = (id: string) => {
  return [`https://localhost:3001/members/${id}`] as const
}

export const getGetOneMemberQueryOptions = <
  TData = Awaited<ReturnType<typeof getOneMember>>,
  TError = NotFoundResponse
>(
  id: string,
  options?: {
    query?: Partial<
      UseQueryOptions<Awaited<ReturnType<typeof getOneMember>>, TError, TData>
    >
    fetch?: RequestInit
  }
) => {
  const { query: queryOptions, fetch: fetchOptions } = options ?? {}

  const queryKey = queryOptions?.queryKey ?? getGetOneMemberQueryKey(id)

  const queryFn: QueryFunction<Awaited<ReturnType<typeof getOneMember>>> = ({
    signal
  }) => getOneMember(id, { ...(signal ? { signal } : {}), ...fetchOptions })

  return {
    queryKey,
    queryFn,
    enabled: !!id,
    ...queryOptions
  } as UseQueryOptions<
    Awaited<ReturnType<typeof getOneMember>>,
    TError,
    TData
  > & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type GetOneMemberQueryResult = NonNullable<
  Awaited<ReturnType<typeof getOneMember>>
>
export type GetOneMemberQueryError = NotFoundResponse

export function useGetOneMember<
  TData = Awaited<ReturnType<typeof getOneMember>>,
  TError = NotFoundResponse
>(
  id: string,
  options: {
    query: Partial<
      UseQueryOptions<Awaited<ReturnType<typeof getOneMember>>, TError, TData>
    > &
      Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof getOneMember>>,
          TError,
          Awaited<ReturnType<typeof getOneMember>>
        >,
        'initialData'
      >
    fetch?: RequestInit
  },
  queryClient?: QueryClient
): DefinedUseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>
}
export function useGetOneMember<
  TData = Awaited<ReturnType<typeof getOneMember>>,
  TError = NotFoundResponse
>(
  id: string,
  options?: {
    query?: Partial<
      UseQueryOptions<Awaited<ReturnType<typeof getOneMember>>, TError, TData>
    > &
      Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof getOneMember>>,
          TError,
          Awaited<ReturnType<typeof getOneMember>>
        >,
        'initialData'
      >
    fetch?: RequestInit
  },
  queryClient?: QueryClient
): UseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>
}
export function useGetOneMember<
  TData = Awaited<ReturnType<typeof getOneMember>>,
  TError = NotFoundResponse
>(
  id: string,
  options?: {
    query?: Partial<
      UseQueryOptions<Awaited<ReturnType<typeof getOneMember>>, TError, TData>
    >
    fetch?: RequestInit
  },
  queryClient?: QueryClient
): UseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>
}
/**
 * @summary Find a member
 */

export function useGetOneMember<
  TData = Awaited<ReturnType<typeof getOneMember>>,
  TError = NotFoundResponse
>(
  id: string,
  options?: {
    query?: Partial<
      UseQueryOptions<Awaited<ReturnType<typeof getOneMember>>, TError, TData>
    >
    fetch?: RequestInit
  },
  queryClient?: QueryClient
): UseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>
} {
  const queryOptions = getGetOneMemberQueryOptions(id, options)

  const query = useQuery(queryOptions, queryClient) as UseQueryResult<
    TData,
    TError
  > & { queryKey: DataTag<QueryKey, TData, TError> }

  query.queryKey = queryOptions.queryKey

  return query
}

/**
 * Update a member
 * @summary Update a member
 */
export const getUpdateMemberUrl = (id: string) => {
  return `https://localhost:3001/members/${id}`
}

export const updateMember = async (
  id: string,
  updateMemberBody: UpdateMemberBody,
  options?: RequestInit
): Promise<UpdateMember200> => {
  const res = await fetch(getUpdateMemberUrl(id), {
    ...options,
    method: 'PATCH',
    headers: { 'Content-Type': 'application/json', ...options?.headers },
    body: JSON.stringify(updateMemberBody)
  })

  const body = [204, 205, 304].includes(res.status) ? null : await res.text()
  const data: UpdateMember200 = body ? JSON.parse(body) : {}

  return data
}

export const getUpdateMemberMutationOptions = <
  TError = NotFoundResponse,
  TContext = unknown
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof updateMember>>,
    TError,
    { id: string; data: UpdateMemberBody },
    TContext
  >
  fetch?: RequestInit
}): UseMutationOptions<
  Awaited<ReturnType<typeof updateMember>>,
  TError,
  { id: string; data: UpdateMemberBody },
  TContext
> => {
  const mutationKey = ['updateMember']
  const { mutation: mutationOptions, fetch: fetchOptions } =
    options ?
      (
        options.mutation &&
        'mutationKey' in options.mutation &&
        options.mutation.mutationKey
      ) ?
        options
      : { ...options, mutation: { ...options.mutation, mutationKey } }
    : { mutation: { mutationKey }, fetch: undefined }

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof updateMember>>,
    { id: string; data: UpdateMemberBody }
  > = (props) => {
    const { id, data } = props ?? {}

    return updateMember(id, data, fetchOptions)
  }

  return { mutationFn, ...mutationOptions }
}

export type UpdateMemberMutationResult = NonNullable<
  Awaited<ReturnType<typeof updateMember>>
>
export type UpdateMemberMutationBody = UpdateMemberBody
export type UpdateMemberMutationError = NotFoundResponse

/**
 * @summary Update a member
 */
export const useUpdateMember = <TError = NotFoundResponse, TContext = unknown>(
  options?: {
    mutation?: UseMutationOptions<
      Awaited<ReturnType<typeof updateMember>>,
      TError,
      { id: string; data: UpdateMemberBody },
      TContext
    >
    fetch?: RequestInit
  },
  queryClient?: QueryClient
): UseMutationResult<
  Awaited<ReturnType<typeof updateMember>>,
  TError,
  { id: string; data: UpdateMemberBody },
  TContext
> => {
  const mutationOptions = getUpdateMemberMutationOptions(options)

  return useMutation(mutationOptions, queryClient)
}

/**
 * Create a new invitation
 * @summary Create a new invitation
 */
export const getCreateInvitationUrl = () => {
  return `https://localhost:3001/invitations`
}

export const createInvitation = async (
  createInvitationBody: CreateInvitationBody,
  options?: RequestInit
): Promise<CreateInvitation201> => {
  const res = await fetch(getCreateInvitationUrl(), {
    ...options,
    method: 'POST',
    headers: { 'Content-Type': 'application/json', ...options?.headers },
    body: JSON.stringify(createInvitationBody)
  })

  const body = [204, 205, 304].includes(res.status) ? null : await res.text()
  const data: CreateInvitation201 = body ? JSON.parse(body) : {}

  return data
}

export const getCreateInvitationMutationOptions = <
  TError = unknown,
  TContext = unknown
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof createInvitation>>,
    TError,
    { data: CreateInvitationBody },
    TContext
  >
  fetch?: RequestInit
}): UseMutationOptions<
  Awaited<ReturnType<typeof createInvitation>>,
  TError,
  { data: CreateInvitationBody },
  TContext
> => {
  const mutationKey = ['createInvitation']
  const { mutation: mutationOptions, fetch: fetchOptions } =
    options ?
      (
        options.mutation &&
        'mutationKey' in options.mutation &&
        options.mutation.mutationKey
      ) ?
        options
      : { ...options, mutation: { ...options.mutation, mutationKey } }
    : { mutation: { mutationKey }, fetch: undefined }

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof createInvitation>>,
    { data: CreateInvitationBody }
  > = (props) => {
    const { data } = props ?? {}

    return createInvitation(data, fetchOptions)
  }

  return { mutationFn, ...mutationOptions }
}

export type CreateInvitationMutationResult = NonNullable<
  Awaited<ReturnType<typeof createInvitation>>
>
export type CreateInvitationMutationBody = CreateInvitationBody
export type CreateInvitationMutationError = unknown

/**
 * @summary Create a new invitation
 */
export const useCreateInvitation = <TError = unknown, TContext = unknown>(
  options?: {
    mutation?: UseMutationOptions<
      Awaited<ReturnType<typeof createInvitation>>,
      TError,
      { data: CreateInvitationBody },
      TContext
    >
    fetch?: RequestInit
  },
  queryClient?: QueryClient
): UseMutationResult<
  Awaited<ReturnType<typeof createInvitation>>,
  TError,
  { data: CreateInvitationBody },
  TContext
> => {
  const mutationOptions = getCreateInvitationMutationOptions(options)

  return useMutation(mutationOptions, queryClient)
}

/**
 * Find many invitations
 * @summary Find many invitations
 */
export const getFindManyInvitationsUrl = (
  params?: FindManyInvitationsParams
) => {
  const normalizedParams = new URLSearchParams()

  Object.entries(params || {}).forEach(([key, value]) => {
    if (value !== undefined) {
      normalizedParams.append(key, value === null ? 'null' : value.toString())
    }
  })

  const stringifiedParams = normalizedParams.toString()

  return stringifiedParams.length > 0 ?
      `https://localhost:3001/invitations?${stringifiedParams}`
    : `https://localhost:3001/invitations`
}

export const findManyInvitations = async (
  params?: FindManyInvitationsParams,
  options?: RequestInit
): Promise<FindManyInvitations200> => {
  const res = await fetch(getFindManyInvitationsUrl(params), {
    ...options,
    method: 'GET'
  })

  const body = [204, 205, 304].includes(res.status) ? null : await res.text()
  const data: FindManyInvitations200 = body ? JSON.parse(body) : {}

  return data
}

export const getFindManyInvitationsQueryKey = (
  params?: FindManyInvitationsParams
) => {
  return [
    `https://localhost:3001/invitations`,
    ...(params ? [params] : [])
  ] as const
}

export const getFindManyInvitationsQueryOptions = <
  TData = Awaited<ReturnType<typeof findManyInvitations>>,
  TError = unknown
>(
  params?: FindManyInvitationsParams,
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof findManyInvitations>>,
        TError,
        TData
      >
    >
    fetch?: RequestInit
  }
) => {
  const { query: queryOptions, fetch: fetchOptions } = options ?? {}

  const queryKey =
    queryOptions?.queryKey ?? getFindManyInvitationsQueryKey(params)

  const queryFn: QueryFunction<
    Awaited<ReturnType<typeof findManyInvitations>>
  > = ({ signal }) =>
    findManyInvitations(params, {
      ...(signal ? { signal } : {}),
      ...fetchOptions
    })

  return { queryKey, queryFn, ...queryOptions } as UseQueryOptions<
    Awaited<ReturnType<typeof findManyInvitations>>,
    TError,
    TData
  > & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type FindManyInvitationsQueryResult = NonNullable<
  Awaited<ReturnType<typeof findManyInvitations>>
>
export type FindManyInvitationsQueryError = unknown

export function useFindManyInvitations<
  TData = Awaited<ReturnType<typeof findManyInvitations>>,
  TError = unknown
>(
  params: undefined | FindManyInvitationsParams,
  options: {
    query: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof findManyInvitations>>,
        TError,
        TData
      >
    > &
      Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof findManyInvitations>>,
          TError,
          Awaited<ReturnType<typeof findManyInvitations>>
        >,
        'initialData'
      >
    fetch?: RequestInit
  },
  queryClient?: QueryClient
): DefinedUseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>
}
export function useFindManyInvitations<
  TData = Awaited<ReturnType<typeof findManyInvitations>>,
  TError = unknown
>(
  params?: FindManyInvitationsParams,
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof findManyInvitations>>,
        TError,
        TData
      >
    > &
      Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof findManyInvitations>>,
          TError,
          Awaited<ReturnType<typeof findManyInvitations>>
        >,
        'initialData'
      >
    fetch?: RequestInit
  },
  queryClient?: QueryClient
): UseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>
}
export function useFindManyInvitations<
  TData = Awaited<ReturnType<typeof findManyInvitations>>,
  TError = unknown
>(
  params?: FindManyInvitationsParams,
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof findManyInvitations>>,
        TError,
        TData
      >
    >
    fetch?: RequestInit
  },
  queryClient?: QueryClient
): UseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>
}
/**
 * @summary Find many invitations
 */

export function useFindManyInvitations<
  TData = Awaited<ReturnType<typeof findManyInvitations>>,
  TError = unknown
>(
  params?: FindManyInvitationsParams,
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof findManyInvitations>>,
        TError,
        TData
      >
    >
    fetch?: RequestInit
  },
  queryClient?: QueryClient
): UseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>
} {
  const queryOptions = getFindManyInvitationsQueryOptions(params, options)

  const query = useQuery(queryOptions, queryClient) as UseQueryResult<
    TData,
    TError
  > & { queryKey: DataTag<QueryKey, TData, TError> }

  query.queryKey = queryOptions.queryKey

  return query
}

/**
 * Delete an invitation
 * @summary Delete an invitation
 */
export const getDeleteInvitationUrl = (id: string) => {
  return `https://localhost:3001/invitations/${id}`
}

export const deleteInvitation = async (
  id: string,
  options?: RequestInit
): Promise<DeleteInvitation200> => {
  const res = await fetch(getDeleteInvitationUrl(id), {
    ...options,
    method: 'DELETE'
  })

  const body = [204, 205, 304].includes(res.status) ? null : await res.text()
  const data: DeleteInvitation200 = body ? JSON.parse(body) : {}

  return data
}

export const getDeleteInvitationMutationOptions = <
  TError = NotFoundResponse,
  TContext = unknown
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof deleteInvitation>>,
    TError,
    { id: string },
    TContext
  >
  fetch?: RequestInit
}): UseMutationOptions<
  Awaited<ReturnType<typeof deleteInvitation>>,
  TError,
  { id: string },
  TContext
> => {
  const mutationKey = ['deleteInvitation']
  const { mutation: mutationOptions, fetch: fetchOptions } =
    options ?
      (
        options.mutation &&
        'mutationKey' in options.mutation &&
        options.mutation.mutationKey
      ) ?
        options
      : { ...options, mutation: { ...options.mutation, mutationKey } }
    : { mutation: { mutationKey }, fetch: undefined }

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof deleteInvitation>>,
    { id: string }
  > = (props) => {
    const { id } = props ?? {}

    return deleteInvitation(id, fetchOptions)
  }

  return { mutationFn, ...mutationOptions }
}

export type DeleteInvitationMutationResult = NonNullable<
  Awaited<ReturnType<typeof deleteInvitation>>
>

export type DeleteInvitationMutationError = NotFoundResponse

/**
 * @summary Delete an invitation
 */
export const useDeleteInvitation = <
  TError = NotFoundResponse,
  TContext = unknown
>(
  options?: {
    mutation?: UseMutationOptions<
      Awaited<ReturnType<typeof deleteInvitation>>,
      TError,
      { id: string },
      TContext
    >
    fetch?: RequestInit
  },
  queryClient?: QueryClient
): UseMutationResult<
  Awaited<ReturnType<typeof deleteInvitation>>,
  TError,
  { id: string },
  TContext
> => {
  const mutationOptions = getDeleteInvitationMutationOptions(options)

  return useMutation(mutationOptions, queryClient)
}

/**
 * Find an invitation
 * @summary Find an invitation
 */
export const getGetOneInvitationUrl = (id: string) => {
  return `https://localhost:3001/invitations/${id}`
}

export const getOneInvitation = async (
  id: string,
  options?: RequestInit
): Promise<GetOneInvitation200> => {
  const res = await fetch(getGetOneInvitationUrl(id), {
    ...options,
    method: 'GET'
  })

  const body = [204, 205, 304].includes(res.status) ? null : await res.text()
  const data: GetOneInvitation200 = body ? JSON.parse(body) : {}

  return data
}

export const getGetOneInvitationQueryKey = (id: string) => {
  return [`https://localhost:3001/invitations/${id}`] as const
}

export const getGetOneInvitationQueryOptions = <
  TData = Awaited<ReturnType<typeof getOneInvitation>>,
  TError = NotFoundResponse
>(
  id: string,
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof getOneInvitation>>,
        TError,
        TData
      >
    >
    fetch?: RequestInit
  }
) => {
  const { query: queryOptions, fetch: fetchOptions } = options ?? {}

  const queryKey = queryOptions?.queryKey ?? getGetOneInvitationQueryKey(id)

  const queryFn: QueryFunction<
    Awaited<ReturnType<typeof getOneInvitation>>
  > = ({ signal }) =>
    getOneInvitation(id, { ...(signal ? { signal } : {}), ...fetchOptions })

  return {
    queryKey,
    queryFn,
    enabled: !!id,
    ...queryOptions
  } as UseQueryOptions<
    Awaited<ReturnType<typeof getOneInvitation>>,
    TError,
    TData
  > & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type GetOneInvitationQueryResult = NonNullable<
  Awaited<ReturnType<typeof getOneInvitation>>
>
export type GetOneInvitationQueryError = NotFoundResponse

export function useGetOneInvitation<
  TData = Awaited<ReturnType<typeof getOneInvitation>>,
  TError = NotFoundResponse
>(
  id: string,
  options: {
    query: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof getOneInvitation>>,
        TError,
        TData
      >
    > &
      Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof getOneInvitation>>,
          TError,
          Awaited<ReturnType<typeof getOneInvitation>>
        >,
        'initialData'
      >
    fetch?: RequestInit
  },
  queryClient?: QueryClient
): DefinedUseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>
}
export function useGetOneInvitation<
  TData = Awaited<ReturnType<typeof getOneInvitation>>,
  TError = NotFoundResponse
>(
  id: string,
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof getOneInvitation>>,
        TError,
        TData
      >
    > &
      Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof getOneInvitation>>,
          TError,
          Awaited<ReturnType<typeof getOneInvitation>>
        >,
        'initialData'
      >
    fetch?: RequestInit
  },
  queryClient?: QueryClient
): UseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>
}
export function useGetOneInvitation<
  TData = Awaited<ReturnType<typeof getOneInvitation>>,
  TError = NotFoundResponse
>(
  id: string,
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof getOneInvitation>>,
        TError,
        TData
      >
    >
    fetch?: RequestInit
  },
  queryClient?: QueryClient
): UseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>
}
/**
 * @summary Find an invitation
 */

export function useGetOneInvitation<
  TData = Awaited<ReturnType<typeof getOneInvitation>>,
  TError = NotFoundResponse
>(
  id: string,
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof getOneInvitation>>,
        TError,
        TData
      >
    >
    fetch?: RequestInit
  },
  queryClient?: QueryClient
): UseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>
} {
  const queryOptions = getGetOneInvitationQueryOptions(id, options)

  const query = useQuery(queryOptions, queryClient) as UseQueryResult<
    TData,
    TError
  > & { queryKey: DataTag<QueryKey, TData, TError> }

  query.queryKey = queryOptions.queryKey

  return query
}

/**
 * Update an invitation
 * @summary Update an invitation
 */
export const getUpdateInvitationUrl = (id: string) => {
  return `https://localhost:3001/invitations/${id}`
}

export const updateInvitation = async (
  id: string,
  updateInvitationBody: UpdateInvitationBody,
  options?: RequestInit
): Promise<UpdateInvitation200> => {
  const res = await fetch(getUpdateInvitationUrl(id), {
    ...options,
    method: 'PATCH',
    headers: { 'Content-Type': 'application/json', ...options?.headers },
    body: JSON.stringify(updateInvitationBody)
  })

  const body = [204, 205, 304].includes(res.status) ? null : await res.text()
  const data: UpdateInvitation200 = body ? JSON.parse(body) : {}

  return data
}

export const getUpdateInvitationMutationOptions = <
  TError = NotFoundResponse,
  TContext = unknown
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof updateInvitation>>,
    TError,
    { id: string; data: UpdateInvitationBody },
    TContext
  >
  fetch?: RequestInit
}): UseMutationOptions<
  Awaited<ReturnType<typeof updateInvitation>>,
  TError,
  { id: string; data: UpdateInvitationBody },
  TContext
> => {
  const mutationKey = ['updateInvitation']
  const { mutation: mutationOptions, fetch: fetchOptions } =
    options ?
      (
        options.mutation &&
        'mutationKey' in options.mutation &&
        options.mutation.mutationKey
      ) ?
        options
      : { ...options, mutation: { ...options.mutation, mutationKey } }
    : { mutation: { mutationKey }, fetch: undefined }

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof updateInvitation>>,
    { id: string; data: UpdateInvitationBody }
  > = (props) => {
    const { id, data } = props ?? {}

    return updateInvitation(id, data, fetchOptions)
  }

  return { mutationFn, ...mutationOptions }
}

export type UpdateInvitationMutationResult = NonNullable<
  Awaited<ReturnType<typeof updateInvitation>>
>
export type UpdateInvitationMutationBody = UpdateInvitationBody
export type UpdateInvitationMutationError = NotFoundResponse

/**
 * @summary Update an invitation
 */
export const useUpdateInvitation = <
  TError = NotFoundResponse,
  TContext = unknown
>(
  options?: {
    mutation?: UseMutationOptions<
      Awaited<ReturnType<typeof updateInvitation>>,
      TError,
      { id: string; data: UpdateInvitationBody },
      TContext
    >
    fetch?: RequestInit
  },
  queryClient?: QueryClient
): UseMutationResult<
  Awaited<ReturnType<typeof updateInvitation>>,
  TError,
  { id: string; data: UpdateInvitationBody },
  TContext
> => {
  const mutationOptions = getUpdateInvitationMutationOptions(options)

  return useMutation(mutationOptions, queryClient)
}

/**
 * Accept an invitation
 * @summary Accept an invitation
 */
export const getAcceptInvitationUrl = (id: string) => {
  return `https://localhost:3001/invitations/${id}/accept`
}

export const acceptInvitation = async (
  id: string,
  options?: RequestInit
): Promise<AcceptInvitation200> => {
  const res = await fetch(getAcceptInvitationUrl(id), {
    ...options,
    method: 'POST'
  })

  const body = [204, 205, 304].includes(res.status) ? null : await res.text()
  const data: AcceptInvitation200 = body ? JSON.parse(body) : {}

  return data
}

export const getAcceptInvitationMutationOptions = <
  TError = UnauthorizedResponse | ForbiddenResponse | NotFoundResponse,
  TContext = unknown
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof acceptInvitation>>,
    TError,
    { id: string },
    TContext
  >
  fetch?: RequestInit
}): UseMutationOptions<
  Awaited<ReturnType<typeof acceptInvitation>>,
  TError,
  { id: string },
  TContext
> => {
  const mutationKey = ['acceptInvitation']
  const { mutation: mutationOptions, fetch: fetchOptions } =
    options ?
      (
        options.mutation &&
        'mutationKey' in options.mutation &&
        options.mutation.mutationKey
      ) ?
        options
      : { ...options, mutation: { ...options.mutation, mutationKey } }
    : { mutation: { mutationKey }, fetch: undefined }

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof acceptInvitation>>,
    { id: string }
  > = (props) => {
    const { id } = props ?? {}

    return acceptInvitation(id, fetchOptions)
  }

  return { mutationFn, ...mutationOptions }
}

export type AcceptInvitationMutationResult = NonNullable<
  Awaited<ReturnType<typeof acceptInvitation>>
>

export type AcceptInvitationMutationError =
  | UnauthorizedResponse
  | ForbiddenResponse
  | NotFoundResponse

/**
 * @summary Accept an invitation
 */
export const useAcceptInvitation = <
  TError = UnauthorizedResponse | ForbiddenResponse | NotFoundResponse,
  TContext = unknown
>(
  options?: {
    mutation?: UseMutationOptions<
      Awaited<ReturnType<typeof acceptInvitation>>,
      TError,
      { id: string },
      TContext
    >
    fetch?: RequestInit
  },
  queryClient?: QueryClient
): UseMutationResult<
  Awaited<ReturnType<typeof acceptInvitation>>,
  TError,
  { id: string },
  TContext
> => {
  const mutationOptions = getAcceptInvitationMutationOptions(options)

  return useMutation(mutationOptions, queryClient)
}

/**
 * Create a checkout session
 * @summary Create a checkout session
 */
export const getCreateCheckoutSessionUrl = () => {
  return `https://localhost:3001/billing/checkout-sessions`
}

export const createCheckoutSession = async (
  createCheckoutSessionBody: CreateCheckoutSessionBody,
  options?: RequestInit
): Promise<CreateCheckoutSession200> => {
  const res = await fetch(getCreateCheckoutSessionUrl(), {
    ...options,
    method: 'POST',
    headers: { 'Content-Type': 'application/json', ...options?.headers },
    body: JSON.stringify(createCheckoutSessionBody)
  })

  const body = [204, 205, 304].includes(res.status) ? null : await res.text()
  const data: CreateCheckoutSession200 = body ? JSON.parse(body) : {}

  return data
}

export const getCreateCheckoutSessionMutationOptions = <
  TError = unknown,
  TContext = unknown
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof createCheckoutSession>>,
    TError,
    { data: CreateCheckoutSessionBody },
    TContext
  >
  fetch?: RequestInit
}): UseMutationOptions<
  Awaited<ReturnType<typeof createCheckoutSession>>,
  TError,
  { data: CreateCheckoutSessionBody },
  TContext
> => {
  const mutationKey = ['createCheckoutSession']
  const { mutation: mutationOptions, fetch: fetchOptions } =
    options ?
      (
        options.mutation &&
        'mutationKey' in options.mutation &&
        options.mutation.mutationKey
      ) ?
        options
      : { ...options, mutation: { ...options.mutation, mutationKey } }
    : { mutation: { mutationKey }, fetch: undefined }

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof createCheckoutSession>>,
    { data: CreateCheckoutSessionBody }
  > = (props) => {
    const { data } = props ?? {}

    return createCheckoutSession(data, fetchOptions)
  }

  return { mutationFn, ...mutationOptions }
}

export type CreateCheckoutSessionMutationResult = NonNullable<
  Awaited<ReturnType<typeof createCheckoutSession>>
>
export type CreateCheckoutSessionMutationBody = CreateCheckoutSessionBody
export type CreateCheckoutSessionMutationError = unknown

/**
 * @summary Create a checkout session
 */
export const useCreateCheckoutSession = <TError = unknown, TContext = unknown>(
  options?: {
    mutation?: UseMutationOptions<
      Awaited<ReturnType<typeof createCheckoutSession>>,
      TError,
      { data: CreateCheckoutSessionBody },
      TContext
    >
    fetch?: RequestInit
  },
  queryClient?: QueryClient
): UseMutationResult<
  Awaited<ReturnType<typeof createCheckoutSession>>,
  TError,
  { data: CreateCheckoutSessionBody },
  TContext
> => {
  const mutationOptions = getCreateCheckoutSessionMutationOptions(options)

  return useMutation(mutationOptions, queryClient)
}

/**
 * Delete a payment method
 * @summary Delete a payment method
 */
export const getDeletePaymentMethodUrl = (id: string) => {
  return `https://localhost:3001/billing/payment-methods/${id}`
}

export const deletePaymentMethod = async (
  id: string,
  options?: RequestInit
): Promise<DeletePaymentMethod200> => {
  const res = await fetch(getDeletePaymentMethodUrl(id), {
    ...options,
    method: 'DELETE'
  })

  const body = [204, 205, 304].includes(res.status) ? null : await res.text()
  const data: DeletePaymentMethod200 = body ? JSON.parse(body) : {}

  return data
}

export const getDeletePaymentMethodMutationOptions = <
  TError = unknown,
  TContext = unknown
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof deletePaymentMethod>>,
    TError,
    { id: string },
    TContext
  >
  fetch?: RequestInit
}): UseMutationOptions<
  Awaited<ReturnType<typeof deletePaymentMethod>>,
  TError,
  { id: string },
  TContext
> => {
  const mutationKey = ['deletePaymentMethod']
  const { mutation: mutationOptions, fetch: fetchOptions } =
    options ?
      (
        options.mutation &&
        'mutationKey' in options.mutation &&
        options.mutation.mutationKey
      ) ?
        options
      : { ...options, mutation: { ...options.mutation, mutationKey } }
    : { mutation: { mutationKey }, fetch: undefined }

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof deletePaymentMethod>>,
    { id: string }
  > = (props) => {
    const { id } = props ?? {}

    return deletePaymentMethod(id, fetchOptions)
  }

  return { mutationFn, ...mutationOptions }
}

export type DeletePaymentMethodMutationResult = NonNullable<
  Awaited<ReturnType<typeof deletePaymentMethod>>
>

export type DeletePaymentMethodMutationError = unknown

/**
 * @summary Delete a payment method
 */
export const useDeletePaymentMethod = <TError = unknown, TContext = unknown>(
  options?: {
    mutation?: UseMutationOptions<
      Awaited<ReturnType<typeof deletePaymentMethod>>,
      TError,
      { id: string },
      TContext
    >
    fetch?: RequestInit
  },
  queryClient?: QueryClient
): UseMutationResult<
  Awaited<ReturnType<typeof deletePaymentMethod>>,
  TError,
  { id: string },
  TContext
> => {
  const mutationOptions = getDeletePaymentMethodMutationOptions(options)

  return useMutation(mutationOptions, queryClient)
}

/**
 * Get a payment method
 * @summary Get a payment method
 */
export const getFindOnePaymentMethodUrl = (id: string) => {
  return `https://localhost:3001/billing/payment-methods/${id}`
}

export const findOnePaymentMethod = async (
  id: string,
  options?: RequestInit
): Promise<FindOnePaymentMethod200> => {
  const res = await fetch(getFindOnePaymentMethodUrl(id), {
    ...options,
    method: 'GET'
  })

  const body = [204, 205, 304].includes(res.status) ? null : await res.text()
  const data: FindOnePaymentMethod200 = body ? JSON.parse(body) : {}

  return data
}

export const getFindOnePaymentMethodQueryKey = (id: string) => {
  return [`https://localhost:3001/billing/payment-methods/${id}`] as const
}

export const getFindOnePaymentMethodQueryOptions = <
  TData = Awaited<ReturnType<typeof findOnePaymentMethod>>,
  TError = unknown
>(
  id: string,
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof findOnePaymentMethod>>,
        TError,
        TData
      >
    >
    fetch?: RequestInit
  }
) => {
  const { query: queryOptions, fetch: fetchOptions } = options ?? {}

  const queryKey = queryOptions?.queryKey ?? getFindOnePaymentMethodQueryKey(id)

  const queryFn: QueryFunction<
    Awaited<ReturnType<typeof findOnePaymentMethod>>
  > = ({ signal }) =>
    findOnePaymentMethod(id, { ...(signal ? { signal } : {}), ...fetchOptions })

  return {
    queryKey,
    queryFn,
    enabled: !!id,
    ...queryOptions
  } as UseQueryOptions<
    Awaited<ReturnType<typeof findOnePaymentMethod>>,
    TError,
    TData
  > & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type FindOnePaymentMethodQueryResult = NonNullable<
  Awaited<ReturnType<typeof findOnePaymentMethod>>
>
export type FindOnePaymentMethodQueryError = unknown

export function useFindOnePaymentMethod<
  TData = Awaited<ReturnType<typeof findOnePaymentMethod>>,
  TError = unknown
>(
  id: string,
  options: {
    query: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof findOnePaymentMethod>>,
        TError,
        TData
      >
    > &
      Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof findOnePaymentMethod>>,
          TError,
          Awaited<ReturnType<typeof findOnePaymentMethod>>
        >,
        'initialData'
      >
    fetch?: RequestInit
  },
  queryClient?: QueryClient
): DefinedUseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>
}
export function useFindOnePaymentMethod<
  TData = Awaited<ReturnType<typeof findOnePaymentMethod>>,
  TError = unknown
>(
  id: string,
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof findOnePaymentMethod>>,
        TError,
        TData
      >
    > &
      Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof findOnePaymentMethod>>,
          TError,
          Awaited<ReturnType<typeof findOnePaymentMethod>>
        >,
        'initialData'
      >
    fetch?: RequestInit
  },
  queryClient?: QueryClient
): UseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>
}
export function useFindOnePaymentMethod<
  TData = Awaited<ReturnType<typeof findOnePaymentMethod>>,
  TError = unknown
>(
  id: string,
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof findOnePaymentMethod>>,
        TError,
        TData
      >
    >
    fetch?: RequestInit
  },
  queryClient?: QueryClient
): UseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>
}
/**
 * @summary Get a payment method
 */

export function useFindOnePaymentMethod<
  TData = Awaited<ReturnType<typeof findOnePaymentMethod>>,
  TError = unknown
>(
  id: string,
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof findOnePaymentMethod>>,
        TError,
        TData
      >
    >
    fetch?: RequestInit
  },
  queryClient?: QueryClient
): UseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>
} {
  const queryOptions = getFindOnePaymentMethodQueryOptions(id, options)

  const query = useQuery(queryOptions, queryClient) as UseQueryResult<
    TData,
    TError
  > & { queryKey: DataTag<QueryKey, TData, TError> }

  query.queryKey = queryOptions.queryKey

  return query
}

/**
 * Get all payment methods
 * @summary Get all payment methods
 */
export const getFindManyPaymentMethodsUrl = () => {
  return `https://localhost:3001/billing/payment-methods`
}

export const findManyPaymentMethods = async (
  options?: RequestInit
): Promise<unknown> => {
  const res = await fetch(getFindManyPaymentMethodsUrl(), {
    ...options,
    method: 'GET'
  })

  const body = [204, 205, 304].includes(res.status) ? null : await res.text()
  const data: unknown = body ? JSON.parse(body) : {}

  return data
}

export const getFindManyPaymentMethodsQueryKey = () => {
  return [`https://localhost:3001/billing/payment-methods`] as const
}

export const getFindManyPaymentMethodsQueryOptions = <
  TData = Awaited<ReturnType<typeof findManyPaymentMethods>>,
  TError = unknown
>(options?: {
  query?: Partial<
    UseQueryOptions<
      Awaited<ReturnType<typeof findManyPaymentMethods>>,
      TError,
      TData
    >
  >
  fetch?: RequestInit
}) => {
  const { query: queryOptions, fetch: fetchOptions } = options ?? {}

  const queryKey = queryOptions?.queryKey ?? getFindManyPaymentMethodsQueryKey()

  const queryFn: QueryFunction<
    Awaited<ReturnType<typeof findManyPaymentMethods>>
  > = ({ signal }) =>
    findManyPaymentMethods({ ...(signal ? { signal } : {}), ...fetchOptions })

  return { queryKey, queryFn, ...queryOptions } as UseQueryOptions<
    Awaited<ReturnType<typeof findManyPaymentMethods>>,
    TError,
    TData
  > & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type FindManyPaymentMethodsQueryResult = NonNullable<
  Awaited<ReturnType<typeof findManyPaymentMethods>>
>
export type FindManyPaymentMethodsQueryError = unknown

export function useFindManyPaymentMethods<
  TData = Awaited<ReturnType<typeof findManyPaymentMethods>>,
  TError = unknown
>(
  options: {
    query: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof findManyPaymentMethods>>,
        TError,
        TData
      >
    > &
      Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof findManyPaymentMethods>>,
          TError,
          Awaited<ReturnType<typeof findManyPaymentMethods>>
        >,
        'initialData'
      >
    fetch?: RequestInit
  },
  queryClient?: QueryClient
): DefinedUseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>
}
export function useFindManyPaymentMethods<
  TData = Awaited<ReturnType<typeof findManyPaymentMethods>>,
  TError = unknown
>(
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof findManyPaymentMethods>>,
        TError,
        TData
      >
    > &
      Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof findManyPaymentMethods>>,
          TError,
          Awaited<ReturnType<typeof findManyPaymentMethods>>
        >,
        'initialData'
      >
    fetch?: RequestInit
  },
  queryClient?: QueryClient
): UseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>
}
export function useFindManyPaymentMethods<
  TData = Awaited<ReturnType<typeof findManyPaymentMethods>>,
  TError = unknown
>(
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof findManyPaymentMethods>>,
        TError,
        TData
      >
    >
    fetch?: RequestInit
  },
  queryClient?: QueryClient
): UseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>
}
/**
 * @summary Get all payment methods
 */

export function useFindManyPaymentMethods<
  TData = Awaited<ReturnType<typeof findManyPaymentMethods>>,
  TError = unknown
>(
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof findManyPaymentMethods>>,
        TError,
        TData
      >
    >
    fetch?: RequestInit
  },
  queryClient?: QueryClient
): UseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>
} {
  const queryOptions = getFindManyPaymentMethodsQueryOptions(options)

  const query = useQuery(queryOptions, queryClient) as UseQueryResult<
    TData,
    TError
  > & { queryKey: DataTag<QueryKey, TData, TError> }

  query.queryKey = queryOptions.queryKey

  return query
}

/**
 * Get all plans
 * @summary Get all plans
 */
export const getGetPlansUrl = () => {
  return `https://localhost:3001/billing/plans`
}

export const getPlans = async (options?: RequestInit): Promise<GetPlans200> => {
  const res = await fetch(getGetPlansUrl(), {
    ...options,
    method: 'GET'
  })

  const body = [204, 205, 304].includes(res.status) ? null : await res.text()
  const data: GetPlans200 = body ? JSON.parse(body) : {}

  return data
}

export const getGetPlansQueryKey = () => {
  return [`https://localhost:3001/billing/plans`] as const
}

export const getGetPlansQueryOptions = <
  TData = Awaited<ReturnType<typeof getPlans>>,
  TError = unknown
>(options?: {
  query?: Partial<
    UseQueryOptions<Awaited<ReturnType<typeof getPlans>>, TError, TData>
  >
  fetch?: RequestInit
}) => {
  const { query: queryOptions, fetch: fetchOptions } = options ?? {}

  const queryKey = queryOptions?.queryKey ?? getGetPlansQueryKey()

  const queryFn: QueryFunction<Awaited<ReturnType<typeof getPlans>>> = ({
    signal
  }) => getPlans({ ...(signal ? { signal } : {}), ...fetchOptions })

  return { queryKey, queryFn, ...queryOptions } as UseQueryOptions<
    Awaited<ReturnType<typeof getPlans>>,
    TError,
    TData
  > & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type GetPlansQueryResult = NonNullable<
  Awaited<ReturnType<typeof getPlans>>
>
export type GetPlansQueryError = unknown

export function useGetPlans<
  TData = Awaited<ReturnType<typeof getPlans>>,
  TError = unknown
>(
  options: {
    query: Partial<
      UseQueryOptions<Awaited<ReturnType<typeof getPlans>>, TError, TData>
    > &
      Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof getPlans>>,
          TError,
          Awaited<ReturnType<typeof getPlans>>
        >,
        'initialData'
      >
    fetch?: RequestInit
  },
  queryClient?: QueryClient
): DefinedUseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>
}
export function useGetPlans<
  TData = Awaited<ReturnType<typeof getPlans>>,
  TError = unknown
>(
  options?: {
    query?: Partial<
      UseQueryOptions<Awaited<ReturnType<typeof getPlans>>, TError, TData>
    > &
      Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof getPlans>>,
          TError,
          Awaited<ReturnType<typeof getPlans>>
        >,
        'initialData'
      >
    fetch?: RequestInit
  },
  queryClient?: QueryClient
): UseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>
}
export function useGetPlans<
  TData = Awaited<ReturnType<typeof getPlans>>,
  TError = unknown
>(
  options?: {
    query?: Partial<
      UseQueryOptions<Awaited<ReturnType<typeof getPlans>>, TError, TData>
    >
    fetch?: RequestInit
  },
  queryClient?: QueryClient
): UseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>
}
/**
 * @summary Get all plans
 */

export function useGetPlans<
  TData = Awaited<ReturnType<typeof getPlans>>,
  TError = unknown
>(
  options?: {
    query?: Partial<
      UseQueryOptions<Awaited<ReturnType<typeof getPlans>>, TError, TData>
    >
    fetch?: RequestInit
  },
  queryClient?: QueryClient
): UseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>
} {
  const queryOptions = getGetPlansQueryOptions(options)

  const query = useQuery(queryOptions, queryClient) as UseQueryResult<
    TData,
    TError
  > & { queryKey: DataTag<QueryKey, TData, TError> }

  query.queryKey = queryOptions.queryKey

  return query
}

/**
 * Create a new portal
 * @summary Create a new portal
 */
export const getCreatePortalUrl = () => {
  return `https://localhost:3001/billing/portal`
}

export const createPortal = async (
  createPortalBody: CreatePortalBody,
  options?: RequestInit
): Promise<unknown> => {
  const res = await fetch(getCreatePortalUrl(), {
    ...options,
    method: 'POST',
    headers: { 'Content-Type': 'application/json', ...options?.headers },
    body: JSON.stringify(createPortalBody)
  })

  const body = [204, 205, 304].includes(res.status) ? null : await res.text()
  const data: unknown = body ? JSON.parse(body) : {}

  return data
}

export const getCreatePortalMutationOptions = <
  TError = unknown,
  TContext = unknown
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof createPortal>>,
    TError,
    { data: CreatePortalBody },
    TContext
  >
  fetch?: RequestInit
}): UseMutationOptions<
  Awaited<ReturnType<typeof createPortal>>,
  TError,
  { data: CreatePortalBody },
  TContext
> => {
  const mutationKey = ['createPortal']
  const { mutation: mutationOptions, fetch: fetchOptions } =
    options ?
      (
        options.mutation &&
        'mutationKey' in options.mutation &&
        options.mutation.mutationKey
      ) ?
        options
      : { ...options, mutation: { ...options.mutation, mutationKey } }
    : { mutation: { mutationKey }, fetch: undefined }

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof createPortal>>,
    { data: CreatePortalBody }
  > = (props) => {
    const { data } = props ?? {}

    return createPortal(data, fetchOptions)
  }

  return { mutationFn, ...mutationOptions }
}

export type CreatePortalMutationResult = NonNullable<
  Awaited<ReturnType<typeof createPortal>>
>
export type CreatePortalMutationBody = CreatePortalBody
export type CreatePortalMutationError = unknown

/**
 * @summary Create a new portal
 */
export const useCreatePortal = <TError = unknown, TContext = unknown>(
  options?: {
    mutation?: UseMutationOptions<
      Awaited<ReturnType<typeof createPortal>>,
      TError,
      { data: CreatePortalBody },
      TContext
    >
    fetch?: RequestInit
  },
  queryClient?: QueryClient
): UseMutationResult<
  Awaited<ReturnType<typeof createPortal>>,
  TError,
  { data: CreatePortalBody },
  TContext
> => {
  const mutationOptions = getCreatePortalMutationOptions(options)

  return useMutation(mutationOptions, queryClient)
}

/**
 * Cancel a subscription
 * @summary Cancel a subscription
 */
export const getCancelSubscriptionUrl = (id: string) => {
  return `https://localhost:3001/billing/subscriptions/${id}`
}

export const cancelSubscription = async (
  id: string,
  options?: RequestInit
): Promise<void> => {
  const res = await fetch(getCancelSubscriptionUrl(id), {
    ...options,
    method: 'DELETE'
  })

  const body = [204, 205, 304].includes(res.status) ? null : await res.text()
  const data: void = body ? JSON.parse(body) : {}

  return data
}

export const getCancelSubscriptionMutationOptions = <
  TError = unknown,
  TContext = unknown
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof cancelSubscription>>,
    TError,
    { id: string },
    TContext
  >
  fetch?: RequestInit
}): UseMutationOptions<
  Awaited<ReturnType<typeof cancelSubscription>>,
  TError,
  { id: string },
  TContext
> => {
  const mutationKey = ['cancelSubscription']
  const { mutation: mutationOptions, fetch: fetchOptions } =
    options ?
      (
        options.mutation &&
        'mutationKey' in options.mutation &&
        options.mutation.mutationKey
      ) ?
        options
      : { ...options, mutation: { ...options.mutation, mutationKey } }
    : { mutation: { mutationKey }, fetch: undefined }

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof cancelSubscription>>,
    { id: string }
  > = (props) => {
    const { id } = props ?? {}

    return cancelSubscription(id, fetchOptions)
  }

  return { mutationFn, ...mutationOptions }
}

export type CancelSubscriptionMutationResult = NonNullable<
  Awaited<ReturnType<typeof cancelSubscription>>
>

export type CancelSubscriptionMutationError = unknown

/**
 * @summary Cancel a subscription
 */
export const useCancelSubscription = <TError = unknown, TContext = unknown>(
  options?: {
    mutation?: UseMutationOptions<
      Awaited<ReturnType<typeof cancelSubscription>>,
      TError,
      { id: string },
      TContext
    >
    fetch?: RequestInit
  },
  queryClient?: QueryClient
): UseMutationResult<
  Awaited<ReturnType<typeof cancelSubscription>>,
  TError,
  { id: string },
  TContext
> => {
  const mutationOptions = getCancelSubscriptionMutationOptions(options)

  return useMutation(mutationOptions, queryClient)
}

/**
 * Update a subscription
 * @summary Update a subscription
 */
export const getUpdateSubscriptionUrl = (id: string) => {
  return `https://localhost:3001/billing/subscriptions/${id}`
}

export const updateSubscription = async (
  id: string,
  updateSubscriptionBody: UpdateSubscriptionBody,
  options?: RequestInit
): Promise<void> => {
  const res = await fetch(getUpdateSubscriptionUrl(id), {
    ...options,
    method: 'PATCH',
    headers: { 'Content-Type': 'application/json', ...options?.headers },
    body: JSON.stringify(updateSubscriptionBody)
  })

  const body = [204, 205, 304].includes(res.status) ? null : await res.text()
  const data: void = body ? JSON.parse(body) : {}

  return data
}

export const getUpdateSubscriptionMutationOptions = <
  TError = unknown,
  TContext = unknown
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof updateSubscription>>,
    TError,
    { id: string; data: UpdateSubscriptionBody },
    TContext
  >
  fetch?: RequestInit
}): UseMutationOptions<
  Awaited<ReturnType<typeof updateSubscription>>,
  TError,
  { id: string; data: UpdateSubscriptionBody },
  TContext
> => {
  const mutationKey = ['updateSubscription']
  const { mutation: mutationOptions, fetch: fetchOptions } =
    options ?
      (
        options.mutation &&
        'mutationKey' in options.mutation &&
        options.mutation.mutationKey
      ) ?
        options
      : { ...options, mutation: { ...options.mutation, mutationKey } }
    : { mutation: { mutationKey }, fetch: undefined }

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof updateSubscription>>,
    { id: string; data: UpdateSubscriptionBody }
  > = (props) => {
    const { id, data } = props ?? {}

    return updateSubscription(id, data, fetchOptions)
  }

  return { mutationFn, ...mutationOptions }
}

export type UpdateSubscriptionMutationResult = NonNullable<
  Awaited<ReturnType<typeof updateSubscription>>
>
export type UpdateSubscriptionMutationBody = UpdateSubscriptionBody
export type UpdateSubscriptionMutationError = unknown

/**
 * @summary Update a subscription
 */
export const useUpdateSubscription = <TError = unknown, TContext = unknown>(
  options?: {
    mutation?: UseMutationOptions<
      Awaited<ReturnType<typeof updateSubscription>>,
      TError,
      { id: string; data: UpdateSubscriptionBody },
      TContext
    >
    fetch?: RequestInit
  },
  queryClient?: QueryClient
): UseMutationResult<
  Awaited<ReturnType<typeof updateSubscription>>,
  TError,
  { id: string; data: UpdateSubscriptionBody },
  TContext
> => {
  const mutationOptions = getUpdateSubscriptionMutationOptions(options)

  return useMutation(mutationOptions, queryClient)
}

/**
 * Create a new api-token
 * @summary Create a new api-token
 */
export const getCreateApiTokenUrl = () => {
  return `https://localhost:3001/api-tokens`
}

export const createApiToken = async (
  createApiTokenBody: CreateApiTokenBody,
  options?: RequestInit
): Promise<CreateApiToken201> => {
  const res = await fetch(getCreateApiTokenUrl(), {
    ...options,
    method: 'POST',
    headers: { 'Content-Type': 'application/json', ...options?.headers },
    body: JSON.stringify(createApiTokenBody)
  })

  const body = [204, 205, 304].includes(res.status) ? null : await res.text()
  const data: CreateApiToken201 = body ? JSON.parse(body) : {}

  return data
}

export const getCreateApiTokenMutationOptions = <
  TError = unknown,
  TContext = unknown
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof createApiToken>>,
    TError,
    { data: CreateApiTokenBody },
    TContext
  >
  fetch?: RequestInit
}): UseMutationOptions<
  Awaited<ReturnType<typeof createApiToken>>,
  TError,
  { data: CreateApiTokenBody },
  TContext
> => {
  const mutationKey = ['createApiToken']
  const { mutation: mutationOptions, fetch: fetchOptions } =
    options ?
      (
        options.mutation &&
        'mutationKey' in options.mutation &&
        options.mutation.mutationKey
      ) ?
        options
      : { ...options, mutation: { ...options.mutation, mutationKey } }
    : { mutation: { mutationKey }, fetch: undefined }

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof createApiToken>>,
    { data: CreateApiTokenBody }
  > = (props) => {
    const { data } = props ?? {}

    return createApiToken(data, fetchOptions)
  }

  return { mutationFn, ...mutationOptions }
}

export type CreateApiTokenMutationResult = NonNullable<
  Awaited<ReturnType<typeof createApiToken>>
>
export type CreateApiTokenMutationBody = CreateApiTokenBody
export type CreateApiTokenMutationError = unknown

/**
 * @summary Create a new api-token
 */
export const useCreateApiToken = <TError = unknown, TContext = unknown>(
  options?: {
    mutation?: UseMutationOptions<
      Awaited<ReturnType<typeof createApiToken>>,
      TError,
      { data: CreateApiTokenBody },
      TContext
    >
    fetch?: RequestInit
  },
  queryClient?: QueryClient
): UseMutationResult<
  Awaited<ReturnType<typeof createApiToken>>,
  TError,
  { data: CreateApiTokenBody },
  TContext
> => {
  const mutationOptions = getCreateApiTokenMutationOptions(options)

  return useMutation(mutationOptions, queryClient)
}

/**
 * Find many api-tokens
 * @summary Find many api-tokens
 */
export const getFindManyApiTokensUrl = (params?: FindManyApiTokensParams) => {
  const normalizedParams = new URLSearchParams()

  Object.entries(params || {}).forEach(([key, value]) => {
    if (value !== undefined) {
      normalizedParams.append(key, value === null ? 'null' : value.toString())
    }
  })

  const stringifiedParams = normalizedParams.toString()

  return stringifiedParams.length > 0 ?
      `https://localhost:3001/api-tokens?${stringifiedParams}`
    : `https://localhost:3001/api-tokens`
}

export const findManyApiTokens = async (
  params?: FindManyApiTokensParams,
  options?: RequestInit
): Promise<FindManyApiTokens200> => {
  const res = await fetch(getFindManyApiTokensUrl(params), {
    ...options,
    method: 'GET'
  })

  const body = [204, 205, 304].includes(res.status) ? null : await res.text()
  const data: FindManyApiTokens200 = body ? JSON.parse(body) : {}

  return data
}

export const getFindManyApiTokensQueryKey = (
  params?: FindManyApiTokensParams
) => {
  return [
    `https://localhost:3001/api-tokens`,
    ...(params ? [params] : [])
  ] as const
}

export const getFindManyApiTokensQueryOptions = <
  TData = Awaited<ReturnType<typeof findManyApiTokens>>,
  TError = unknown
>(
  params?: FindManyApiTokensParams,
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof findManyApiTokens>>,
        TError,
        TData
      >
    >
    fetch?: RequestInit
  }
) => {
  const { query: queryOptions, fetch: fetchOptions } = options ?? {}

  const queryKey =
    queryOptions?.queryKey ?? getFindManyApiTokensQueryKey(params)

  const queryFn: QueryFunction<
    Awaited<ReturnType<typeof findManyApiTokens>>
  > = ({ signal }) =>
    findManyApiTokens(params, {
      ...(signal ? { signal } : {}),
      ...fetchOptions
    })

  return { queryKey, queryFn, ...queryOptions } as UseQueryOptions<
    Awaited<ReturnType<typeof findManyApiTokens>>,
    TError,
    TData
  > & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type FindManyApiTokensQueryResult = NonNullable<
  Awaited<ReturnType<typeof findManyApiTokens>>
>
export type FindManyApiTokensQueryError = unknown

export function useFindManyApiTokens<
  TData = Awaited<ReturnType<typeof findManyApiTokens>>,
  TError = unknown
>(
  params: undefined | FindManyApiTokensParams,
  options: {
    query: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof findManyApiTokens>>,
        TError,
        TData
      >
    > &
      Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof findManyApiTokens>>,
          TError,
          Awaited<ReturnType<typeof findManyApiTokens>>
        >,
        'initialData'
      >
    fetch?: RequestInit
  },
  queryClient?: QueryClient
): DefinedUseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>
}
export function useFindManyApiTokens<
  TData = Awaited<ReturnType<typeof findManyApiTokens>>,
  TError = unknown
>(
  params?: FindManyApiTokensParams,
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof findManyApiTokens>>,
        TError,
        TData
      >
    > &
      Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof findManyApiTokens>>,
          TError,
          Awaited<ReturnType<typeof findManyApiTokens>>
        >,
        'initialData'
      >
    fetch?: RequestInit
  },
  queryClient?: QueryClient
): UseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>
}
export function useFindManyApiTokens<
  TData = Awaited<ReturnType<typeof findManyApiTokens>>,
  TError = unknown
>(
  params?: FindManyApiTokensParams,
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof findManyApiTokens>>,
        TError,
        TData
      >
    >
    fetch?: RequestInit
  },
  queryClient?: QueryClient
): UseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>
}
/**
 * @summary Find many api-tokens
 */

export function useFindManyApiTokens<
  TData = Awaited<ReturnType<typeof findManyApiTokens>>,
  TError = unknown
>(
  params?: FindManyApiTokensParams,
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof findManyApiTokens>>,
        TError,
        TData
      >
    >
    fetch?: RequestInit
  },
  queryClient?: QueryClient
): UseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>
} {
  const queryOptions = getFindManyApiTokensQueryOptions(params, options)

  const query = useQuery(queryOptions, queryClient) as UseQueryResult<
    TData,
    TError
  > & { queryKey: DataTag<QueryKey, TData, TError> }

  query.queryKey = queryOptions.queryKey

  return query
}

/**
 * Delete an api-token
 * @summary Delete an api-token
 */
export const getDeleteApiTokenUrl = (id: string) => {
  return `https://localhost:3001/api-tokens/${id}`
}

export const deleteApiToken = async (
  id: string,
  options?: RequestInit
): Promise<DeleteApiToken200> => {
  const res = await fetch(getDeleteApiTokenUrl(id), {
    ...options,
    method: 'DELETE'
  })

  const body = [204, 205, 304].includes(res.status) ? null : await res.text()
  const data: DeleteApiToken200 = body ? JSON.parse(body) : {}

  return data
}

export const getDeleteApiTokenMutationOptions = <
  TError = NotFoundResponse,
  TContext = unknown
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof deleteApiToken>>,
    TError,
    { id: string },
    TContext
  >
  fetch?: RequestInit
}): UseMutationOptions<
  Awaited<ReturnType<typeof deleteApiToken>>,
  TError,
  { id: string },
  TContext
> => {
  const mutationKey = ['deleteApiToken']
  const { mutation: mutationOptions, fetch: fetchOptions } =
    options ?
      (
        options.mutation &&
        'mutationKey' in options.mutation &&
        options.mutation.mutationKey
      ) ?
        options
      : { ...options, mutation: { ...options.mutation, mutationKey } }
    : { mutation: { mutationKey }, fetch: undefined }

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof deleteApiToken>>,
    { id: string }
  > = (props) => {
    const { id } = props ?? {}

    return deleteApiToken(id, fetchOptions)
  }

  return { mutationFn, ...mutationOptions }
}

export type DeleteApiTokenMutationResult = NonNullable<
  Awaited<ReturnType<typeof deleteApiToken>>
>

export type DeleteApiTokenMutationError = NotFoundResponse

/**
 * @summary Delete an api-token
 */
export const useDeleteApiToken = <
  TError = NotFoundResponse,
  TContext = unknown
>(
  options?: {
    mutation?: UseMutationOptions<
      Awaited<ReturnType<typeof deleteApiToken>>,
      TError,
      { id: string },
      TContext
    >
    fetch?: RequestInit
  },
  queryClient?: QueryClient
): UseMutationResult<
  Awaited<ReturnType<typeof deleteApiToken>>,
  TError,
  { id: string },
  TContext
> => {
  const mutationOptions = getDeleteApiTokenMutationOptions(options)

  return useMutation(mutationOptions, queryClient)
}

/**
 * Find an api-token
 * @summary Find an api-token
 */
export const getGetOneApiTokenUrl = (id: string) => {
  return `https://localhost:3001/api-tokens/${id}`
}

export const getOneApiToken = async (
  id: string,
  options?: RequestInit
): Promise<GetOneApiToken200> => {
  const res = await fetch(getGetOneApiTokenUrl(id), {
    ...options,
    method: 'GET'
  })

  const body = [204, 205, 304].includes(res.status) ? null : await res.text()
  const data: GetOneApiToken200 = body ? JSON.parse(body) : {}

  return data
}

export const getGetOneApiTokenQueryKey = (id: string) => {
  return [`https://localhost:3001/api-tokens/${id}`] as const
}

export const getGetOneApiTokenQueryOptions = <
  TData = Awaited<ReturnType<typeof getOneApiToken>>,
  TError = NotFoundResponse
>(
  id: string,
  options?: {
    query?: Partial<
      UseQueryOptions<Awaited<ReturnType<typeof getOneApiToken>>, TError, TData>
    >
    fetch?: RequestInit
  }
) => {
  const { query: queryOptions, fetch: fetchOptions } = options ?? {}

  const queryKey = queryOptions?.queryKey ?? getGetOneApiTokenQueryKey(id)

  const queryFn: QueryFunction<Awaited<ReturnType<typeof getOneApiToken>>> = ({
    signal
  }) => getOneApiToken(id, { ...(signal ? { signal } : {}), ...fetchOptions })

  return {
    queryKey,
    queryFn,
    enabled: !!id,
    ...queryOptions
  } as UseQueryOptions<
    Awaited<ReturnType<typeof getOneApiToken>>,
    TError,
    TData
  > & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type GetOneApiTokenQueryResult = NonNullable<
  Awaited<ReturnType<typeof getOneApiToken>>
>
export type GetOneApiTokenQueryError = NotFoundResponse

export function useGetOneApiToken<
  TData = Awaited<ReturnType<typeof getOneApiToken>>,
  TError = NotFoundResponse
>(
  id: string,
  options: {
    query: Partial<
      UseQueryOptions<Awaited<ReturnType<typeof getOneApiToken>>, TError, TData>
    > &
      Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof getOneApiToken>>,
          TError,
          Awaited<ReturnType<typeof getOneApiToken>>
        >,
        'initialData'
      >
    fetch?: RequestInit
  },
  queryClient?: QueryClient
): DefinedUseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>
}
export function useGetOneApiToken<
  TData = Awaited<ReturnType<typeof getOneApiToken>>,
  TError = NotFoundResponse
>(
  id: string,
  options?: {
    query?: Partial<
      UseQueryOptions<Awaited<ReturnType<typeof getOneApiToken>>, TError, TData>
    > &
      Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof getOneApiToken>>,
          TError,
          Awaited<ReturnType<typeof getOneApiToken>>
        >,
        'initialData'
      >
    fetch?: RequestInit
  },
  queryClient?: QueryClient
): UseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>
}
export function useGetOneApiToken<
  TData = Awaited<ReturnType<typeof getOneApiToken>>,
  TError = NotFoundResponse
>(
  id: string,
  options?: {
    query?: Partial<
      UseQueryOptions<Awaited<ReturnType<typeof getOneApiToken>>, TError, TData>
    >
    fetch?: RequestInit
  },
  queryClient?: QueryClient
): UseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>
}
/**
 * @summary Find an api-token
 */

export function useGetOneApiToken<
  TData = Awaited<ReturnType<typeof getOneApiToken>>,
  TError = NotFoundResponse
>(
  id: string,
  options?: {
    query?: Partial<
      UseQueryOptions<Awaited<ReturnType<typeof getOneApiToken>>, TError, TData>
    >
    fetch?: RequestInit
  },
  queryClient?: QueryClient
): UseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>
} {
  const queryOptions = getGetOneApiTokenQueryOptions(id, options)

  const query = useQuery(queryOptions, queryClient) as UseQueryResult<
    TData,
    TError
  > & { queryKey: DataTag<QueryKey, TData, TError> }

  query.queryKey = queryOptions.queryKey

  return query
}

/**
 * Update an api-token
 * @summary Update an api-token
 */
export const getUpdateApiTokenUrl = (id: string) => {
  return `https://localhost:3001/api-tokens/${id}`
}

export const updateApiToken = async (
  id: string,
  updateApiTokenBody: UpdateApiTokenBody,
  options?: RequestInit
): Promise<UpdateApiToken200> => {
  const res = await fetch(getUpdateApiTokenUrl(id), {
    ...options,
    method: 'PATCH',
    headers: { 'Content-Type': 'application/json', ...options?.headers },
    body: JSON.stringify(updateApiTokenBody)
  })

  const body = [204, 205, 304].includes(res.status) ? null : await res.text()
  const data: UpdateApiToken200 = body ? JSON.parse(body) : {}

  return data
}

export const getUpdateApiTokenMutationOptions = <
  TError = NotFoundResponse,
  TContext = unknown
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof updateApiToken>>,
    TError,
    { id: string; data: UpdateApiTokenBody },
    TContext
  >
  fetch?: RequestInit
}): UseMutationOptions<
  Awaited<ReturnType<typeof updateApiToken>>,
  TError,
  { id: string; data: UpdateApiTokenBody },
  TContext
> => {
  const mutationKey = ['updateApiToken']
  const { mutation: mutationOptions, fetch: fetchOptions } =
    options ?
      (
        options.mutation &&
        'mutationKey' in options.mutation &&
        options.mutation.mutationKey
      ) ?
        options
      : { ...options, mutation: { ...options.mutation, mutationKey } }
    : { mutation: { mutationKey }, fetch: undefined }

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof updateApiToken>>,
    { id: string; data: UpdateApiTokenBody }
  > = (props) => {
    const { id, data } = props ?? {}

    return updateApiToken(id, data, fetchOptions)
  }

  return { mutationFn, ...mutationOptions }
}

export type UpdateApiTokenMutationResult = NonNullable<
  Awaited<ReturnType<typeof updateApiToken>>
>
export type UpdateApiTokenMutationBody = UpdateApiTokenBody
export type UpdateApiTokenMutationError = NotFoundResponse

/**
 * @summary Update an api-token
 */
export const useUpdateApiToken = <
  TError = NotFoundResponse,
  TContext = unknown
>(
  options?: {
    mutation?: UseMutationOptions<
      Awaited<ReturnType<typeof updateApiToken>>,
      TError,
      { id: string; data: UpdateApiTokenBody },
      TContext
    >
    fetch?: RequestInit
  },
  queryClient?: QueryClient
): UseMutationResult<
  Awaited<ReturnType<typeof updateApiToken>>,
  TError,
  { id: string; data: UpdateApiTokenBody },
  TContext
> => {
  const mutationOptions = getUpdateApiTokenMutationOptions(options)

  return useMutation(mutationOptions, queryClient)
}

/**
 * Authenticate with Firebase using OAuth
 * @summary Authenticate with Firebase
 */
export const getFirebaseUrl = () => {
  return `https://localhost:3001/oauth/firebase`
}

export const firebase = async (
  options?: RequestInit
): Promise<NoContentResponse> => {
  const res = await fetch(getFirebaseUrl(), {
    ...options,
    method: 'POST'
  })

  const body = [204, 205, 304].includes(res.status) ? null : await res.text()
  const data: NoContentResponse = body ? JSON.parse(body) : {}

  return data
}

export const getFirebaseMutationOptions = <
  TError = unknown,
  TContext = unknown
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof firebase>>,
    TError,
    void,
    TContext
  >
  fetch?: RequestInit
}): UseMutationOptions<
  Awaited<ReturnType<typeof firebase>>,
  TError,
  void,
  TContext
> => {
  const mutationKey = ['firebase']
  const { mutation: mutationOptions, fetch: fetchOptions } =
    options ?
      (
        options.mutation &&
        'mutationKey' in options.mutation &&
        options.mutation.mutationKey
      ) ?
        options
      : { ...options, mutation: { ...options.mutation, mutationKey } }
    : { mutation: { mutationKey }, fetch: undefined }

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof firebase>>,
    void
  > = () => {
    return firebase(fetchOptions)
  }

  return { mutationFn, ...mutationOptions }
}

export type FirebaseMutationResult = NonNullable<
  Awaited<ReturnType<typeof firebase>>
>

export type FirebaseMutationError = unknown

/**
 * @summary Authenticate with Firebase
 */
export const useFirebase = <TError = unknown, TContext = unknown>(
  options?: {
    mutation?: UseMutationOptions<
      Awaited<ReturnType<typeof firebase>>,
      TError,
      void,
      TContext
    >
    fetch?: RequestInit
  },
  queryClient?: QueryClient
): UseMutationResult<
  Awaited<ReturnType<typeof firebase>>,
  TError,
  void,
  TContext
> => {
  const mutationOptions = getFirebaseMutationOptions(options)

  return useMutation(mutationOptions, queryClient)
}

/**
 * Redirects user to Twitter for authentication.
 * @summary Redirect to Twitter OAuth
 */
export const getTwitterUrl = () => {
  return `https://localhost:3001/oauth/twitter`
}

export const twitter = async (
  options?: RequestInit
): Promise<NoContentResponse> => {
  const res = await fetch(getTwitterUrl(), {
    ...options,
    method: 'GET'
  })

  const body = [204, 205, 304].includes(res.status) ? null : await res.text()
  const data: NoContentResponse = body ? JSON.parse(body) : {}

  return data
}

export const getTwitterQueryKey = () => {
  return [`https://localhost:3001/oauth/twitter`] as const
}

export const getTwitterQueryOptions = <
  TData = Awaited<ReturnType<typeof twitter>>,
  TError = unknown
>(options?: {
  query?: Partial<
    UseQueryOptions<Awaited<ReturnType<typeof twitter>>, TError, TData>
  >
  fetch?: RequestInit
}) => {
  const { query: queryOptions, fetch: fetchOptions } = options ?? {}

  const queryKey = queryOptions?.queryKey ?? getTwitterQueryKey()

  const queryFn: QueryFunction<Awaited<ReturnType<typeof twitter>>> = ({
    signal
  }) => twitter({ ...(signal ? { signal } : {}), ...fetchOptions })

  return { queryKey, queryFn, ...queryOptions } as UseQueryOptions<
    Awaited<ReturnType<typeof twitter>>,
    TError,
    TData
  > & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type TwitterQueryResult = NonNullable<
  Awaited<ReturnType<typeof twitter>>
>
export type TwitterQueryError = unknown

export function useTwitter<
  TData = Awaited<ReturnType<typeof twitter>>,
  TError = unknown
>(
  options: {
    query: Partial<
      UseQueryOptions<Awaited<ReturnType<typeof twitter>>, TError, TData>
    > &
      Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof twitter>>,
          TError,
          Awaited<ReturnType<typeof twitter>>
        >,
        'initialData'
      >
    fetch?: RequestInit
  },
  queryClient?: QueryClient
): DefinedUseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>
}
export function useTwitter<
  TData = Awaited<ReturnType<typeof twitter>>,
  TError = unknown
>(
  options?: {
    query?: Partial<
      UseQueryOptions<Awaited<ReturnType<typeof twitter>>, TError, TData>
    > &
      Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof twitter>>,
          TError,
          Awaited<ReturnType<typeof twitter>>
        >,
        'initialData'
      >
    fetch?: RequestInit
  },
  queryClient?: QueryClient
): UseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>
}
export function useTwitter<
  TData = Awaited<ReturnType<typeof twitter>>,
  TError = unknown
>(
  options?: {
    query?: Partial<
      UseQueryOptions<Awaited<ReturnType<typeof twitter>>, TError, TData>
    >
    fetch?: RequestInit
  },
  queryClient?: QueryClient
): UseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>
}
/**
 * @summary Redirect to Twitter OAuth
 */

export function useTwitter<
  TData = Awaited<ReturnType<typeof twitter>>,
  TError = unknown
>(
  options?: {
    query?: Partial<
      UseQueryOptions<Awaited<ReturnType<typeof twitter>>, TError, TData>
    >
    fetch?: RequestInit
  },
  queryClient?: QueryClient
): UseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>
} {
  const queryOptions = getTwitterQueryOptions(options)

  const query = useQuery(queryOptions, queryClient) as UseQueryResult<
    TData,
    TError
  > & { queryKey: DataTag<QueryKey, TData, TError> }

  query.queryKey = queryOptions.queryKey

  return query
}

/**
 * Receives the Twitter OAuth callback after successful authentication.
 * @summary Handle Twitter OAuth callback
 */
export const getTwitterCallbackUrl = () => {
  return `https://localhost:3001/oauth/twitter/callback`
}

export const twitterCallback = async (
  options?: RequestInit
): Promise<NoContentResponse> => {
  const res = await fetch(getTwitterCallbackUrl(), {
    ...options,
    method: 'GET'
  })

  const body = [204, 205, 304].includes(res.status) ? null : await res.text()
  const data: NoContentResponse = body ? JSON.parse(body) : {}

  return data
}

export const getTwitterCallbackQueryKey = () => {
  return [`https://localhost:3001/oauth/twitter/callback`] as const
}

export const getTwitterCallbackQueryOptions = <
  TData = Awaited<ReturnType<typeof twitterCallback>>,
  TError = unknown
>(options?: {
  query?: Partial<
    UseQueryOptions<Awaited<ReturnType<typeof twitterCallback>>, TError, TData>
  >
  fetch?: RequestInit
}) => {
  const { query: queryOptions, fetch: fetchOptions } = options ?? {}

  const queryKey = queryOptions?.queryKey ?? getTwitterCallbackQueryKey()

  const queryFn: QueryFunction<Awaited<ReturnType<typeof twitterCallback>>> = ({
    signal
  }) => twitterCallback({ ...(signal ? { signal } : {}), ...fetchOptions })

  return { queryKey, queryFn, ...queryOptions } as UseQueryOptions<
    Awaited<ReturnType<typeof twitterCallback>>,
    TError,
    TData
  > & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type TwitterCallbackQueryResult = NonNullable<
  Awaited<ReturnType<typeof twitterCallback>>
>
export type TwitterCallbackQueryError = unknown

export function useTwitterCallback<
  TData = Awaited<ReturnType<typeof twitterCallback>>,
  TError = unknown
>(
  options: {
    query: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof twitterCallback>>,
        TError,
        TData
      >
    > &
      Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof twitterCallback>>,
          TError,
          Awaited<ReturnType<typeof twitterCallback>>
        >,
        'initialData'
      >
    fetch?: RequestInit
  },
  queryClient?: QueryClient
): DefinedUseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>
}
export function useTwitterCallback<
  TData = Awaited<ReturnType<typeof twitterCallback>>,
  TError = unknown
>(
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof twitterCallback>>,
        TError,
        TData
      >
    > &
      Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof twitterCallback>>,
          TError,
          Awaited<ReturnType<typeof twitterCallback>>
        >,
        'initialData'
      >
    fetch?: RequestInit
  },
  queryClient?: QueryClient
): UseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>
}
export function useTwitterCallback<
  TData = Awaited<ReturnType<typeof twitterCallback>>,
  TError = unknown
>(
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof twitterCallback>>,
        TError,
        TData
      >
    >
    fetch?: RequestInit
  },
  queryClient?: QueryClient
): UseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>
}
/**
 * @summary Handle Twitter OAuth callback
 */

export function useTwitterCallback<
  TData = Awaited<ReturnType<typeof twitterCallback>>,
  TError = unknown
>(
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof twitterCallback>>,
        TError,
        TData
      >
    >
    fetch?: RequestInit
  },
  queryClient?: QueryClient
): UseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>
} {
  const queryOptions = getTwitterCallbackQueryOptions(options)

  const query = useQuery(queryOptions, queryClient) as UseQueryResult<
    TData,
    TError
  > & { queryKey: DataTag<QueryKey, TData, TError> }

  query.queryKey = queryOptions.queryKey

  return query
}

/**
 * This endpoint will log you in with your e-mail and password
 * @summary Login
 */
export const getLoginUrl = () => {
  return `https://localhost:3001/auth/login`
}

export const login = async (
  loginBody: LoginBody,
  options?: RequestInit
): Promise<NoContentResponse> => {
  const res = await fetch(getLoginUrl(), {
    ...options,
    method: 'POST',
    headers: { 'Content-Type': 'application/json', ...options?.headers },
    body: JSON.stringify(loginBody)
  })

  const body = [204, 205, 304].includes(res.status) ? null : await res.text()
  const data: NoContentResponse = body ? JSON.parse(body) : {}

  return data
}

export const getLoginMutationOptions = <
  TError = UnauthorizedResponse,
  TContext = unknown
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof login>>,
    TError,
    { data: LoginBody },
    TContext
  >
  fetch?: RequestInit
}): UseMutationOptions<
  Awaited<ReturnType<typeof login>>,
  TError,
  { data: LoginBody },
  TContext
> => {
  const mutationKey = ['login']
  const { mutation: mutationOptions, fetch: fetchOptions } =
    options ?
      (
        options.mutation &&
        'mutationKey' in options.mutation &&
        options.mutation.mutationKey
      ) ?
        options
      : { ...options, mutation: { ...options.mutation, mutationKey } }
    : { mutation: { mutationKey }, fetch: undefined }

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof login>>,
    { data: LoginBody }
  > = (props) => {
    const { data } = props ?? {}

    return login(data, fetchOptions)
  }

  return { mutationFn, ...mutationOptions }
}

export type LoginMutationResult = NonNullable<Awaited<ReturnType<typeof login>>>
export type LoginMutationBody = LoginBody
export type LoginMutationError = UnauthorizedResponse

/**
 * @summary Login
 */
export const useLogin = <TError = UnauthorizedResponse, TContext = unknown>(
  options?: {
    mutation?: UseMutationOptions<
      Awaited<ReturnType<typeof login>>,
      TError,
      { data: LoginBody },
      TContext
    >
    fetch?: RequestInit
  },
  queryClient?: QueryClient
): UseMutationResult<
  Awaited<ReturnType<typeof login>>,
  TError,
  { data: LoginBody },
  TContext
> => {
  const mutationOptions = getLoginMutationOptions(options)

  return useMutation(mutationOptions, queryClient)
}

/**
 * This endpoint will log you out of the current session
 * @summary Logout
 */
export const getLogoutUrl = () => {
  return `https://localhost:3001/auth/logout`
}

export const logout = async (
  options?: RequestInit
): Promise<NoContentResponse> => {
  const res = await fetch(getLogoutUrl(), {
    ...options,
    method: 'POST'
  })

  const body = [204, 205, 304].includes(res.status) ? null : await res.text()
  const data: NoContentResponse = body ? JSON.parse(body) : {}

  return data
}

export const getLogoutMutationOptions = <
  TError = UnauthorizedResponse,
  TContext = unknown
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof logout>>,
    TError,
    void,
    TContext
  >
  fetch?: RequestInit
}): UseMutationOptions<
  Awaited<ReturnType<typeof logout>>,
  TError,
  void,
  TContext
> => {
  const mutationKey = ['logout']
  const { mutation: mutationOptions, fetch: fetchOptions } =
    options ?
      (
        options.mutation &&
        'mutationKey' in options.mutation &&
        options.mutation.mutationKey
      ) ?
        options
      : { ...options, mutation: { ...options.mutation, mutationKey } }
    : { mutation: { mutationKey }, fetch: undefined }

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof logout>>,
    void
  > = () => {
    return logout(fetchOptions)
  }

  return { mutationFn, ...mutationOptions }
}

export type LogoutMutationResult = NonNullable<
  Awaited<ReturnType<typeof logout>>
>

export type LogoutMutationError = UnauthorizedResponse

/**
 * @summary Logout
 */
export const useLogout = <TError = UnauthorizedResponse, TContext = unknown>(
  options?: {
    mutation?: UseMutationOptions<
      Awaited<ReturnType<typeof logout>>,
      TError,
      void,
      TContext
    >
    fetch?: RequestInit
  },
  queryClient?: QueryClient
): UseMutationResult<
  Awaited<ReturnType<typeof logout>>,
  TError,
  void,
  TContext
> => {
  const mutationOptions = getLogoutMutationOptions(options)

  return useMutation(mutationOptions, queryClient)
}

/**
 * This endpoint will return the current session information
 * @summary Get Session
 */
export const getGetSessionUrl = () => {
  return `https://localhost:3001/auth/session`
}

export const getSession = async (
  options?: RequestInit
): Promise<GetSession200> => {
  const res = await fetch(getGetSessionUrl(), {
    ...options,
    method: 'GET'
  })

  const body = [204, 205, 304].includes(res.status) ? null : await res.text()
  const data: GetSession200 = body ? JSON.parse(body) : {}

  return data
}

export const getGetSessionQueryKey = () => {
  return [`https://localhost:3001/auth/session`] as const
}

export const getGetSessionQueryOptions = <
  TData = Awaited<ReturnType<typeof getSession>>,
  TError = UnauthorizedResponse
>(options?: {
  query?: Partial<
    UseQueryOptions<Awaited<ReturnType<typeof getSession>>, TError, TData>
  >
  fetch?: RequestInit
}) => {
  const { query: queryOptions, fetch: fetchOptions } = options ?? {}

  const queryKey = queryOptions?.queryKey ?? getGetSessionQueryKey()

  const queryFn: QueryFunction<Awaited<ReturnType<typeof getSession>>> = ({
    signal
  }) => getSession({ ...(signal ? { signal } : {}), ...fetchOptions })

  return { queryKey, queryFn, ...queryOptions } as UseQueryOptions<
    Awaited<ReturnType<typeof getSession>>,
    TError,
    TData
  > & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type GetSessionQueryResult = NonNullable<
  Awaited<ReturnType<typeof getSession>>
>
export type GetSessionQueryError = UnauthorizedResponse

export function useGetSession<
  TData = Awaited<ReturnType<typeof getSession>>,
  TError = UnauthorizedResponse
>(
  options: {
    query: Partial<
      UseQueryOptions<Awaited<ReturnType<typeof getSession>>, TError, TData>
    > &
      Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof getSession>>,
          TError,
          Awaited<ReturnType<typeof getSession>>
        >,
        'initialData'
      >
    fetch?: RequestInit
  },
  queryClient?: QueryClient
): DefinedUseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>
}
export function useGetSession<
  TData = Awaited<ReturnType<typeof getSession>>,
  TError = UnauthorizedResponse
>(
  options?: {
    query?: Partial<
      UseQueryOptions<Awaited<ReturnType<typeof getSession>>, TError, TData>
    > &
      Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof getSession>>,
          TError,
          Awaited<ReturnType<typeof getSession>>
        >,
        'initialData'
      >
    fetch?: RequestInit
  },
  queryClient?: QueryClient
): UseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>
}
export function useGetSession<
  TData = Awaited<ReturnType<typeof getSession>>,
  TError = UnauthorizedResponse
>(
  options?: {
    query?: Partial<
      UseQueryOptions<Awaited<ReturnType<typeof getSession>>, TError, TData>
    >
    fetch?: RequestInit
  },
  queryClient?: QueryClient
): UseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>
}
/**
 * @summary Get Session
 */

export function useGetSession<
  TData = Awaited<ReturnType<typeof getSession>>,
  TError = UnauthorizedResponse
>(
  options?: {
    query?: Partial<
      UseQueryOptions<Awaited<ReturnType<typeof getSession>>, TError, TData>
    >
    fetch?: RequestInit
  },
  queryClient?: QueryClient
): UseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>
} {
  const queryOptions = getGetSessionQueryOptions(options)

  const query = useQuery(queryOptions, queryClient) as UseQueryResult<
    TData,
    TError
  > & { queryKey: DataTag<QueryKey, TData, TError> }

  query.queryKey = queryOptions.queryKey

  return query
}

/**
 * This endpoint will confirm your password change with a token
 * @summary Confirm password reset
 */
export const getConfirmPasswordResetUrl = () => {
  return `https://localhost:3001/auth/password-reset/confirm`
}

export const confirmPasswordReset = async (
  confirmPasswordResetBody: ConfirmPasswordResetBody,
  options?: RequestInit
): Promise<NoContentResponse> => {
  const res = await fetch(getConfirmPasswordResetUrl(), {
    ...options,
    method: 'POST',
    headers: { 'Content-Type': 'application/json', ...options?.headers },
    body: JSON.stringify(confirmPasswordResetBody)
  })

  const body = [204, 205, 304].includes(res.status) ? null : await res.text()
  const data: NoContentResponse = body ? JSON.parse(body) : {}

  return data
}

export const getConfirmPasswordResetMutationOptions = <
  TError = UnauthorizedResponse | NotFoundResponse,
  TContext = unknown
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof confirmPasswordReset>>,
    TError,
    { data: ConfirmPasswordResetBody },
    TContext
  >
  fetch?: RequestInit
}): UseMutationOptions<
  Awaited<ReturnType<typeof confirmPasswordReset>>,
  TError,
  { data: ConfirmPasswordResetBody },
  TContext
> => {
  const mutationKey = ['confirmPasswordReset']
  const { mutation: mutationOptions, fetch: fetchOptions } =
    options ?
      (
        options.mutation &&
        'mutationKey' in options.mutation &&
        options.mutation.mutationKey
      ) ?
        options
      : { ...options, mutation: { ...options.mutation, mutationKey } }
    : { mutation: { mutationKey }, fetch: undefined }

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof confirmPasswordReset>>,
    { data: ConfirmPasswordResetBody }
  > = (props) => {
    const { data } = props ?? {}

    return confirmPasswordReset(data, fetchOptions)
  }

  return { mutationFn, ...mutationOptions }
}

export type ConfirmPasswordResetMutationResult = NonNullable<
  Awaited<ReturnType<typeof confirmPasswordReset>>
>
export type ConfirmPasswordResetMutationBody = ConfirmPasswordResetBody
export type ConfirmPasswordResetMutationError =
  | UnauthorizedResponse
  | NotFoundResponse

/**
 * @summary Confirm password reset
 */
export const useConfirmPasswordReset = <
  TError = UnauthorizedResponse | NotFoundResponse,
  TContext = unknown
>(
  options?: {
    mutation?: UseMutationOptions<
      Awaited<ReturnType<typeof confirmPasswordReset>>,
      TError,
      { data: ConfirmPasswordResetBody },
      TContext
    >
    fetch?: RequestInit
  },
  queryClient?: QueryClient
): UseMutationResult<
  Awaited<ReturnType<typeof confirmPasswordReset>>,
  TError,
  { data: ConfirmPasswordResetBody },
  TContext
> => {
  const mutationOptions = getConfirmPasswordResetMutationOptions(options)

  return useMutation(mutationOptions, queryClient)
}

/**
 * This endpoint will request a password reset link
 * @summary Request password reset
 */
export const getRequestPasswordResetUrl = () => {
  return `https://localhost:3001/auth/password-reset/request`
}

export const requestPasswordReset = async (
  requestPasswordResetBody: RequestPasswordResetBody,
  options?: RequestInit
): Promise<NoContentResponse> => {
  const res = await fetch(getRequestPasswordResetUrl(), {
    ...options,
    method: 'POST',
    headers: { 'Content-Type': 'application/json', ...options?.headers },
    body: JSON.stringify(requestPasswordResetBody)
  })

  const body = [204, 205, 304].includes(res.status) ? null : await res.text()
  const data: NoContentResponse = body ? JSON.parse(body) : {}

  return data
}

export const getRequestPasswordResetMutationOptions = <
  TError = unknown,
  TContext = unknown
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof requestPasswordReset>>,
    TError,
    { data: RequestPasswordResetBody },
    TContext
  >
  fetch?: RequestInit
}): UseMutationOptions<
  Awaited<ReturnType<typeof requestPasswordReset>>,
  TError,
  { data: RequestPasswordResetBody },
  TContext
> => {
  const mutationKey = ['requestPasswordReset']
  const { mutation: mutationOptions, fetch: fetchOptions } =
    options ?
      (
        options.mutation &&
        'mutationKey' in options.mutation &&
        options.mutation.mutationKey
      ) ?
        options
      : { ...options, mutation: { ...options.mutation, mutationKey } }
    : { mutation: { mutationKey }, fetch: undefined }

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof requestPasswordReset>>,
    { data: RequestPasswordResetBody }
  > = (props) => {
    const { data } = props ?? {}

    return requestPasswordReset(data, fetchOptions)
  }

  return { mutationFn, ...mutationOptions }
}

export type RequestPasswordResetMutationResult = NonNullable<
  Awaited<ReturnType<typeof requestPasswordReset>>
>
export type RequestPasswordResetMutationBody = RequestPasswordResetBody
export type RequestPasswordResetMutationError = unknown

/**
 * @summary Request password reset
 */
export const useRequestPasswordReset = <TError = unknown, TContext = unknown>(
  options?: {
    mutation?: UseMutationOptions<
      Awaited<ReturnType<typeof requestPasswordReset>>,
      TError,
      { data: RequestPasswordResetBody },
      TContext
    >
    fetch?: RequestInit
  },
  queryClient?: QueryClient
): UseMutationResult<
  Awaited<ReturnType<typeof requestPasswordReset>>,
  TError,
  { data: RequestPasswordResetBody },
  TContext
> => {
  const mutationOptions = getRequestPasswordResetMutationOptions(options)

  return useMutation(mutationOptions, queryClient)
}

/**
 * This endpoint will confirm your e-mail change with a token
 * @summary Confirm e-mail change
 */
export const getConfirmEmailChangeUrl = () => {
  return `https://localhost:3001/auth/email-change/confirm`
}

export const confirmEmailChange = async (
  confirmEmailChangeBody: ConfirmEmailChangeBody,
  options?: RequestInit
): Promise<NoContentResponse> => {
  const res = await fetch(getConfirmEmailChangeUrl(), {
    ...options,
    method: 'POST',
    headers: { 'Content-Type': 'application/json', ...options?.headers },
    body: JSON.stringify(confirmEmailChangeBody)
  })

  const body = [204, 205, 304].includes(res.status) ? null : await res.text()
  const data: NoContentResponse = body ? JSON.parse(body) : {}

  return data
}

export const getConfirmEmailChangeMutationOptions = <
  TError = UnauthorizedResponse | NotFoundResponse,
  TContext = unknown
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof confirmEmailChange>>,
    TError,
    { data: ConfirmEmailChangeBody },
    TContext
  >
  fetch?: RequestInit
}): UseMutationOptions<
  Awaited<ReturnType<typeof confirmEmailChange>>,
  TError,
  { data: ConfirmEmailChangeBody },
  TContext
> => {
  const mutationKey = ['confirmEmailChange']
  const { mutation: mutationOptions, fetch: fetchOptions } =
    options ?
      (
        options.mutation &&
        'mutationKey' in options.mutation &&
        options.mutation.mutationKey
      ) ?
        options
      : { ...options, mutation: { ...options.mutation, mutationKey } }
    : { mutation: { mutationKey }, fetch: undefined }

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof confirmEmailChange>>,
    { data: ConfirmEmailChangeBody }
  > = (props) => {
    const { data } = props ?? {}

    return confirmEmailChange(data, fetchOptions)
  }

  return { mutationFn, ...mutationOptions }
}

export type ConfirmEmailChangeMutationResult = NonNullable<
  Awaited<ReturnType<typeof confirmEmailChange>>
>
export type ConfirmEmailChangeMutationBody = ConfirmEmailChangeBody
export type ConfirmEmailChangeMutationError =
  | UnauthorizedResponse
  | NotFoundResponse

/**
 * @summary Confirm e-mail change
 */
export const useConfirmEmailChange = <
  TError = UnauthorizedResponse | NotFoundResponse,
  TContext = unknown
>(
  options?: {
    mutation?: UseMutationOptions<
      Awaited<ReturnType<typeof confirmEmailChange>>,
      TError,
      { data: ConfirmEmailChangeBody },
      TContext
    >
    fetch?: RequestInit
  },
  queryClient?: QueryClient
): UseMutationResult<
  Awaited<ReturnType<typeof confirmEmailChange>>,
  TError,
  { data: ConfirmEmailChangeBody },
  TContext
> => {
  const mutationOptions = getConfirmEmailChangeMutationOptions(options)

  return useMutation(mutationOptions, queryClient)
}

/**
 * This endpoint will request your e-mail change with a token
 * @summary Request e-mail change
 */
export const getRequestEmailChangeUrl = () => {
  return `https://localhost:3001/auth/email-change/request`
}

export const requestEmailChange = async (
  requestEmailChangeBody: RequestEmailChangeBody,
  options?: RequestInit
): Promise<NoContentResponse> => {
  const res = await fetch(getRequestEmailChangeUrl(), {
    ...options,
    method: 'POST',
    headers: { 'Content-Type': 'application/json', ...options?.headers },
    body: JSON.stringify(requestEmailChangeBody)
  })

  const body = [204, 205, 304].includes(res.status) ? null : await res.text()
  const data: NoContentResponse = body ? JSON.parse(body) : {}

  return data
}

export const getRequestEmailChangeMutationOptions = <
  TError = unknown,
  TContext = unknown
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof requestEmailChange>>,
    TError,
    { data: RequestEmailChangeBody },
    TContext
  >
  fetch?: RequestInit
}): UseMutationOptions<
  Awaited<ReturnType<typeof requestEmailChange>>,
  TError,
  { data: RequestEmailChangeBody },
  TContext
> => {
  const mutationKey = ['requestEmailChange']
  const { mutation: mutationOptions, fetch: fetchOptions } =
    options ?
      (
        options.mutation &&
        'mutationKey' in options.mutation &&
        options.mutation.mutationKey
      ) ?
        options
      : { ...options, mutation: { ...options.mutation, mutationKey } }
    : { mutation: { mutationKey }, fetch: undefined }

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof requestEmailChange>>,
    { data: RequestEmailChangeBody }
  > = (props) => {
    const { data } = props ?? {}

    return requestEmailChange(data, fetchOptions)
  }

  return { mutationFn, ...mutationOptions }
}

export type RequestEmailChangeMutationResult = NonNullable<
  Awaited<ReturnType<typeof requestEmailChange>>
>
export type RequestEmailChangeMutationBody = RequestEmailChangeBody
export type RequestEmailChangeMutationError = unknown

/**
 * @summary Request e-mail change
 */
export const useRequestEmailChange = <TError = unknown, TContext = unknown>(
  options?: {
    mutation?: UseMutationOptions<
      Awaited<ReturnType<typeof requestEmailChange>>,
      TError,
      { data: RequestEmailChangeBody },
      TContext
    >
    fetch?: RequestInit
  },
  queryClient?: QueryClient
): UseMutationResult<
  Awaited<ReturnType<typeof requestEmailChange>>,
  TError,
  { data: RequestEmailChangeBody },
  TContext
> => {
  const mutationOptions = getRequestEmailChangeMutationOptions(options)

  return useMutation(mutationOptions, queryClient)
}

/**
 * This endpoint will confirm your e-mail with a token
 * @summary Confirm e-mail verification
 */
export const getConfirmEmailVerificationUrl = () => {
  return `https://localhost:3001/auth/email-verification/confirm`
}

export const confirmEmailVerification = async (
  confirmEmailVerificationBody: ConfirmEmailVerificationBody,
  options?: RequestInit
): Promise<NoContentResponse> => {
  const res = await fetch(getConfirmEmailVerificationUrl(), {
    ...options,
    method: 'POST',
    headers: { 'Content-Type': 'application/json', ...options?.headers },
    body: JSON.stringify(confirmEmailVerificationBody)
  })

  const body = [204, 205, 304].includes(res.status) ? null : await res.text()
  const data: NoContentResponse = body ? JSON.parse(body) : {}

  return data
}

export const getConfirmEmailVerificationMutationOptions = <
  TError = UnauthorizedResponse | NotFoundResponse,
  TContext = unknown
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof confirmEmailVerification>>,
    TError,
    { data: ConfirmEmailVerificationBody },
    TContext
  >
  fetch?: RequestInit
}): UseMutationOptions<
  Awaited<ReturnType<typeof confirmEmailVerification>>,
  TError,
  { data: ConfirmEmailVerificationBody },
  TContext
> => {
  const mutationKey = ['confirmEmailVerification']
  const { mutation: mutationOptions, fetch: fetchOptions } =
    options ?
      (
        options.mutation &&
        'mutationKey' in options.mutation &&
        options.mutation.mutationKey
      ) ?
        options
      : { ...options, mutation: { ...options.mutation, mutationKey } }
    : { mutation: { mutationKey }, fetch: undefined }

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof confirmEmailVerification>>,
    { data: ConfirmEmailVerificationBody }
  > = (props) => {
    const { data } = props ?? {}

    return confirmEmailVerification(data, fetchOptions)
  }

  return { mutationFn, ...mutationOptions }
}

export type ConfirmEmailVerificationMutationResult = NonNullable<
  Awaited<ReturnType<typeof confirmEmailVerification>>
>
export type ConfirmEmailVerificationMutationBody = ConfirmEmailVerificationBody
export type ConfirmEmailVerificationMutationError =
  | UnauthorizedResponse
  | NotFoundResponse

/**
 * @summary Confirm e-mail verification
 */
export const useConfirmEmailVerification = <
  TError = UnauthorizedResponse | NotFoundResponse,
  TContext = unknown
>(
  options?: {
    mutation?: UseMutationOptions<
      Awaited<ReturnType<typeof confirmEmailVerification>>,
      TError,
      { data: ConfirmEmailVerificationBody },
      TContext
    >
    fetch?: RequestInit
  },
  queryClient?: QueryClient
): UseMutationResult<
  Awaited<ReturnType<typeof confirmEmailVerification>>,
  TError,
  { data: ConfirmEmailVerificationBody },
  TContext
> => {
  const mutationOptions = getConfirmEmailVerificationMutationOptions(options)

  return useMutation(mutationOptions, queryClient)
}

/**
 * This endpoint will send an e-mail verification link to you. ADMIN ONLY.
 * @summary Request e-mail verification
 */
export const getRequestEmailVerificationUrl = () => {
  return `https://localhost:3001/auth/email-verification/request`
}

export const requestEmailVerification = async (
  options?: RequestInit
): Promise<NoContentResponse> => {
  const res = await fetch(getRequestEmailVerificationUrl(), {
    ...options,
    method: 'POST'
  })

  const body = [204, 205, 304].includes(res.status) ? null : await res.text()
  const data: NoContentResponse = body ? JSON.parse(body) : {}

  return data
}

export const getRequestEmailVerificationMutationOptions = <
  TError = unknown,
  TContext = unknown
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof requestEmailVerification>>,
    TError,
    void,
    TContext
  >
  fetch?: RequestInit
}): UseMutationOptions<
  Awaited<ReturnType<typeof requestEmailVerification>>,
  TError,
  void,
  TContext
> => {
  const mutationKey = ['requestEmailVerification']
  const { mutation: mutationOptions, fetch: fetchOptions } =
    options ?
      (
        options.mutation &&
        'mutationKey' in options.mutation &&
        options.mutation.mutationKey
      ) ?
        options
      : { ...options, mutation: { ...options.mutation, mutationKey } }
    : { mutation: { mutationKey }, fetch: undefined }

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof requestEmailVerification>>,
    void
  > = () => {
    return requestEmailVerification(fetchOptions)
  }

  return { mutationFn, ...mutationOptions }
}

export type RequestEmailVerificationMutationResult = NonNullable<
  Awaited<ReturnType<typeof requestEmailVerification>>
>

export type RequestEmailVerificationMutationError = unknown

/**
 * @summary Request e-mail verification
 */
export const useRequestEmailVerification = <
  TError = unknown,
  TContext = unknown
>(
  options?: {
    mutation?: UseMutationOptions<
      Awaited<ReturnType<typeof requestEmailVerification>>,
      TError,
      void,
      TContext
    >
    fetch?: RequestInit
  },
  queryClient?: QueryClient
): UseMutationResult<
  Awaited<ReturnType<typeof requestEmailVerification>>,
  TError,
  void,
  TContext
> => {
  const mutationOptions = getRequestEmailVerificationMutationOptions(options)

  return useMutation(mutationOptions, queryClient)
}

/**
 * This endpoint will register you with your e-mail and password
 * @summary Register
 */
export const getRegisterUrl = () => {
  return `https://localhost:3001/auth/register`
}

export const register = async (
  registerBody: RegisterBody,
  options?: RequestInit
): Promise<NoContentResponse> => {
  const res = await fetch(getRegisterUrl(), {
    ...options,
    method: 'POST',
    headers: { 'Content-Type': 'application/json', ...options?.headers },
    body: JSON.stringify(registerBody)
  })

  const body = [204, 205, 304].includes(res.status) ? null : await res.text()
  const data: NoContentResponse = body ? JSON.parse(body) : {}

  return data
}

export const getRegisterMutationOptions = <
  TError = UnauthorizedResponse,
  TContext = unknown
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof register>>,
    TError,
    { data: RegisterBody },
    TContext
  >
  fetch?: RequestInit
}): UseMutationOptions<
  Awaited<ReturnType<typeof register>>,
  TError,
  { data: RegisterBody },
  TContext
> => {
  const mutationKey = ['register']
  const { mutation: mutationOptions, fetch: fetchOptions } =
    options ?
      (
        options.mutation &&
        'mutationKey' in options.mutation &&
        options.mutation.mutationKey
      ) ?
        options
      : { ...options, mutation: { ...options.mutation, mutationKey } }
    : { mutation: { mutationKey }, fetch: undefined }

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof register>>,
    { data: RegisterBody }
  > = (props) => {
    const { data } = props ?? {}

    return register(data, fetchOptions)
  }

  return { mutationFn, ...mutationOptions }
}

export type RegisterMutationResult = NonNullable<
  Awaited<ReturnType<typeof register>>
>
export type RegisterMutationBody = RegisterBody
export type RegisterMutationError = UnauthorizedResponse

/**
 * @summary Register
 */
export const useRegister = <TError = UnauthorizedResponse, TContext = unknown>(
  options?: {
    mutation?: UseMutationOptions<
      Awaited<ReturnType<typeof register>>,
      TError,
      { data: RegisterBody },
      TContext
    >
    fetch?: RequestInit
  },
  queryClient?: QueryClient
): UseMutationResult<
  Awaited<ReturnType<typeof register>>,
  TError,
  { data: RegisterBody },
  TContext
> => {
  const mutationOptions = getRegisterMutationOptions(options)

  return useMutation(mutationOptions, queryClient)
}
