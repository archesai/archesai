/**
 * Generated by orval v7.10.0 üç∫
 * Do not edit manually.
 * Arches AI API
 * The Arches AI API
 * OpenAPI spec version: v1
 */
import type {
  DataTag,
  DefinedInitialDataOptions,
  DefinedUseQueryResult,
  MutationFunction,
  QueryClient,
  QueryFunction,
  QueryKey,
  UndefinedInitialDataOptions,
  UseMutationOptions,
  UseMutationResult,
  UseQueryOptions,
  UseQueryResult,
  UseSuspenseQueryOptions,
  UseSuspenseQueryResult
} from '@tanstack/react-query'

import { useMutation, useQuery, useSuspenseQuery } from '@tanstack/react-query'
import qs from 'qs'

import type {
  DeleteFilesKey200,
  GetFiles200,
  GetFilesParams,
  PostDownloadUrl200,
  PostDownloadUrlBody,
  PostMultipartAbort200,
  PostMultipartAbortBody,
  PostMultipartComplete200,
  PostMultipartCompleteBody,
  PostMultipartCreate200,
  PostMultipartCreateBody,
  PostMultipartPartUrl200,
  PostMultipartPartUrlBody,
  PostUploadUrl200,
  PostUploadUrlBody
} from '../orval.schemas'

import { customFetch } from '../../fetcher'

type SecondParameter<T extends (...args: never) => unknown> = Parameters<T>[1]

export const getPostUploadUrlUrl = () => {
  return `/upload-url`
}

export const postUploadUrl = async (
  postUploadUrlBody: PostUploadUrlBody,
  options?: RequestInit
): Promise<PostUploadUrl200> => {
  return customFetch<PostUploadUrl200>(getPostUploadUrlUrl(), {
    ...options,
    method: 'POST',
    headers: { 'Content-Type': 'application/json', ...options?.headers },
    body: JSON.stringify(postUploadUrlBody)
  })
}

export const getPostUploadUrlMutationOptions = <
  TError = unknown,
  TContext = unknown
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof postUploadUrl>>,
    TError,
    { data: PostUploadUrlBody },
    TContext
  >
  request?: SecondParameter<typeof customFetch>
}): UseMutationOptions<
  Awaited<ReturnType<typeof postUploadUrl>>,
  TError,
  { data: PostUploadUrlBody },
  TContext
> => {
  const mutationKey = ['postUploadUrl']
  const { mutation: mutationOptions, request: requestOptions } =
    options ?
      (
        options.mutation &&
        'mutationKey' in options.mutation &&
        options.mutation.mutationKey
      ) ?
        options
      : { ...options, mutation: { ...options.mutation, mutationKey } }
    : { mutation: { mutationKey }, request: undefined }

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof postUploadUrl>>,
    { data: PostUploadUrlBody }
  > = (props) => {
    const { data } = props ?? {}

    return postUploadUrl(data, requestOptions)
  }

  return { mutationFn, ...mutationOptions }
}

export type PostUploadUrlMutationResult = NonNullable<
  Awaited<ReturnType<typeof postUploadUrl>>
>
export type PostUploadUrlMutationBody = PostUploadUrlBody
export type PostUploadUrlMutationError = unknown

export const usePostUploadUrl = <TError = unknown, TContext = unknown>(
  options?: {
    mutation?: UseMutationOptions<
      Awaited<ReturnType<typeof postUploadUrl>>,
      TError,
      { data: PostUploadUrlBody },
      TContext
    >
    request?: SecondParameter<typeof customFetch>
  },
  queryClient?: QueryClient
): UseMutationResult<
  Awaited<ReturnType<typeof postUploadUrl>>,
  TError,
  { data: PostUploadUrlBody },
  TContext
> => {
  const mutationOptions = getPostUploadUrlMutationOptions(options)

  return useMutation(mutationOptions, queryClient)
}
export const getPostDownloadUrlUrl = () => {
  return `/download-url`
}

export const postDownloadUrl = async (
  postDownloadUrlBody: PostDownloadUrlBody,
  options?: RequestInit
): Promise<PostDownloadUrl200> => {
  return customFetch<PostDownloadUrl200>(getPostDownloadUrlUrl(), {
    ...options,
    method: 'POST',
    headers: { 'Content-Type': 'application/json', ...options?.headers },
    body: JSON.stringify(postDownloadUrlBody)
  })
}

export const getPostDownloadUrlMutationOptions = <
  TError = unknown,
  TContext = unknown
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof postDownloadUrl>>,
    TError,
    { data: PostDownloadUrlBody },
    TContext
  >
  request?: SecondParameter<typeof customFetch>
}): UseMutationOptions<
  Awaited<ReturnType<typeof postDownloadUrl>>,
  TError,
  { data: PostDownloadUrlBody },
  TContext
> => {
  const mutationKey = ['postDownloadUrl']
  const { mutation: mutationOptions, request: requestOptions } =
    options ?
      (
        options.mutation &&
        'mutationKey' in options.mutation &&
        options.mutation.mutationKey
      ) ?
        options
      : { ...options, mutation: { ...options.mutation, mutationKey } }
    : { mutation: { mutationKey }, request: undefined }

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof postDownloadUrl>>,
    { data: PostDownloadUrlBody }
  > = (props) => {
    const { data } = props ?? {}

    return postDownloadUrl(data, requestOptions)
  }

  return { mutationFn, ...mutationOptions }
}

export type PostDownloadUrlMutationResult = NonNullable<
  Awaited<ReturnType<typeof postDownloadUrl>>
>
export type PostDownloadUrlMutationBody = PostDownloadUrlBody
export type PostDownloadUrlMutationError = unknown

export const usePostDownloadUrl = <TError = unknown, TContext = unknown>(
  options?: {
    mutation?: UseMutationOptions<
      Awaited<ReturnType<typeof postDownloadUrl>>,
      TError,
      { data: PostDownloadUrlBody },
      TContext
    >
    request?: SecondParameter<typeof customFetch>
  },
  queryClient?: QueryClient
): UseMutationResult<
  Awaited<ReturnType<typeof postDownloadUrl>>,
  TError,
  { data: PostDownloadUrlBody },
  TContext
> => {
  const mutationOptions = getPostDownloadUrlMutationOptions(options)

  return useMutation(mutationOptions, queryClient)
}
export const getGetFilesUrl = (params?: GetFilesParams) => {
  const stringifiedParams = qs.stringify(params || {}, {
    skipNulls: false,
    strictNullHandling: true
  })

  return stringifiedParams.length > 0 ? `/files?${stringifiedParams}` : `/files`
}

export const getFiles = async (
  params?: GetFilesParams,
  options?: RequestInit
): Promise<GetFiles200> => {
  return customFetch<GetFiles200>(getGetFilesUrl(params), {
    ...options,
    method: 'GET'
  })
}

export const getGetFilesQueryKey = (params?: GetFilesParams) => {
  return [`/files`, ...(params ? [params] : [])] as const
}

export const getGetFilesQueryOptions = <
  TData = Awaited<ReturnType<typeof getFiles>>,
  TError = unknown
>(
  params?: GetFilesParams,
  options?: {
    query?: Partial<
      UseQueryOptions<Awaited<ReturnType<typeof getFiles>>, TError, TData>
    >
    request?: SecondParameter<typeof customFetch>
  }
) => {
  const { query: queryOptions, request: requestOptions } = options ?? {}

  const queryKey = queryOptions?.queryKey ?? getGetFilesQueryKey(params)

  const queryFn: QueryFunction<Awaited<ReturnType<typeof getFiles>>> = ({
    signal
  }) => getFiles(params, { signal, ...requestOptions })

  return { queryKey, queryFn, ...queryOptions } as UseQueryOptions<
    Awaited<ReturnType<typeof getFiles>>,
    TError,
    TData
  > & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type GetFilesQueryResult = NonNullable<
  Awaited<ReturnType<typeof getFiles>>
>
export type GetFilesQueryError = unknown

export function useGetFiles<
  TData = Awaited<ReturnType<typeof getFiles>>,
  TError = unknown
>(
  params: undefined | GetFilesParams,
  options: {
    query: Partial<
      UseQueryOptions<Awaited<ReturnType<typeof getFiles>>, TError, TData>
    > &
      Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof getFiles>>,
          TError,
          Awaited<ReturnType<typeof getFiles>>
        >,
        'initialData'
      >
    request?: SecondParameter<typeof customFetch>
  },
  queryClient?: QueryClient
): DefinedUseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>
}
export function useGetFiles<
  TData = Awaited<ReturnType<typeof getFiles>>,
  TError = unknown
>(
  params?: GetFilesParams,
  options?: {
    query?: Partial<
      UseQueryOptions<Awaited<ReturnType<typeof getFiles>>, TError, TData>
    > &
      Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof getFiles>>,
          TError,
          Awaited<ReturnType<typeof getFiles>>
        >,
        'initialData'
      >
    request?: SecondParameter<typeof customFetch>
  },
  queryClient?: QueryClient
): UseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>
}
export function useGetFiles<
  TData = Awaited<ReturnType<typeof getFiles>>,
  TError = unknown
>(
  params?: GetFilesParams,
  options?: {
    query?: Partial<
      UseQueryOptions<Awaited<ReturnType<typeof getFiles>>, TError, TData>
    >
    request?: SecondParameter<typeof customFetch>
  },
  queryClient?: QueryClient
): UseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>
}

export function useGetFiles<
  TData = Awaited<ReturnType<typeof getFiles>>,
  TError = unknown
>(
  params?: GetFilesParams,
  options?: {
    query?: Partial<
      UseQueryOptions<Awaited<ReturnType<typeof getFiles>>, TError, TData>
    >
    request?: SecondParameter<typeof customFetch>
  },
  queryClient?: QueryClient
): UseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>
} {
  const queryOptions = getGetFilesQueryOptions(params, options)

  const query = useQuery(queryOptions, queryClient) as UseQueryResult<
    TData,
    TError
  > & { queryKey: DataTag<QueryKey, TData, TError> }

  query.queryKey = queryOptions.queryKey

  return query
}

export const getGetFilesSuspenseQueryOptions = <
  TData = Awaited<ReturnType<typeof getFiles>>,
  TError = unknown
>(
  params?: GetFilesParams,
  options?: {
    query?: Partial<
      UseSuspenseQueryOptions<
        Awaited<ReturnType<typeof getFiles>>,
        TError,
        TData
      >
    >
    request?: SecondParameter<typeof customFetch>
  }
) => {
  const { query: queryOptions, request: requestOptions } = options ?? {}

  const queryKey = queryOptions?.queryKey ?? getGetFilesQueryKey(params)

  const queryFn: QueryFunction<Awaited<ReturnType<typeof getFiles>>> = ({
    signal
  }) => getFiles(params, { signal, ...requestOptions })

  return { queryKey, queryFn, ...queryOptions } as UseSuspenseQueryOptions<
    Awaited<ReturnType<typeof getFiles>>,
    TError,
    TData
  > & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type GetFilesSuspenseQueryResult = NonNullable<
  Awaited<ReturnType<typeof getFiles>>
>
export type GetFilesSuspenseQueryError = unknown

export function useGetFilesSuspense<
  TData = Awaited<ReturnType<typeof getFiles>>,
  TError = unknown
>(
  params: undefined | GetFilesParams,
  options: {
    query: Partial<
      UseSuspenseQueryOptions<
        Awaited<ReturnType<typeof getFiles>>,
        TError,
        TData
      >
    >
    request?: SecondParameter<typeof customFetch>
  },
  queryClient?: QueryClient
): UseSuspenseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>
}
export function useGetFilesSuspense<
  TData = Awaited<ReturnType<typeof getFiles>>,
  TError = unknown
>(
  params?: GetFilesParams,
  options?: {
    query?: Partial<
      UseSuspenseQueryOptions<
        Awaited<ReturnType<typeof getFiles>>,
        TError,
        TData
      >
    >
    request?: SecondParameter<typeof customFetch>
  },
  queryClient?: QueryClient
): UseSuspenseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>
}
export function useGetFilesSuspense<
  TData = Awaited<ReturnType<typeof getFiles>>,
  TError = unknown
>(
  params?: GetFilesParams,
  options?: {
    query?: Partial<
      UseSuspenseQueryOptions<
        Awaited<ReturnType<typeof getFiles>>,
        TError,
        TData
      >
    >
    request?: SecondParameter<typeof customFetch>
  },
  queryClient?: QueryClient
): UseSuspenseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>
}

export function useGetFilesSuspense<
  TData = Awaited<ReturnType<typeof getFiles>>,
  TError = unknown
>(
  params?: GetFilesParams,
  options?: {
    query?: Partial<
      UseSuspenseQueryOptions<
        Awaited<ReturnType<typeof getFiles>>,
        TError,
        TData
      >
    >
    request?: SecondParameter<typeof customFetch>
  },
  queryClient?: QueryClient
): UseSuspenseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>
} {
  const queryOptions = getGetFilesSuspenseQueryOptions(params, options)

  const query = useSuspenseQuery(
    queryOptions,
    queryClient
  ) as UseSuspenseQueryResult<TData, TError> & {
    queryKey: DataTag<QueryKey, TData, TError>
  }

  query.queryKey = queryOptions.queryKey

  return query
}

export const getDeleteFilesKeyUrl = (key: string | undefined | null) => {
  return `/files/${key}`
}

export const deleteFilesKey = async (
  key: string | undefined | null,
  options?: RequestInit
): Promise<DeleteFilesKey200> => {
  return customFetch<DeleteFilesKey200>(getDeleteFilesKeyUrl(key), {
    ...options,
    method: 'DELETE'
  })
}

export const getDeleteFilesKeyMutationOptions = <
  TError = unknown,
  TContext = unknown
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof deleteFilesKey>>,
    TError,
    { key: string | undefined | null },
    TContext
  >
  request?: SecondParameter<typeof customFetch>
}): UseMutationOptions<
  Awaited<ReturnType<typeof deleteFilesKey>>,
  TError,
  { key: string | undefined | null },
  TContext
> => {
  const mutationKey = ['deleteFilesKey']
  const { mutation: mutationOptions, request: requestOptions } =
    options ?
      (
        options.mutation &&
        'mutationKey' in options.mutation &&
        options.mutation.mutationKey
      ) ?
        options
      : { ...options, mutation: { ...options.mutation, mutationKey } }
    : { mutation: { mutationKey }, request: undefined }

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof deleteFilesKey>>,
    { key: string | undefined | null }
  > = (props) => {
    const { key } = props ?? {}

    return deleteFilesKey(key, requestOptions)
  }

  return { mutationFn, ...mutationOptions }
}

export type DeleteFilesKeyMutationResult = NonNullable<
  Awaited<ReturnType<typeof deleteFilesKey>>
>

export type DeleteFilesKeyMutationError = unknown

export const useDeleteFilesKey = <TError = unknown, TContext = unknown>(
  options?: {
    mutation?: UseMutationOptions<
      Awaited<ReturnType<typeof deleteFilesKey>>,
      TError,
      { key: string | undefined | null },
      TContext
    >
    request?: SecondParameter<typeof customFetch>
  },
  queryClient?: QueryClient
): UseMutationResult<
  Awaited<ReturnType<typeof deleteFilesKey>>,
  TError,
  { key: string | undefined | null },
  TContext
> => {
  const mutationOptions = getDeleteFilesKeyMutationOptions(options)

  return useMutation(mutationOptions, queryClient)
}
export const getPostMultipartCreateUrl = () => {
  return `/multipart/create`
}

export const postMultipartCreate = async (
  postMultipartCreateBody: PostMultipartCreateBody,
  options?: RequestInit
): Promise<PostMultipartCreate200> => {
  return customFetch<PostMultipartCreate200>(getPostMultipartCreateUrl(), {
    ...options,
    method: 'POST',
    headers: { 'Content-Type': 'application/json', ...options?.headers },
    body: JSON.stringify(postMultipartCreateBody)
  })
}

export const getPostMultipartCreateMutationOptions = <
  TError = unknown,
  TContext = unknown
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof postMultipartCreate>>,
    TError,
    { data: PostMultipartCreateBody },
    TContext
  >
  request?: SecondParameter<typeof customFetch>
}): UseMutationOptions<
  Awaited<ReturnType<typeof postMultipartCreate>>,
  TError,
  { data: PostMultipartCreateBody },
  TContext
> => {
  const mutationKey = ['postMultipartCreate']
  const { mutation: mutationOptions, request: requestOptions } =
    options ?
      (
        options.mutation &&
        'mutationKey' in options.mutation &&
        options.mutation.mutationKey
      ) ?
        options
      : { ...options, mutation: { ...options.mutation, mutationKey } }
    : { mutation: { mutationKey }, request: undefined }

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof postMultipartCreate>>,
    { data: PostMultipartCreateBody }
  > = (props) => {
    const { data } = props ?? {}

    return postMultipartCreate(data, requestOptions)
  }

  return { mutationFn, ...mutationOptions }
}

export type PostMultipartCreateMutationResult = NonNullable<
  Awaited<ReturnType<typeof postMultipartCreate>>
>
export type PostMultipartCreateMutationBody = PostMultipartCreateBody
export type PostMultipartCreateMutationError = unknown

export const usePostMultipartCreate = <TError = unknown, TContext = unknown>(
  options?: {
    mutation?: UseMutationOptions<
      Awaited<ReturnType<typeof postMultipartCreate>>,
      TError,
      { data: PostMultipartCreateBody },
      TContext
    >
    request?: SecondParameter<typeof customFetch>
  },
  queryClient?: QueryClient
): UseMutationResult<
  Awaited<ReturnType<typeof postMultipartCreate>>,
  TError,
  { data: PostMultipartCreateBody },
  TContext
> => {
  const mutationOptions = getPostMultipartCreateMutationOptions(options)

  return useMutation(mutationOptions, queryClient)
}
export const getPostMultipartPartUrlUrl = () => {
  return `/multipart/part-url`
}

export const postMultipartPartUrl = async (
  postMultipartPartUrlBody: PostMultipartPartUrlBody,
  options?: RequestInit
): Promise<PostMultipartPartUrl200> => {
  return customFetch<PostMultipartPartUrl200>(getPostMultipartPartUrlUrl(), {
    ...options,
    method: 'POST',
    headers: { 'Content-Type': 'application/json', ...options?.headers },
    body: JSON.stringify(postMultipartPartUrlBody)
  })
}

export const getPostMultipartPartUrlMutationOptions = <
  TError = unknown,
  TContext = unknown
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof postMultipartPartUrl>>,
    TError,
    { data: PostMultipartPartUrlBody },
    TContext
  >
  request?: SecondParameter<typeof customFetch>
}): UseMutationOptions<
  Awaited<ReturnType<typeof postMultipartPartUrl>>,
  TError,
  { data: PostMultipartPartUrlBody },
  TContext
> => {
  const mutationKey = ['postMultipartPartUrl']
  const { mutation: mutationOptions, request: requestOptions } =
    options ?
      (
        options.mutation &&
        'mutationKey' in options.mutation &&
        options.mutation.mutationKey
      ) ?
        options
      : { ...options, mutation: { ...options.mutation, mutationKey } }
    : { mutation: { mutationKey }, request: undefined }

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof postMultipartPartUrl>>,
    { data: PostMultipartPartUrlBody }
  > = (props) => {
    const { data } = props ?? {}

    return postMultipartPartUrl(data, requestOptions)
  }

  return { mutationFn, ...mutationOptions }
}

export type PostMultipartPartUrlMutationResult = NonNullable<
  Awaited<ReturnType<typeof postMultipartPartUrl>>
>
export type PostMultipartPartUrlMutationBody = PostMultipartPartUrlBody
export type PostMultipartPartUrlMutationError = unknown

export const usePostMultipartPartUrl = <TError = unknown, TContext = unknown>(
  options?: {
    mutation?: UseMutationOptions<
      Awaited<ReturnType<typeof postMultipartPartUrl>>,
      TError,
      { data: PostMultipartPartUrlBody },
      TContext
    >
    request?: SecondParameter<typeof customFetch>
  },
  queryClient?: QueryClient
): UseMutationResult<
  Awaited<ReturnType<typeof postMultipartPartUrl>>,
  TError,
  { data: PostMultipartPartUrlBody },
  TContext
> => {
  const mutationOptions = getPostMultipartPartUrlMutationOptions(options)

  return useMutation(mutationOptions, queryClient)
}
export const getPostMultipartCompleteUrl = () => {
  return `/multipart/complete`
}

export const postMultipartComplete = async (
  postMultipartCompleteBody: PostMultipartCompleteBody,
  options?: RequestInit
): Promise<PostMultipartComplete200> => {
  return customFetch<PostMultipartComplete200>(getPostMultipartCompleteUrl(), {
    ...options,
    method: 'POST',
    headers: { 'Content-Type': 'application/json', ...options?.headers },
    body: JSON.stringify(postMultipartCompleteBody)
  })
}

export const getPostMultipartCompleteMutationOptions = <
  TError = unknown,
  TContext = unknown
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof postMultipartComplete>>,
    TError,
    { data: PostMultipartCompleteBody },
    TContext
  >
  request?: SecondParameter<typeof customFetch>
}): UseMutationOptions<
  Awaited<ReturnType<typeof postMultipartComplete>>,
  TError,
  { data: PostMultipartCompleteBody },
  TContext
> => {
  const mutationKey = ['postMultipartComplete']
  const { mutation: mutationOptions, request: requestOptions } =
    options ?
      (
        options.mutation &&
        'mutationKey' in options.mutation &&
        options.mutation.mutationKey
      ) ?
        options
      : { ...options, mutation: { ...options.mutation, mutationKey } }
    : { mutation: { mutationKey }, request: undefined }

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof postMultipartComplete>>,
    { data: PostMultipartCompleteBody }
  > = (props) => {
    const { data } = props ?? {}

    return postMultipartComplete(data, requestOptions)
  }

  return { mutationFn, ...mutationOptions }
}

export type PostMultipartCompleteMutationResult = NonNullable<
  Awaited<ReturnType<typeof postMultipartComplete>>
>
export type PostMultipartCompleteMutationBody = PostMultipartCompleteBody
export type PostMultipartCompleteMutationError = unknown

export const usePostMultipartComplete = <TError = unknown, TContext = unknown>(
  options?: {
    mutation?: UseMutationOptions<
      Awaited<ReturnType<typeof postMultipartComplete>>,
      TError,
      { data: PostMultipartCompleteBody },
      TContext
    >
    request?: SecondParameter<typeof customFetch>
  },
  queryClient?: QueryClient
): UseMutationResult<
  Awaited<ReturnType<typeof postMultipartComplete>>,
  TError,
  { data: PostMultipartCompleteBody },
  TContext
> => {
  const mutationOptions = getPostMultipartCompleteMutationOptions(options)

  return useMutation(mutationOptions, queryClient)
}
export const getPostMultipartAbortUrl = () => {
  return `/multipart/abort`
}

export const postMultipartAbort = async (
  postMultipartAbortBody: PostMultipartAbortBody,
  options?: RequestInit
): Promise<PostMultipartAbort200> => {
  return customFetch<PostMultipartAbort200>(getPostMultipartAbortUrl(), {
    ...options,
    method: 'POST',
    headers: { 'Content-Type': 'application/json', ...options?.headers },
    body: JSON.stringify(postMultipartAbortBody)
  })
}

export const getPostMultipartAbortMutationOptions = <
  TError = unknown,
  TContext = unknown
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof postMultipartAbort>>,
    TError,
    { data: PostMultipartAbortBody },
    TContext
  >
  request?: SecondParameter<typeof customFetch>
}): UseMutationOptions<
  Awaited<ReturnType<typeof postMultipartAbort>>,
  TError,
  { data: PostMultipartAbortBody },
  TContext
> => {
  const mutationKey = ['postMultipartAbort']
  const { mutation: mutationOptions, request: requestOptions } =
    options ?
      (
        options.mutation &&
        'mutationKey' in options.mutation &&
        options.mutation.mutationKey
      ) ?
        options
      : { ...options, mutation: { ...options.mutation, mutationKey } }
    : { mutation: { mutationKey }, request: undefined }

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof postMultipartAbort>>,
    { data: PostMultipartAbortBody }
  > = (props) => {
    const { data } = props ?? {}

    return postMultipartAbort(data, requestOptions)
  }

  return { mutationFn, ...mutationOptions }
}

export type PostMultipartAbortMutationResult = NonNullable<
  Awaited<ReturnType<typeof postMultipartAbort>>
>
export type PostMultipartAbortMutationBody = PostMultipartAbortBody
export type PostMultipartAbortMutationError = unknown

export const usePostMultipartAbort = <TError = unknown, TContext = unknown>(
  options?: {
    mutation?: UseMutationOptions<
      Awaited<ReturnType<typeof postMultipartAbort>>,
      TError,
      { data: PostMultipartAbortBody },
      TContext
    >
    request?: SecondParameter<typeof customFetch>
  },
  queryClient?: QueryClient
): UseMutationResult<
  Awaited<ReturnType<typeof postMultipartAbort>>,
  TError,
  { data: PostMultipartAbortBody },
  TContext
> => {
  const mutationOptions = getPostMultipartAbortMutationOptions(options)

  return useMutation(mutationOptions, queryClient)
}
