// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.30.0
// source: accounts.gen.sql

package repositories

import (
	"context"
	"time"

	"github.com/google/uuid"
)

const countAccounts = `-- name: CountAccounts :one
SELECT
  COUNT(*)
FROM
  account
`

func (q *Queries) CountAccounts(ctx context.Context) (int64, error) {
	row := q.db.QueryRow(ctx, countAccounts)
	var count int64
	err := row.Scan(&count)
	return count, err
}

const createAccount = `-- name: CreateAccount :one
INSERT INTO
  account (id, access_token, access_token_expires_at, account_identifier, id_token, provider, refresh_token, refresh_token_expires_at, scope, user_id)
VALUES
  (
    $1,
    $2,
    $3,
    $4,
    $5,
    $6,
    $7,
    $8,
    $9,
    $10
  )
RETURNING
  id, created_at, updated_at, access_token, access_token_expires_at, account_identifier, id_token, provider, refresh_token, refresh_token_expires_at, scope, user_id
`

type CreateAccountParams struct {
	ID                    uuid.UUID
	AccessToken           *string
	AccessTokenExpiresAt  *time.Time
	AccountIdentifier     string
	IDToken               *string
	Provider              string
	RefreshToken          *string
	RefreshTokenExpiresAt *time.Time
	Scope                 *string
	UserID                uuid.UUID
}

func (q *Queries) CreateAccount(ctx context.Context, arg CreateAccountParams) (Account, error) {
	row := q.db.QueryRow(ctx, createAccount,
		arg.ID,
		arg.AccessToken,
		arg.AccessTokenExpiresAt,
		arg.AccountIdentifier,
		arg.IDToken,
		arg.Provider,
		arg.RefreshToken,
		arg.RefreshTokenExpiresAt,
		arg.Scope,
		arg.UserID,
	)
	var i Account
	err := row.Scan(
		&i.ID,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.AccessToken,
		&i.AccessTokenExpiresAt,
		&i.AccountIdentifier,
		&i.IDToken,
		&i.Provider,
		&i.RefreshToken,
		&i.RefreshTokenExpiresAt,
		&i.Scope,
		&i.UserID,
	)
	return i, err
}

const deleteAccount = `-- name: DeleteAccount :exec
DELETE FROM account
WHERE
  id = $1
`

type DeleteAccountParams struct {
	ID uuid.UUID
}

func (q *Queries) DeleteAccount(ctx context.Context, arg DeleteAccountParams) error {
	_, err := q.db.Exec(ctx, deleteAccount, arg.ID)
	return err
}

const getAccount = `-- name: GetAccount :one
SELECT
  id, created_at, updated_at, access_token, access_token_expires_at, account_identifier, id_token, provider, refresh_token, refresh_token_expires_at, scope, user_id
FROM
  account
WHERE
  id = $1
LIMIT
  1
`

type GetAccountParams struct {
	ID uuid.UUID
}

func (q *Queries) GetAccount(ctx context.Context, arg GetAccountParams) (Account, error) {
	row := q.db.QueryRow(ctx, getAccount, arg.ID)
	var i Account
	err := row.Scan(
		&i.ID,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.AccessToken,
		&i.AccessTokenExpiresAt,
		&i.AccountIdentifier,
		&i.IDToken,
		&i.Provider,
		&i.RefreshToken,
		&i.RefreshTokenExpiresAt,
		&i.Scope,
		&i.UserID,
	)
	return i, err
}

const getAccountByProvider = `-- name: GetAccountByProvider :one
SELECT
  id, created_at, updated_at, access_token, access_token_expires_at, account_identifier, id_token, provider, refresh_token, refresh_token_expires_at, scope, user_id
FROM
  account
WHERE
  provider = $1 AND
  account_identifier = $2
LIMIT
  1
`

type GetAccountByProviderParams struct {
	Provider          string
	AccountIdentifier string
}

func (q *Queries) GetAccountByProvider(ctx context.Context, arg GetAccountByProviderParams) (Account, error) {
	row := q.db.QueryRow(ctx, getAccountByProvider, arg.Provider, arg.AccountIdentifier)
	var i Account
	err := row.Scan(
		&i.ID,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.AccessToken,
		&i.AccessTokenExpiresAt,
		&i.AccountIdentifier,
		&i.IDToken,
		&i.Provider,
		&i.RefreshToken,
		&i.RefreshTokenExpiresAt,
		&i.Scope,
		&i.UserID,
	)
	return i, err
}

const listAccounts = `-- name: ListAccounts :many
SELECT
  id, created_at, updated_at, access_token, access_token_expires_at, account_identifier, id_token, provider, refresh_token, refresh_token_expires_at, scope, user_id
FROM
  account
ORDER BY
  created_at DESC
LIMIT
  $2
OFFSET
  $1
`

type ListAccountsParams struct {
	Offset int32
	Limit  int32
}

func (q *Queries) ListAccounts(ctx context.Context, arg ListAccountsParams) ([]Account, error) {
	rows, err := q.db.Query(ctx, listAccounts, arg.Offset, arg.Limit)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Account
	for rows.Next() {
		var i Account
		if err := rows.Scan(
			&i.ID,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.AccessToken,
			&i.AccessTokenExpiresAt,
			&i.AccountIdentifier,
			&i.IDToken,
			&i.Provider,
			&i.RefreshToken,
			&i.RefreshTokenExpiresAt,
			&i.Scope,
			&i.UserID,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listAccountsByUserID = `-- name: ListAccountsByUserID :many
SELECT
  id, created_at, updated_at, access_token, access_token_expires_at, account_identifier, id_token, provider, refresh_token, refresh_token_expires_at, scope, user_id
FROM
  account
WHERE
  user_id = $1
ORDER BY
  created_at DESC
`

type ListAccountsByUserIDParams struct {
	UserID uuid.UUID
}

func (q *Queries) ListAccountsByUserID(ctx context.Context, arg ListAccountsByUserIDParams) ([]Account, error) {
	rows, err := q.db.Query(ctx, listAccountsByUserID, arg.UserID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Account
	for rows.Next() {
		var i Account
		if err := rows.Scan(
			&i.ID,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.AccessToken,
			&i.AccessTokenExpiresAt,
			&i.AccountIdentifier,
			&i.IDToken,
			&i.Provider,
			&i.RefreshToken,
			&i.RefreshTokenExpiresAt,
			&i.Scope,
			&i.UserID,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const updateAccount = `-- name: UpdateAccount :one
UPDATE account
SET
  access_token = COALESCE($1, access_token),
  access_token_expires_at = COALESCE($2, access_token_expires_at),
  account_identifier = COALESCE($3, account_identifier),
  id_token = COALESCE($4, id_token),
  provider = COALESCE($5, provider),
  refresh_token = COALESCE($6, refresh_token),
  refresh_token_expires_at = COALESCE($7, refresh_token_expires_at),
  scope = COALESCE($8, scope),
  user_id = COALESCE($9, user_id)
WHERE
  id = $10
RETURNING
  id, created_at, updated_at, access_token, access_token_expires_at, account_identifier, id_token, provider, refresh_token, refresh_token_expires_at, scope, user_id
`

type UpdateAccountParams struct {
	AccessToken           *string
	AccessTokenExpiresAt  *time.Time
	AccountIdentifier     *string
	IDToken               *string
	Provider              *string
	RefreshToken          *string
	RefreshTokenExpiresAt *time.Time
	Scope                 *string
	UserID                *uuid.UUID
	ID                    uuid.UUID
}

func (q *Queries) UpdateAccount(ctx context.Context, arg UpdateAccountParams) (Account, error) {
	row := q.db.QueryRow(ctx, updateAccount,
		arg.AccessToken,
		arg.AccessTokenExpiresAt,
		arg.AccountIdentifier,
		arg.IDToken,
		arg.Provider,
		arg.RefreshToken,
		arg.RefreshTokenExpiresAt,
		arg.Scope,
		arg.UserID,
		arg.ID,
	)
	var i Account
	err := row.Scan(
		&i.ID,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.AccessToken,
		&i.AccessTokenExpiresAt,
		&i.AccountIdentifier,
		&i.IDToken,
		&i.Provider,
		&i.RefreshToken,
		&i.RefreshTokenExpiresAt,
		&i.Scope,
		&i.UserID,
	)
	return i, err
}
