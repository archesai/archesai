/**
 * Generated by @openapi-codegen
 *
 * @version v1
 */
import * as reactQuery from "@tanstack/react-query";
import { useArchesApiContext, ArchesApiContext } from "./archesApiContext";
import type * as Fetcher from "./archesApiFetcher";
import { archesApiFetch } from "./archesApiFetcher";
import type * as Schemas from "./archesApiSchemas";

export type AuthControllerLoginError = Fetcher.ErrorWrapper<undefined>;

export type AuthControllerLoginVariables = {
  body: Schemas.LoginDto;
} & ArchesApiContext["fetcherOptions"];

export const fetchAuthControllerLogin = (
  variables: AuthControllerLoginVariables,
  signal?: AbortSignal,
) =>
  archesApiFetch<
    Schemas.TokenDto,
    AuthControllerLoginError,
    Schemas.LoginDto,
    {},
    {},
    {}
  >({ url: "/auth/login", method: "post", ...variables, signal });

export const useAuthControllerLogin = (
  options?: Omit<
    reactQuery.UseMutationOptions<
      Schemas.TokenDto,
      AuthControllerLoginError,
      AuthControllerLoginVariables
    >,
    "mutationFn"
  >,
) => {
  const { fetcherOptions } = useArchesApiContext();
  return reactQuery.useMutation<
    Schemas.TokenDto,
    AuthControllerLoginError,
    AuthControllerLoginVariables
  >({
    mutationFn: (variables: AuthControllerLoginVariables) =>
      fetchAuthControllerLogin({ ...fetcherOptions, ...variables }),
    ...options,
  });
};

export type AuthControllerRefreshTokenError = Fetcher.ErrorWrapper<undefined>;

export type AuthControllerRefreshTokenVariables =
  ArchesApiContext["fetcherOptions"];

export const fetchAuthControllerRefreshToken = (
  variables: AuthControllerRefreshTokenVariables,
  signal?: AbortSignal,
) =>
  archesApiFetch<
    Schemas.TokenDto,
    AuthControllerRefreshTokenError,
    undefined,
    {},
    {},
    {}
  >({ url: "/auth/refresh-token", method: "post", ...variables, signal });

export const useAuthControllerRefreshToken = (
  options?: Omit<
    reactQuery.UseMutationOptions<
      Schemas.TokenDto,
      AuthControllerRefreshTokenError,
      AuthControllerRefreshTokenVariables
    >,
    "mutationFn"
  >,
) => {
  const { fetcherOptions } = useArchesApiContext();
  return reactQuery.useMutation<
    Schemas.TokenDto,
    AuthControllerRefreshTokenError,
    AuthControllerRefreshTokenVariables
  >({
    mutationFn: (variables: AuthControllerRefreshTokenVariables) =>
      fetchAuthControllerRefreshToken({ ...fetcherOptions, ...variables }),
    ...options,
  });
};

export type AuthControllerRegisterError = Fetcher.ErrorWrapper<undefined>;

export type AuthControllerRegisterVariables = {
  body: Schemas.RegisterDto;
} & ArchesApiContext["fetcherOptions"];

/**
 * This endpoint will register a new account and return a JWT token which should be provided in your auth headers
 */
export const fetchAuthControllerRegister = (
  variables: AuthControllerRegisterVariables,
  signal?: AbortSignal,
) =>
  archesApiFetch<
    Schemas.TokenDto,
    AuthControllerRegisterError,
    Schemas.RegisterDto,
    {},
    {},
    {}
  >({ url: "/auth/register", method: "post", ...variables, signal });

/**
 * This endpoint will register a new account and return a JWT token which should be provided in your auth headers
 */
export const useAuthControllerRegister = (
  options?: Omit<
    reactQuery.UseMutationOptions<
      Schemas.TokenDto,
      AuthControllerRegisterError,
      AuthControllerRegisterVariables
    >,
    "mutationFn"
  >,
) => {
  const { fetcherOptions } = useArchesApiContext();
  return reactQuery.useMutation<
    Schemas.TokenDto,
    AuthControllerRegisterError,
    AuthControllerRegisterVariables
  >({
    mutationFn: (variables: AuthControllerRegisterVariables) =>
      fetchAuthControllerRegister({ ...fetcherOptions, ...variables }),
    ...options,
  });
};

export type UserControllerDeactivateError = Fetcher.ErrorWrapper<undefined>;

export type UserControllerDeactivateVariables =
  ArchesApiContext["fetcherOptions"];

export const fetchUserControllerDeactivate = (
  variables: UserControllerDeactivateVariables,
  signal?: AbortSignal,
) =>
  archesApiFetch<
    undefined,
    UserControllerDeactivateError,
    undefined,
    {},
    {},
    {}
  >({ url: "/user/deactivate", method: "post", ...variables, signal });

export const useUserControllerDeactivate = (
  options?: Omit<
    reactQuery.UseMutationOptions<
      undefined,
      UserControllerDeactivateError,
      UserControllerDeactivateVariables
    >,
    "mutationFn"
  >,
) => {
  const { fetcherOptions } = useArchesApiContext();
  return reactQuery.useMutation<
    undefined,
    UserControllerDeactivateError,
    UserControllerDeactivateVariables
  >({
    mutationFn: (variables: UserControllerDeactivateVariables) =>
      fetchUserControllerDeactivate({ ...fetcherOptions, ...variables }),
    ...options,
  });
};

export type UserControllerFindOneError = Fetcher.ErrorWrapper<undefined>;

export type UserControllerFindOneVariables = ArchesApiContext["fetcherOptions"];

/**
 * This endpoint can be used to find out about the currently authorized user. USER and ADMIN can use endpoint.
 */
export const fetchUserControllerFindOne = (
  variables: UserControllerFindOneVariables,
  signal?: AbortSignal,
) =>
  archesApiFetch<
    Schemas.UserEntity,
    UserControllerFindOneError,
    undefined,
    {},
    {},
    {}
  >({ url: "/user", method: "get", ...variables, signal });

/**
 * This endpoint can be used to find out about the currently authorized user. USER and ADMIN can use endpoint.
 */
export const useUserControllerFindOne = <TData = Schemas.UserEntity,>(
  variables: UserControllerFindOneVariables,
  options?: Omit<
    reactQuery.UseQueryOptions<
      Schemas.UserEntity,
      UserControllerFindOneError,
      TData
    >,
    "queryKey" | "queryFn" | "initialData"
  >,
) => {
  const { fetcherOptions, queryOptions, queryKeyFn } =
    useArchesApiContext(options);
  return reactQuery.useQuery<
    Schemas.UserEntity,
    UserControllerFindOneError,
    TData
  >({
    queryKey: queryKeyFn({
      path: "/user",
      operationId: "userControllerFindOne",
      variables,
    }),
    queryFn: ({ signal }) =>
      fetchUserControllerFindOne({ ...fetcherOptions, ...variables }, signal),
    ...options,
    ...queryOptions,
  });
};

export type UserControllerUpdateError = Fetcher.ErrorWrapper<undefined>;

export type UserControllerUpdateVariables = {
  body?: Schemas.UpdateUserDto;
} & ArchesApiContext["fetcherOptions"];

/**
 * This endpoint can be used to update the currently authorized user. ADMIN ONLY.
 */
export const fetchUserControllerUpdate = (
  variables: UserControllerUpdateVariables,
  signal?: AbortSignal,
) =>
  archesApiFetch<
    Schemas.UserEntity,
    UserControllerUpdateError,
    Schemas.UpdateUserDto,
    {},
    {},
    {}
  >({ url: "/user", method: "patch", ...variables, signal });

/**
 * This endpoint can be used to update the currently authorized user. ADMIN ONLY.
 */
export const useUserControllerUpdate = (
  options?: Omit<
    reactQuery.UseMutationOptions<
      Schemas.UserEntity,
      UserControllerUpdateError,
      UserControllerUpdateVariables
    >,
    "mutationFn"
  >,
) => {
  const { fetcherOptions } = useArchesApiContext();
  return reactQuery.useMutation<
    Schemas.UserEntity,
    UserControllerUpdateError,
    UserControllerUpdateVariables
  >({
    mutationFn: (variables: UserControllerUpdateVariables) =>
      fetchUserControllerUpdate({ ...fetcherOptions, ...variables }),
    ...options,
  });
};

export type OrganizationsControllerCreateError =
  Fetcher.ErrorWrapper<undefined>;

export type OrganizationsControllerCreateVariables = {
  body: Schemas.CreateOrganizationDto;
} & ArchesApiContext["fetcherOptions"];

/**
 * Create an organization. ADMIN ONLY.
 */
export const fetchOrganizationsControllerCreate = (
  variables: OrganizationsControllerCreateVariables,
  signal?: AbortSignal,
) =>
  archesApiFetch<
    Schemas.OrganizationEntity,
    OrganizationsControllerCreateError,
    Schemas.CreateOrganizationDto,
    {},
    {},
    {}
  >({ url: "/organizations", method: "post", ...variables, signal });

/**
 * Create an organization. ADMIN ONLY.
 */
export const useOrganizationsControllerCreate = (
  options?: Omit<
    reactQuery.UseMutationOptions<
      Schemas.OrganizationEntity,
      OrganizationsControllerCreateError,
      OrganizationsControllerCreateVariables
    >,
    "mutationFn"
  >,
) => {
  const { fetcherOptions } = useArchesApiContext();
  return reactQuery.useMutation<
    Schemas.OrganizationEntity,
    OrganizationsControllerCreateError,
    OrganizationsControllerCreateVariables
  >({
    mutationFn: (variables: OrganizationsControllerCreateVariables) =>
      fetchOrganizationsControllerCreate({ ...fetcherOptions, ...variables }),
    ...options,
  });
};

export type OrganizationsControllerDeletePathParams = {
  orgname: string;
};

export type OrganizationsControllerDeleteError =
  Fetcher.ErrorWrapper<undefined>;

export type OrganizationsControllerDeleteVariables = {
  pathParams: OrganizationsControllerDeletePathParams;
} & ArchesApiContext["fetcherOptions"];

/**
 * Delete an organization. ADMIN ONLY.
 */
export const fetchOrganizationsControllerDelete = (
  variables: OrganizationsControllerDeleteVariables,
  signal?: AbortSignal,
) =>
  archesApiFetch<
    undefined,
    OrganizationsControllerDeleteError,
    undefined,
    {},
    {},
    OrganizationsControllerDeletePathParams
  >({
    url: "/organizations/{orgname}",
    method: "delete",
    ...variables,
    signal,
  });

/**
 * Delete an organization. ADMIN ONLY.
 */
export const useOrganizationsControllerDelete = (
  options?: Omit<
    reactQuery.UseMutationOptions<
      undefined,
      OrganizationsControllerDeleteError,
      OrganizationsControllerDeleteVariables
    >,
    "mutationFn"
  >,
) => {
  const { fetcherOptions } = useArchesApiContext();
  return reactQuery.useMutation<
    undefined,
    OrganizationsControllerDeleteError,
    OrganizationsControllerDeleteVariables
  >({
    mutationFn: (variables: OrganizationsControllerDeleteVariables) =>
      fetchOrganizationsControllerDelete({ ...fetcherOptions, ...variables }),
    ...options,
  });
};

export type OrganizationsControllerFindOnePathParams = {
  orgname: string;
};

export type OrganizationsControllerFindOneError =
  Fetcher.ErrorWrapper<undefined>;

export type OrganizationsControllerFindOneVariables = {
  pathParams: OrganizationsControllerFindOnePathParams;
} & ArchesApiContext["fetcherOptions"];

/**
 * Get an organization. ADMIN ONLY.
 */
export const fetchOrganizationsControllerFindOne = (
  variables: OrganizationsControllerFindOneVariables,
  signal?: AbortSignal,
) =>
  archesApiFetch<
    Schemas.OrganizationEntity,
    OrganizationsControllerFindOneError,
    undefined,
    {},
    {},
    OrganizationsControllerFindOnePathParams
  >({ url: "/organizations/{orgname}", method: "get", ...variables, signal });

/**
 * Get an organization. ADMIN ONLY.
 */
export const useOrganizationsControllerFindOne = <
  TData = Schemas.OrganizationEntity,
>(
  variables: OrganizationsControllerFindOneVariables,
  options?: Omit<
    reactQuery.UseQueryOptions<
      Schemas.OrganizationEntity,
      OrganizationsControllerFindOneError,
      TData
    >,
    "queryKey" | "queryFn" | "initialData"
  >,
) => {
  const { fetcherOptions, queryOptions, queryKeyFn } =
    useArchesApiContext(options);
  return reactQuery.useQuery<
    Schemas.OrganizationEntity,
    OrganizationsControllerFindOneError,
    TData
  >({
    queryKey: queryKeyFn({
      path: "/organizations/{orgname}",
      operationId: "organizationsControllerFindOne",
      variables,
    }),
    queryFn: ({ signal }) =>
      fetchOrganizationsControllerFindOne(
        { ...fetcherOptions, ...variables },
        signal,
      ),
    ...options,
    ...queryOptions,
  });
};

export type OrganizationsControllerUpdatePathParams = {
  orgname: string;
};

export type OrganizationsControllerUpdateError =
  Fetcher.ErrorWrapper<undefined>;

export type OrganizationsControllerUpdateVariables = {
  body: Schemas.UpdateOrganizationDto;
  pathParams: OrganizationsControllerUpdatePathParams;
} & ArchesApiContext["fetcherOptions"];

/**
 * Update an organization. ADMIN ONLY.
 */
export const fetchOrganizationsControllerUpdate = (
  variables: OrganizationsControllerUpdateVariables,
  signal?: AbortSignal,
) =>
  archesApiFetch<
    undefined,
    OrganizationsControllerUpdateError,
    Schemas.UpdateOrganizationDto,
    {},
    {},
    OrganizationsControllerUpdatePathParams
  >({ url: "/organizations/{orgname}", method: "patch", ...variables, signal });

/**
 * Update an organization. ADMIN ONLY.
 */
export const useOrganizationsControllerUpdate = (
  options?: Omit<
    reactQuery.UseMutationOptions<
      undefined,
      OrganizationsControllerUpdateError,
      OrganizationsControllerUpdateVariables
    >,
    "mutationFn"
  >,
) => {
  const { fetcherOptions } = useArchesApiContext();
  return reactQuery.useMutation<
    undefined,
    OrganizationsControllerUpdateError,
    OrganizationsControllerUpdateVariables
  >({
    mutationFn: (variables: OrganizationsControllerUpdateVariables) =>
      fetchOrganizationsControllerUpdate({ ...fetcherOptions, ...variables }),
    ...options,
  });
};

export type StripeControllerCreateBillingPortalPathParams = {
  orgname: string;
};

export type StripeControllerCreateBillingPortalError =
  Fetcher.ErrorWrapper<undefined>;

export type StripeControllerCreateBillingPortalVariables = {
  pathParams: StripeControllerCreateBillingPortalPathParams;
} & ArchesApiContext["fetcherOptions"];

/**
 * This endpoint will create a billing for an organization to edit their subscription and billing information. Only available on archesai.com. ADMIN ONLY.
 */
export const fetchStripeControllerCreateBillingPortal = (
  variables: StripeControllerCreateBillingPortalVariables,
  signal?: AbortSignal,
) =>
  archesApiFetch<
    Schemas.BillingUrlEntity,
    StripeControllerCreateBillingPortalError,
    undefined,
    {},
    {},
    StripeControllerCreateBillingPortalPathParams
  >({
    url: "/organizations/{orgname}/billing",
    method: "post",
    ...variables,
    signal,
  });

/**
 * This endpoint will create a billing for an organization to edit their subscription and billing information. Only available on archesai.com. ADMIN ONLY.
 */
export const useStripeControllerCreateBillingPortal = (
  options?: Omit<
    reactQuery.UseMutationOptions<
      Schemas.BillingUrlEntity,
      StripeControllerCreateBillingPortalError,
      StripeControllerCreateBillingPortalVariables
    >,
    "mutationFn"
  >,
) => {
  const { fetcherOptions } = useArchesApiContext();
  return reactQuery.useMutation<
    Schemas.BillingUrlEntity,
    StripeControllerCreateBillingPortalError,
    StripeControllerCreateBillingPortalVariables
  >({
    mutationFn: (variables: StripeControllerCreateBillingPortalVariables) =>
      fetchStripeControllerCreateBillingPortal({
        ...fetcherOptions,
        ...variables,
      }),
    ...options,
  });
};

export type StripeControllerCreateCheckoutSessionPathParams = {
  orgname: string;
};

export type StripeControllerCreateCheckoutSessionQueryParams = {
  product: string;
};

export type StripeControllerCreateCheckoutSessionError =
  Fetcher.ErrorWrapper<undefined>;

export type StripeControllerCreateCheckoutSessionVariables = {
  pathParams: StripeControllerCreateCheckoutSessionPathParams;
  queryParams: StripeControllerCreateCheckoutSessionQueryParams;
} & ArchesApiContext["fetcherOptions"];

/**
 * This endpoint will create a checkout session for an organization to purchase a subscription. Only available on archesai.com. ADMIN ONLY.
 */
export const fetchStripeControllerCreateCheckoutSession = (
  variables: StripeControllerCreateCheckoutSessionVariables,
  signal?: AbortSignal,
) =>
  archesApiFetch<
    Schemas.BillingUrlEntity,
    StripeControllerCreateCheckoutSessionError,
    undefined,
    {},
    StripeControllerCreateCheckoutSessionQueryParams,
    StripeControllerCreateCheckoutSessionPathParams
  >({
    url: "/organizations/{orgname}/checkout",
    method: "post",
    ...variables,
    signal,
  });

/**
 * This endpoint will create a checkout session for an organization to purchase a subscription. Only available on archesai.com. ADMIN ONLY.
 */
export const useStripeControllerCreateCheckoutSession = (
  options?: Omit<
    reactQuery.UseMutationOptions<
      Schemas.BillingUrlEntity,
      StripeControllerCreateCheckoutSessionError,
      StripeControllerCreateCheckoutSessionVariables
    >,
    "mutationFn"
  >,
) => {
  const { fetcherOptions } = useArchesApiContext();
  return reactQuery.useMutation<
    Schemas.BillingUrlEntity,
    StripeControllerCreateCheckoutSessionError,
    StripeControllerCreateCheckoutSessionVariables
  >({
    mutationFn: (variables: StripeControllerCreateCheckoutSessionVariables) =>
      fetchStripeControllerCreateCheckoutSession({
        ...fetcherOptions,
        ...variables,
      }),
    ...options,
  });
};

export type ApiTokensControllerCreatePathParams = {
  orgname: string;
};

export type ApiTokensControllerCreateError = Fetcher.ErrorWrapper<undefined>;

export type ApiTokensControllerCreateVariables = {
  body: Schemas.CreateApiTokenDto;
  pathParams: ApiTokensControllerCreatePathParams;
} & ArchesApiContext["fetcherOptions"];

/**
 * Create a new API token. ADMIN ONLY.
 */
export const fetchApiTokensControllerCreate = (
  variables: ApiTokensControllerCreateVariables,
  signal?: AbortSignal,
) =>
  archesApiFetch<
    Schemas.ApiTokenEntity,
    ApiTokensControllerCreateError,
    Schemas.CreateApiTokenDto,
    {},
    {},
    ApiTokensControllerCreatePathParams
  >({
    url: "/organizations/{orgname}/api-tokens",
    method: "post",
    ...variables,
    signal,
  });

/**
 * Create a new API token. ADMIN ONLY.
 */
export const useApiTokensControllerCreate = (
  options?: Omit<
    reactQuery.UseMutationOptions<
      Schemas.ApiTokenEntity,
      ApiTokensControllerCreateError,
      ApiTokensControllerCreateVariables
    >,
    "mutationFn"
  >,
) => {
  const { fetcherOptions } = useArchesApiContext();
  return reactQuery.useMutation<
    Schemas.ApiTokenEntity,
    ApiTokensControllerCreateError,
    ApiTokensControllerCreateVariables
  >({
    mutationFn: (variables: ApiTokensControllerCreateVariables) =>
      fetchApiTokensControllerCreate({ ...fetcherOptions, ...variables }),
    ...options,
  });
};

export type ApiTokensControllerFindAllPathParams = {
  orgname: string;
};

export type ApiTokensControllerFindAllQueryParams = {
  /**
   * The end date to search to
   */
  endDate?: string;
  /**
   * The limit of the number of results returned
   *
   * @default 10
   */
  limit?: number;
  /**
   * The offset of the returned results
   *
   * @default 0
   */
  offset?: number;
  /**
   * Search term
   *
   * @default
   */
  searchTerm?: string;
  /**
   * The field to sort the results by
   *
   * @default createdAt
   */
  sortBy?: "createdAt";
  /**
   * The direction to sort the results by
   *
   * @default desc
   */
  sortDirection?: "asc" | "desc";
  /**
   * The start date to search from
   */
  startDate?: string;
  /**
   * The name to search for
   */
  name: string;
};

export type ApiTokensControllerFindAllError = Fetcher.ErrorWrapper<undefined>;

export type ApiTokensControllerFindAllResponse = Schemas.PaginatedDto & {
  results?: Schemas.ApiTokenEntity[];
};

export type ApiTokensControllerFindAllVariables = {
  pathParams: ApiTokensControllerFindAllPathParams;
  queryParams: ApiTokensControllerFindAllQueryParams;
} & ArchesApiContext["fetcherOptions"];

/**
 * Get all API tokens. ADMIN ONLY.
 */
export const fetchApiTokensControllerFindAll = (
  variables: ApiTokensControllerFindAllVariables,
  signal?: AbortSignal,
) =>
  archesApiFetch<
    ApiTokensControllerFindAllResponse,
    ApiTokensControllerFindAllError,
    undefined,
    {},
    ApiTokensControllerFindAllQueryParams,
    ApiTokensControllerFindAllPathParams
  >({
    url: "/organizations/{orgname}/api-tokens",
    method: "get",
    ...variables,
    signal,
  });

/**
 * Get all API tokens. ADMIN ONLY.
 */
export const useApiTokensControllerFindAll = <
  TData = ApiTokensControllerFindAllResponse,
>(
  variables: ApiTokensControllerFindAllVariables,
  options?: Omit<
    reactQuery.UseQueryOptions<
      ApiTokensControllerFindAllResponse,
      ApiTokensControllerFindAllError,
      TData
    >,
    "queryKey" | "queryFn" | "initialData"
  >,
) => {
  const { fetcherOptions, queryOptions, queryKeyFn } =
    useArchesApiContext(options);
  return reactQuery.useQuery<
    ApiTokensControllerFindAllResponse,
    ApiTokensControllerFindAllError,
    TData
  >({
    queryKey: queryKeyFn({
      path: "/organizations/{orgname}/api-tokens",
      operationId: "apiTokensControllerFindAll",
      variables,
    }),
    queryFn: ({ signal }) =>
      fetchApiTokensControllerFindAll(
        { ...fetcherOptions, ...variables },
        signal,
      ),
    ...options,
    ...queryOptions,
  });
};

export type ApiTokensControllerFindOnePathParams = {
  orgname: string;
  id: string;
};

export type ApiTokensControllerFindOneError = Fetcher.ErrorWrapper<undefined>;

export type ApiTokensControllerFindOneVariables = {
  pathParams: ApiTokensControllerFindOnePathParams;
} & ArchesApiContext["fetcherOptions"];

/**
 * Get a API token. ADMIN ONLY.
 */
export const fetchApiTokensControllerFindOne = (
  variables: ApiTokensControllerFindOneVariables,
  signal?: AbortSignal,
) =>
  archesApiFetch<
    Schemas.ApiTokenEntity,
    ApiTokensControllerFindOneError,
    undefined,
    {},
    {},
    ApiTokensControllerFindOnePathParams
  >({
    url: "/organizations/{orgname}/api-tokens/{id}",
    method: "get",
    ...variables,
    signal,
  });

/**
 * Get a API token. ADMIN ONLY.
 */
export const useApiTokensControllerFindOne = <TData = Schemas.ApiTokenEntity,>(
  variables: ApiTokensControllerFindOneVariables,
  options?: Omit<
    reactQuery.UseQueryOptions<
      Schemas.ApiTokenEntity,
      ApiTokensControllerFindOneError,
      TData
    >,
    "queryKey" | "queryFn" | "initialData"
  >,
) => {
  const { fetcherOptions, queryOptions, queryKeyFn } =
    useArchesApiContext(options);
  return reactQuery.useQuery<
    Schemas.ApiTokenEntity,
    ApiTokensControllerFindOneError,
    TData
  >({
    queryKey: queryKeyFn({
      path: "/organizations/{orgname}/api-tokens/{id}",
      operationId: "apiTokensControllerFindOne",
      variables,
    }),
    queryFn: ({ signal }) =>
      fetchApiTokensControllerFindOne(
        { ...fetcherOptions, ...variables },
        signal,
      ),
    ...options,
    ...queryOptions,
  });
};

export type ApiTokensControllerRemovePathParams = {
  orgname: string;
  id: string;
};

export type ApiTokensControllerRemoveError = Fetcher.ErrorWrapper<undefined>;

export type ApiTokensControllerRemoveVariables = {
  pathParams: ApiTokensControllerRemovePathParams;
} & ArchesApiContext["fetcherOptions"];

/**
 * Delete a API token. ADMIN ONLY.
 */
export const fetchApiTokensControllerRemove = (
  variables: ApiTokensControllerRemoveVariables,
  signal?: AbortSignal,
) =>
  archesApiFetch<
    undefined,
    ApiTokensControllerRemoveError,
    undefined,
    {},
    {},
    ApiTokensControllerRemovePathParams
  >({
    url: "/organizations/{orgname}/api-tokens/{id}",
    method: "delete",
    ...variables,
    signal,
  });

/**
 * Delete a API token. ADMIN ONLY.
 */
export const useApiTokensControllerRemove = (
  options?: Omit<
    reactQuery.UseMutationOptions<
      undefined,
      ApiTokensControllerRemoveError,
      ApiTokensControllerRemoveVariables
    >,
    "mutationFn"
  >,
) => {
  const { fetcherOptions } = useArchesApiContext();
  return reactQuery.useMutation<
    undefined,
    ApiTokensControllerRemoveError,
    ApiTokensControllerRemoveVariables
  >({
    mutationFn: (variables: ApiTokensControllerRemoveVariables) =>
      fetchApiTokensControllerRemove({ ...fetcherOptions, ...variables }),
    ...options,
  });
};

export type ApiTokensControllerUpdatePathParams = {
  orgname: string;
  id: string;
};

export type ApiTokensControllerUpdateQueryParams = {
  /**
   * The domains that can access this API token
   *
   * @default *
   */
  domains?: string;
  /**
   * The name of the API token
   */
  name?: string;
  /**
   * The role of the API token
   */
  role?: "USER" | "ADMIN";
  /**
   * The ids of the agent this token will have access to. This can not be changed later.
   */
  chatbotIds?: string[];
};

export type ApiTokensControllerUpdateError = Fetcher.ErrorWrapper<undefined>;

export type ApiTokensControllerUpdateVariables = {
  pathParams: ApiTokensControllerUpdatePathParams;
  queryParams?: ApiTokensControllerUpdateQueryParams;
} & ArchesApiContext["fetcherOptions"];

/**
 * Update a API token. ADMIN ONLY.
 */
export const fetchApiTokensControllerUpdate = (
  variables: ApiTokensControllerUpdateVariables,
  signal?: AbortSignal,
) =>
  archesApiFetch<
    Schemas.ApiTokenEntity,
    ApiTokensControllerUpdateError,
    undefined,
    {},
    ApiTokensControllerUpdateQueryParams,
    ApiTokensControllerUpdatePathParams
  >({
    url: "/organizations/{orgname}/api-tokens/{id}",
    method: "patch",
    ...variables,
    signal,
  });

/**
 * Update a API token. ADMIN ONLY.
 */
export const useApiTokensControllerUpdate = (
  options?: Omit<
    reactQuery.UseMutationOptions<
      Schemas.ApiTokenEntity,
      ApiTokensControllerUpdateError,
      ApiTokensControllerUpdateVariables
    >,
    "mutationFn"
  >,
) => {
  const { fetcherOptions } = useArchesApiContext();
  return reactQuery.useMutation<
    Schemas.ApiTokenEntity,
    ApiTokensControllerUpdateError,
    ApiTokensControllerUpdateVariables
  >({
    mutationFn: (variables: ApiTokensControllerUpdateVariables) =>
      fetchApiTokensControllerUpdate({ ...fetcherOptions, ...variables }),
    ...options,
  });
};

export type MembersControllerCreatePathParams = {
  orgname: string;
};

export type MembersControllerCreateError = Fetcher.ErrorWrapper<undefined>;

export type MembersControllerCreateVariables = {
  body: Schemas.CreateMemberDto;
  pathParams: MembersControllerCreatePathParams;
} & ArchesApiContext["fetcherOptions"];

/**
 * Create a new member. ADMIN ONLY.
 */
export const fetchMembersControllerCreate = (
  variables: MembersControllerCreateVariables,
  signal?: AbortSignal,
) =>
  archesApiFetch<
    Schemas.MemberEntity,
    MembersControllerCreateError,
    Schemas.CreateMemberDto,
    {},
    {},
    MembersControllerCreatePathParams
  >({
    url: "/organizations/{orgname}/members",
    method: "post",
    ...variables,
    signal,
  });

/**
 * Create a new member. ADMIN ONLY.
 */
export const useMembersControllerCreate = (
  options?: Omit<
    reactQuery.UseMutationOptions<
      Schemas.MemberEntity,
      MembersControllerCreateError,
      MembersControllerCreateVariables
    >,
    "mutationFn"
  >,
) => {
  const { fetcherOptions } = useArchesApiContext();
  return reactQuery.useMutation<
    Schemas.MemberEntity,
    MembersControllerCreateError,
    MembersControllerCreateVariables
  >({
    mutationFn: (variables: MembersControllerCreateVariables) =>
      fetchMembersControllerCreate({ ...fetcherOptions, ...variables }),
    ...options,
  });
};

export type MembersControllerFindAllPathParams = {
  orgname: string;
};

export type MembersControllerFindAllQueryParams = {
  /**
   * The end date to search to
   */
  endDate?: string;
  /**
   * The limit of the number of results returned
   *
   * @default 10
   */
  limit?: number;
  /**
   * The offset of the returned results
   *
   * @default 0
   */
  offset?: number;
  /**
   * Search term
   *
   * @default
   */
  searchTerm?: string;
  /**
   * The field to sort the results by
   *
   * @default username
   */
  sortBy?: "createdAt" | "username";
  /**
   * The direction to sort the results by
   *
   * @default desc
   */
  sortDirection?: "asc" | "desc";
  /**
   * The start date to search from
   */
  startDate?: string;
};

export type MembersControllerFindAllError = Fetcher.ErrorWrapper<undefined>;

export type MembersControllerFindAllResponse = Schemas.PaginatedDto & {
  results?: Schemas.MemberEntity[];
};

export type MembersControllerFindAllVariables = {
  pathParams: MembersControllerFindAllPathParams;
  queryParams?: MembersControllerFindAllQueryParams;
} & ArchesApiContext["fetcherOptions"];

/**
 * Get all members. ADMIN ONLY.
 */
export const fetchMembersControllerFindAll = (
  variables: MembersControllerFindAllVariables,
  signal?: AbortSignal,
) =>
  archesApiFetch<
    MembersControllerFindAllResponse,
    MembersControllerFindAllError,
    undefined,
    {},
    MembersControllerFindAllQueryParams,
    MembersControllerFindAllPathParams
  >({
    url: "/organizations/{orgname}/members",
    method: "get",
    ...variables,
    signal,
  });

/**
 * Get all members. ADMIN ONLY.
 */
export const useMembersControllerFindAll = <
  TData = MembersControllerFindAllResponse,
>(
  variables: MembersControllerFindAllVariables,
  options?: Omit<
    reactQuery.UseQueryOptions<
      MembersControllerFindAllResponse,
      MembersControllerFindAllError,
      TData
    >,
    "queryKey" | "queryFn" | "initialData"
  >,
) => {
  const { fetcherOptions, queryOptions, queryKeyFn } =
    useArchesApiContext(options);
  return reactQuery.useQuery<
    MembersControllerFindAllResponse,
    MembersControllerFindAllError,
    TData
  >({
    queryKey: queryKeyFn({
      path: "/organizations/{orgname}/members",
      operationId: "membersControllerFindAll",
      variables,
    }),
    queryFn: ({ signal }) =>
      fetchMembersControllerFindAll(
        { ...fetcherOptions, ...variables },
        signal,
      ),
    ...options,
    ...queryOptions,
  });
};

export type MembersControllerJoinPathParams = {
  orgname: string;
};

export type MembersControllerJoinError = Fetcher.ErrorWrapper<undefined>;

export type MembersControllerJoinVariables = {
  pathParams: MembersControllerJoinPathParams;
} & ArchesApiContext["fetcherOptions"];

/**
 * Accept invitation to this organization. ADMIN ONLY.
 */
export const fetchMembersControllerJoin = (
  variables: MembersControllerJoinVariables,
  signal?: AbortSignal,
) =>
  archesApiFetch<
    Schemas.MemberEntity,
    MembersControllerJoinError,
    undefined,
    {},
    {},
    MembersControllerJoinPathParams
  >({
    url: "/organizations/{orgname}/members/join",
    method: "post",
    ...variables,
    signal,
  });

/**
 * Accept invitation to this organization. ADMIN ONLY.
 */
export const useMembersControllerJoin = (
  options?: Omit<
    reactQuery.UseMutationOptions<
      Schemas.MemberEntity,
      MembersControllerJoinError,
      MembersControllerJoinVariables
    >,
    "mutationFn"
  >,
) => {
  const { fetcherOptions } = useArchesApiContext();
  return reactQuery.useMutation<
    Schemas.MemberEntity,
    MembersControllerJoinError,
    MembersControllerJoinVariables
  >({
    mutationFn: (variables: MembersControllerJoinVariables) =>
      fetchMembersControllerJoin({ ...fetcherOptions, ...variables }),
    ...options,
  });
};

export type MembersControllerRemovePathParams = {
  orgname: string;
  memberId: string;
};

export type MembersControllerRemoveError = Fetcher.ErrorWrapper<undefined>;

export type MembersControllerRemoveVariables = {
  pathParams: MembersControllerRemovePathParams;
} & ArchesApiContext["fetcherOptions"];

/**
 * Delete a member. ADMIN ONLY.
 */
export const fetchMembersControllerRemove = (
  variables: MembersControllerRemoveVariables,
  signal?: AbortSignal,
) =>
  archesApiFetch<
    undefined,
    MembersControllerRemoveError,
    undefined,
    {},
    {},
    MembersControllerRemovePathParams
  >({
    url: "/organizations/{orgname}/members/{memberId}",
    method: "delete",
    ...variables,
    signal,
  });

/**
 * Delete a member. ADMIN ONLY.
 */
export const useMembersControllerRemove = (
  options?: Omit<
    reactQuery.UseMutationOptions<
      undefined,
      MembersControllerRemoveError,
      MembersControllerRemoveVariables
    >,
    "mutationFn"
  >,
) => {
  const { fetcherOptions } = useArchesApiContext();
  return reactQuery.useMutation<
    undefined,
    MembersControllerRemoveError,
    MembersControllerRemoveVariables
  >({
    mutationFn: (variables: MembersControllerRemoveVariables) =>
      fetchMembersControllerRemove({ ...fetcherOptions, ...variables }),
    ...options,
  });
};

export type MembersControllerUpdatePathParams = {
  orgname: string;
  memberId: string;
};

export type MembersControllerUpdateError = Fetcher.ErrorWrapper<undefined>;

export type MembersControllerUpdateVariables = {
  body?: Schemas.UpdateMemberDto;
  pathParams: MembersControllerUpdatePathParams;
} & ArchesApiContext["fetcherOptions"];

/**
 * Update a member. ADMIN ONLY.
 */
export const fetchMembersControllerUpdate = (
  variables: MembersControllerUpdateVariables,
  signal?: AbortSignal,
) =>
  archesApiFetch<
    Schemas.MemberEntity,
    MembersControllerUpdateError,
    Schemas.UpdateMemberDto,
    {},
    {},
    MembersControllerUpdatePathParams
  >({
    url: "/organizations/{orgname}/members/{memberId}",
    method: "patch",
    ...variables,
    signal,
  });

/**
 * Update a member. ADMIN ONLY.
 */
export const useMembersControllerUpdate = (
  options?: Omit<
    reactQuery.UseMutationOptions<
      Schemas.MemberEntity,
      MembersControllerUpdateError,
      MembersControllerUpdateVariables
    >,
    "mutationFn"
  >,
) => {
  const { fetcherOptions } = useArchesApiContext();
  return reactQuery.useMutation<
    Schemas.MemberEntity,
    MembersControllerUpdateError,
    MembersControllerUpdateVariables
  >({
    mutationFn: (variables: MembersControllerUpdateVariables) =>
      fetchMembersControllerUpdate({ ...fetcherOptions, ...variables }),
    ...options,
  });
};

export type EmailVerificationControllerConfirmError =
  Fetcher.ErrorWrapper<undefined>;

export type EmailVerificationControllerConfirmVariables = {
  body: Schemas.ConfirmEmailVerificationDto;
} & ArchesApiContext["fetcherOptions"];

/**
 * This endpoint will confirm your e-mail with a token
 */
export const fetchEmailVerificationControllerConfirm = (
  variables: EmailVerificationControllerConfirmVariables,
  signal?: AbortSignal,
) =>
  archesApiFetch<
    Schemas.TokenDto,
    EmailVerificationControllerConfirmError,
    Schemas.ConfirmEmailVerificationDto,
    {},
    {},
    {}
  >({
    url: "/auth/email-verification/confirm",
    method: "post",
    ...variables,
    signal,
  });

/**
 * This endpoint will confirm your e-mail with a token
 */
export const useEmailVerificationControllerConfirm = (
  options?: Omit<
    reactQuery.UseMutationOptions<
      Schemas.TokenDto,
      EmailVerificationControllerConfirmError,
      EmailVerificationControllerConfirmVariables
    >,
    "mutationFn"
  >,
) => {
  const { fetcherOptions } = useArchesApiContext();
  return reactQuery.useMutation<
    Schemas.TokenDto,
    EmailVerificationControllerConfirmError,
    EmailVerificationControllerConfirmVariables
  >({
    mutationFn: (variables: EmailVerificationControllerConfirmVariables) =>
      fetchEmailVerificationControllerConfirm({
        ...fetcherOptions,
        ...variables,
      }),
    ...options,
  });
};

export type EmailVerificationControllerRequestError =
  Fetcher.ErrorWrapper<undefined>;

export type EmailVerificationControllerRequestVariables =
  ArchesApiContext["fetcherOptions"];

/**
 * This endpoint will send an e-mail verification link to you. ADMIN ONLY.
 */
export const fetchEmailVerificationControllerRequest = (
  variables: EmailVerificationControllerRequestVariables,
  signal?: AbortSignal,
) =>
  archesApiFetch<
    undefined,
    EmailVerificationControllerRequestError,
    undefined,
    {},
    {},
    {}
  >({
    url: "/auth/email-verification/request",
    method: "post",
    ...variables,
    signal,
  });

/**
 * This endpoint will send an e-mail verification link to you. ADMIN ONLY.
 */
export const useEmailVerificationControllerRequest = (
  options?: Omit<
    reactQuery.UseMutationOptions<
      undefined,
      EmailVerificationControllerRequestError,
      EmailVerificationControllerRequestVariables
    >,
    "mutationFn"
  >,
) => {
  const { fetcherOptions } = useArchesApiContext();
  return reactQuery.useMutation<
    undefined,
    EmailVerificationControllerRequestError,
    EmailVerificationControllerRequestVariables
  >({
    mutationFn: (variables: EmailVerificationControllerRequestVariables) =>
      fetchEmailVerificationControllerRequest({
        ...fetcherOptions,
        ...variables,
      }),
    ...options,
  });
};

export type ThreadsControllerCreatePathParams = {
  orgname: string;
  chatbotId: string;
};

export type ThreadsControllerCreateError = Fetcher.ErrorWrapper<undefined>;

export type ThreadsControllerCreateVariables = {
  body?: Schemas.CreateThreadDto;
  pathParams: ThreadsControllerCreatePathParams;
} & ArchesApiContext["fetcherOptions"];

/**
 * Create a new thread. USER and ADMIN can access this endpoint.
 */
export const fetchThreadsControllerCreate = (
  variables: ThreadsControllerCreateVariables,
  signal?: AbortSignal,
) =>
  archesApiFetch<
    Schemas.ThreadEntity,
    ThreadsControllerCreateError,
    Schemas.CreateThreadDto,
    {},
    {},
    ThreadsControllerCreatePathParams
  >({
    url: "/organizations/{orgname}/chatbots/{chatbotId}/threads",
    method: "post",
    ...variables,
    signal,
  });

/**
 * Create a new thread. USER and ADMIN can access this endpoint.
 */
export const useThreadsControllerCreate = (
  options?: Omit<
    reactQuery.UseMutationOptions<
      Schemas.ThreadEntity,
      ThreadsControllerCreateError,
      ThreadsControllerCreateVariables
    >,
    "mutationFn"
  >,
) => {
  const { fetcherOptions } = useArchesApiContext();
  return reactQuery.useMutation<
    Schemas.ThreadEntity,
    ThreadsControllerCreateError,
    ThreadsControllerCreateVariables
  >({
    mutationFn: (variables: ThreadsControllerCreateVariables) =>
      fetchThreadsControllerCreate({ ...fetcherOptions, ...variables }),
    ...options,
  });
};

export type ThreadsControllerFindAllPathParams = {
  orgname: string;
  chatbotId: string;
};

export type ThreadsControllerFindAllQueryParams = {
  /**
   * The end date to search to
   */
  endDate?: string;
  /**
   * The limit of the number of results returned
   *
   * @default 10
   */
  limit?: number;
  /**
   * The offset of the returned results
   *
   * @default 0
   */
  offset?: number;
  /**
   * Search term
   *
   * @default
   */
  searchTerm?: string;
  /**
   * The field to sort the results by
   *
   * @default createdAt
   */
  sortBy?: "createdAt" | "credits";
  /**
   * The direction to sort the results by
   *
   * @default desc
   */
  sortDirection?: "asc" | "desc";
  /**
   * The start date to search from
   */
  startDate?: string;
  /**
   * The granularity to use for ranged aggregates
   */
  aggregateGranularity?: "day" | "month" | "week" | "year";
  /**
   * Whether or not to include aggregates in the response
   *
   * @default false
   */
  aggregates?: boolean;
};

export type ThreadsControllerFindAllError = Fetcher.ErrorWrapper<undefined>;

export type ThreadsControllerFindAllResponse = Schemas.PaginatedDto & {
  results?: Schemas.ThreadEntity[];
  aggregates?: Schemas.ThreadAggregates;
};

export type ThreadsControllerFindAllVariables = {
  pathParams: ThreadsControllerFindAllPathParams;
  queryParams?: ThreadsControllerFindAllQueryParams;
} & ArchesApiContext["fetcherOptions"];

/**
 * Get all threads. ADMIN ONLY.
 */
export const fetchThreadsControllerFindAll = (
  variables: ThreadsControllerFindAllVariables,
  signal?: AbortSignal,
) =>
  archesApiFetch<
    ThreadsControllerFindAllResponse,
    ThreadsControllerFindAllError,
    undefined,
    {},
    ThreadsControllerFindAllQueryParams,
    ThreadsControllerFindAllPathParams
  >({
    url: "/organizations/{orgname}/chatbots/{chatbotId}/threads",
    method: "get",
    ...variables,
    signal,
  });

/**
 * Get all threads. ADMIN ONLY.
 */
export const useThreadsControllerFindAll = <
  TData = ThreadsControllerFindAllResponse,
>(
  variables: ThreadsControllerFindAllVariables,
  options?: Omit<
    reactQuery.UseQueryOptions<
      ThreadsControllerFindAllResponse,
      ThreadsControllerFindAllError,
      TData
    >,
    "queryKey" | "queryFn" | "initialData"
  >,
) => {
  const { fetcherOptions, queryOptions, queryKeyFn } =
    useArchesApiContext(options);
  return reactQuery.useQuery<
    ThreadsControllerFindAllResponse,
    ThreadsControllerFindAllError,
    TData
  >({
    queryKey: queryKeyFn({
      path: "/organizations/{orgname}/chatbots/{chatbotId}/threads",
      operationId: "threadsControllerFindAll",
      variables,
    }),
    queryFn: ({ signal }) =>
      fetchThreadsControllerFindAll(
        { ...fetcherOptions, ...variables },
        signal,
      ),
    ...options,
    ...queryOptions,
  });
};

export type ThreadsControllerFindOnePathParams = {
  orgname: string;
  chatbotId: string;
  threadId: string;
};

export type ThreadsControllerFindOneError = Fetcher.ErrorWrapper<undefined>;

export type ThreadsControllerFindOneVariables = {
  pathParams: ThreadsControllerFindOnePathParams;
} & ArchesApiContext["fetcherOptions"];

/**
 * Get a thread. ADMIN ONLY.
 */
export const fetchThreadsControllerFindOne = (
  variables: ThreadsControllerFindOneVariables,
  signal?: AbortSignal,
) =>
  archesApiFetch<
    Schemas.ThreadEntity,
    ThreadsControllerFindOneError,
    undefined,
    {},
    {},
    ThreadsControllerFindOnePathParams
  >({
    url: "/organizations/{orgname}/chatbots/{chatbotId}/threads/{threadId}",
    method: "get",
    ...variables,
    signal,
  });

/**
 * Get a thread. ADMIN ONLY.
 */
export const useThreadsControllerFindOne = <TData = Schemas.ThreadEntity,>(
  variables: ThreadsControllerFindOneVariables,
  options?: Omit<
    reactQuery.UseQueryOptions<
      Schemas.ThreadEntity,
      ThreadsControllerFindOneError,
      TData
    >,
    "queryKey" | "queryFn" | "initialData"
  >,
) => {
  const { fetcherOptions, queryOptions, queryKeyFn } =
    useArchesApiContext(options);
  return reactQuery.useQuery<
    Schemas.ThreadEntity,
    ThreadsControllerFindOneError,
    TData
  >({
    queryKey: queryKeyFn({
      path: "/organizations/{orgname}/chatbots/{chatbotId}/threads/{threadId}",
      operationId: "threadsControllerFindOne",
      variables,
    }),
    queryFn: ({ signal }) =>
      fetchThreadsControllerFindOne(
        { ...fetcherOptions, ...variables },
        signal,
      ),
    ...options,
    ...queryOptions,
  });
};

export type ThreadsControllerRemovePathParams = {
  orgname: string;
  chatbotId: string;
  threadId: string;
};

export type ThreadsControllerRemoveError = Fetcher.ErrorWrapper<undefined>;

export type ThreadsControllerRemoveVariables = {
  pathParams: ThreadsControllerRemovePathParams;
} & ArchesApiContext["fetcherOptions"];

/**
 * Delete a thread. ADMIN ONLY.
 */
export const fetchThreadsControllerRemove = (
  variables: ThreadsControllerRemoveVariables,
  signal?: AbortSignal,
) =>
  archesApiFetch<
    undefined,
    ThreadsControllerRemoveError,
    undefined,
    {},
    {},
    ThreadsControllerRemovePathParams
  >({
    url: "/organizations/{orgname}/chatbots/{chatbotId}/threads/{threadId}",
    method: "delete",
    ...variables,
    signal,
  });

/**
 * Delete a thread. ADMIN ONLY.
 */
export const useThreadsControllerRemove = (
  options?: Omit<
    reactQuery.UseMutationOptions<
      undefined,
      ThreadsControllerRemoveError,
      ThreadsControllerRemoveVariables
    >,
    "mutationFn"
  >,
) => {
  const { fetcherOptions } = useArchesApiContext();
  return reactQuery.useMutation<
    undefined,
    ThreadsControllerRemoveError,
    ThreadsControllerRemoveVariables
  >({
    mutationFn: (variables: ThreadsControllerRemoveVariables) =>
      fetchThreadsControllerRemove({ ...fetcherOptions, ...variables }),
    ...options,
  });
};

export type StorageControllerDeletePathParams = {
  orgname: string;
};

export type StorageControllerDeleteQueryParams = {
  path: string;
};

export type StorageControllerDeleteError = Fetcher.ErrorWrapper<undefined>;

export type StorageControllerDeleteVariables = {
  pathParams: StorageControllerDeletePathParams;
  queryParams: StorageControllerDeleteQueryParams;
} & ArchesApiContext["fetcherOptions"];

/**
 * This endpoint will delete a file or directory in the organization's secure storage at the specified path. ADMIN ONLY.
 */
export const fetchStorageControllerDelete = (
  variables: StorageControllerDeleteVariables,
  signal?: AbortSignal,
) =>
  archesApiFetch<
    undefined,
    StorageControllerDeleteError,
    undefined,
    {},
    StorageControllerDeleteQueryParams,
    StorageControllerDeletePathParams
  >({
    url: "/organizations/{orgname}/storage/delete",
    method: "delete",
    ...variables,
    signal,
  });

/**
 * This endpoint will delete a file or directory in the organization's secure storage at the specified path. ADMIN ONLY.
 */
export const useStorageControllerDelete = (
  options?: Omit<
    reactQuery.UseMutationOptions<
      undefined,
      StorageControllerDeleteError,
      StorageControllerDeleteVariables
    >,
    "mutationFn"
  >,
) => {
  const { fetcherOptions } = useArchesApiContext();
  return reactQuery.useMutation<
    undefined,
    StorageControllerDeleteError,
    StorageControllerDeleteVariables
  >({
    mutationFn: (variables: StorageControllerDeleteVariables) =>
      fetchStorageControllerDelete({ ...fetcherOptions, ...variables }),
    ...options,
  });
};

export type StorageControllerGetReadUrlPathParams = {
  orgname: string;
};

export type StorageControllerGetReadUrlError = Fetcher.ErrorWrapper<undefined>;

export type StorageControllerGetReadUrlVariables = {
  body: Schemas.PathDto;
  pathParams: StorageControllerGetReadUrlPathParams;
} & ArchesApiContext["fetcherOptions"];

/**
 * This endpoint will return a url for reading a file in the organization's secure storage. It will be valid for 15 minutes. ADMIN ONLY.
 */
export const fetchStorageControllerGetReadUrl = (
  variables: StorageControllerGetReadUrlVariables,
  signal?: AbortSignal,
) =>
  archesApiFetch<
    Schemas.ReadUrlDto,
    StorageControllerGetReadUrlError,
    Schemas.PathDto,
    {},
    {},
    StorageControllerGetReadUrlPathParams
  >({
    url: "/organizations/{orgname}/storage/read",
    method: "post",
    ...variables,
    signal,
  });

/**
 * This endpoint will return a url for reading a file in the organization's secure storage. It will be valid for 15 minutes. ADMIN ONLY.
 */
export const useStorageControllerGetReadUrl = (
  options?: Omit<
    reactQuery.UseMutationOptions<
      Schemas.ReadUrlDto,
      StorageControllerGetReadUrlError,
      StorageControllerGetReadUrlVariables
    >,
    "mutationFn"
  >,
) => {
  const { fetcherOptions } = useArchesApiContext();
  return reactQuery.useMutation<
    Schemas.ReadUrlDto,
    StorageControllerGetReadUrlError,
    StorageControllerGetReadUrlVariables
  >({
    mutationFn: (variables: StorageControllerGetReadUrlVariables) =>
      fetchStorageControllerGetReadUrl({ ...fetcherOptions, ...variables }),
    ...options,
  });
};

export type StorageControllerGetWriteUrlPathParams = {
  orgname: string;
};

export type StorageControllerGetWriteUrlError = Fetcher.ErrorWrapper<undefined>;

export type StorageControllerGetWriteUrlVariables = {
  body: Schemas.PathDto;
  pathParams: StorageControllerGetWriteUrlPathParams;
} & ArchesApiContext["fetcherOptions"];

/**
 * This endpoint will return a url for writing to a file location in the organization's secure storage. You must write your file to the url returned by this endpoint. If you use is isDir param, it will create a directory instead of a file and you do not need to write to the url. ADMIN ONLY.
 */
export const fetchStorageControllerGetWriteUrl = (
  variables: StorageControllerGetWriteUrlVariables,
  signal?: AbortSignal,
) =>
  archesApiFetch<
    Schemas.WriteUrlDto,
    StorageControllerGetWriteUrlError,
    Schemas.PathDto,
    {},
    {},
    StorageControllerGetWriteUrlPathParams
  >({
    url: "/organizations/{orgname}/storage/write",
    method: "post",
    ...variables,
    signal,
  });

/**
 * This endpoint will return a url for writing to a file location in the organization's secure storage. You must write your file to the url returned by this endpoint. If you use is isDir param, it will create a directory instead of a file and you do not need to write to the url. ADMIN ONLY.
 */
export const useStorageControllerGetWriteUrl = (
  options?: Omit<
    reactQuery.UseMutationOptions<
      Schemas.WriteUrlDto,
      StorageControllerGetWriteUrlError,
      StorageControllerGetWriteUrlVariables
    >,
    "mutationFn"
  >,
) => {
  const { fetcherOptions } = useArchesApiContext();
  return reactQuery.useMutation<
    Schemas.WriteUrlDto,
    StorageControllerGetWriteUrlError,
    StorageControllerGetWriteUrlVariables
  >({
    mutationFn: (variables: StorageControllerGetWriteUrlVariables) =>
      fetchStorageControllerGetWriteUrl({ ...fetcherOptions, ...variables }),
    ...options,
  });
};

export type StorageControllerListDirectoryPathParams = {
  orgname: string;
};

export type StorageControllerListDirectoryQueryParams = {
  path: string;
};

export type StorageControllerListDirectoryError =
  Fetcher.ErrorWrapper<undefined>;

export type StorageControllerListDirectoryResponse = Schemas.StorageItemDto[];

export type StorageControllerListDirectoryVariables = {
  pathParams: StorageControllerListDirectoryPathParams;
  queryParams: StorageControllerListDirectoryQueryParams;
} & ArchesApiContext["fetcherOptions"];

/**
 * This endpoint will return a list of files and directories in the organization's secure storage at the specified path. ADMIN ONLY.
 */
export const fetchStorageControllerListDirectory = (
  variables: StorageControllerListDirectoryVariables,
  signal?: AbortSignal,
) =>
  archesApiFetch<
    StorageControllerListDirectoryResponse,
    StorageControllerListDirectoryError,
    undefined,
    {},
    StorageControllerListDirectoryQueryParams,
    StorageControllerListDirectoryPathParams
  >({
    url: "/organizations/{orgname}/storage/items",
    method: "get",
    ...variables,
    signal,
  });

/**
 * This endpoint will return a list of files and directories in the organization's secure storage at the specified path. ADMIN ONLY.
 */
export const useStorageControllerListDirectory = <
  TData = StorageControllerListDirectoryResponse,
>(
  variables: StorageControllerListDirectoryVariables,
  options?: Omit<
    reactQuery.UseQueryOptions<
      StorageControllerListDirectoryResponse,
      StorageControllerListDirectoryError,
      TData
    >,
    "queryKey" | "queryFn" | "initialData"
  >,
) => {
  const { fetcherOptions, queryOptions, queryKeyFn } =
    useArchesApiContext(options);
  return reactQuery.useQuery<
    StorageControllerListDirectoryResponse,
    StorageControllerListDirectoryError,
    TData
  >({
    queryKey: queryKeyFn({
      path: "/organizations/{orgname}/storage/items",
      operationId: "storageControllerListDirectory",
      variables,
    }),
    queryFn: ({ signal }) =>
      fetchStorageControllerListDirectory(
        { ...fetcherOptions, ...variables },
        signal,
      ),
    ...options,
    ...queryOptions,
  });
};

export type ChatbotsControllerCreatePathParams = {
  orgname: string;
};

export type ChatbotsControllerCreateError = Fetcher.ErrorWrapper<undefined>;

export type ChatbotsControllerCreateVariables = {
  body: Schemas.CreateChatbotDto;
  pathParams: ChatbotsControllerCreatePathParams;
} & ArchesApiContext["fetcherOptions"];

/**
 * Create a new chatbot. ADMIN ONLY.
 */
export const fetchChatbotsControllerCreate = (
  variables: ChatbotsControllerCreateVariables,
  signal?: AbortSignal,
) =>
  archesApiFetch<
    Schemas.ChatbotEntity,
    ChatbotsControllerCreateError,
    Schemas.CreateChatbotDto,
    {},
    {},
    ChatbotsControllerCreatePathParams
  >({
    url: "/organizations/{orgname}/chatbots",
    method: "post",
    ...variables,
    signal,
  });

/**
 * Create a new chatbot. ADMIN ONLY.
 */
export const useChatbotsControllerCreate = (
  options?: Omit<
    reactQuery.UseMutationOptions<
      Schemas.ChatbotEntity,
      ChatbotsControllerCreateError,
      ChatbotsControllerCreateVariables
    >,
    "mutationFn"
  >,
) => {
  const { fetcherOptions } = useArchesApiContext();
  return reactQuery.useMutation<
    Schemas.ChatbotEntity,
    ChatbotsControllerCreateError,
    ChatbotsControllerCreateVariables
  >({
    mutationFn: (variables: ChatbotsControllerCreateVariables) =>
      fetchChatbotsControllerCreate({ ...fetcherOptions, ...variables }),
    ...options,
  });
};

export type ChatbotsControllerFindAllPathParams = {
  orgname: string;
};

export type ChatbotsControllerFindAllQueryParams = {
  /**
   * The end date to search to
   */
  endDate?: string;
  /**
   * The limit of the number of results returned
   *
   * @default 10
   */
  limit?: number;
  /**
   * The offset of the returned results
   *
   * @default 0
   */
  offset?: number;
  /**
   * Search term
   *
   * @default
   */
  searchTerm?: string;
  /**
   * The field to sort the results by
   *
   * @default createdAt
   */
  sortBy?: "createdAt";
  /**
   * The direction to sort the results by
   *
   * @default desc
   */
  sortDirection?: "asc" | "desc";
  /**
   * The start date to search from
   */
  startDate?: string;
  /**
   * The name to search for
   */
  name: string;
};

export type ChatbotsControllerFindAllError = Fetcher.ErrorWrapper<undefined>;

export type ChatbotsControllerFindAllResponse = Schemas.PaginatedDto & {
  results?: Schemas.ChatbotEntity[];
};

export type ChatbotsControllerFindAllVariables = {
  pathParams: ChatbotsControllerFindAllPathParams;
  queryParams: ChatbotsControllerFindAllQueryParams;
} & ArchesApiContext["fetcherOptions"];

/**
 * Get all chatbots. ADMIN ONLY.
 */
export const fetchChatbotsControllerFindAll = (
  variables: ChatbotsControllerFindAllVariables,
  signal?: AbortSignal,
) =>
  archesApiFetch<
    ChatbotsControllerFindAllResponse,
    ChatbotsControllerFindAllError,
    undefined,
    {},
    ChatbotsControllerFindAllQueryParams,
    ChatbotsControllerFindAllPathParams
  >({
    url: "/organizations/{orgname}/chatbots",
    method: "get",
    ...variables,
    signal,
  });

/**
 * Get all chatbots. ADMIN ONLY.
 */
export const useChatbotsControllerFindAll = <
  TData = ChatbotsControllerFindAllResponse,
>(
  variables: ChatbotsControllerFindAllVariables,
  options?: Omit<
    reactQuery.UseQueryOptions<
      ChatbotsControllerFindAllResponse,
      ChatbotsControllerFindAllError,
      TData
    >,
    "queryKey" | "queryFn" | "initialData"
  >,
) => {
  const { fetcherOptions, queryOptions, queryKeyFn } =
    useArchesApiContext(options);
  return reactQuery.useQuery<
    ChatbotsControllerFindAllResponse,
    ChatbotsControllerFindAllError,
    TData
  >({
    queryKey: queryKeyFn({
      path: "/organizations/{orgname}/chatbots",
      operationId: "chatbotsControllerFindAll",
      variables,
    }),
    queryFn: ({ signal }) =>
      fetchChatbotsControllerFindAll(
        { ...fetcherOptions, ...variables },
        signal,
      ),
    ...options,
    ...queryOptions,
  });
};

export type ChatbotsControllerFindOnePathParams = {
  orgname: string;
  chatbotId: string;
};

export type ChatbotsControllerFindOneError = Fetcher.ErrorWrapper<undefined>;

export type ChatbotsControllerFindOneVariables = {
  pathParams: ChatbotsControllerFindOnePathParams;
} & ArchesApiContext["fetcherOptions"];

/**
 * Get a chatbot. ADMIN ONLY.
 */
export const fetchChatbotsControllerFindOne = (
  variables: ChatbotsControllerFindOneVariables,
  signal?: AbortSignal,
) =>
  archesApiFetch<
    Schemas.ChatbotEntity,
    ChatbotsControllerFindOneError,
    undefined,
    {},
    {},
    ChatbotsControllerFindOnePathParams
  >({
    url: "/organizations/{orgname}/chatbots/{chatbotId}",
    method: "get",
    ...variables,
    signal,
  });

/**
 * Get a chatbot. ADMIN ONLY.
 */
export const useChatbotsControllerFindOne = <TData = Schemas.ChatbotEntity,>(
  variables: ChatbotsControllerFindOneVariables,
  options?: Omit<
    reactQuery.UseQueryOptions<
      Schemas.ChatbotEntity,
      ChatbotsControllerFindOneError,
      TData
    >,
    "queryKey" | "queryFn" | "initialData"
  >,
) => {
  const { fetcherOptions, queryOptions, queryKeyFn } =
    useArchesApiContext(options);
  return reactQuery.useQuery<
    Schemas.ChatbotEntity,
    ChatbotsControllerFindOneError,
    TData
  >({
    queryKey: queryKeyFn({
      path: "/organizations/{orgname}/chatbots/{chatbotId}",
      operationId: "chatbotsControllerFindOne",
      variables,
    }),
    queryFn: ({ signal }) =>
      fetchChatbotsControllerFindOne(
        { ...fetcherOptions, ...variables },
        signal,
      ),
    ...options,
    ...queryOptions,
  });
};

export type ChatbotsControllerRemovePathParams = {
  orgname: string;
  chatbotId: string;
};

export type ChatbotsControllerRemoveError = Fetcher.ErrorWrapper<undefined>;

export type ChatbotsControllerRemoveVariables = {
  pathParams: ChatbotsControllerRemovePathParams;
} & ArchesApiContext["fetcherOptions"];

/**
 * Delete a chatbot. ADMIN ONLY.
 */
export const fetchChatbotsControllerRemove = (
  variables: ChatbotsControllerRemoveVariables,
  signal?: AbortSignal,
) =>
  archesApiFetch<
    undefined,
    ChatbotsControllerRemoveError,
    undefined,
    {},
    {},
    ChatbotsControllerRemovePathParams
  >({
    url: "/organizations/{orgname}/chatbots/{chatbotId}",
    method: "delete",
    ...variables,
    signal,
  });

/**
 * Delete a chatbot. ADMIN ONLY.
 */
export const useChatbotsControllerRemove = (
  options?: Omit<
    reactQuery.UseMutationOptions<
      undefined,
      ChatbotsControllerRemoveError,
      ChatbotsControllerRemoveVariables
    >,
    "mutationFn"
  >,
) => {
  const { fetcherOptions } = useArchesApiContext();
  return reactQuery.useMutation<
    undefined,
    ChatbotsControllerRemoveError,
    ChatbotsControllerRemoveVariables
  >({
    mutationFn: (variables: ChatbotsControllerRemoveVariables) =>
      fetchChatbotsControllerRemove({ ...fetcherOptions, ...variables }),
    ...options,
  });
};

export type ChatbotsControllerUpdatePathParams = {
  orgname: string;
  chatbotId: string;
};

export type ChatbotsControllerUpdateError = Fetcher.ErrorWrapper<undefined>;

export type ChatbotsControllerUpdateVariables = {
  body?: Schemas.UpdateChatbotDto;
  pathParams: ChatbotsControllerUpdatePathParams;
} & ArchesApiContext["fetcherOptions"];

/**
 * Update a chatbot. ADMIN ONLY.
 */
export const fetchChatbotsControllerUpdate = (
  variables: ChatbotsControllerUpdateVariables,
  signal?: AbortSignal,
) =>
  archesApiFetch<
    Schemas.ChatbotEntity,
    ChatbotsControllerUpdateError,
    Schemas.UpdateChatbotDto,
    {},
    {},
    ChatbotsControllerUpdatePathParams
  >({
    url: "/organizations/{orgname}/chatbots/{chatbotId}",
    method: "patch",
    ...variables,
    signal,
  });

/**
 * Update a chatbot. ADMIN ONLY.
 */
export const useChatbotsControllerUpdate = (
  options?: Omit<
    reactQuery.UseMutationOptions<
      Schemas.ChatbotEntity,
      ChatbotsControllerUpdateError,
      ChatbotsControllerUpdateVariables
    >,
    "mutationFn"
  >,
) => {
  const { fetcherOptions } = useArchesApiContext();
  return reactQuery.useMutation<
    Schemas.ChatbotEntity,
    ChatbotsControllerUpdateError,
    ChatbotsControllerUpdateVariables
  >({
    mutationFn: (variables: ChatbotsControllerUpdateVariables) =>
      fetchChatbotsControllerUpdate({ ...fetcherOptions, ...variables }),
    ...options,
  });
};

export type MessagesControllerCreatePathParams = {
  orgname: string;
  chatbotId: string;
  threadId: string;
};

export type MessagesControllerCreateError = Fetcher.ErrorWrapper<undefined>;

export type MessagesControllerCreateVariables = {
  body: Schemas.CreateMessageDto;
  pathParams: MessagesControllerCreatePathParams;
} & ArchesApiContext["fetcherOptions"];

/**
 * Create a new message. ADMIN ONLY.
 */
export const fetchMessagesControllerCreate = (
  variables: MessagesControllerCreateVariables,
  signal?: AbortSignal,
) =>
  archesApiFetch<
    Schemas.MessageEntity,
    MessagesControllerCreateError,
    Schemas.CreateMessageDto,
    {},
    {},
    MessagesControllerCreatePathParams
  >({
    url: "/organizations/{orgname}/chatbots/{chatbotId}/threads/{threadId}/messages",
    method: "post",
    ...variables,
    signal,
  });

/**
 * Create a new message. ADMIN ONLY.
 */
export const useMessagesControllerCreate = (
  options?: Omit<
    reactQuery.UseMutationOptions<
      Schemas.MessageEntity,
      MessagesControllerCreateError,
      MessagesControllerCreateVariables
    >,
    "mutationFn"
  >,
) => {
  const { fetcherOptions } = useArchesApiContext();
  return reactQuery.useMutation<
    Schemas.MessageEntity,
    MessagesControllerCreateError,
    MessagesControllerCreateVariables
  >({
    mutationFn: (variables: MessagesControllerCreateVariables) =>
      fetchMessagesControllerCreate({ ...fetcherOptions, ...variables }),
    ...options,
  });
};

export type MessagesControllerFindAllPathParams = {
  orgname: string;
  chatbotId: string;
  threadId: string;
};

export type MessagesControllerFindAllQueryParams = {
  /**
   * The limit of the number of results returned
   *
   * @default 10
   */
  limit?: number;
  /**
   * The offset of the returned results
   *
   * @default 0
   */
  offset?: number;
  /**
   * The direction to sort the results by
   *
   * @default desc
   */
  sortDirection?: "asc" | "desc";
  /**
   * @default createdAt
   */
  sortBy?: "createdAt";
};

export type MessagesControllerFindAllError = Fetcher.ErrorWrapper<undefined>;

export type MessagesControllerFindAllResponse = Schemas.PaginatedDto & {
  results?: Schemas.MessageEntity[];
};

export type MessagesControllerFindAllVariables = {
  pathParams: MessagesControllerFindAllPathParams;
  queryParams?: MessagesControllerFindAllQueryParams;
} & ArchesApiContext["fetcherOptions"];

/**
 * Get all messages. ADMIN ONLY.
 */
export const fetchMessagesControllerFindAll = (
  variables: MessagesControllerFindAllVariables,
  signal?: AbortSignal,
) =>
  archesApiFetch<
    MessagesControllerFindAllResponse,
    MessagesControllerFindAllError,
    undefined,
    {},
    MessagesControllerFindAllQueryParams,
    MessagesControllerFindAllPathParams
  >({
    url: "/organizations/{orgname}/chatbots/{chatbotId}/threads/{threadId}/messages",
    method: "get",
    ...variables,
    signal,
  });

/**
 * Get all messages. ADMIN ONLY.
 */
export const useMessagesControllerFindAll = <
  TData = MessagesControllerFindAllResponse,
>(
  variables: MessagesControllerFindAllVariables,
  options?: Omit<
    reactQuery.UseQueryOptions<
      MessagesControllerFindAllResponse,
      MessagesControllerFindAllError,
      TData
    >,
    "queryKey" | "queryFn" | "initialData"
  >,
) => {
  const { fetcherOptions, queryOptions, queryKeyFn } =
    useArchesApiContext(options);
  return reactQuery.useQuery<
    MessagesControllerFindAllResponse,
    MessagesControllerFindAllError,
    TData
  >({
    queryKey: queryKeyFn({
      path: "/organizations/{orgname}/chatbots/{chatbotId}/threads/{threadId}/messages",
      operationId: "messagesControllerFindAll",
      variables,
    }),
    queryFn: ({ signal }) =>
      fetchMessagesControllerFindAll(
        { ...fetcherOptions, ...variables },
        signal,
      ),
    ...options,
    ...queryOptions,
  });
};

export type ContentControllerCreatePathParams = {
  orgname: string;
};

export type ContentControllerCreateError = Fetcher.ErrorWrapper<undefined>;

export type ContentControllerCreateVariables = {
  body: Schemas.CreateContentDto;
  pathParams: ContentControllerCreatePathParams;
} & ArchesApiContext["fetcherOptions"];

/**
 * Create a new content. ADMIN ONLY.
 */
export const fetchContentControllerCreate = (
  variables: ContentControllerCreateVariables,
  signal?: AbortSignal,
) =>
  archesApiFetch<
    Schemas.ContentEntity,
    ContentControllerCreateError,
    Schemas.CreateContentDto,
    {},
    {},
    ContentControllerCreatePathParams
  >({
    url: "/organizations/{orgname}/content",
    method: "post",
    ...variables,
    signal,
  });

/**
 * Create a new content. ADMIN ONLY.
 */
export const useContentControllerCreate = (
  options?: Omit<
    reactQuery.UseMutationOptions<
      Schemas.ContentEntity,
      ContentControllerCreateError,
      ContentControllerCreateVariables
    >,
    "mutationFn"
  >,
) => {
  const { fetcherOptions } = useArchesApiContext();
  return reactQuery.useMutation<
    Schemas.ContentEntity,
    ContentControllerCreateError,
    ContentControllerCreateVariables
  >({
    mutationFn: (variables: ContentControllerCreateVariables) =>
      fetchContentControllerCreate({ ...fetcherOptions, ...variables }),
    ...options,
  });
};

export type ContentControllerFindAllPathParams = {
  orgname: string;
};

export type ContentControllerFindAllQueryParams = {
  /**
   * The end date to search to
   */
  endDate?: string;
  /**
   * The limit of the number of results returned
   *
   * @default 10
   */
  limit?: number;
  /**
   * The offset of the returned results
   *
   * @default 0
   */
  offset?: number;
  /**
   * Search term
   *
   * @default
   */
  searchTerm?: string;
  /**
   * The field to sort the results by
   *
   * @default createdAt
   */
  sortBy?: "createdAt" | "name";
  /**
   * The direction to sort the results by
   *
   * @default desc
   */
  sortDirection?: "asc" | "desc";
  /**
   * The start date to search from
   */
  startDate?: string;
};

export type ContentControllerFindAllError = Fetcher.ErrorWrapper<undefined>;

export type ContentControllerFindAllResponse = Schemas.PaginatedDto & {
  results?: Schemas.ContentEntity[];
};

export type ContentControllerFindAllVariables = {
  pathParams: ContentControllerFindAllPathParams;
  queryParams?: ContentControllerFindAllQueryParams;
} & ArchesApiContext["fetcherOptions"];

/**
 * Get all contents. ADMIN ONLY.
 */
export const fetchContentControllerFindAll = (
  variables: ContentControllerFindAllVariables,
  signal?: AbortSignal,
) =>
  archesApiFetch<
    ContentControllerFindAllResponse,
    ContentControllerFindAllError,
    undefined,
    {},
    ContentControllerFindAllQueryParams,
    ContentControllerFindAllPathParams
  >({
    url: "/organizations/{orgname}/content",
    method: "get",
    ...variables,
    signal,
  });

/**
 * Get all contents. ADMIN ONLY.
 */
export const useContentControllerFindAll = <
  TData = ContentControllerFindAllResponse,
>(
  variables: ContentControllerFindAllVariables,
  options?: Omit<
    reactQuery.UseQueryOptions<
      ContentControllerFindAllResponse,
      ContentControllerFindAllError,
      TData
    >,
    "queryKey" | "queryFn" | "initialData"
  >,
) => {
  const { fetcherOptions, queryOptions, queryKeyFn } =
    useArchesApiContext(options);
  return reactQuery.useQuery<
    ContentControllerFindAllResponse,
    ContentControllerFindAllError,
    TData
  >({
    queryKey: queryKeyFn({
      path: "/organizations/{orgname}/content",
      operationId: "contentControllerFindAll",
      variables,
    }),
    queryFn: ({ signal }) =>
      fetchContentControllerFindAll(
        { ...fetcherOptions, ...variables },
        signal,
      ),
    ...options,
    ...queryOptions,
  });
};

export type ContentControllerFindOnePathParams = {
  orgname: string;
  contentId: string;
};

export type ContentControllerFindOneError = Fetcher.ErrorWrapper<undefined>;

export type ContentControllerFindOneVariables = {
  pathParams: ContentControllerFindOnePathParams;
} & ArchesApiContext["fetcherOptions"];

/**
 * Get a content. ADMIN ONLY.
 */
export const fetchContentControllerFindOne = (
  variables: ContentControllerFindOneVariables,
  signal?: AbortSignal,
) =>
  archesApiFetch<
    Schemas.ContentEntity,
    ContentControllerFindOneError,
    undefined,
    {},
    {},
    ContentControllerFindOnePathParams
  >({
    url: "/organizations/{orgname}/content/{contentId}",
    method: "get",
    ...variables,
    signal,
  });

/**
 * Get a content. ADMIN ONLY.
 */
export const useContentControllerFindOne = <TData = Schemas.ContentEntity,>(
  variables: ContentControllerFindOneVariables,
  options?: Omit<
    reactQuery.UseQueryOptions<
      Schemas.ContentEntity,
      ContentControllerFindOneError,
      TData
    >,
    "queryKey" | "queryFn" | "initialData"
  >,
) => {
  const { fetcherOptions, queryOptions, queryKeyFn } =
    useArchesApiContext(options);
  return reactQuery.useQuery<
    Schemas.ContentEntity,
    ContentControllerFindOneError,
    TData
  >({
    queryKey: queryKeyFn({
      path: "/organizations/{orgname}/content/{contentId}",
      operationId: "contentControllerFindOne",
      variables,
    }),
    queryFn: ({ signal }) =>
      fetchContentControllerFindOne(
        { ...fetcherOptions, ...variables },
        signal,
      ),
    ...options,
    ...queryOptions,
  });
};

export type ContentControllerRemovePathParams = {
  orgname: string;
  contentId: string;
};

export type ContentControllerRemoveError = Fetcher.ErrorWrapper<undefined>;

export type ContentControllerRemoveVariables = {
  pathParams: ContentControllerRemovePathParams;
} & ArchesApiContext["fetcherOptions"];

/**
 * Delete a content. ADMIN ONLY.
 */
export const fetchContentControllerRemove = (
  variables: ContentControllerRemoveVariables,
  signal?: AbortSignal,
) =>
  archesApiFetch<
    undefined,
    ContentControllerRemoveError,
    undefined,
    {},
    {},
    ContentControllerRemovePathParams
  >({
    url: "/organizations/{orgname}/content/{contentId}",
    method: "delete",
    ...variables,
    signal,
  });

/**
 * Delete a content. ADMIN ONLY.
 */
export const useContentControllerRemove = (
  options?: Omit<
    reactQuery.UseMutationOptions<
      undefined,
      ContentControllerRemoveError,
      ContentControllerRemoveVariables
    >,
    "mutationFn"
  >,
) => {
  const { fetcherOptions } = useArchesApiContext();
  return reactQuery.useMutation<
    undefined,
    ContentControllerRemoveError,
    ContentControllerRemoveVariables
  >({
    mutationFn: (variables: ContentControllerRemoveVariables) =>
      fetchContentControllerRemove({ ...fetcherOptions, ...variables }),
    ...options,
  });
};

export type ContentControllerUpdatePathParams = {
  orgname: string;
  contentId: string;
};

export type ContentControllerUpdateError = Fetcher.ErrorWrapper<undefined>;

export type ContentControllerUpdateVariables = {
  body: Schemas.UpdateContentDto;
  pathParams: ContentControllerUpdatePathParams;
} & ArchesApiContext["fetcherOptions"];

/**
 * Update a content. ADMIN ONLY.
 */
export const fetchContentControllerUpdate = (
  variables: ContentControllerUpdateVariables,
  signal?: AbortSignal,
) =>
  archesApiFetch<
    Schemas.ContentEntity,
    ContentControllerUpdateError,
    Schemas.UpdateContentDto,
    {},
    {},
    ContentControllerUpdatePathParams
  >({
    url: "/organizations/{orgname}/content/{contentId}",
    method: "patch",
    ...variables,
    signal,
  });

/**
 * Update a content. ADMIN ONLY.
 */
export const useContentControllerUpdate = (
  options?: Omit<
    reactQuery.UseMutationOptions<
      Schemas.ContentEntity,
      ContentControllerUpdateError,
      ContentControllerUpdateVariables
    >,
    "mutationFn"
  >,
) => {
  const { fetcherOptions } = useArchesApiContext();
  return reactQuery.useMutation<
    Schemas.ContentEntity,
    ContentControllerUpdateError,
    ContentControllerUpdateVariables
  >({
    mutationFn: (variables: ContentControllerUpdateVariables) =>
      fetchContentControllerUpdate({ ...fetcherOptions, ...variables }),
    ...options,
  });
};

export type JobsControllerFindAllPathParams = {
  orgname: string;
};

export type JobsControllerFindAllQueryParams = {
  /**
   * The end date to search to
   */
  endDate?: string;
  /**
   * The limit of the number of results returned
   *
   * @default 10
   */
  limit?: number;
  /**
   * The offset of the returned results
   *
   * @default 0
   */
  offset?: number;
  /**
   * Search term
   *
   * @default
   */
  searchTerm?: string;
  /**
   * The field to sort the results by
   *
   * @default createdAt
   */
  sortBy?: "createdAt";
  /**
   * The direction to sort the results by
   *
   * @default desc
   */
  sortDirection?: "asc" | "desc";
  /**
   * The start date to search from
   */
  startDate?: string;
};

export type JobsControllerFindAllError = Fetcher.ErrorWrapper<undefined>;

export type JobsControllerFindAllResponse = Schemas.PaginatedDto & {
  results?: Schemas.JobEntity[];
};

export type JobsControllerFindAllVariables = {
  pathParams: JobsControllerFindAllPathParams;
  queryParams?: JobsControllerFindAllQueryParams;
} & ArchesApiContext["fetcherOptions"];

/**
 * Get all jobs. ADMIN ONLY.
 */
export const fetchJobsControllerFindAll = (
  variables: JobsControllerFindAllVariables,
  signal?: AbortSignal,
) =>
  archesApiFetch<
    JobsControllerFindAllResponse,
    JobsControllerFindAllError,
    undefined,
    {},
    JobsControllerFindAllQueryParams,
    JobsControllerFindAllPathParams
  >({
    url: "/organizations/{orgname}/jobs",
    method: "get",
    ...variables,
    signal,
  });

/**
 * Get all jobs. ADMIN ONLY.
 */
export const useJobsControllerFindAll = <
  TData = JobsControllerFindAllResponse,
>(
  variables: JobsControllerFindAllVariables,
  options?: Omit<
    reactQuery.UseQueryOptions<
      JobsControllerFindAllResponse,
      JobsControllerFindAllError,
      TData
    >,
    "queryKey" | "queryFn" | "initialData"
  >,
) => {
  const { fetcherOptions, queryOptions, queryKeyFn } =
    useArchesApiContext(options);
  return reactQuery.useQuery<
    JobsControllerFindAllResponse,
    JobsControllerFindAllError,
    TData
  >({
    queryKey: queryKeyFn({
      path: "/organizations/{orgname}/jobs",
      operationId: "jobsControllerFindAll",
      variables,
    }),
    queryFn: ({ signal }) =>
      fetchJobsControllerFindAll({ ...fetcherOptions, ...variables }, signal),
    ...options,
    ...queryOptions,
  });
};

export type JobsControllerFindOnePathParams = {
  orgname: string;
  id: string;
};

export type JobsControllerFindOneError = Fetcher.ErrorWrapper<undefined>;

export type JobsControllerFindOneVariables = {
  pathParams: JobsControllerFindOnePathParams;
} & ArchesApiContext["fetcherOptions"];

/**
 * Get a job. ADMIN ONLY.
 */
export const fetchJobsControllerFindOne = (
  variables: JobsControllerFindOneVariables,
  signal?: AbortSignal,
) =>
  archesApiFetch<
    Schemas.JobEntity,
    JobsControllerFindOneError,
    undefined,
    {},
    {},
    JobsControllerFindOnePathParams
  >({
    url: "/organizations/{orgname}/jobs/{id}",
    method: "get",
    ...variables,
    signal,
  });

/**
 * Get a job. ADMIN ONLY.
 */
export const useJobsControllerFindOne = <TData = Schemas.JobEntity,>(
  variables: JobsControllerFindOneVariables,
  options?: Omit<
    reactQuery.UseQueryOptions<
      Schemas.JobEntity,
      JobsControllerFindOneError,
      TData
    >,
    "queryKey" | "queryFn" | "initialData"
  >,
) => {
  const { fetcherOptions, queryOptions, queryKeyFn } =
    useArchesApiContext(options);
  return reactQuery.useQuery<
    Schemas.JobEntity,
    JobsControllerFindOneError,
    TData
  >({
    queryKey: queryKeyFn({
      path: "/organizations/{orgname}/jobs/{id}",
      operationId: "jobsControllerFindOne",
      variables,
    }),
    queryFn: ({ signal }) =>
      fetchJobsControllerFindOne({ ...fetcherOptions, ...variables }, signal),
    ...options,
    ...queryOptions,
  });
};

export type JobsControllerRemovePathParams = {
  orgname: string;
  id: string;
};

export type JobsControllerRemoveError = Fetcher.ErrorWrapper<undefined>;

export type JobsControllerRemoveVariables = {
  pathParams: JobsControllerRemovePathParams;
} & ArchesApiContext["fetcherOptions"];

/**
 * Delete a job. ADMIN ONLY.
 */
export const fetchJobsControllerRemove = (
  variables: JobsControllerRemoveVariables,
  signal?: AbortSignal,
) =>
  archesApiFetch<
    undefined,
    JobsControllerRemoveError,
    undefined,
    {},
    {},
    JobsControllerRemovePathParams
  >({
    url: "/organizations/{orgname}/jobs/{id}",
    method: "delete",
    ...variables,
    signal,
  });

/**
 * Delete a job. ADMIN ONLY.
 */
export const useJobsControllerRemove = (
  options?: Omit<
    reactQuery.UseMutationOptions<
      undefined,
      JobsControllerRemoveError,
      JobsControllerRemoveVariables
    >,
    "mutationFn"
  >,
) => {
  const { fetcherOptions } = useArchesApiContext();
  return reactQuery.useMutation<
    undefined,
    JobsControllerRemoveError,
    JobsControllerRemoveVariables
  >({
    mutationFn: (variables: JobsControllerRemoveVariables) =>
      fetchJobsControllerRemove({ ...fetcherOptions, ...variables }),
    ...options,
  });
};

export type VectorRecordControllerFindAllPathParams = {
  orgname: string;
  contentId: string;
};

export type VectorRecordControllerFindAllQueryParams = {
  /**
   * The end date to search to
   */
  endDate?: string;
  /**
   * The limit of the number of results returned
   *
   * @default 10
   */
  limit?: number;
  /**
   * The offset of the returned results
   *
   * @default 0
   */
  offset?: number;
  /**
   * Search term
   *
   * @default
   */
  searchTerm?: string;
  /**
   * The field to sort the results by
   *
   * @default createdAt
   */
  sortBy?: "createdAt";
  /**
   * The direction to sort the results by
   *
   * @default desc
   */
  sortDirection?: "asc" | "desc";
  /**
   * The start date to search from
   */
  startDate?: string;
};

export type VectorRecordControllerFindAllError =
  Fetcher.ErrorWrapper<undefined>;

export type VectorRecordControllerFindAllResponse = Schemas.PaginatedDto & {
  results?: Schemas.VectorRecordEntity[];
};

export type VectorRecordControllerFindAllVariables = {
  pathParams: VectorRecordControllerFindAllPathParams;
  queryParams?: VectorRecordControllerFindAllQueryParams;
} & ArchesApiContext["fetcherOptions"];

/**
 * Get all vector records. ADMIN ONLY.
 */
export const fetchVectorRecordControllerFindAll = (
  variables: VectorRecordControllerFindAllVariables,
  signal?: AbortSignal,
) =>
  archesApiFetch<
    VectorRecordControllerFindAllResponse,
    VectorRecordControllerFindAllError,
    undefined,
    {},
    VectorRecordControllerFindAllQueryParams,
    VectorRecordControllerFindAllPathParams
  >({
    url: "/organizations/{orgname}/content/{contentId}/vector-records",
    method: "get",
    ...variables,
    signal,
  });

/**
 * Get all vector records. ADMIN ONLY.
 */
export const useVectorRecordControllerFindAll = <
  TData = VectorRecordControllerFindAllResponse,
>(
  variables: VectorRecordControllerFindAllVariables,
  options?: Omit<
    reactQuery.UseQueryOptions<
      VectorRecordControllerFindAllResponse,
      VectorRecordControllerFindAllError,
      TData
    >,
    "queryKey" | "queryFn" | "initialData"
  >,
) => {
  const { fetcherOptions, queryOptions, queryKeyFn } =
    useArchesApiContext(options);
  return reactQuery.useQuery<
    VectorRecordControllerFindAllResponse,
    VectorRecordControllerFindAllError,
    TData
  >({
    queryKey: queryKeyFn({
      path: "/organizations/{orgname}/content/{contentId}/vector-records",
      operationId: "vectorRecordControllerFindAll",
      variables,
    }),
    queryFn: ({ signal }) =>
      fetchVectorRecordControllerFindAll(
        { ...fetcherOptions, ...variables },
        signal,
      ),
    ...options,
    ...queryOptions,
  });
};

export type VectorRecordControllerFindOnePathParams = {
  orgname: string;
  contentId: string;
};

export type VectorRecordControllerFindOneError =
  Fetcher.ErrorWrapper<undefined>;

export type VectorRecordControllerFindOneVariables = {
  pathParams: VectorRecordControllerFindOnePathParams;
} & ArchesApiContext["fetcherOptions"];

/**
 * Get a vector record. ADMIN ONLY.
 */
export const fetchVectorRecordControllerFindOne = (
  variables: VectorRecordControllerFindOneVariables,
  signal?: AbortSignal,
) =>
  archesApiFetch<
    Schemas.VectorRecordEntity,
    VectorRecordControllerFindOneError,
    undefined,
    {},
    {},
    VectorRecordControllerFindOnePathParams
  >({
    url: "/organizations/{orgname}/content/{contentId}/vector-records/{vectorRecordId}",
    method: "get",
    ...variables,
    signal,
  });

/**
 * Get a vector record. ADMIN ONLY.
 */
export const useVectorRecordControllerFindOne = <
  TData = Schemas.VectorRecordEntity,
>(
  variables: VectorRecordControllerFindOneVariables,
  options?: Omit<
    reactQuery.UseQueryOptions<
      Schemas.VectorRecordEntity,
      VectorRecordControllerFindOneError,
      TData
    >,
    "queryKey" | "queryFn" | "initialData"
  >,
) => {
  const { fetcherOptions, queryOptions, queryKeyFn } =
    useArchesApiContext(options);
  return reactQuery.useQuery<
    Schemas.VectorRecordEntity,
    VectorRecordControllerFindOneError,
    TData
  >({
    queryKey: queryKeyFn({
      path: "/organizations/{orgname}/content/{contentId}/vector-records/{vectorRecordId}",
      operationId: "vectorRecordControllerFindOne",
      variables,
    }),
    queryFn: ({ signal }) =>
      fetchVectorRecordControllerFindOne(
        { ...fetcherOptions, ...variables },
        signal,
      ),
    ...options,
    ...queryOptions,
  });
};

export type PasswordResetControllerConfirmError =
  Fetcher.ErrorWrapper<undefined>;

export type PasswordResetControllerConfirmVariables = {
  body: Schemas.ConfirmPasswordResetDto;
} & ArchesApiContext["fetcherOptions"];

/**
 * This endpoint will confirm your password change with a token
 */
export const fetchPasswordResetControllerConfirm = (
  variables: PasswordResetControllerConfirmVariables,
  signal?: AbortSignal,
) =>
  archesApiFetch<
    Schemas.TokenDto,
    PasswordResetControllerConfirmError,
    Schemas.ConfirmPasswordResetDto,
    {},
    {},
    {}
  >({
    url: "/auth/password-reset/confirm",
    method: "post",
    ...variables,
    signal,
  });

/**
 * This endpoint will confirm your password change with a token
 */
export const usePasswordResetControllerConfirm = (
  options?: Omit<
    reactQuery.UseMutationOptions<
      Schemas.TokenDto,
      PasswordResetControllerConfirmError,
      PasswordResetControllerConfirmVariables
    >,
    "mutationFn"
  >,
) => {
  const { fetcherOptions } = useArchesApiContext();
  return reactQuery.useMutation<
    Schemas.TokenDto,
    PasswordResetControllerConfirmError,
    PasswordResetControllerConfirmVariables
  >({
    mutationFn: (variables: PasswordResetControllerConfirmVariables) =>
      fetchPasswordResetControllerConfirm({ ...fetcherOptions, ...variables }),
    ...options,
  });
};

export type PasswordResetControllerRequestError =
  Fetcher.ErrorWrapper<undefined>;

export type PasswordResetControllerRequestVariables = {
  body: Schemas.RequestPasswordResetDto;
} & ArchesApiContext["fetcherOptions"];

/**
 * This endpoint will request a password reset link
 */
export const fetchPasswordResetControllerRequest = (
  variables: PasswordResetControllerRequestVariables,
  signal?: AbortSignal,
) =>
  archesApiFetch<
    undefined,
    PasswordResetControllerRequestError,
    Schemas.RequestPasswordResetDto,
    {},
    {},
    {}
  >({
    url: "/auth/password-reset/request",
    method: "post",
    ...variables,
    signal,
  });

/**
 * This endpoint will request a password reset link
 */
export const usePasswordResetControllerRequest = (
  options?: Omit<
    reactQuery.UseMutationOptions<
      undefined,
      PasswordResetControllerRequestError,
      PasswordResetControllerRequestVariables
    >,
    "mutationFn"
  >,
) => {
  const { fetcherOptions } = useArchesApiContext();
  return reactQuery.useMutation<
    undefined,
    PasswordResetControllerRequestError,
    PasswordResetControllerRequestVariables
  >({
    mutationFn: (variables: PasswordResetControllerRequestVariables) =>
      fetchPasswordResetControllerRequest({ ...fetcherOptions, ...variables }),
    ...options,
  });
};

export type EmailChangeControllerConfirmError = Fetcher.ErrorWrapper<undefined>;

export type EmailChangeControllerConfirmVariables = {
  body: Schemas.ConfirmEmailChangeDto;
} & ArchesApiContext["fetcherOptions"];

/**
 * This endpoint will confirm your e-mail change with a token
 */
export const fetchEmailChangeControllerConfirm = (
  variables: EmailChangeControllerConfirmVariables,
  signal?: AbortSignal,
) =>
  archesApiFetch<
    Schemas.TokenDto,
    EmailChangeControllerConfirmError,
    Schemas.ConfirmEmailChangeDto,
    {},
    {},
    {}
  >({
    url: "/auth/email-change/confirm",
    method: "post",
    ...variables,
    signal,
  });

/**
 * This endpoint will confirm your e-mail change with a token
 */
export const useEmailChangeControllerConfirm = (
  options?: Omit<
    reactQuery.UseMutationOptions<
      Schemas.TokenDto,
      EmailChangeControllerConfirmError,
      EmailChangeControllerConfirmVariables
    >,
    "mutationFn"
  >,
) => {
  const { fetcherOptions } = useArchesApiContext();
  return reactQuery.useMutation<
    Schemas.TokenDto,
    EmailChangeControllerConfirmError,
    EmailChangeControllerConfirmVariables
  >({
    mutationFn: (variables: EmailChangeControllerConfirmVariables) =>
      fetchEmailChangeControllerConfirm({ ...fetcherOptions, ...variables }),
    ...options,
  });
};

export type EmailChangeControllerRequestError = Fetcher.ErrorWrapper<undefined>;

export type EmailChangeControllerRequestVariables = {
  body: Schemas.RequestEmailChangeDto;
} & ArchesApiContext["fetcherOptions"];

/**
 * This endpoint will request your e-mail change with a token
 */
export const fetchEmailChangeControllerRequest = (
  variables: EmailChangeControllerRequestVariables,
  signal?: AbortSignal,
) =>
  archesApiFetch<
    undefined,
    EmailChangeControllerRequestError,
    Schemas.RequestEmailChangeDto,
    {},
    {},
    {}
  >({
    url: "/auth/email-change/request",
    method: "post",
    ...variables,
    signal,
  });

/**
 * This endpoint will request your e-mail change with a token
 */
export const useEmailChangeControllerRequest = (
  options?: Omit<
    reactQuery.UseMutationOptions<
      undefined,
      EmailChangeControllerRequestError,
      EmailChangeControllerRequestVariables
    >,
    "mutationFn"
  >,
) => {
  const { fetcherOptions } = useArchesApiContext();
  return reactQuery.useMutation<
    undefined,
    EmailChangeControllerRequestError,
    EmailChangeControllerRequestVariables
  >({
    mutationFn: (variables: EmailChangeControllerRequestVariables) =>
      fetchEmailChangeControllerRequest({ ...fetcherOptions, ...variables }),
    ...options,
  });
};

export type QueryOperation =
  | {
      path: "/user";
      operationId: "userControllerFindOne";
      variables: UserControllerFindOneVariables;
    }
  | {
      path: "/organizations/{orgname}";
      operationId: "organizationsControllerFindOne";
      variables: OrganizationsControllerFindOneVariables;
    }
  | {
      path: "/organizations/{orgname}/api-tokens";
      operationId: "apiTokensControllerFindAll";
      variables: ApiTokensControllerFindAllVariables;
    }
  | {
      path: "/organizations/{orgname}/api-tokens/{id}";
      operationId: "apiTokensControllerFindOne";
      variables: ApiTokensControllerFindOneVariables;
    }
  | {
      path: "/organizations/{orgname}/members";
      operationId: "membersControllerFindAll";
      variables: MembersControllerFindAllVariables;
    }
  | {
      path: "/organizations/{orgname}/chatbots/{chatbotId}/threads";
      operationId: "threadsControllerFindAll";
      variables: ThreadsControllerFindAllVariables;
    }
  | {
      path: "/organizations/{orgname}/chatbots/{chatbotId}/threads/{threadId}";
      operationId: "threadsControllerFindOne";
      variables: ThreadsControllerFindOneVariables;
    }
  | {
      path: "/organizations/{orgname}/storage/items";
      operationId: "storageControllerListDirectory";
      variables: StorageControllerListDirectoryVariables;
    }
  | {
      path: "/organizations/{orgname}/chatbots";
      operationId: "chatbotsControllerFindAll";
      variables: ChatbotsControllerFindAllVariables;
    }
  | {
      path: "/organizations/{orgname}/chatbots/{chatbotId}";
      operationId: "chatbotsControllerFindOne";
      variables: ChatbotsControllerFindOneVariables;
    }
  | {
      path: "/organizations/{orgname}/chatbots/{chatbotId}/threads/{threadId}/messages";
      operationId: "messagesControllerFindAll";
      variables: MessagesControllerFindAllVariables;
    }
  | {
      path: "/organizations/{orgname}/content";
      operationId: "contentControllerFindAll";
      variables: ContentControllerFindAllVariables;
    }
  | {
      path: "/organizations/{orgname}/content/{contentId}";
      operationId: "contentControllerFindOne";
      variables: ContentControllerFindOneVariables;
    }
  | {
      path: "/organizations/{orgname}/jobs";
      operationId: "jobsControllerFindAll";
      variables: JobsControllerFindAllVariables;
    }
  | {
      path: "/organizations/{orgname}/jobs/{id}";
      operationId: "jobsControllerFindOne";
      variables: JobsControllerFindOneVariables;
    }
  | {
      path: "/organizations/{orgname}/content/{contentId}/vector-records";
      operationId: "vectorRecordControllerFindAll";
      variables: VectorRecordControllerFindAllVariables;
    }
  | {
      path: "/organizations/{orgname}/content/{contentId}/vector-records/{vectorRecordId}";
      operationId: "vectorRecordControllerFindOne";
      variables: VectorRecordControllerFindOneVariables;
    };
