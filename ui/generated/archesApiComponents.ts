/**
 * Generated by @openapi-codegen
 *
 * @version v1
 */
import * as reactQuery from "@tanstack/react-query";
import { useArchesApiContext, ArchesApiContext } from "./archesApiContext";
import type * as Fetcher from "./archesApiFetcher";
import { archesApiFetch } from "./archesApiFetcher";
import type * as Schemas from "./archesApiSchemas";

export type PipelinesControllerCreatePathParams = {
  orgname: string;
};

export type PipelinesControllerCreateError = Fetcher.ErrorWrapper<undefined>;

export type PipelinesControllerCreateVariables = {
  body: Schemas.CreatePipelineDto;
  pathParams: PipelinesControllerCreatePathParams;
} & ArchesApiContext["fetcherOptions"];

/**
 * Create a new pipeline. ADMIN ONLY.
 */
export const fetchPipelinesControllerCreate = (
  variables: PipelinesControllerCreateVariables,
  signal?: AbortSignal,
) =>
  archesApiFetch<
    Schemas.PipelineEntity,
    PipelinesControllerCreateError,
    Schemas.CreatePipelineDto,
    {},
    {},
    PipelinesControllerCreatePathParams
  >({
    url: "/organizations/{orgname}/pipelines",
    method: "post",
    ...variables,
    signal,
  });

/**
 * Create a new pipeline. ADMIN ONLY.
 */
export const usePipelinesControllerCreate = (
  options?: Omit<
    reactQuery.UseMutationOptions<
      Schemas.PipelineEntity,
      PipelinesControllerCreateError,
      PipelinesControllerCreateVariables
    >,
    "mutationFn"
  >,
) => {
  const { fetcherOptions } = useArchesApiContext();
  return reactQuery.useMutation<
    Schemas.PipelineEntity,
    PipelinesControllerCreateError,
    PipelinesControllerCreateVariables
  >({
    mutationFn: (variables: PipelinesControllerCreateVariables) =>
      fetchPipelinesControllerCreate({ ...fetcherOptions, ...variables }),
    ...options,
  });
};

export type PipelinesControllerFindAllPathParams = {
  orgname: string;
};

export type PipelinesControllerFindAllQueryParams = {
  /**
   * The end date to search to
   */
  endDate?: string;
  /**
   * Filter fields and values
   */
  filters?: Schemas.FilterField[];
  /**
   * The limit of the number of results returned
   *
   * @default 10
   */
  limit?: number;
  /**
   * The offset of the returned results
   *
   * @default 0
   */
  offset?: number;
  /**
   * The field to sort the results by
   *
   * @default createdAt
   */
  sortBy?: string;
  /**
   * The direction to sort the results by
   *
   * @default desc
   */
  sortDirection?: "asc" | "desc";
  /**
   * The start date to search from
   */
  startDate?: string;
};

export type PipelinesControllerFindAllError = Fetcher.ErrorWrapper<undefined>;

export type PipelinesControllerFindAllResponse = Schemas.PaginatedDto & {
  results?: Schemas.PipelineEntity[];
};

export type PipelinesControllerFindAllVariables = {
  pathParams: PipelinesControllerFindAllPathParams;
  queryParams?: PipelinesControllerFindAllQueryParams;
} & ArchesApiContext["fetcherOptions"];

/**
 * Get all pipelines. ADMIN ONLY.
 */
export const fetchPipelinesControllerFindAll = (
  variables: PipelinesControllerFindAllVariables,
  signal?: AbortSignal,
) =>
  archesApiFetch<
    PipelinesControllerFindAllResponse,
    PipelinesControllerFindAllError,
    undefined,
    {},
    PipelinesControllerFindAllQueryParams,
    PipelinesControllerFindAllPathParams
  >({
    url: "/organizations/{orgname}/pipelines",
    method: "get",
    ...variables,
    signal,
  });

/**
 * Get all pipelines. ADMIN ONLY.
 */
export const usePipelinesControllerFindAll = <
  TData = PipelinesControllerFindAllResponse,
>(
  variables: PipelinesControllerFindAllVariables,
  options?: Omit<
    reactQuery.UseQueryOptions<
      PipelinesControllerFindAllResponse,
      PipelinesControllerFindAllError,
      TData
    >,
    "queryKey" | "queryFn" | "initialData"
  >,
) => {
  const { fetcherOptions, queryOptions, queryKeyFn } =
    useArchesApiContext(options);
  return reactQuery.useQuery<
    PipelinesControllerFindAllResponse,
    PipelinesControllerFindAllError,
    TData
  >({
    queryKey: queryKeyFn({
      path: "/organizations/{orgname}/pipelines",
      operationId: "pipelinesControllerFindAll",
      variables,
    }),
    queryFn: ({ signal }) =>
      fetchPipelinesControllerFindAll(
        { ...fetcherOptions, ...variables },
        signal,
      ),
    ...options,
    ...queryOptions,
  });
};

export type PipelinesControllerCreatePipelineRunPathParams = {
  orgname: string;
  pipelineId: string;
};

export type PipelinesControllerCreatePipelineRunError =
  Fetcher.ErrorWrapper<undefined>;

export type PipelinesControllerCreatePipelineRunVariables = {
  body?: Schemas.CreatePipelineRunDto;
  pathParams: PipelinesControllerCreatePipelineRunPathParams;
} & ArchesApiContext["fetcherOptions"];

/**
 * Create a new pipeline run. ADMIN ONLY.
 */
export const fetchPipelinesControllerCreatePipelineRun = (
  variables: PipelinesControllerCreatePipelineRunVariables,
  signal?: AbortSignal,
) =>
  archesApiFetch<
    Schemas.PipelineRunEntity,
    PipelinesControllerCreatePipelineRunError,
    Schemas.CreatePipelineRunDto,
    {},
    {},
    PipelinesControllerCreatePipelineRunPathParams
  >({
    url: "/organizations/{orgname}/pipelines/{pipelineId}/runs",
    method: "post",
    ...variables,
    signal,
  });

/**
 * Create a new pipeline run. ADMIN ONLY.
 */
export const usePipelinesControllerCreatePipelineRun = (
  options?: Omit<
    reactQuery.UseMutationOptions<
      Schemas.PipelineRunEntity,
      PipelinesControllerCreatePipelineRunError,
      PipelinesControllerCreatePipelineRunVariables
    >,
    "mutationFn"
  >,
) => {
  const { fetcherOptions } = useArchesApiContext();
  return reactQuery.useMutation<
    Schemas.PipelineRunEntity,
    PipelinesControllerCreatePipelineRunError,
    PipelinesControllerCreatePipelineRunVariables
  >({
    mutationFn: (variables: PipelinesControllerCreatePipelineRunVariables) =>
      fetchPipelinesControllerCreatePipelineRun({
        ...fetcherOptions,
        ...variables,
      }),
    ...options,
  });
};

export type PipelinesControllerFindOnePathParams = {
  orgname: string;
  pipelineId: string;
};

export type PipelinesControllerFindOneError = Fetcher.ErrorWrapper<undefined>;

export type PipelinesControllerFindOneVariables = {
  pathParams: PipelinesControllerFindOnePathParams;
} & ArchesApiContext["fetcherOptions"];

/**
 * Get a pipeline. ADMIN ONLY.
 */
export const fetchPipelinesControllerFindOne = (
  variables: PipelinesControllerFindOneVariables,
  signal?: AbortSignal,
) =>
  archesApiFetch<
    Schemas.PipelineEntity,
    PipelinesControllerFindOneError,
    undefined,
    {},
    {},
    PipelinesControllerFindOnePathParams
  >({
    url: "/organizations/{orgname}/pipelines/{pipelineId}",
    method: "get",
    ...variables,
    signal,
  });

/**
 * Get a pipeline. ADMIN ONLY.
 */
export const usePipelinesControllerFindOne = <TData = Schemas.PipelineEntity,>(
  variables: PipelinesControllerFindOneVariables,
  options?: Omit<
    reactQuery.UseQueryOptions<
      Schemas.PipelineEntity,
      PipelinesControllerFindOneError,
      TData
    >,
    "queryKey" | "queryFn" | "initialData"
  >,
) => {
  const { fetcherOptions, queryOptions, queryKeyFn } =
    useArchesApiContext(options);
  return reactQuery.useQuery<
    Schemas.PipelineEntity,
    PipelinesControllerFindOneError,
    TData
  >({
    queryKey: queryKeyFn({
      path: "/organizations/{orgname}/pipelines/{pipelineId}",
      operationId: "pipelinesControllerFindOne",
      variables,
    }),
    queryFn: ({ signal }) =>
      fetchPipelinesControllerFindOne(
        { ...fetcherOptions, ...variables },
        signal,
      ),
    ...options,
    ...queryOptions,
  });
};

export type PipelinesControllerRemovePathParams = {
  orgname: string;
  pipelineId: string;
};

export type PipelinesControllerRemoveError = Fetcher.ErrorWrapper<undefined>;

export type PipelinesControllerRemoveVariables = {
  pathParams: PipelinesControllerRemovePathParams;
} & ArchesApiContext["fetcherOptions"];

/**
 * Delete a pipeline. ADMIN ONLY.
 */
export const fetchPipelinesControllerRemove = (
  variables: PipelinesControllerRemoveVariables,
  signal?: AbortSignal,
) =>
  archesApiFetch<
    undefined,
    PipelinesControllerRemoveError,
    undefined,
    {},
    {},
    PipelinesControllerRemovePathParams
  >({
    url: "/organizations/{orgname}/pipelines/{pipelineId}",
    method: "delete",
    ...variables,
    signal,
  });

/**
 * Delete a pipeline. ADMIN ONLY.
 */
export const usePipelinesControllerRemove = (
  options?: Omit<
    reactQuery.UseMutationOptions<
      undefined,
      PipelinesControllerRemoveError,
      PipelinesControllerRemoveVariables
    >,
    "mutationFn"
  >,
) => {
  const { fetcherOptions } = useArchesApiContext();
  return reactQuery.useMutation<
    undefined,
    PipelinesControllerRemoveError,
    PipelinesControllerRemoveVariables
  >({
    mutationFn: (variables: PipelinesControllerRemoveVariables) =>
      fetchPipelinesControllerRemove({ ...fetcherOptions, ...variables }),
    ...options,
  });
};

export type PipelinesControllerUpdatePathParams = {
  orgname: string;
  pipelineId: string;
};

export type PipelinesControllerUpdateError = Fetcher.ErrorWrapper<undefined>;

export type PipelinesControllerUpdateVariables = {
  body?: Schemas.UpdatePipelineDto;
  pathParams: PipelinesControllerUpdatePathParams;
} & ArchesApiContext["fetcherOptions"];

/**
 * Update a pipeline. ADMIN ONLY.
 */
export const fetchPipelinesControllerUpdate = (
  variables: PipelinesControllerUpdateVariables,
  signal?: AbortSignal,
) =>
  archesApiFetch<
    Schemas.PipelineEntity,
    PipelinesControllerUpdateError,
    Schemas.UpdatePipelineDto,
    {},
    {},
    PipelinesControllerUpdatePathParams
  >({
    url: "/organizations/{orgname}/pipelines/{pipelineId}",
    method: "patch",
    ...variables,
    signal,
  });

/**
 * Update a pipeline. ADMIN ONLY.
 */
export const usePipelinesControllerUpdate = (
  options?: Omit<
    reactQuery.UseMutationOptions<
      Schemas.PipelineEntity,
      PipelinesControllerUpdateError,
      PipelinesControllerUpdateVariables
    >,
    "mutationFn"
  >,
) => {
  const { fetcherOptions } = useArchesApiContext();
  return reactQuery.useMutation<
    Schemas.PipelineEntity,
    PipelinesControllerUpdateError,
    PipelinesControllerUpdateVariables
  >({
    mutationFn: (variables: PipelinesControllerUpdateVariables) =>
      fetchPipelinesControllerUpdate({ ...fetcherOptions, ...variables }),
    ...options,
  });
};

export type AuthControllerEmailChangeConfirmError =
  Fetcher.ErrorWrapper<undefined>;

export type AuthControllerEmailChangeConfirmVariables = {
  body: Schemas.ConfirmationTokenDto;
} & ArchesApiContext["fetcherOptions"];

/**
 * This endpoint will confirm your e-mail change with a token
 */
export const fetchAuthControllerEmailChangeConfirm = (
  variables: AuthControllerEmailChangeConfirmVariables,
  signal?: AbortSignal,
) =>
  archesApiFetch<
    Schemas.TokenDto,
    AuthControllerEmailChangeConfirmError,
    Schemas.ConfirmationTokenDto,
    {},
    {},
    {}
  >({
    url: "/auth/email-change/confirm",
    method: "post",
    ...variables,
    signal,
  });

/**
 * This endpoint will confirm your e-mail change with a token
 */
export const useAuthControllerEmailChangeConfirm = (
  options?: Omit<
    reactQuery.UseMutationOptions<
      Schemas.TokenDto,
      AuthControllerEmailChangeConfirmError,
      AuthControllerEmailChangeConfirmVariables
    >,
    "mutationFn"
  >,
) => {
  const { fetcherOptions } = useArchesApiContext();
  return reactQuery.useMutation<
    Schemas.TokenDto,
    AuthControllerEmailChangeConfirmError,
    AuthControllerEmailChangeConfirmVariables
  >({
    mutationFn: (variables: AuthControllerEmailChangeConfirmVariables) =>
      fetchAuthControllerEmailChangeConfirm({
        ...fetcherOptions,
        ...variables,
      }),
    ...options,
  });
};

export type AuthControllerEmailChangeRequestError =
  Fetcher.ErrorWrapper<undefined>;

export type AuthControllerEmailChangeRequestVariables = {
  body: Schemas.EmailRequestDto;
} & ArchesApiContext["fetcherOptions"];

/**
 * This endpoint will request your e-mail change with a token
 */
export const fetchAuthControllerEmailChangeRequest = (
  variables: AuthControllerEmailChangeRequestVariables,
  signal?: AbortSignal,
) =>
  archesApiFetch<
    undefined,
    AuthControllerEmailChangeRequestError,
    Schemas.EmailRequestDto,
    {},
    {},
    {}
  >({
    url: "/auth/email-change/request",
    method: "post",
    ...variables,
    signal,
  });

/**
 * This endpoint will request your e-mail change with a token
 */
export const useAuthControllerEmailChangeRequest = (
  options?: Omit<
    reactQuery.UseMutationOptions<
      undefined,
      AuthControllerEmailChangeRequestError,
      AuthControllerEmailChangeRequestVariables
    >,
    "mutationFn"
  >,
) => {
  const { fetcherOptions } = useArchesApiContext();
  return reactQuery.useMutation<
    undefined,
    AuthControllerEmailChangeRequestError,
    AuthControllerEmailChangeRequestVariables
  >({
    mutationFn: (variables: AuthControllerEmailChangeRequestVariables) =>
      fetchAuthControllerEmailChangeRequest({
        ...fetcherOptions,
        ...variables,
      }),
    ...options,
  });
};

export type AuthControllerEmailVerificationConfirmError =
  Fetcher.ErrorWrapper<undefined>;

export type AuthControllerEmailVerificationConfirmVariables = {
  body: Schemas.ConfirmationTokenDto;
} & ArchesApiContext["fetcherOptions"];

/**
 * This endpoint will confirm your e-mail with a token
 */
export const fetchAuthControllerEmailVerificationConfirm = (
  variables: AuthControllerEmailVerificationConfirmVariables,
  signal?: AbortSignal,
) =>
  archesApiFetch<
    Schemas.TokenDto,
    AuthControllerEmailVerificationConfirmError,
    Schemas.ConfirmationTokenDto,
    {},
    {},
    {}
  >({
    url: "/auth/email-verification/confirm",
    method: "post",
    ...variables,
    signal,
  });

/**
 * This endpoint will confirm your e-mail with a token
 */
export const useAuthControllerEmailVerificationConfirm = (
  options?: Omit<
    reactQuery.UseMutationOptions<
      Schemas.TokenDto,
      AuthControllerEmailVerificationConfirmError,
      AuthControllerEmailVerificationConfirmVariables
    >,
    "mutationFn"
  >,
) => {
  const { fetcherOptions } = useArchesApiContext();
  return reactQuery.useMutation<
    Schemas.TokenDto,
    AuthControllerEmailVerificationConfirmError,
    AuthControllerEmailVerificationConfirmVariables
  >({
    mutationFn: (variables: AuthControllerEmailVerificationConfirmVariables) =>
      fetchAuthControllerEmailVerificationConfirm({
        ...fetcherOptions,
        ...variables,
      }),
    ...options,
  });
};

export type AuthControllerEmailVerificationRequestError =
  Fetcher.ErrorWrapper<undefined>;

export type AuthControllerEmailVerificationRequestVariables =
  ArchesApiContext["fetcherOptions"];

/**
 * This endpoint will send an e-mail verification link to you. ADMIN ONLY.
 */
export const fetchAuthControllerEmailVerificationRequest = (
  variables: AuthControllerEmailVerificationRequestVariables,
  signal?: AbortSignal,
) =>
  archesApiFetch<
    undefined,
    AuthControllerEmailVerificationRequestError,
    undefined,
    {},
    {},
    {}
  >({
    url: "/auth/email-verification/request",
    method: "post",
    ...variables,
    signal,
  });

/**
 * This endpoint will send an e-mail verification link to you. ADMIN ONLY.
 */
export const useAuthControllerEmailVerificationRequest = (
  options?: Omit<
    reactQuery.UseMutationOptions<
      undefined,
      AuthControllerEmailVerificationRequestError,
      AuthControllerEmailVerificationRequestVariables
    >,
    "mutationFn"
  >,
) => {
  const { fetcherOptions } = useArchesApiContext();
  return reactQuery.useMutation<
    undefined,
    AuthControllerEmailVerificationRequestError,
    AuthControllerEmailVerificationRequestVariables
  >({
    mutationFn: (variables: AuthControllerEmailVerificationRequestVariables) =>
      fetchAuthControllerEmailVerificationRequest({
        ...fetcherOptions,
        ...variables,
      }),
    ...options,
  });
};

export type AuthControllerLoginError = Fetcher.ErrorWrapper<undefined>;

export type AuthControllerLoginVariables = {
  body: Schemas.LoginDto;
} & ArchesApiContext["fetcherOptions"];

export const fetchAuthControllerLogin = (
  variables: AuthControllerLoginVariables,
  signal?: AbortSignal,
) =>
  archesApiFetch<
    Schemas.TokenDto,
    AuthControllerLoginError,
    Schemas.LoginDto,
    {},
    {},
    {}
  >({ url: "/auth/login", method: "post", ...variables, signal });

export const useAuthControllerLogin = (
  options?: Omit<
    reactQuery.UseMutationOptions<
      Schemas.TokenDto,
      AuthControllerLoginError,
      AuthControllerLoginVariables
    >,
    "mutationFn"
  >,
) => {
  const { fetcherOptions } = useArchesApiContext();
  return reactQuery.useMutation<
    Schemas.TokenDto,
    AuthControllerLoginError,
    AuthControllerLoginVariables
  >({
    mutationFn: (variables: AuthControllerLoginVariables) =>
      fetchAuthControllerLogin({ ...fetcherOptions, ...variables }),
    ...options,
  });
};

export type AuthControllerPasswordResetConfirmError =
  Fetcher.ErrorWrapper<undefined>;

export type AuthControllerPasswordResetConfirmVariables = {
  body: Schemas.ConfirmationTokenWithNewPasswordDto;
} & ArchesApiContext["fetcherOptions"];

/**
 * This endpoint will confirm your password change with a token
 */
export const fetchAuthControllerPasswordResetConfirm = (
  variables: AuthControllerPasswordResetConfirmVariables,
  signal?: AbortSignal,
) =>
  archesApiFetch<
    Schemas.TokenDto,
    AuthControllerPasswordResetConfirmError,
    Schemas.ConfirmationTokenWithNewPasswordDto,
    {},
    {},
    {}
  >({
    url: "/auth/password-reset/confirm",
    method: "post",
    ...variables,
    signal,
  });

/**
 * This endpoint will confirm your password change with a token
 */
export const useAuthControllerPasswordResetConfirm = (
  options?: Omit<
    reactQuery.UseMutationOptions<
      Schemas.TokenDto,
      AuthControllerPasswordResetConfirmError,
      AuthControllerPasswordResetConfirmVariables
    >,
    "mutationFn"
  >,
) => {
  const { fetcherOptions } = useArchesApiContext();
  return reactQuery.useMutation<
    Schemas.TokenDto,
    AuthControllerPasswordResetConfirmError,
    AuthControllerPasswordResetConfirmVariables
  >({
    mutationFn: (variables: AuthControllerPasswordResetConfirmVariables) =>
      fetchAuthControllerPasswordResetConfirm({
        ...fetcherOptions,
        ...variables,
      }),
    ...options,
  });
};

export type AuthControllerPasswordResetRequestError =
  Fetcher.ErrorWrapper<undefined>;

export type AuthControllerPasswordResetRequestVariables = {
  body: Schemas.EmailRequestDto;
} & ArchesApiContext["fetcherOptions"];

/**
 * This endpoint will request a password reset link
 */
export const fetchAuthControllerPasswordResetRequest = (
  variables: AuthControllerPasswordResetRequestVariables,
  signal?: AbortSignal,
) =>
  archesApiFetch<
    undefined,
    AuthControllerPasswordResetRequestError,
    Schemas.EmailRequestDto,
    {},
    {},
    {}
  >({
    url: "/auth/password-reset/request",
    method: "post",
    ...variables,
    signal,
  });

/**
 * This endpoint will request a password reset link
 */
export const useAuthControllerPasswordResetRequest = (
  options?: Omit<
    reactQuery.UseMutationOptions<
      undefined,
      AuthControllerPasswordResetRequestError,
      AuthControllerPasswordResetRequestVariables
    >,
    "mutationFn"
  >,
) => {
  const { fetcherOptions } = useArchesApiContext();
  return reactQuery.useMutation<
    undefined,
    AuthControllerPasswordResetRequestError,
    AuthControllerPasswordResetRequestVariables
  >({
    mutationFn: (variables: AuthControllerPasswordResetRequestVariables) =>
      fetchAuthControllerPasswordResetRequest({
        ...fetcherOptions,
        ...variables,
      }),
    ...options,
  });
};

export type AuthControllerRefreshTokenError = Fetcher.ErrorWrapper<undefined>;

export type AuthControllerRefreshTokenVariables =
  ArchesApiContext["fetcherOptions"];

export const fetchAuthControllerRefreshToken = (
  variables: AuthControllerRefreshTokenVariables,
  signal?: AbortSignal,
) =>
  archesApiFetch<
    Schemas.TokenDto,
    AuthControllerRefreshTokenError,
    undefined,
    {},
    {},
    {}
  >({ url: "/auth/refresh-token", method: "post", ...variables, signal });

export const useAuthControllerRefreshToken = (
  options?: Omit<
    reactQuery.UseMutationOptions<
      Schemas.TokenDto,
      AuthControllerRefreshTokenError,
      AuthControllerRefreshTokenVariables
    >,
    "mutationFn"
  >,
) => {
  const { fetcherOptions } = useArchesApiContext();
  return reactQuery.useMutation<
    Schemas.TokenDto,
    AuthControllerRefreshTokenError,
    AuthControllerRefreshTokenVariables
  >({
    mutationFn: (variables: AuthControllerRefreshTokenVariables) =>
      fetchAuthControllerRefreshToken({ ...fetcherOptions, ...variables }),
    ...options,
  });
};

export type AuthControllerRegisterError = Fetcher.ErrorWrapper<undefined>;

export type AuthControllerRegisterVariables = {
  body: Schemas.RegisterDto;
} & ArchesApiContext["fetcherOptions"];

/**
 * This endpoint will register a new account and return a JWT token which should be provided in your auth headers
 */
export const fetchAuthControllerRegister = (
  variables: AuthControllerRegisterVariables,
  signal?: AbortSignal,
) =>
  archesApiFetch<
    Schemas.TokenDto,
    AuthControllerRegisterError,
    Schemas.RegisterDto,
    {},
    {},
    {}
  >({ url: "/auth/register", method: "post", ...variables, signal });

/**
 * This endpoint will register a new account and return a JWT token which should be provided in your auth headers
 */
export const useAuthControllerRegister = (
  options?: Omit<
    reactQuery.UseMutationOptions<
      Schemas.TokenDto,
      AuthControllerRegisterError,
      AuthControllerRegisterVariables
    >,
    "mutationFn"
  >,
) => {
  const { fetcherOptions } = useArchesApiContext();
  return reactQuery.useMutation<
    Schemas.TokenDto,
    AuthControllerRegisterError,
    AuthControllerRegisterVariables
  >({
    mutationFn: (variables: AuthControllerRegisterVariables) =>
      fetchAuthControllerRegister({ ...fetcherOptions, ...variables }),
    ...options,
  });
};

export type UserControllerDeactivateError = Fetcher.ErrorWrapper<undefined>;

export type UserControllerDeactivateVariables =
  ArchesApiContext["fetcherOptions"];

export const fetchUserControllerDeactivate = (
  variables: UserControllerDeactivateVariables,
  signal?: AbortSignal,
) =>
  archesApiFetch<
    undefined,
    UserControllerDeactivateError,
    undefined,
    {},
    {},
    {}
  >({ url: "/user/deactivate", method: "post", ...variables, signal });

export const useUserControllerDeactivate = (
  options?: Omit<
    reactQuery.UseMutationOptions<
      undefined,
      UserControllerDeactivateError,
      UserControllerDeactivateVariables
    >,
    "mutationFn"
  >,
) => {
  const { fetcherOptions } = useArchesApiContext();
  return reactQuery.useMutation<
    undefined,
    UserControllerDeactivateError,
    UserControllerDeactivateVariables
  >({
    mutationFn: (variables: UserControllerDeactivateVariables) =>
      fetchUserControllerDeactivate({ ...fetcherOptions, ...variables }),
    ...options,
  });
};

export type UserControllerFindOneError = Fetcher.ErrorWrapper<undefined>;

export type UserControllerFindOneVariables = ArchesApiContext["fetcherOptions"];

/**
 * Get a user. ADMIN ONLY.
 */
export const fetchUserControllerFindOne = (
  variables: UserControllerFindOneVariables,
  signal?: AbortSignal,
) =>
  archesApiFetch<
    Schemas.UserEntity,
    UserControllerFindOneError,
    undefined,
    {},
    {},
    {}
  >({ url: "/user", method: "get", ...variables, signal });

/**
 * Get a user. ADMIN ONLY.
 */
export const useUserControllerFindOne = <TData = Schemas.UserEntity,>(
  variables: UserControllerFindOneVariables,
  options?: Omit<
    reactQuery.UseQueryOptions<
      Schemas.UserEntity,
      UserControllerFindOneError,
      TData
    >,
    "queryKey" | "queryFn" | "initialData"
  >,
) => {
  const { fetcherOptions, queryOptions, queryKeyFn } =
    useArchesApiContext(options);
  return reactQuery.useQuery<
    Schemas.UserEntity,
    UserControllerFindOneError,
    TData
  >({
    queryKey: queryKeyFn({
      path: "/user",
      operationId: "userControllerFindOne",
      variables,
    }),
    queryFn: ({ signal }) =>
      fetchUserControllerFindOne({ ...fetcherOptions, ...variables }, signal),
    ...options,
    ...queryOptions,
  });
};

export type UserControllerUpdateError = Fetcher.ErrorWrapper<undefined>;

export type UserControllerUpdateVariables = {
  body?: Schemas.UpdateUserDto;
} & ArchesApiContext["fetcherOptions"];

/**
 * Update a user. ADMIN ONLY.
 */
export const fetchUserControllerUpdate = (
  variables: UserControllerUpdateVariables,
  signal?: AbortSignal,
) =>
  archesApiFetch<
    Schemas.UserEntity,
    UserControllerUpdateError,
    Schemas.UpdateUserDto,
    {},
    {},
    {}
  >({ url: "/user", method: "patch", ...variables, signal });

/**
 * Update a user. ADMIN ONLY.
 */
export const useUserControllerUpdate = (
  options?: Omit<
    reactQuery.UseMutationOptions<
      Schemas.UserEntity,
      UserControllerUpdateError,
      UserControllerUpdateVariables
    >,
    "mutationFn"
  >,
) => {
  const { fetcherOptions } = useArchesApiContext();
  return reactQuery.useMutation<
    Schemas.UserEntity,
    UserControllerUpdateError,
    UserControllerUpdateVariables
  >({
    mutationFn: (variables: UserControllerUpdateVariables) =>
      fetchUserControllerUpdate({ ...fetcherOptions, ...variables }),
    ...options,
  });
};

export type OrganizationsControllerCreateError =
  Fetcher.ErrorWrapper<undefined>;

export type OrganizationsControllerCreateVariables = {
  body: Schemas.CreateOrganizationDto;
} & ArchesApiContext["fetcherOptions"];

/**
 * Create a new organization. ADMIN ONLY.
 */
export const fetchOrganizationsControllerCreate = (
  variables: OrganizationsControllerCreateVariables,
  signal?: AbortSignal,
) =>
  archesApiFetch<
    Schemas.OrganizationEntity,
    OrganizationsControllerCreateError,
    Schemas.CreateOrganizationDto,
    {},
    {},
    {}
  >({ url: "/organizations", method: "post", ...variables, signal });

/**
 * Create a new organization. ADMIN ONLY.
 */
export const useOrganizationsControllerCreate = (
  options?: Omit<
    reactQuery.UseMutationOptions<
      Schemas.OrganizationEntity,
      OrganizationsControllerCreateError,
      OrganizationsControllerCreateVariables
    >,
    "mutationFn"
  >,
) => {
  const { fetcherOptions } = useArchesApiContext();
  return reactQuery.useMutation<
    Schemas.OrganizationEntity,
    OrganizationsControllerCreateError,
    OrganizationsControllerCreateVariables
  >({
    mutationFn: (variables: OrganizationsControllerCreateVariables) =>
      fetchOrganizationsControllerCreate({ ...fetcherOptions, ...variables }),
    ...options,
  });
};

export type OrganizationsControllerDeletePathParams = {
  orgname: string;
};

export type OrganizationsControllerDeleteError =
  Fetcher.ErrorWrapper<undefined>;

export type OrganizationsControllerDeleteVariables = {
  pathParams: OrganizationsControllerDeletePathParams;
} & ArchesApiContext["fetcherOptions"];

/**
 * Delete a organization. ADMIN ONLY.
 */
export const fetchOrganizationsControllerDelete = (
  variables: OrganizationsControllerDeleteVariables,
  signal?: AbortSignal,
) =>
  archesApiFetch<
    undefined,
    OrganizationsControllerDeleteError,
    undefined,
    {},
    {},
    OrganizationsControllerDeletePathParams
  >({
    url: "/organizations/{orgname}",
    method: "delete",
    ...variables,
    signal,
  });

/**
 * Delete a organization. ADMIN ONLY.
 */
export const useOrganizationsControllerDelete = (
  options?: Omit<
    reactQuery.UseMutationOptions<
      undefined,
      OrganizationsControllerDeleteError,
      OrganizationsControllerDeleteVariables
    >,
    "mutationFn"
  >,
) => {
  const { fetcherOptions } = useArchesApiContext();
  return reactQuery.useMutation<
    undefined,
    OrganizationsControllerDeleteError,
    OrganizationsControllerDeleteVariables
  >({
    mutationFn: (variables: OrganizationsControllerDeleteVariables) =>
      fetchOrganizationsControllerDelete({ ...fetcherOptions, ...variables }),
    ...options,
  });
};

export type OrganizationsControllerFindOnePathParams = {
  orgname: string;
};

export type OrganizationsControllerFindOneError =
  Fetcher.ErrorWrapper<undefined>;

export type OrganizationsControllerFindOneVariables = {
  pathParams: OrganizationsControllerFindOnePathParams;
} & ArchesApiContext["fetcherOptions"];

/**
 * Get a organization. ADMIN ONLY.
 */
export const fetchOrganizationsControllerFindOne = (
  variables: OrganizationsControllerFindOneVariables,
  signal?: AbortSignal,
) =>
  archesApiFetch<
    Schemas.OrganizationEntity,
    OrganizationsControllerFindOneError,
    undefined,
    {},
    {},
    OrganizationsControllerFindOnePathParams
  >({ url: "/organizations/{orgname}", method: "get", ...variables, signal });

/**
 * Get a organization. ADMIN ONLY.
 */
export const useOrganizationsControllerFindOne = <
  TData = Schemas.OrganizationEntity,
>(
  variables: OrganizationsControllerFindOneVariables,
  options?: Omit<
    reactQuery.UseQueryOptions<
      Schemas.OrganizationEntity,
      OrganizationsControllerFindOneError,
      TData
    >,
    "queryKey" | "queryFn" | "initialData"
  >,
) => {
  const { fetcherOptions, queryOptions, queryKeyFn } =
    useArchesApiContext(options);
  return reactQuery.useQuery<
    Schemas.OrganizationEntity,
    OrganizationsControllerFindOneError,
    TData
  >({
    queryKey: queryKeyFn({
      path: "/organizations/{orgname}",
      operationId: "organizationsControllerFindOne",
      variables,
    }),
    queryFn: ({ signal }) =>
      fetchOrganizationsControllerFindOne(
        { ...fetcherOptions, ...variables },
        signal,
      ),
    ...options,
    ...queryOptions,
  });
};

export type OrganizationsControllerUpdatePathParams = {
  orgname: string;
};

export type OrganizationsControllerUpdateError =
  Fetcher.ErrorWrapper<undefined>;

export type OrganizationsControllerUpdateVariables = {
  body: Schemas.UpdateOrganizationDto;
  pathParams: OrganizationsControllerUpdatePathParams;
} & ArchesApiContext["fetcherOptions"];

/**
 * Update a organization. ADMIN ONLY.
 */
export const fetchOrganizationsControllerUpdate = (
  variables: OrganizationsControllerUpdateVariables,
  signal?: AbortSignal,
) =>
  archesApiFetch<
    Schemas.OrganizationEntity,
    OrganizationsControllerUpdateError,
    Schemas.UpdateOrganizationDto,
    {},
    {},
    OrganizationsControllerUpdatePathParams
  >({ url: "/organizations/{orgname}", method: "patch", ...variables, signal });

/**
 * Update a organization. ADMIN ONLY.
 */
export const useOrganizationsControllerUpdate = (
  options?: Omit<
    reactQuery.UseMutationOptions<
      Schemas.OrganizationEntity,
      OrganizationsControllerUpdateError,
      OrganizationsControllerUpdateVariables
    >,
    "mutationFn"
  >,
) => {
  const { fetcherOptions } = useArchesApiContext();
  return reactQuery.useMutation<
    Schemas.OrganizationEntity,
    OrganizationsControllerUpdateError,
    OrganizationsControllerUpdateVariables
  >({
    mutationFn: (variables: OrganizationsControllerUpdateVariables) =>
      fetchOrganizationsControllerUpdate({ ...fetcherOptions, ...variables }),
    ...options,
  });
};

export type BillingControllerCancelSubscriptionPlanPathParams = {
  orgname: string;
};

export type BillingControllerCancelSubscriptionPlanError =
  Fetcher.ErrorWrapper<undefined>;

export type BillingControllerCancelSubscriptionPlanVariables = {
  pathParams: BillingControllerCancelSubscriptionPlanPathParams;
} & ArchesApiContext["fetcherOptions"];

/**
 * Cancel the subscription plan for an organization
 */
export const fetchBillingControllerCancelSubscriptionPlan = (
  variables: BillingControllerCancelSubscriptionPlanVariables,
  signal?: AbortSignal,
) =>
  archesApiFetch<
    undefined,
    BillingControllerCancelSubscriptionPlanError,
    undefined,
    {},
    {},
    BillingControllerCancelSubscriptionPlanPathParams
  >({
    url: "/organizations/{orgname}/billing/subscription/cancel",
    method: "post",
    ...variables,
    signal,
  });

/**
 * Cancel the subscription plan for an organization
 */
export const useBillingControllerCancelSubscriptionPlan = (
  options?: Omit<
    reactQuery.UseMutationOptions<
      undefined,
      BillingControllerCancelSubscriptionPlanError,
      BillingControllerCancelSubscriptionPlanVariables
    >,
    "mutationFn"
  >,
) => {
  const { fetcherOptions } = useArchesApiContext();
  return reactQuery.useMutation<
    undefined,
    BillingControllerCancelSubscriptionPlanError,
    BillingControllerCancelSubscriptionPlanVariables
  >({
    mutationFn: (variables: BillingControllerCancelSubscriptionPlanVariables) =>
      fetchBillingControllerCancelSubscriptionPlan({
        ...fetcherOptions,
        ...variables,
      }),
    ...options,
  });
};

export type BillingControllerChangeSubscriptionPlanPathParams = {
  orgname: string;
};

export type BillingControllerChangeSubscriptionPlanQueryParams = {
  planId: string;
};

export type BillingControllerChangeSubscriptionPlanError =
  Fetcher.ErrorWrapper<undefined>;

export type BillingControllerChangeSubscriptionPlanVariables = {
  pathParams: BillingControllerChangeSubscriptionPlanPathParams;
  queryParams: BillingControllerChangeSubscriptionPlanQueryParams;
} & ArchesApiContext["fetcherOptions"];

/**
 * Switch subscription plan for an organization
 */
export const fetchBillingControllerChangeSubscriptionPlan = (
  variables: BillingControllerChangeSubscriptionPlanVariables,
  signal?: AbortSignal,
) =>
  archesApiFetch<
    undefined,
    BillingControllerChangeSubscriptionPlanError,
    undefined,
    {},
    BillingControllerChangeSubscriptionPlanQueryParams,
    BillingControllerChangeSubscriptionPlanPathParams
  >({
    url: "/organizations/{orgname}/billing/subscription",
    method: "post",
    ...variables,
    signal,
  });

/**
 * Switch subscription plan for an organization
 */
export const useBillingControllerChangeSubscriptionPlan = (
  options?: Omit<
    reactQuery.UseMutationOptions<
      undefined,
      BillingControllerChangeSubscriptionPlanError,
      BillingControllerChangeSubscriptionPlanVariables
    >,
    "mutationFn"
  >,
) => {
  const { fetcherOptions } = useArchesApiContext();
  return reactQuery.useMutation<
    undefined,
    BillingControllerChangeSubscriptionPlanError,
    BillingControllerChangeSubscriptionPlanVariables
  >({
    mutationFn: (variables: BillingControllerChangeSubscriptionPlanVariables) =>
      fetchBillingControllerChangeSubscriptionPlan({
        ...fetcherOptions,
        ...variables,
      }),
    ...options,
  });
};

export type BillingControllerCreateBillingPortalPathParams = {
  orgname: string;
};

export type BillingControllerCreateBillingPortalError =
  Fetcher.ErrorWrapper<undefined>;

export type BillingControllerCreateBillingPortalVariables = {
  pathParams: BillingControllerCreateBillingPortalPathParams;
} & ArchesApiContext["fetcherOptions"];

/**
 * This endpoint will create a billing portal for an organization to edit their subscription and billing information. Only available on archesai.com. ADMIN ONLY.
 */
export const fetchBillingControllerCreateBillingPortal = (
  variables: BillingControllerCreateBillingPortalVariables,
  signal?: AbortSignal,
) =>
  archesApiFetch<
    Schemas.BillingUrlEntity,
    BillingControllerCreateBillingPortalError,
    undefined,
    {},
    {},
    BillingControllerCreateBillingPortalPathParams
  >({
    url: "/organizations/{orgname}/billing/portal",
    method: "post",
    ...variables,
    signal,
  });

/**
 * This endpoint will create a billing portal for an organization to edit their subscription and billing information. Only available on archesai.com. ADMIN ONLY.
 */
export const useBillingControllerCreateBillingPortal = (
  options?: Omit<
    reactQuery.UseMutationOptions<
      Schemas.BillingUrlEntity,
      BillingControllerCreateBillingPortalError,
      BillingControllerCreateBillingPortalVariables
    >,
    "mutationFn"
  >,
) => {
  const { fetcherOptions } = useArchesApiContext();
  return reactQuery.useMutation<
    Schemas.BillingUrlEntity,
    BillingControllerCreateBillingPortalError,
    BillingControllerCreateBillingPortalVariables
  >({
    mutationFn: (variables: BillingControllerCreateBillingPortalVariables) =>
      fetchBillingControllerCreateBillingPortal({
        ...fetcherOptions,
        ...variables,
      }),
    ...options,
  });
};

export type BillingControllerCreateCheckoutSessionPathParams = {
  orgname: string;
};

export type BillingControllerCreateCheckoutSessionQueryParams = {
  planId: string;
};

export type BillingControllerCreateCheckoutSessionError =
  Fetcher.ErrorWrapper<undefined>;

export type BillingControllerCreateCheckoutSessionVariables = {
  pathParams: BillingControllerCreateCheckoutSessionPathParams;
  queryParams: BillingControllerCreateCheckoutSessionQueryParams;
} & ArchesApiContext["fetcherOptions"];

/**
 * This endpoint will create a checkout session for an organization to purchase a subscription or one-time product. Only available on archesai.com. ADMIN ONLY.
 */
export const fetchBillingControllerCreateCheckoutSession = (
  variables: BillingControllerCreateCheckoutSessionVariables,
  signal?: AbortSignal,
) =>
  archesApiFetch<
    Schemas.BillingUrlEntity,
    BillingControllerCreateCheckoutSessionError,
    undefined,
    {},
    BillingControllerCreateCheckoutSessionQueryParams,
    BillingControllerCreateCheckoutSessionPathParams
  >({
    url: "/organizations/{orgname}/billing/checkout",
    method: "post",
    ...variables,
    signal,
  });

/**
 * This endpoint will create a checkout session for an organization to purchase a subscription or one-time product. Only available on archesai.com. ADMIN ONLY.
 */
export const useBillingControllerCreateCheckoutSession = (
  options?: Omit<
    reactQuery.UseMutationOptions<
      Schemas.BillingUrlEntity,
      BillingControllerCreateCheckoutSessionError,
      BillingControllerCreateCheckoutSessionVariables
    >,
    "mutationFn"
  >,
) => {
  const { fetcherOptions } = useArchesApiContext();
  return reactQuery.useMutation<
    Schemas.BillingUrlEntity,
    BillingControllerCreateCheckoutSessionError,
    BillingControllerCreateCheckoutSessionVariables
  >({
    mutationFn: (variables: BillingControllerCreateCheckoutSessionVariables) =>
      fetchBillingControllerCreateCheckoutSession({
        ...fetcherOptions,
        ...variables,
      }),
    ...options,
  });
};

export type BillingControllerGetPlansError = Fetcher.ErrorWrapper<undefined>;

export type BillingControllerGetPlansResponse = Schemas.PlanEntity[];

export type BillingControllerGetPlansVariables =
  ArchesApiContext["fetcherOptions"];

/**
 * Get a list of available billing plans
 */
export const fetchBillingControllerGetPlans = (
  variables: BillingControllerGetPlansVariables,
  signal?: AbortSignal,
) =>
  archesApiFetch<
    BillingControllerGetPlansResponse,
    BillingControllerGetPlansError,
    undefined,
    {},
    {},
    {}
  >({ url: "/plans", method: "get", ...variables, signal });

/**
 * Get a list of available billing plans
 */
export const useBillingControllerGetPlans = <
  TData = BillingControllerGetPlansResponse,
>(
  variables: BillingControllerGetPlansVariables,
  options?: Omit<
    reactQuery.UseQueryOptions<
      BillingControllerGetPlansResponse,
      BillingControllerGetPlansError,
      TData
    >,
    "queryKey" | "queryFn" | "initialData"
  >,
) => {
  const { fetcherOptions, queryOptions, queryKeyFn } =
    useArchesApiContext(options);
  return reactQuery.useQuery<
    BillingControllerGetPlansResponse,
    BillingControllerGetPlansError,
    TData
  >({
    queryKey: queryKeyFn({
      path: "/plans",
      operationId: "billingControllerGetPlans",
      variables,
    }),
    queryFn: ({ signal }) =>
      fetchBillingControllerGetPlans(
        { ...fetcherOptions, ...variables },
        signal,
      ),
    ...options,
    ...queryOptions,
  });
};

export type BillingControllerListPaymentMethodsPathParams = {
  orgname: string;
};

export type BillingControllerListPaymentMethodsError =
  Fetcher.ErrorWrapper<undefined>;

export type BillingControllerListPaymentMethodsResponse =
  Schemas.PaymentMethodEntity[];

export type BillingControllerListPaymentMethodsVariables = {
  pathParams: BillingControllerListPaymentMethodsPathParams;
} & ArchesApiContext["fetcherOptions"];

/**
 * List payment methods for an organization
 */
export const fetchBillingControllerListPaymentMethods = (
  variables: BillingControllerListPaymentMethodsVariables,
  signal?: AbortSignal,
) =>
  archesApiFetch<
    BillingControllerListPaymentMethodsResponse,
    BillingControllerListPaymentMethodsError,
    undefined,
    {},
    {},
    BillingControllerListPaymentMethodsPathParams
  >({
    url: "/organizations/{orgname}/billing/payment-methods",
    method: "get",
    ...variables,
    signal,
  });

/**
 * List payment methods for an organization
 */
export const useBillingControllerListPaymentMethods = <
  TData = BillingControllerListPaymentMethodsResponse,
>(
  variables: BillingControllerListPaymentMethodsVariables,
  options?: Omit<
    reactQuery.UseQueryOptions<
      BillingControllerListPaymentMethodsResponse,
      BillingControllerListPaymentMethodsError,
      TData
    >,
    "queryKey" | "queryFn" | "initialData"
  >,
) => {
  const { fetcherOptions, queryOptions, queryKeyFn } =
    useArchesApiContext(options);
  return reactQuery.useQuery<
    BillingControllerListPaymentMethodsResponse,
    BillingControllerListPaymentMethodsError,
    TData
  >({
    queryKey: queryKeyFn({
      path: "/organizations/{orgname}/billing/payment-methods",
      operationId: "billingControllerListPaymentMethods",
      variables,
    }),
    queryFn: ({ signal }) =>
      fetchBillingControllerListPaymentMethods(
        { ...fetcherOptions, ...variables },
        signal,
      ),
    ...options,
    ...queryOptions,
  });
};

export type BillingControllerRemovePaymentMethodPathParams = {
  orgname: string;
  paymentMethodId: string;
};

export type BillingControllerRemovePaymentMethodError =
  Fetcher.ErrorWrapper<undefined>;

export type BillingControllerRemovePaymentMethodVariables = {
  pathParams: BillingControllerRemovePaymentMethodPathParams;
} & ArchesApiContext["fetcherOptions"];

/**
 * Remove a payment method from an organization
 */
export const fetchBillingControllerRemovePaymentMethod = (
  variables: BillingControllerRemovePaymentMethodVariables,
  signal?: AbortSignal,
) =>
  archesApiFetch<
    undefined,
    BillingControllerRemovePaymentMethodError,
    undefined,
    {},
    {},
    BillingControllerRemovePaymentMethodPathParams
  >({
    url: "/organizations/{orgname}/billing/payment-methods/{paymentMethodId}",
    method: "delete",
    ...variables,
    signal,
  });

/**
 * Remove a payment method from an organization
 */
export const useBillingControllerRemovePaymentMethod = (
  options?: Omit<
    reactQuery.UseMutationOptions<
      undefined,
      BillingControllerRemovePaymentMethodError,
      BillingControllerRemovePaymentMethodVariables
    >,
    "mutationFn"
  >,
) => {
  const { fetcherOptions } = useArchesApiContext();
  return reactQuery.useMutation<
    undefined,
    BillingControllerRemovePaymentMethodError,
    BillingControllerRemovePaymentMethodVariables
  >({
    mutationFn: (variables: BillingControllerRemovePaymentMethodVariables) =>
      fetchBillingControllerRemovePaymentMethod({
        ...fetcherOptions,
        ...variables,
      }),
    ...options,
  });
};

export type ApiTokensControllerCreatePathParams = {
  orgname: string;
};

export type ApiTokensControllerCreateError = Fetcher.ErrorWrapper<undefined>;

export type ApiTokensControllerCreateVariables = {
  body: Schemas.CreateApiTokenDto;
  pathParams: ApiTokensControllerCreatePathParams;
} & ArchesApiContext["fetcherOptions"];

/**
 * Create a new API token. ADMIN ONLY.
 */
export const fetchApiTokensControllerCreate = (
  variables: ApiTokensControllerCreateVariables,
  signal?: AbortSignal,
) =>
  archesApiFetch<
    Schemas.ApiTokenEntity,
    ApiTokensControllerCreateError,
    Schemas.CreateApiTokenDto,
    {},
    {},
    ApiTokensControllerCreatePathParams
  >({
    url: "/organizations/{orgname}/api-tokens",
    method: "post",
    ...variables,
    signal,
  });

/**
 * Create a new API token. ADMIN ONLY.
 */
export const useApiTokensControllerCreate = (
  options?: Omit<
    reactQuery.UseMutationOptions<
      Schemas.ApiTokenEntity,
      ApiTokensControllerCreateError,
      ApiTokensControllerCreateVariables
    >,
    "mutationFn"
  >,
) => {
  const { fetcherOptions } = useArchesApiContext();
  return reactQuery.useMutation<
    Schemas.ApiTokenEntity,
    ApiTokensControllerCreateError,
    ApiTokensControllerCreateVariables
  >({
    mutationFn: (variables: ApiTokensControllerCreateVariables) =>
      fetchApiTokensControllerCreate({ ...fetcherOptions, ...variables }),
    ...options,
  });
};

export type ApiTokensControllerFindAllPathParams = {
  orgname: string;
};

export type ApiTokensControllerFindAllQueryParams = {
  /**
   * The end date to search to
   */
  endDate?: string;
  /**
   * Filter fields and values
   */
  filters?: Schemas.FilterField[];
  /**
   * The limit of the number of results returned
   *
   * @default 10
   */
  limit?: number;
  /**
   * The offset of the returned results
   *
   * @default 0
   */
  offset?: number;
  /**
   * The field to sort the results by
   *
   * @default createdAt
   */
  sortBy?: string;
  /**
   * The direction to sort the results by
   *
   * @default desc
   */
  sortDirection?: "asc" | "desc";
  /**
   * The start date to search from
   */
  startDate?: string;
};

export type ApiTokensControllerFindAllError = Fetcher.ErrorWrapper<undefined>;

export type ApiTokensControllerFindAllResponse = Schemas.PaginatedDto & {
  results?: Schemas.ApiTokenEntity[];
};

export type ApiTokensControllerFindAllVariables = {
  pathParams: ApiTokensControllerFindAllPathParams;
  queryParams?: ApiTokensControllerFindAllQueryParams;
} & ArchesApiContext["fetcherOptions"];

/**
 * Get all API tokens. ADMIN ONLY.
 */
export const fetchApiTokensControllerFindAll = (
  variables: ApiTokensControllerFindAllVariables,
  signal?: AbortSignal,
) =>
  archesApiFetch<
    ApiTokensControllerFindAllResponse,
    ApiTokensControllerFindAllError,
    undefined,
    {},
    ApiTokensControllerFindAllQueryParams,
    ApiTokensControllerFindAllPathParams
  >({
    url: "/organizations/{orgname}/api-tokens",
    method: "get",
    ...variables,
    signal,
  });

/**
 * Get all API tokens. ADMIN ONLY.
 */
export const useApiTokensControllerFindAll = <
  TData = ApiTokensControllerFindAllResponse,
>(
  variables: ApiTokensControllerFindAllVariables,
  options?: Omit<
    reactQuery.UseQueryOptions<
      ApiTokensControllerFindAllResponse,
      ApiTokensControllerFindAllError,
      TData
    >,
    "queryKey" | "queryFn" | "initialData"
  >,
) => {
  const { fetcherOptions, queryOptions, queryKeyFn } =
    useArchesApiContext(options);
  return reactQuery.useQuery<
    ApiTokensControllerFindAllResponse,
    ApiTokensControllerFindAllError,
    TData
  >({
    queryKey: queryKeyFn({
      path: "/organizations/{orgname}/api-tokens",
      operationId: "apiTokensControllerFindAll",
      variables,
    }),
    queryFn: ({ signal }) =>
      fetchApiTokensControllerFindAll(
        { ...fetcherOptions, ...variables },
        signal,
      ),
    ...options,
    ...queryOptions,
  });
};

export type ApiTokensControllerFindOnePathParams = {
  orgname: string;
  id: string;
};

export type ApiTokensControllerFindOneError = Fetcher.ErrorWrapper<undefined>;

export type ApiTokensControllerFindOneVariables = {
  pathParams: ApiTokensControllerFindOnePathParams;
} & ArchesApiContext["fetcherOptions"];

/**
 * Get a API token. ADMIN ONLY.
 */
export const fetchApiTokensControllerFindOne = (
  variables: ApiTokensControllerFindOneVariables,
  signal?: AbortSignal,
) =>
  archesApiFetch<
    Schemas.ApiTokenEntity,
    ApiTokensControllerFindOneError,
    undefined,
    {},
    {},
    ApiTokensControllerFindOnePathParams
  >({
    url: "/organizations/{orgname}/api-tokens/{id}",
    method: "get",
    ...variables,
    signal,
  });

/**
 * Get a API token. ADMIN ONLY.
 */
export const useApiTokensControllerFindOne = <TData = Schemas.ApiTokenEntity,>(
  variables: ApiTokensControllerFindOneVariables,
  options?: Omit<
    reactQuery.UseQueryOptions<
      Schemas.ApiTokenEntity,
      ApiTokensControllerFindOneError,
      TData
    >,
    "queryKey" | "queryFn" | "initialData"
  >,
) => {
  const { fetcherOptions, queryOptions, queryKeyFn } =
    useArchesApiContext(options);
  return reactQuery.useQuery<
    Schemas.ApiTokenEntity,
    ApiTokensControllerFindOneError,
    TData
  >({
    queryKey: queryKeyFn({
      path: "/organizations/{orgname}/api-tokens/{id}",
      operationId: "apiTokensControllerFindOne",
      variables,
    }),
    queryFn: ({ signal }) =>
      fetchApiTokensControllerFindOne(
        { ...fetcherOptions, ...variables },
        signal,
      ),
    ...options,
    ...queryOptions,
  });
};

export type ApiTokensControllerRemovePathParams = {
  orgname: string;
  id: string;
};

export type ApiTokensControllerRemoveError = Fetcher.ErrorWrapper<undefined>;

export type ApiTokensControllerRemoveVariables = {
  pathParams: ApiTokensControllerRemovePathParams;
} & ArchesApiContext["fetcherOptions"];

/**
 * Delete a API token. ADMIN ONLY.
 */
export const fetchApiTokensControllerRemove = (
  variables: ApiTokensControllerRemoveVariables,
  signal?: AbortSignal,
) =>
  archesApiFetch<
    undefined,
    ApiTokensControllerRemoveError,
    undefined,
    {},
    {},
    ApiTokensControllerRemovePathParams
  >({
    url: "/organizations/{orgname}/api-tokens/{id}",
    method: "delete",
    ...variables,
    signal,
  });

/**
 * Delete a API token. ADMIN ONLY.
 */
export const useApiTokensControllerRemove = (
  options?: Omit<
    reactQuery.UseMutationOptions<
      undefined,
      ApiTokensControllerRemoveError,
      ApiTokensControllerRemoveVariables
    >,
    "mutationFn"
  >,
) => {
  const { fetcherOptions } = useArchesApiContext();
  return reactQuery.useMutation<
    undefined,
    ApiTokensControllerRemoveError,
    ApiTokensControllerRemoveVariables
  >({
    mutationFn: (variables: ApiTokensControllerRemoveVariables) =>
      fetchApiTokensControllerRemove({ ...fetcherOptions, ...variables }),
    ...options,
  });
};

export type ApiTokensControllerUpdatePathParams = {
  orgname: string;
  id: string;
};

export type ApiTokensControllerUpdateError = Fetcher.ErrorWrapper<undefined>;

export type ApiTokensControllerUpdateVariables = {
  body?: Schemas.UpdateApiTokenDto;
  pathParams: ApiTokensControllerUpdatePathParams;
} & ArchesApiContext["fetcherOptions"];

/**
 * Update a API token. ADMIN ONLY.
 */
export const fetchApiTokensControllerUpdate = (
  variables: ApiTokensControllerUpdateVariables,
  signal?: AbortSignal,
) =>
  archesApiFetch<
    Schemas.ApiTokenEntity,
    ApiTokensControllerUpdateError,
    Schemas.UpdateApiTokenDto,
    {},
    {},
    ApiTokensControllerUpdatePathParams
  >({
    url: "/organizations/{orgname}/api-tokens/{id}",
    method: "patch",
    ...variables,
    signal,
  });

/**
 * Update a API token. ADMIN ONLY.
 */
export const useApiTokensControllerUpdate = (
  options?: Omit<
    reactQuery.UseMutationOptions<
      Schemas.ApiTokenEntity,
      ApiTokensControllerUpdateError,
      ApiTokensControllerUpdateVariables
    >,
    "mutationFn"
  >,
) => {
  const { fetcherOptions } = useArchesApiContext();
  return reactQuery.useMutation<
    Schemas.ApiTokenEntity,
    ApiTokensControllerUpdateError,
    ApiTokensControllerUpdateVariables
  >({
    mutationFn: (variables: ApiTokensControllerUpdateVariables) =>
      fetchApiTokensControllerUpdate({ ...fetcherOptions, ...variables }),
    ...options,
  });
};

export type ContentControllerCreatePathParams = {
  orgname: string;
};

export type ContentControllerCreateError = Fetcher.ErrorWrapper<undefined>;

export type ContentControllerCreateVariables = {
  body: Schemas.CreateContentDto;
  pathParams: ContentControllerCreatePathParams;
} & ArchesApiContext["fetcherOptions"];

/**
 * Create a new content. ADMIN ONLY.
 */
export const fetchContentControllerCreate = (
  variables: ContentControllerCreateVariables,
  signal?: AbortSignal,
) =>
  archesApiFetch<
    Schemas.ContentEntity,
    ContentControllerCreateError,
    Schemas.CreateContentDto,
    {},
    {},
    ContentControllerCreatePathParams
  >({
    url: "/organizations/{orgname}/content",
    method: "post",
    ...variables,
    signal,
  });

/**
 * Create a new content. ADMIN ONLY.
 */
export const useContentControllerCreate = (
  options?: Omit<
    reactQuery.UseMutationOptions<
      Schemas.ContentEntity,
      ContentControllerCreateError,
      ContentControllerCreateVariables
    >,
    "mutationFn"
  >,
) => {
  const { fetcherOptions } = useArchesApiContext();
  return reactQuery.useMutation<
    Schemas.ContentEntity,
    ContentControllerCreateError,
    ContentControllerCreateVariables
  >({
    mutationFn: (variables: ContentControllerCreateVariables) =>
      fetchContentControllerCreate({ ...fetcherOptions, ...variables }),
    ...options,
  });
};

export type ContentControllerFindAllPathParams = {
  orgname: string;
};

export type ContentControllerFindAllQueryParams = {
  /**
   * The end date to search to
   */
  endDate?: string;
  /**
   * Filter fields and values
   */
  filters?: Schemas.FilterField[];
  /**
   * The limit of the number of results returned
   *
   * @default 10
   */
  limit?: number;
  /**
   * The offset of the returned results
   *
   * @default 0
   */
  offset?: number;
  /**
   * The field to sort the results by
   *
   * @default createdAt
   */
  sortBy?: string;
  /**
   * The direction to sort the results by
   *
   * @default desc
   */
  sortDirection?: "asc" | "desc";
  /**
   * The start date to search from
   */
  startDate?: string;
};

export type ContentControllerFindAllError = Fetcher.ErrorWrapper<undefined>;

export type ContentControllerFindAllResponse = Schemas.PaginatedDto & {
  results?: Schemas.ContentEntity[];
};

export type ContentControllerFindAllVariables = {
  pathParams: ContentControllerFindAllPathParams;
  queryParams?: ContentControllerFindAllQueryParams;
} & ArchesApiContext["fetcherOptions"];

/**
 * Get all contents. ADMIN ONLY.
 */
export const fetchContentControllerFindAll = (
  variables: ContentControllerFindAllVariables,
  signal?: AbortSignal,
) =>
  archesApiFetch<
    ContentControllerFindAllResponse,
    ContentControllerFindAllError,
    undefined,
    {},
    ContentControllerFindAllQueryParams,
    ContentControllerFindAllPathParams
  >({
    url: "/organizations/{orgname}/content",
    method: "get",
    ...variables,
    signal,
  });

/**
 * Get all contents. ADMIN ONLY.
 */
export const useContentControllerFindAll = <
  TData = ContentControllerFindAllResponse,
>(
  variables: ContentControllerFindAllVariables,
  options?: Omit<
    reactQuery.UseQueryOptions<
      ContentControllerFindAllResponse,
      ContentControllerFindAllError,
      TData
    >,
    "queryKey" | "queryFn" | "initialData"
  >,
) => {
  const { fetcherOptions, queryOptions, queryKeyFn } =
    useArchesApiContext(options);
  return reactQuery.useQuery<
    ContentControllerFindAllResponse,
    ContentControllerFindAllError,
    TData
  >({
    queryKey: queryKeyFn({
      path: "/organizations/{orgname}/content",
      operationId: "contentControllerFindAll",
      variables,
    }),
    queryFn: ({ signal }) =>
      fetchContentControllerFindAll(
        { ...fetcherOptions, ...variables },
        signal,
      ),
    ...options,
    ...queryOptions,
  });
};

export type ContentControllerFindOnePathParams = {
  orgname: string;
  contentId: string;
};

export type ContentControllerFindOneError = Fetcher.ErrorWrapper<undefined>;

export type ContentControllerFindOneVariables = {
  pathParams: ContentControllerFindOnePathParams;
} & ArchesApiContext["fetcherOptions"];

/**
 * Get a content. ADMIN ONLY.
 */
export const fetchContentControllerFindOne = (
  variables: ContentControllerFindOneVariables,
  signal?: AbortSignal,
) =>
  archesApiFetch<
    Schemas.ContentEntity,
    ContentControllerFindOneError,
    undefined,
    {},
    {},
    ContentControllerFindOnePathParams
  >({
    url: "/organizations/{orgname}/content/{contentId}",
    method: "get",
    ...variables,
    signal,
  });

/**
 * Get a content. ADMIN ONLY.
 */
export const useContentControllerFindOne = <TData = Schemas.ContentEntity,>(
  variables: ContentControllerFindOneVariables,
  options?: Omit<
    reactQuery.UseQueryOptions<
      Schemas.ContentEntity,
      ContentControllerFindOneError,
      TData
    >,
    "queryKey" | "queryFn" | "initialData"
  >,
) => {
  const { fetcherOptions, queryOptions, queryKeyFn } =
    useArchesApiContext(options);
  return reactQuery.useQuery<
    Schemas.ContentEntity,
    ContentControllerFindOneError,
    TData
  >({
    queryKey: queryKeyFn({
      path: "/organizations/{orgname}/content/{contentId}",
      operationId: "contentControllerFindOne",
      variables,
    }),
    queryFn: ({ signal }) =>
      fetchContentControllerFindOne(
        { ...fetcherOptions, ...variables },
        signal,
      ),
    ...options,
    ...queryOptions,
  });
};

export type ContentControllerRemovePathParams = {
  orgname: string;
  contentId: string;
};

export type ContentControllerRemoveError = Fetcher.ErrorWrapper<undefined>;

export type ContentControllerRemoveVariables = {
  pathParams: ContentControllerRemovePathParams;
} & ArchesApiContext["fetcherOptions"];

/**
 * Delete a content. ADMIN ONLY.
 */
export const fetchContentControllerRemove = (
  variables: ContentControllerRemoveVariables,
  signal?: AbortSignal,
) =>
  archesApiFetch<
    undefined,
    ContentControllerRemoveError,
    undefined,
    {},
    {},
    ContentControllerRemovePathParams
  >({
    url: "/organizations/{orgname}/content/{contentId}",
    method: "delete",
    ...variables,
    signal,
  });

/**
 * Delete a content. ADMIN ONLY.
 */
export const useContentControllerRemove = (
  options?: Omit<
    reactQuery.UseMutationOptions<
      undefined,
      ContentControllerRemoveError,
      ContentControllerRemoveVariables
    >,
    "mutationFn"
  >,
) => {
  const { fetcherOptions } = useArchesApiContext();
  return reactQuery.useMutation<
    undefined,
    ContentControllerRemoveError,
    ContentControllerRemoveVariables
  >({
    mutationFn: (variables: ContentControllerRemoveVariables) =>
      fetchContentControllerRemove({ ...fetcherOptions, ...variables }),
    ...options,
  });
};

export type ContentControllerUpdatePathParams = {
  orgname: string;
  contentId: string;
};

export type ContentControllerUpdateError = Fetcher.ErrorWrapper<undefined>;

export type ContentControllerUpdateVariables = {
  body?: Schemas.UpdateContentDto;
  pathParams: ContentControllerUpdatePathParams;
} & ArchesApiContext["fetcherOptions"];

/**
 * Update a content. ADMIN ONLY.
 */
export const fetchContentControllerUpdate = (
  variables: ContentControllerUpdateVariables,
  signal?: AbortSignal,
) =>
  archesApiFetch<
    Schemas.ContentEntity,
    ContentControllerUpdateError,
    Schemas.UpdateContentDto,
    {},
    {},
    ContentControllerUpdatePathParams
  >({
    url: "/organizations/{orgname}/content/{contentId}",
    method: "patch",
    ...variables,
    signal,
  });

/**
 * Update a content. ADMIN ONLY.
 */
export const useContentControllerUpdate = (
  options?: Omit<
    reactQuery.UseMutationOptions<
      Schemas.ContentEntity,
      ContentControllerUpdateError,
      ContentControllerUpdateVariables
    >,
    "mutationFn"
  >,
) => {
  const { fetcherOptions } = useArchesApiContext();
  return reactQuery.useMutation<
    Schemas.ContentEntity,
    ContentControllerUpdateError,
    ContentControllerUpdateVariables
  >({
    mutationFn: (variables: ContentControllerUpdateVariables) =>
      fetchContentControllerUpdate({ ...fetcherOptions, ...variables }),
    ...options,
  });
};

export type StorageControllerDeletePathParams = {
  orgname: string;
};

export type StorageControllerDeleteQueryParams = {
  path: string;
};

export type StorageControllerDeleteError = Fetcher.ErrorWrapper<undefined>;

export type StorageControllerDeleteVariables = {
  pathParams: StorageControllerDeletePathParams;
  queryParams: StorageControllerDeleteQueryParams;
} & ArchesApiContext["fetcherOptions"];

/**
 * This endpoint will delete a file or directory in the organization's secure storage at the specified path. ADMIN ONLY.
 */
export const fetchStorageControllerDelete = (
  variables: StorageControllerDeleteVariables,
  signal?: AbortSignal,
) =>
  archesApiFetch<
    undefined,
    StorageControllerDeleteError,
    undefined,
    {},
    StorageControllerDeleteQueryParams,
    StorageControllerDeletePathParams
  >({
    url: "/organizations/{orgname}/storage/delete",
    method: "delete",
    ...variables,
    signal,
  });

/**
 * This endpoint will delete a file or directory in the organization's secure storage at the specified path. ADMIN ONLY.
 */
export const useStorageControllerDelete = (
  options?: Omit<
    reactQuery.UseMutationOptions<
      undefined,
      StorageControllerDeleteError,
      StorageControllerDeleteVariables
    >,
    "mutationFn"
  >,
) => {
  const { fetcherOptions } = useArchesApiContext();
  return reactQuery.useMutation<
    undefined,
    StorageControllerDeleteError,
    StorageControllerDeleteVariables
  >({
    mutationFn: (variables: StorageControllerDeleteVariables) =>
      fetchStorageControllerDelete({ ...fetcherOptions, ...variables }),
    ...options,
  });
};

export type StorageControllerGetReadUrlPathParams = {
  orgname: string;
};

export type StorageControllerGetReadUrlError = Fetcher.ErrorWrapper<undefined>;

export type StorageControllerGetReadUrlVariables = {
  body: Schemas.PathDto;
  pathParams: StorageControllerGetReadUrlPathParams;
} & ArchesApiContext["fetcherOptions"];

/**
 * This endpoint will return a url for reading a file in the organization's secure storage. It will be valid for 15 minutes. ADMIN ONLY.
 */
export const fetchStorageControllerGetReadUrl = (
  variables: StorageControllerGetReadUrlVariables,
  signal?: AbortSignal,
) =>
  archesApiFetch<
    Schemas.ReadUrlDto,
    StorageControllerGetReadUrlError,
    Schemas.PathDto,
    {},
    {},
    StorageControllerGetReadUrlPathParams
  >({
    url: "/organizations/{orgname}/storage/read",
    method: "post",
    ...variables,
    signal,
  });

/**
 * This endpoint will return a url for reading a file in the organization's secure storage. It will be valid for 15 minutes. ADMIN ONLY.
 */
export const useStorageControllerGetReadUrl = (
  options?: Omit<
    reactQuery.UseMutationOptions<
      Schemas.ReadUrlDto,
      StorageControllerGetReadUrlError,
      StorageControllerGetReadUrlVariables
    >,
    "mutationFn"
  >,
) => {
  const { fetcherOptions } = useArchesApiContext();
  return reactQuery.useMutation<
    Schemas.ReadUrlDto,
    StorageControllerGetReadUrlError,
    StorageControllerGetReadUrlVariables
  >({
    mutationFn: (variables: StorageControllerGetReadUrlVariables) =>
      fetchStorageControllerGetReadUrl({ ...fetcherOptions, ...variables }),
    ...options,
  });
};

export type StorageControllerGetWriteUrlPathParams = {
  orgname: string;
};

export type StorageControllerGetWriteUrlError = Fetcher.ErrorWrapper<undefined>;

export type StorageControllerGetWriteUrlVariables = {
  body: Schemas.PathDto;
  pathParams: StorageControllerGetWriteUrlPathParams;
} & ArchesApiContext["fetcherOptions"];

/**
 * This endpoint will return a url for writing to a file location in the organization's secure storage. You must write your file to the url returned by this endpoint. If you use is isDir param, it will create a directory instead of a file and you do not need to write to the url. ADMIN ONLY.
 */
export const fetchStorageControllerGetWriteUrl = (
  variables: StorageControllerGetWriteUrlVariables,
  signal?: AbortSignal,
) =>
  archesApiFetch<
    Schemas.WriteUrlDto,
    StorageControllerGetWriteUrlError,
    Schemas.PathDto,
    {},
    {},
    StorageControllerGetWriteUrlPathParams
  >({
    url: "/organizations/{orgname}/storage/write",
    method: "post",
    ...variables,
    signal,
  });

/**
 * This endpoint will return a url for writing to a file location in the organization's secure storage. You must write your file to the url returned by this endpoint. If you use is isDir param, it will create a directory instead of a file and you do not need to write to the url. ADMIN ONLY.
 */
export const useStorageControllerGetWriteUrl = (
  options?: Omit<
    reactQuery.UseMutationOptions<
      Schemas.WriteUrlDto,
      StorageControllerGetWriteUrlError,
      StorageControllerGetWriteUrlVariables
    >,
    "mutationFn"
  >,
) => {
  const { fetcherOptions } = useArchesApiContext();
  return reactQuery.useMutation<
    Schemas.WriteUrlDto,
    StorageControllerGetWriteUrlError,
    StorageControllerGetWriteUrlVariables
  >({
    mutationFn: (variables: StorageControllerGetWriteUrlVariables) =>
      fetchStorageControllerGetWriteUrl({ ...fetcherOptions, ...variables }),
    ...options,
  });
};

export type StorageControllerListDirectoryPathParams = {
  orgname: string;
};

export type StorageControllerListDirectoryQueryParams = {
  path: string;
};

export type StorageControllerListDirectoryError =
  Fetcher.ErrorWrapper<undefined>;

export type StorageControllerListDirectoryResponse = Schemas.StorageItemDto[];

export type StorageControllerListDirectoryVariables = {
  pathParams: StorageControllerListDirectoryPathParams;
  queryParams: StorageControllerListDirectoryQueryParams;
} & ArchesApiContext["fetcherOptions"];

/**
 * This endpoint will return a list of files and directories in the organization's secure storage at the specified path. ADMIN ONLY.
 */
export const fetchStorageControllerListDirectory = (
  variables: StorageControllerListDirectoryVariables,
  signal?: AbortSignal,
) =>
  archesApiFetch<
    StorageControllerListDirectoryResponse,
    StorageControllerListDirectoryError,
    undefined,
    {},
    StorageControllerListDirectoryQueryParams,
    StorageControllerListDirectoryPathParams
  >({
    url: "/organizations/{orgname}/storage/items",
    method: "get",
    ...variables,
    signal,
  });

/**
 * This endpoint will return a list of files and directories in the organization's secure storage at the specified path. ADMIN ONLY.
 */
export const useStorageControllerListDirectory = <
  TData = StorageControllerListDirectoryResponse,
>(
  variables: StorageControllerListDirectoryVariables,
  options?: Omit<
    reactQuery.UseQueryOptions<
      StorageControllerListDirectoryResponse,
      StorageControllerListDirectoryError,
      TData
    >,
    "queryKey" | "queryFn" | "initialData"
  >,
) => {
  const { fetcherOptions, queryOptions, queryKeyFn } =
    useArchesApiContext(options);
  return reactQuery.useQuery<
    StorageControllerListDirectoryResponse,
    StorageControllerListDirectoryError,
    TData
  >({
    queryKey: queryKeyFn({
      path: "/organizations/{orgname}/storage/items",
      operationId: "storageControllerListDirectory",
      variables,
    }),
    queryFn: ({ signal }) =>
      fetchStorageControllerListDirectory(
        { ...fetcherOptions, ...variables },
        signal,
      ),
    ...options,
    ...queryOptions,
  });
};

export type MembersControllerCreatePathParams = {
  orgname: string;
};

export type MembersControllerCreateError = Fetcher.ErrorWrapper<undefined>;

export type MembersControllerCreateVariables = {
  body: Schemas.CreateMemberDto;
  pathParams: MembersControllerCreatePathParams;
} & ArchesApiContext["fetcherOptions"];

/**
 * Create a new member. ADMIN ONLY.
 */
export const fetchMembersControllerCreate = (
  variables: MembersControllerCreateVariables,
  signal?: AbortSignal,
) =>
  archesApiFetch<
    Schemas.MemberEntity,
    MembersControllerCreateError,
    Schemas.CreateMemberDto,
    {},
    {},
    MembersControllerCreatePathParams
  >({
    url: "/organizations/{orgname}/members",
    method: "post",
    ...variables,
    signal,
  });

/**
 * Create a new member. ADMIN ONLY.
 */
export const useMembersControllerCreate = (
  options?: Omit<
    reactQuery.UseMutationOptions<
      Schemas.MemberEntity,
      MembersControllerCreateError,
      MembersControllerCreateVariables
    >,
    "mutationFn"
  >,
) => {
  const { fetcherOptions } = useArchesApiContext();
  return reactQuery.useMutation<
    Schemas.MemberEntity,
    MembersControllerCreateError,
    MembersControllerCreateVariables
  >({
    mutationFn: (variables: MembersControllerCreateVariables) =>
      fetchMembersControllerCreate({ ...fetcherOptions, ...variables }),
    ...options,
  });
};

export type MembersControllerFindAllPathParams = {
  orgname: string;
};

export type MembersControllerFindAllQueryParams = {
  /**
   * The end date to search to
   */
  endDate?: string;
  /**
   * Filter fields and values
   */
  filters?: Schemas.FilterField[];
  /**
   * The limit of the number of results returned
   *
   * @default 10
   */
  limit?: number;
  /**
   * The offset of the returned results
   *
   * @default 0
   */
  offset?: number;
  /**
   * The field to sort the results by
   *
   * @default createdAt
   */
  sortBy?: string;
  /**
   * The direction to sort the results by
   *
   * @default desc
   */
  sortDirection?: "asc" | "desc";
  /**
   * The start date to search from
   */
  startDate?: string;
};

export type MembersControllerFindAllError = Fetcher.ErrorWrapper<undefined>;

export type MembersControllerFindAllResponse = Schemas.PaginatedDto & {
  results?: Schemas.MemberEntity[];
};

export type MembersControllerFindAllVariables = {
  pathParams: MembersControllerFindAllPathParams;
  queryParams?: MembersControllerFindAllQueryParams;
} & ArchesApiContext["fetcherOptions"];

/**
 * Get all members. ADMIN ONLY.
 */
export const fetchMembersControllerFindAll = (
  variables: MembersControllerFindAllVariables,
  signal?: AbortSignal,
) =>
  archesApiFetch<
    MembersControllerFindAllResponse,
    MembersControllerFindAllError,
    undefined,
    {},
    MembersControllerFindAllQueryParams,
    MembersControllerFindAllPathParams
  >({
    url: "/organizations/{orgname}/members",
    method: "get",
    ...variables,
    signal,
  });

/**
 * Get all members. ADMIN ONLY.
 */
export const useMembersControllerFindAll = <
  TData = MembersControllerFindAllResponse,
>(
  variables: MembersControllerFindAllVariables,
  options?: Omit<
    reactQuery.UseQueryOptions<
      MembersControllerFindAllResponse,
      MembersControllerFindAllError,
      TData
    >,
    "queryKey" | "queryFn" | "initialData"
  >,
) => {
  const { fetcherOptions, queryOptions, queryKeyFn } =
    useArchesApiContext(options);
  return reactQuery.useQuery<
    MembersControllerFindAllResponse,
    MembersControllerFindAllError,
    TData
  >({
    queryKey: queryKeyFn({
      path: "/organizations/{orgname}/members",
      operationId: "membersControllerFindAll",
      variables,
    }),
    queryFn: ({ signal }) =>
      fetchMembersControllerFindAll(
        { ...fetcherOptions, ...variables },
        signal,
      ),
    ...options,
    ...queryOptions,
  });
};

export type MembersControllerJoinPathParams = {
  orgname: string;
};

export type MembersControllerJoinError = Fetcher.ErrorWrapper<undefined>;

export type MembersControllerJoinVariables = {
  pathParams: MembersControllerJoinPathParams;
} & ArchesApiContext["fetcherOptions"];

/**
 * Accept invitation to this organization. ADMIN ONLY.
 */
export const fetchMembersControllerJoin = (
  variables: MembersControllerJoinVariables,
  signal?: AbortSignal,
) =>
  archesApiFetch<
    Schemas.MemberEntity,
    MembersControllerJoinError,
    undefined,
    {},
    {},
    MembersControllerJoinPathParams
  >({
    url: "/organizations/{orgname}/members/join",
    method: "post",
    ...variables,
    signal,
  });

/**
 * Accept invitation to this organization. ADMIN ONLY.
 */
export const useMembersControllerJoin = (
  options?: Omit<
    reactQuery.UseMutationOptions<
      Schemas.MemberEntity,
      MembersControllerJoinError,
      MembersControllerJoinVariables
    >,
    "mutationFn"
  >,
) => {
  const { fetcherOptions } = useArchesApiContext();
  return reactQuery.useMutation<
    Schemas.MemberEntity,
    MembersControllerJoinError,
    MembersControllerJoinVariables
  >({
    mutationFn: (variables: MembersControllerJoinVariables) =>
      fetchMembersControllerJoin({ ...fetcherOptions, ...variables }),
    ...options,
  });
};

export type MembersControllerRemovePathParams = {
  orgname: string;
  memberId: string;
};

export type MembersControllerRemoveError = Fetcher.ErrorWrapper<undefined>;

export type MembersControllerRemoveVariables = {
  pathParams: MembersControllerRemovePathParams;
} & ArchesApiContext["fetcherOptions"];

/**
 * Delete a member. ADMIN ONLY.
 */
export const fetchMembersControllerRemove = (
  variables: MembersControllerRemoveVariables,
  signal?: AbortSignal,
) =>
  archesApiFetch<
    undefined,
    MembersControllerRemoveError,
    undefined,
    {},
    {},
    MembersControllerRemovePathParams
  >({
    url: "/organizations/{orgname}/members/{memberId}",
    method: "delete",
    ...variables,
    signal,
  });

/**
 * Delete a member. ADMIN ONLY.
 */
export const useMembersControllerRemove = (
  options?: Omit<
    reactQuery.UseMutationOptions<
      undefined,
      MembersControllerRemoveError,
      MembersControllerRemoveVariables
    >,
    "mutationFn"
  >,
) => {
  const { fetcherOptions } = useArchesApiContext();
  return reactQuery.useMutation<
    undefined,
    MembersControllerRemoveError,
    MembersControllerRemoveVariables
  >({
    mutationFn: (variables: MembersControllerRemoveVariables) =>
      fetchMembersControllerRemove({ ...fetcherOptions, ...variables }),
    ...options,
  });
};

export type MembersControllerUpdatePathParams = {
  orgname: string;
  memberId: string;
};

export type MembersControllerUpdateError = Fetcher.ErrorWrapper<undefined>;

export type MembersControllerUpdateVariables = {
  body?: Schemas.UpdateMemberDto;
  pathParams: MembersControllerUpdatePathParams;
} & ArchesApiContext["fetcherOptions"];

/**
 * Update a member. ADMIN ONLY.
 */
export const fetchMembersControllerUpdate = (
  variables: MembersControllerUpdateVariables,
  signal?: AbortSignal,
) =>
  archesApiFetch<
    Schemas.MemberEntity,
    MembersControllerUpdateError,
    Schemas.UpdateMemberDto,
    {},
    {},
    MembersControllerUpdatePathParams
  >({
    url: "/organizations/{orgname}/members/{memberId}",
    method: "patch",
    ...variables,
    signal,
  });

/**
 * Update a member. ADMIN ONLY.
 */
export const useMembersControllerUpdate = (
  options?: Omit<
    reactQuery.UseMutationOptions<
      Schemas.MemberEntity,
      MembersControllerUpdateError,
      MembersControllerUpdateVariables
    >,
    "mutationFn"
  >,
) => {
  const { fetcherOptions } = useArchesApiContext();
  return reactQuery.useMutation<
    Schemas.MemberEntity,
    MembersControllerUpdateError,
    MembersControllerUpdateVariables
  >({
    mutationFn: (variables: MembersControllerUpdateVariables) =>
      fetchMembersControllerUpdate({ ...fetcherOptions, ...variables }),
    ...options,
  });
};

export type LabelsControllerCreatePathParams = {
  orgname: string;
};

export type LabelsControllerCreateError = Fetcher.ErrorWrapper<undefined>;

export type LabelsControllerCreateVariables = {
  body?: Schemas.CreateLabelDto;
  pathParams: LabelsControllerCreatePathParams;
} & ArchesApiContext["fetcherOptions"];

/**
 * Create a new label. USER and ADMIN can access this endpoint.
 */
export const fetchLabelsControllerCreate = (
  variables: LabelsControllerCreateVariables,
  signal?: AbortSignal,
) =>
  archesApiFetch<
    Schemas.LabelEntity,
    LabelsControllerCreateError,
    Schemas.CreateLabelDto,
    {},
    {},
    LabelsControllerCreatePathParams
  >({
    url: "/organizations/{orgname}/labels",
    method: "post",
    ...variables,
    signal,
  });

/**
 * Create a new label. USER and ADMIN can access this endpoint.
 */
export const useLabelsControllerCreate = (
  options?: Omit<
    reactQuery.UseMutationOptions<
      Schemas.LabelEntity,
      LabelsControllerCreateError,
      LabelsControllerCreateVariables
    >,
    "mutationFn"
  >,
) => {
  const { fetcherOptions } = useArchesApiContext();
  return reactQuery.useMutation<
    Schemas.LabelEntity,
    LabelsControllerCreateError,
    LabelsControllerCreateVariables
  >({
    mutationFn: (variables: LabelsControllerCreateVariables) =>
      fetchLabelsControllerCreate({ ...fetcherOptions, ...variables }),
    ...options,
  });
};

export type LabelsControllerFindAllPathParams = {
  orgname: string;
};

export type LabelsControllerFindAllQueryParams = {
  /**
   * The end date to search to
   */
  endDate?: string;
  /**
   * Filter fields and values
   */
  filters?: Schemas.FilterField[];
  /**
   * The limit of the number of results returned
   *
   * @default 10
   */
  limit?: number;
  /**
   * The offset of the returned results
   *
   * @default 0
   */
  offset?: number;
  /**
   * The field to sort the results by
   *
   * @default createdAt
   */
  sortBy?: string;
  /**
   * The direction to sort the results by
   *
   * @default desc
   */
  sortDirection?: "asc" | "desc";
  /**
   * The start date to search from
   */
  startDate?: string;
  /**
   * The granularity to use for ranged aggregates
   */
  aggregateGranularity?: "day" | "month" | "week" | "year";
  /**
   * Whether or not to include aggregates in the response
   *
   * @default false
   */
  aggregates?: boolean;
};

export type LabelsControllerFindAllError = Fetcher.ErrorWrapper<undefined>;

export type LabelsControllerFindAllResponse = Schemas.PaginatedDto & {
  results?: Schemas.LabelEntity[];
  aggregates?: Schemas.LabelAggregates;
};

export type LabelsControllerFindAllVariables = {
  pathParams: LabelsControllerFindAllPathParams;
  queryParams?: LabelsControllerFindAllQueryParams;
} & ArchesApiContext["fetcherOptions"];

/**
 * Get all labels. ADMIN ONLY.
 */
export const fetchLabelsControllerFindAll = (
  variables: LabelsControllerFindAllVariables,
  signal?: AbortSignal,
) =>
  archesApiFetch<
    LabelsControllerFindAllResponse,
    LabelsControllerFindAllError,
    undefined,
    {},
    LabelsControllerFindAllQueryParams,
    LabelsControllerFindAllPathParams
  >({
    url: "/organizations/{orgname}/labels",
    method: "get",
    ...variables,
    signal,
  });

/**
 * Get all labels. ADMIN ONLY.
 */
export const useLabelsControllerFindAll = <
  TData = LabelsControllerFindAllResponse,
>(
  variables: LabelsControllerFindAllVariables,
  options?: Omit<
    reactQuery.UseQueryOptions<
      LabelsControllerFindAllResponse,
      LabelsControllerFindAllError,
      TData
    >,
    "queryKey" | "queryFn" | "initialData"
  >,
) => {
  const { fetcherOptions, queryOptions, queryKeyFn } =
    useArchesApiContext(options);
  return reactQuery.useQuery<
    LabelsControllerFindAllResponse,
    LabelsControllerFindAllError,
    TData
  >({
    queryKey: queryKeyFn({
      path: "/organizations/{orgname}/labels",
      operationId: "labelsControllerFindAll",
      variables,
    }),
    queryFn: ({ signal }) =>
      fetchLabelsControllerFindAll({ ...fetcherOptions, ...variables }, signal),
    ...options,
    ...queryOptions,
  });
};

export type LabelsControllerFindOnePathParams = {
  orgname: string;
  labelId: string;
};

export type LabelsControllerFindOneError = Fetcher.ErrorWrapper<undefined>;

export type LabelsControllerFindOneVariables = {
  pathParams: LabelsControllerFindOnePathParams;
} & ArchesApiContext["fetcherOptions"];

/**
 * Get a label. ADMIN ONLY.
 */
export const fetchLabelsControllerFindOne = (
  variables: LabelsControllerFindOneVariables,
  signal?: AbortSignal,
) =>
  archesApiFetch<
    Schemas.LabelEntity,
    LabelsControllerFindOneError,
    undefined,
    {},
    {},
    LabelsControllerFindOnePathParams
  >({
    url: "/organizations/{orgname}/labels/{labelId}",
    method: "get",
    ...variables,
    signal,
  });

/**
 * Get a label. ADMIN ONLY.
 */
export const useLabelsControllerFindOne = <TData = Schemas.LabelEntity,>(
  variables: LabelsControllerFindOneVariables,
  options?: Omit<
    reactQuery.UseQueryOptions<
      Schemas.LabelEntity,
      LabelsControllerFindOneError,
      TData
    >,
    "queryKey" | "queryFn" | "initialData"
  >,
) => {
  const { fetcherOptions, queryOptions, queryKeyFn } =
    useArchesApiContext(options);
  return reactQuery.useQuery<
    Schemas.LabelEntity,
    LabelsControllerFindOneError,
    TData
  >({
    queryKey: queryKeyFn({
      path: "/organizations/{orgname}/labels/{labelId}",
      operationId: "labelsControllerFindOne",
      variables,
    }),
    queryFn: ({ signal }) =>
      fetchLabelsControllerFindOne({ ...fetcherOptions, ...variables }, signal),
    ...options,
    ...queryOptions,
  });
};

export type LabelsControllerRemovePathParams = {
  orgname: string;
  labelId: string;
};

export type LabelsControllerRemoveError = Fetcher.ErrorWrapper<undefined>;

export type LabelsControllerRemoveVariables = {
  pathParams: LabelsControllerRemovePathParams;
} & ArchesApiContext["fetcherOptions"];

/**
 * Delete a label. ADMIN ONLY.
 */
export const fetchLabelsControllerRemove = (
  variables: LabelsControllerRemoveVariables,
  signal?: AbortSignal,
) =>
  archesApiFetch<
    undefined,
    LabelsControllerRemoveError,
    undefined,
    {},
    {},
    LabelsControllerRemovePathParams
  >({
    url: "/organizations/{orgname}/labels/{labelId}",
    method: "delete",
    ...variables,
    signal,
  });

/**
 * Delete a label. ADMIN ONLY.
 */
export const useLabelsControllerRemove = (
  options?: Omit<
    reactQuery.UseMutationOptions<
      undefined,
      LabelsControllerRemoveError,
      LabelsControllerRemoveVariables
    >,
    "mutationFn"
  >,
) => {
  const { fetcherOptions } = useArchesApiContext();
  return reactQuery.useMutation<
    undefined,
    LabelsControllerRemoveError,
    LabelsControllerRemoveVariables
  >({
    mutationFn: (variables: LabelsControllerRemoveVariables) =>
      fetchLabelsControllerRemove({ ...fetcherOptions, ...variables }),
    ...options,
  });
};

export type ToolsControllerCreatePathParams = {
  orgname: string;
};

export type ToolsControllerCreateError = Fetcher.ErrorWrapper<undefined>;

export type ToolsControllerCreateVariables = {
  body: Schemas.CreateToolDto;
  pathParams: ToolsControllerCreatePathParams;
} & ArchesApiContext["fetcherOptions"];

/**
 * Create a new tool. ADMIN ONLY.
 */
export const fetchToolsControllerCreate = (
  variables: ToolsControllerCreateVariables,
  signal?: AbortSignal,
) =>
  archesApiFetch<
    Schemas.ToolEntity,
    ToolsControllerCreateError,
    Schemas.CreateToolDto,
    {},
    {},
    ToolsControllerCreatePathParams
  >({
    url: "/organizations/{orgname}/tools",
    method: "post",
    ...variables,
    signal,
  });

/**
 * Create a new tool. ADMIN ONLY.
 */
export const useToolsControllerCreate = (
  options?: Omit<
    reactQuery.UseMutationOptions<
      Schemas.ToolEntity,
      ToolsControllerCreateError,
      ToolsControllerCreateVariables
    >,
    "mutationFn"
  >,
) => {
  const { fetcherOptions } = useArchesApiContext();
  return reactQuery.useMutation<
    Schemas.ToolEntity,
    ToolsControllerCreateError,
    ToolsControllerCreateVariables
  >({
    mutationFn: (variables: ToolsControllerCreateVariables) =>
      fetchToolsControllerCreate({ ...fetcherOptions, ...variables }),
    ...options,
  });
};

export type ToolsControllerFindAllPathParams = {
  orgname: string;
};

export type ToolsControllerFindAllQueryParams = {
  /**
   * The end date to search to
   */
  endDate?: string;
  /**
   * Filter fields and values
   */
  filters?: Schemas.FilterField[];
  /**
   * The limit of the number of results returned
   *
   * @default 10
   */
  limit?: number;
  /**
   * The offset of the returned results
   *
   * @default 0
   */
  offset?: number;
  /**
   * The field to sort the results by
   *
   * @default createdAt
   */
  sortBy?: string;
  /**
   * The direction to sort the results by
   *
   * @default desc
   */
  sortDirection?: "asc" | "desc";
  /**
   * The start date to search from
   */
  startDate?: string;
};

export type ToolsControllerFindAllError = Fetcher.ErrorWrapper<undefined>;

export type ToolsControllerFindAllResponse = Schemas.PaginatedDto & {
  results?: Schemas.ToolEntity[];
};

export type ToolsControllerFindAllVariables = {
  pathParams: ToolsControllerFindAllPathParams;
  queryParams?: ToolsControllerFindAllQueryParams;
} & ArchesApiContext["fetcherOptions"];

/**
 * Get all tools. ADMIN ONLY.
 */
export const fetchToolsControllerFindAll = (
  variables: ToolsControllerFindAllVariables,
  signal?: AbortSignal,
) =>
  archesApiFetch<
    ToolsControllerFindAllResponse,
    ToolsControllerFindAllError,
    undefined,
    {},
    ToolsControllerFindAllQueryParams,
    ToolsControllerFindAllPathParams
  >({
    url: "/organizations/{orgname}/tools",
    method: "get",
    ...variables,
    signal,
  });

/**
 * Get all tools. ADMIN ONLY.
 */
export const useToolsControllerFindAll = <
  TData = ToolsControllerFindAllResponse,
>(
  variables: ToolsControllerFindAllVariables,
  options?: Omit<
    reactQuery.UseQueryOptions<
      ToolsControllerFindAllResponse,
      ToolsControllerFindAllError,
      TData
    >,
    "queryKey" | "queryFn" | "initialData"
  >,
) => {
  const { fetcherOptions, queryOptions, queryKeyFn } =
    useArchesApiContext(options);
  return reactQuery.useQuery<
    ToolsControllerFindAllResponse,
    ToolsControllerFindAllError,
    TData
  >({
    queryKey: queryKeyFn({
      path: "/organizations/{orgname}/tools",
      operationId: "toolsControllerFindAll",
      variables,
    }),
    queryFn: ({ signal }) =>
      fetchToolsControllerFindAll({ ...fetcherOptions, ...variables }, signal),
    ...options,
    ...queryOptions,
  });
};

export type ToolsControllerFindOnePathParams = {
  orgname: string;
  toolId: string;
};

export type ToolsControllerFindOneError = Fetcher.ErrorWrapper<undefined>;

export type ToolsControllerFindOneVariables = {
  pathParams: ToolsControllerFindOnePathParams;
} & ArchesApiContext["fetcherOptions"];

/**
 * Get a tool. ADMIN ONLY.
 */
export const fetchToolsControllerFindOne = (
  variables: ToolsControllerFindOneVariables,
  signal?: AbortSignal,
) =>
  archesApiFetch<
    Schemas.ToolEntity,
    ToolsControllerFindOneError,
    undefined,
    {},
    {},
    ToolsControllerFindOnePathParams
  >({
    url: "/organizations/{orgname}/tools/{toolId}",
    method: "get",
    ...variables,
    signal,
  });

/**
 * Get a tool. ADMIN ONLY.
 */
export const useToolsControllerFindOne = <TData = Schemas.ToolEntity,>(
  variables: ToolsControllerFindOneVariables,
  options?: Omit<
    reactQuery.UseQueryOptions<
      Schemas.ToolEntity,
      ToolsControllerFindOneError,
      TData
    >,
    "queryKey" | "queryFn" | "initialData"
  >,
) => {
  const { fetcherOptions, queryOptions, queryKeyFn } =
    useArchesApiContext(options);
  return reactQuery.useQuery<
    Schemas.ToolEntity,
    ToolsControllerFindOneError,
    TData
  >({
    queryKey: queryKeyFn({
      path: "/organizations/{orgname}/tools/{toolId}",
      operationId: "toolsControllerFindOne",
      variables,
    }),
    queryFn: ({ signal }) =>
      fetchToolsControllerFindOne({ ...fetcherOptions, ...variables }, signal),
    ...options,
    ...queryOptions,
  });
};

export type ToolsControllerRemovePathParams = {
  orgname: string;
  toolId: string;
};

export type ToolsControllerRemoveError = Fetcher.ErrorWrapper<undefined>;

export type ToolsControllerRemoveVariables = {
  pathParams: ToolsControllerRemovePathParams;
} & ArchesApiContext["fetcherOptions"];

/**
 * Delete a tools. ADMIN ONLY.
 */
export const fetchToolsControllerRemove = (
  variables: ToolsControllerRemoveVariables,
  signal?: AbortSignal,
) =>
  archesApiFetch<
    undefined,
    ToolsControllerRemoveError,
    undefined,
    {},
    {},
    ToolsControllerRemovePathParams
  >({
    url: "/organizations/{orgname}/tools/{toolId}",
    method: "delete",
    ...variables,
    signal,
  });

/**
 * Delete a tools. ADMIN ONLY.
 */
export const useToolsControllerRemove = (
  options?: Omit<
    reactQuery.UseMutationOptions<
      undefined,
      ToolsControllerRemoveError,
      ToolsControllerRemoveVariables
    >,
    "mutationFn"
  >,
) => {
  const { fetcherOptions } = useArchesApiContext();
  return reactQuery.useMutation<
    undefined,
    ToolsControllerRemoveError,
    ToolsControllerRemoveVariables
  >({
    mutationFn: (variables: ToolsControllerRemoveVariables) =>
      fetchToolsControllerRemove({ ...fetcherOptions, ...variables }),
    ...options,
  });
};

export type ToolsControllerUpdatePathParams = {
  orgname: string;
  toolId: string;
};

export type ToolsControllerUpdateError = Fetcher.ErrorWrapper<undefined>;

export type ToolsControllerUpdateVariables = {
  body?: Schemas.UpdateToolDto;
  pathParams: ToolsControllerUpdatePathParams;
} & ArchesApiContext["fetcherOptions"];

/**
 * Update a tools. ADMIN ONLY.
 */
export const fetchToolsControllerUpdate = (
  variables: ToolsControllerUpdateVariables,
  signal?: AbortSignal,
) =>
  archesApiFetch<
    Schemas.ToolEntity,
    ToolsControllerUpdateError,
    Schemas.UpdateToolDto,
    {},
    {},
    ToolsControllerUpdatePathParams
  >({
    url: "/organizations/{orgname}/tools/{toolId}",
    method: "patch",
    ...variables,
    signal,
  });

/**
 * Update a tools. ADMIN ONLY.
 */
export const useToolsControllerUpdate = (
  options?: Omit<
    reactQuery.UseMutationOptions<
      Schemas.ToolEntity,
      ToolsControllerUpdateError,
      ToolsControllerUpdateVariables
    >,
    "mutationFn"
  >,
) => {
  const { fetcherOptions } = useArchesApiContext();
  return reactQuery.useMutation<
    Schemas.ToolEntity,
    ToolsControllerUpdateError,
    ToolsControllerUpdateVariables
  >({
    mutationFn: (variables: ToolsControllerUpdateVariables) =>
      fetchToolsControllerUpdate({ ...fetcherOptions, ...variables }),
    ...options,
  });
};

export type QueryOperation =
  | {
      path: "/organizations/{orgname}/pipelines";
      operationId: "pipelinesControllerFindAll";
      variables: PipelinesControllerFindAllVariables;
    }
  | {
      path: "/organizations/{orgname}/pipelines/{pipelineId}";
      operationId: "pipelinesControllerFindOne";
      variables: PipelinesControllerFindOneVariables;
    }
  | {
      path: "/user";
      operationId: "userControllerFindOne";
      variables: UserControllerFindOneVariables;
    }
  | {
      path: "/organizations/{orgname}";
      operationId: "organizationsControllerFindOne";
      variables: OrganizationsControllerFindOneVariables;
    }
  | {
      path: "/plans";
      operationId: "billingControllerGetPlans";
      variables: BillingControllerGetPlansVariables;
    }
  | {
      path: "/organizations/{orgname}/billing/payment-methods";
      operationId: "billingControllerListPaymentMethods";
      variables: BillingControllerListPaymentMethodsVariables;
    }
  | {
      path: "/organizations/{orgname}/api-tokens";
      operationId: "apiTokensControllerFindAll";
      variables: ApiTokensControllerFindAllVariables;
    }
  | {
      path: "/organizations/{orgname}/api-tokens/{id}";
      operationId: "apiTokensControllerFindOne";
      variables: ApiTokensControllerFindOneVariables;
    }
  | {
      path: "/organizations/{orgname}/content";
      operationId: "contentControllerFindAll";
      variables: ContentControllerFindAllVariables;
    }
  | {
      path: "/organizations/{orgname}/content/{contentId}";
      operationId: "contentControllerFindOne";
      variables: ContentControllerFindOneVariables;
    }
  | {
      path: "/organizations/{orgname}/storage/items";
      operationId: "storageControllerListDirectory";
      variables: StorageControllerListDirectoryVariables;
    }
  | {
      path: "/organizations/{orgname}/members";
      operationId: "membersControllerFindAll";
      variables: MembersControllerFindAllVariables;
    }
  | {
      path: "/organizations/{orgname}/labels";
      operationId: "labelsControllerFindAll";
      variables: LabelsControllerFindAllVariables;
    }
  | {
      path: "/organizations/{orgname}/labels/{labelId}";
      operationId: "labelsControllerFindOne";
      variables: LabelsControllerFindOneVariables;
    }
  | {
      path: "/organizations/{orgname}/tools";
      operationId: "toolsControllerFindAll";
      variables: ToolsControllerFindAllVariables;
    }
  | {
      path: "/organizations/{orgname}/tools/{toolId}";
      operationId: "toolsControllerFindOne";
      variables: ToolsControllerFindOneVariables;
    };
