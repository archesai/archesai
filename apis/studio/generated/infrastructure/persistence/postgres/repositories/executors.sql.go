// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.30.0
// source: executors.sql

package repositories

import (
	"context"

	"github.com/google/uuid"
)

const createExecutor = `-- name: CreateExecutor :one
INSERT INTO
  executor (
    id,
    organization_id,
    name,
    description,
    language,
    execute_code,
    dependencies,
    schema_in,
    schema_out,
    extra_files,
    timeout,
    memory_mb,
    cpu_shares,
    env,
    is_active,
    version
  )
VALUES
  ($1, $2, $3, $4, $5, $6, $7, $8, $9, $10, $11, $12, $13, $14, $15, $16)
RETURNING
  id, created_at, updated_at, cpu_shares, dependencies, description, env, execute_code, extra_files, is_active, language, memory_mb, name, organization_id, schema_in, schema_out, timeout, version
`

type CreateExecutorParams struct {
	ID             uuid.UUID
	OrganizationID uuid.UUID
	Name           string
	Description    string
	Language       string
	ExecuteCode    string
	Dependencies   *string
	SchemaIn       *string
	SchemaOut      *string
	ExtraFiles     *string
	Timeout        int32
	MemoryMB       int32
	CPUShares      int32
	Env            *string
	IsActive       bool
	Version        int32
}

func (q *Queries) CreateExecutor(ctx context.Context, arg CreateExecutorParams) (Executor, error) {
	row := q.db.QueryRow(ctx, createExecutor,
		arg.ID,
		arg.OrganizationID,
		arg.Name,
		arg.Description,
		arg.Language,
		arg.ExecuteCode,
		arg.Dependencies,
		arg.SchemaIn,
		arg.SchemaOut,
		arg.ExtraFiles,
		arg.Timeout,
		arg.MemoryMB,
		arg.CPUShares,
		arg.Env,
		arg.IsActive,
		arg.Version,
	)
	var i Executor
	err := row.Scan(
		&i.ID,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.CPUShares,
		&i.Dependencies,
		&i.Description,
		&i.Env,
		&i.ExecuteCode,
		&i.ExtraFiles,
		&i.IsActive,
		&i.Language,
		&i.MemoryMB,
		&i.Name,
		&i.OrganizationID,
		&i.SchemaIn,
		&i.SchemaOut,
		&i.Timeout,
		&i.Version,
	)
	return i, err
}

const deleteExecutor = `-- name: DeleteExecutor :exec
DELETE FROM executor
WHERE
  id = $1
`

type DeleteExecutorParams struct {
	ID uuid.UUID
}

func (q *Queries) DeleteExecutor(ctx context.Context, arg DeleteExecutorParams) error {
	_, err := q.db.Exec(ctx, deleteExecutor, arg.ID)
	return err
}

const deleteExecutorsByOrganization = `-- name: DeleteExecutorsByOrganization :exec
DELETE FROM executor
WHERE
  organization_id = $1
`

type DeleteExecutorsByOrganizationParams struct {
	OrganizationID uuid.UUID
}

func (q *Queries) DeleteExecutorsByOrganization(ctx context.Context, arg DeleteExecutorsByOrganizationParams) error {
	_, err := q.db.Exec(ctx, deleteExecutorsByOrganization, arg.OrganizationID)
	return err
}

const getExecutor = `-- name: GetExecutor :one
SELECT
  id, created_at, updated_at, cpu_shares, dependencies, description, env, execute_code, extra_files, is_active, language, memory_mb, name, organization_id, schema_in, schema_out, timeout, version
FROM
  executor
WHERE
  id = $1
LIMIT
  1
`

type GetExecutorParams struct {
	ID uuid.UUID
}

func (q *Queries) GetExecutor(ctx context.Context, arg GetExecutorParams) (Executor, error) {
	row := q.db.QueryRow(ctx, getExecutor, arg.ID)
	var i Executor
	err := row.Scan(
		&i.ID,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.CPUShares,
		&i.Dependencies,
		&i.Description,
		&i.Env,
		&i.ExecuteCode,
		&i.ExtraFiles,
		&i.IsActive,
		&i.Language,
		&i.MemoryMB,
		&i.Name,
		&i.OrganizationID,
		&i.SchemaIn,
		&i.SchemaOut,
		&i.Timeout,
		&i.Version,
	)
	return i, err
}

const listExecutors = `-- name: ListExecutors :many
SELECT
  id, created_at, updated_at, cpu_shares, dependencies, description, env, execute_code, extra_files, is_active, language, memory_mb, name, organization_id, schema_in, schema_out, timeout, version
FROM
  executor
ORDER BY
  created_at DESC
LIMIT
  $1
OFFSET
  $2
`

type ListExecutorsParams struct {
	Limit  int32
	Offset int32
}

func (q *Queries) ListExecutors(ctx context.Context, arg ListExecutorsParams) ([]Executor, error) {
	rows, err := q.db.Query(ctx, listExecutors, arg.Limit, arg.Offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Executor
	for rows.Next() {
		var i Executor
		if err := rows.Scan(
			&i.ID,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.CPUShares,
			&i.Dependencies,
			&i.Description,
			&i.Env,
			&i.ExecuteCode,
			&i.ExtraFiles,
			&i.IsActive,
			&i.Language,
			&i.MemoryMB,
			&i.Name,
			&i.OrganizationID,
			&i.SchemaIn,
			&i.SchemaOut,
			&i.Timeout,
			&i.Version,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listExecutorsByOrganization = `-- name: ListExecutorsByOrganization :many
SELECT
  id, created_at, updated_at, cpu_shares, dependencies, description, env, execute_code, extra_files, is_active, language, memory_mb, name, organization_id, schema_in, schema_out, timeout, version
FROM
  executor
WHERE
  organization_id = $1
ORDER BY
  created_at DESC
LIMIT
  $2
OFFSET
  $3
`

type ListExecutorsByOrganizationParams struct {
	OrganizationID uuid.UUID
	Limit          int32
	Offset         int32
}

func (q *Queries) ListExecutorsByOrganization(ctx context.Context, arg ListExecutorsByOrganizationParams) ([]Executor, error) {
	rows, err := q.db.Query(ctx, listExecutorsByOrganization, arg.OrganizationID, arg.Limit, arg.Offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Executor
	for rows.Next() {
		var i Executor
		if err := rows.Scan(
			&i.ID,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.CPUShares,
			&i.Dependencies,
			&i.Description,
			&i.Env,
			&i.ExecuteCode,
			&i.ExtraFiles,
			&i.IsActive,
			&i.Language,
			&i.MemoryMB,
			&i.Name,
			&i.OrganizationID,
			&i.SchemaIn,
			&i.SchemaOut,
			&i.Timeout,
			&i.Version,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const updateExecutor = `-- name: UpdateExecutor :one
UPDATE executor
SET
  name = COALESCE($2, name),
  description = COALESCE($3, description),
  language = COALESCE($4, language),
  execute_code = COALESCE($5, execute_code),
  dependencies = COALESCE($6, dependencies),
  schema_in = COALESCE($7, schema_in),
  schema_out = COALESCE($8, schema_out),
  extra_files = COALESCE($9, extra_files),
  timeout = COALESCE($10, timeout),
  memory_mb = COALESCE($11, memory_mb),
  cpu_shares = COALESCE($12, cpu_shares),
  env = COALESCE($13, env),
  is_active = COALESCE($14, is_active),
  version = version + 1,
  updated_at = CURRENT_TIMESTAMP
WHERE
  id = $1
RETURNING
  id, created_at, updated_at, cpu_shares, dependencies, description, env, execute_code, extra_files, is_active, language, memory_mb, name, organization_id, schema_in, schema_out, timeout, version
`

type UpdateExecutorParams struct {
	ID           uuid.UUID
	Name         *string
	Description  *string
	Language     *string
	ExecuteCode  *string
	Dependencies *string
	SchemaIn     *string
	SchemaOut    *string
	ExtraFiles   *string
	Timeout      *int32
	MemoryMB     *int32
	CPUShares    *int32
	Env          *string
	IsActive     *bool
}

func (q *Queries) UpdateExecutor(ctx context.Context, arg UpdateExecutorParams) (Executor, error) {
	row := q.db.QueryRow(ctx, updateExecutor,
		arg.ID,
		arg.Name,
		arg.Description,
		arg.Language,
		arg.ExecuteCode,
		arg.Dependencies,
		arg.SchemaIn,
		arg.SchemaOut,
		arg.ExtraFiles,
		arg.Timeout,
		arg.MemoryMB,
		arg.CPUShares,
		arg.Env,
		arg.IsActive,
	)
	var i Executor
	err := row.Scan(
		&i.ID,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.CPUShares,
		&i.Dependencies,
		&i.Description,
		&i.Env,
		&i.ExecuteCode,
		&i.ExtraFiles,
		&i.IsActive,
		&i.Language,
		&i.MemoryMB,
		&i.Name,
		&i.OrganizationID,
		&i.SchemaIn,
		&i.SchemaOut,
		&i.Timeout,
		&i.Version,
	)
	return i, err
}
