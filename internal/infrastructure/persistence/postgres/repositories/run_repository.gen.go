// Code generated by archesai. DO NOT EDIT.

package repositories

import (
	"context"
	"database/sql"
	"errors"
	"fmt"

	"github.com/archesai/archesai/internal/core/entities"
	corerrors "github.com/archesai/archesai/internal/core/errors"
	"github.com/google/uuid"
	"github.com/jackc/pgx/v5"
	"github.com/jackc/pgx/v5/pgxpool"
)

// PostgresRunRepository implements RunRepository using PostgreSQL.
type PostgresRunRepository struct {
	queries *Queries
}

// NewPostgresRunRepository creates a new PostgreSQL repository.
func NewPostgresRunRepository(db *pgxpool.Pool) *PostgresRunRepository {
	return &PostgresRunRepository{
		queries: New(db),
	}
}

// Run operations

// Create creates a new run
func (r *PostgresRunRepository) Create(ctx context.Context, entity *entities.Run) (*entities.Run, error) {
	params := CreateRunParams{
		ID:             entity.ID,
		OrganizationID: entity.OrganizationID,
		PipelineID:     entity.PipelineID,
		Progress:       entity.Progress,
		Status:         string(entity.Status),
		ToolID:         entity.ToolID,
	}

	result, err := r.queries.CreateRun(ctx, params)
	if err != nil {
		return nil, fmt.Errorf("failed to create run: %w", err)
	}

	return mapRunFromDB(&result), nil
}

// Get retrieves a run by ID
func (r *PostgresRunRepository) Get(ctx context.Context, id uuid.UUID) (*entities.Run, error) {
	params := GetRunParams{
		ID: id,
	}

	result, err := r.queries.GetRun(ctx, params)
	if err != nil {
		if errors.Is(err, pgx.ErrNoRows) || err == sql.ErrNoRows {
			return nil, corerrors.ErrRunNotFound
		}
		return nil, fmt.Errorf("failed to get run: %w", err)
	}

	return mapRunFromDB(&result), nil
}

// Update updates an existing run
func (r *PostgresRunRepository) Update(ctx context.Context, id uuid.UUID, entity *entities.Run) (*entities.Run, error) {

	statusStr := string(entity.Status)

	params := UpdateRunParams{
		ID:          id,
		CompletedAt: entity.CompletedAt,
		Error:       entity.Error,
		PipelineID:  &entity.PipelineID,
		Progress:    &entity.Progress,
		StartedAt:   entity.StartedAt,
		Status:      &statusStr,
		ToolID:      &entity.ToolID,
	}

	result, err := r.queries.UpdateRun(ctx, params)
	if err != nil {
		if errors.Is(err, pgx.ErrNoRows) || err == sql.ErrNoRows {
			return nil, corerrors.ErrRunNotFound
		}
		return nil, fmt.Errorf("failed to update run: %w", err)
	}

	return mapRunFromDB(&result), nil
}

// Delete removes a run
func (r *PostgresRunRepository) Delete(ctx context.Context, id uuid.UUID) error {
	params := DeleteRunParams{
		ID: id,
	}

	err := r.queries.DeleteRun(ctx, params)
	if err != nil {
		if errors.Is(err, pgx.ErrNoRows) || err == sql.ErrNoRows {
			return corerrors.ErrRunNotFound
		}
		return fmt.Errorf("failed to delete run: %w", err)
	}
	return nil
}

// List returns a paginated list of runs
func (r *PostgresRunRepository) List(ctx context.Context, limit, offset int32) ([]*entities.Run, int64, error) {
	listParams := ListRunsParams{
		Limit:  limit,
		Offset: offset,
	}

	results, err := r.queries.ListRuns(ctx, listParams)
	if err != nil {
		return nil, 0, fmt.Errorf("failed to list runs: %w", err)
	}

	items := make([]*entities.Run, len(results))
	for i, result := range results {
		items[i] = mapRunFromDB(&result)
	}

	// For now, return the count as the length of results
	// In production, you'd want a separate count query
	count := int64(len(results))

	return items, count, nil
}

// ListRunsByPipeline retrieves multiple Runs by pipelineID
func (r *PostgresRunRepository) ListRunsByPipeline(ctx context.Context, pipelineID string) ([]*entities.Run, error) {
	params := ListRunsByPipelineParams{
		PipelineID: uuid.MustParse(pipelineID),
	}

	result, err := r.queries.ListRunsByPipeline(ctx, params)
	if err != nil {
		if errors.Is(err, pgx.ErrNoRows) || err == sql.ErrNoRows {
			return nil, corerrors.ErrRunNotFound
		}
		return nil, fmt.Errorf("failed to ListRunsByPipeline: %w", err)
	}
	items := make([]*entities.Run, len(result))
	for i, res := range result {
		items[i] = mapRunFromDB(&res)
	}
	return items, nil

}

// ListRunsByOrganization retrieves multiple Runs by organizationID
func (r *PostgresRunRepository) ListRunsByOrganization(ctx context.Context, organizationID string) ([]*entities.Run, error) {
	params := ListRunsByOrganizationParams{
		OrganizationID: uuid.MustParse(organizationID),
	}

	result, err := r.queries.ListRunsByOrganization(ctx, params)
	if err != nil {
		if errors.Is(err, pgx.ErrNoRows) || err == sql.ErrNoRows {
			return nil, corerrors.ErrRunNotFound
		}
		return nil, fmt.Errorf("failed to ListRunsByOrganization: %w", err)
	}
	items := make([]*entities.Run, len(result))
	for i, res := range result {
		items[i] = mapRunFromDB(&res)
	}
	return items, nil

}

// ListRunsByTool retrieves multiple Runs by toolID
func (r *PostgresRunRepository) ListRunsByTool(ctx context.Context, toolID string) ([]*entities.Run, error) {
	params := ListRunsByToolParams{
		ToolID: uuid.MustParse(toolID),
	}

	result, err := r.queries.ListRunsByTool(ctx, params)
	if err != nil {
		if errors.Is(err, pgx.ErrNoRows) || err == sql.ErrNoRows {
			return nil, corerrors.ErrRunNotFound
		}
		return nil, fmt.Errorf("failed to ListRunsByTool: %w", err)
	}
	items := make([]*entities.Run, len(result))
	for i, res := range result {
		items[i] = mapRunFromDB(&res)
	}
	return items, nil

}

func mapRunFromDB(db *Run) *entities.Run {
	if db == nil {
		return nil
	}

	result := &entities.Run{
		ID:             db.ID,
		CreatedAt:      db.CreatedAt,
		UpdatedAt:      db.UpdatedAt,
		CompletedAt:    db.CompletedAt,
		Error:          db.Error,
		OrganizationID: db.OrganizationID,
		PipelineID:     db.PipelineID,
		Progress:       db.Progress,
		StartedAt:      db.StartedAt,
		Status:         entities.RunStatus(db.Status),
		ToolID:         db.ToolID,
	}

	return result
}
