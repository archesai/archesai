{{- /*
Template: operations.go.tmpl
Generates: Operation DTOs, interface, and (for non-custom) default implementation
Expected data: OperationsView
*/ -}}
{{template "header" .}}
package {{ .Package }}

import (
	"context"
	"fmt"
	"time"

	"github.com/google/uuid"

{{- if not .IsSingleMode }}
	"{{ .ProjectName }}/schemas"
{{- end }}
	"github.com/archesai/archesai/pkg/events"
	"github.com/archesai/archesai/pkg/executor"
	serverschemas "github.com/archesai/archesai/pkg/server/schemas"
)
{{- range .OwnOperations }}
{{- $op := . }}

// ============================================================================
// {{ $op.ID }}
// ============================================================================

// {{ $op.ID }}Input represents the input for the {{ $op.ID }} operation.
type {{ $op.ID }}Input struct {
{{- if eq $op.Internal "auth" }}
{{- if or $op.HasBearerAuth $op.HasCookieAuth }}
	SessionID uuid.UUID
{{- end }}
{{- end }}
{{- range $op.GetPathParams }}
	{{ pascalCase .Title }} {{ .GoType }}
{{- end }}
{{- range $op.GetHeaderParams }}
	{{ pascalCase .Title }} {{ .GoType }}
{{- end }}
{{- range $op.GetQueryParams }}
	{{ pascalCase .Title }} {{ if .NeedsPointer }}*{{ end }}{{ .GoType }}
{{- end }}
{{- if $op.RequestBody }}
{{- range $op.RequestBody.GetSortedProperties }}
	{{ .Title }} {{ if .NeedsPointer }}*{{ end }}{{ .GoType }}
{{- end }}
{{- end }}
}
{{- $successResponse := $op.GetSuccessResponse }}
{{- if and $successResponse (ne $successResponse.StatusCode "204") }}
{{- if or $successResponse.HasProperties $op.CustomHandler }}

{{- /* Generate nested type definitions for inline object properties */ -}}
{{- range $successResponse.GetSortedProperties }}
{{- $field := . }}
{{- if and (eq $field.Type.PrimaryType "object") (gt (len $field.Properties) 0) }}

// {{ $op.ID }}Output{{ $field.Title }} defines the {{ lower $field.Title }} structure in the output.
type {{ $op.ID }}Output{{ $field.Title }} struct {
{{- range $field.GetSortedProperties }}
{{- $nestedField := . }}
{{- if and (eq $nestedField.Type.PrimaryType "array") $nestedField.Items (eq $nestedField.Items.Type.PrimaryType "object") (gt (len $nestedField.Items.Properties) 0) }}
	{{ $nestedField.Title }} []struct {
		{{- range $nestedField.Items.GetSortedProperties }}
		{{ .Title }} {{ .GoType }} `json:"{{ camelCase .JSONTag }}"`
		{{- end }}
	} `json:"{{ camelCase $nestedField.JSONTag }}"`
{{- else }}
	{{ $nestedField.Title }} {{ $nestedField.GoType }} `json:"{{ camelCase $nestedField.JSONTag }}"`
{{- end }}
{{- end }}
}
{{- end }}
{{- end }}

// {{ $op.ID }}Output represents the output for the {{ $op.ID }} operation.
type {{ $op.ID }}Output struct {
{{- range $successResponse.GetSortedProperties }}
{{- $field := . }}
{{- if and (eq $field.Type.PrimaryType "object") (gt (len $field.Properties) 0) }}
	{{ $field.Title }} {{ $op.ID }}Output{{ $field.Title }} `json:"{{ camelCase $field.JSONTag }}"`
{{- else }}
	{{ $field.Title }} {{ if $field.NeedsPointer }}*{{ end }}{{ $.ModelType $field.GoType }} `json:"{{ camelCase $field.JSONTag }}"`
{{- end }}
{{- end }}
}
{{- end }}
{{- end }}

// {{ $op.ID }} defines the executor interface for the {{ $op.ID }} operation.
{{- if and $successResponse (eq $successResponse.StatusCode "204") }}
type {{ $op.ID }} = executor.VoidExecutor[{{ $op.ID }}Input]
{{- else }}
type {{ $op.ID }} = executor.Executor[{{ $op.ID }}Input, {{ $op.ID }}Output]
{{- end }}

{{- if not $op.CustomHandler }}

// {{ $op.ID }}Impl is the default implementation of {{ $op.ID }}.
type {{ $op.ID }}Impl struct {
	repo      {{ $.SchemasPrefix }}{{ $op.Tag }}Repository
{{- if ne $op.Method "GET" }}
	publisher events.Publisher
{{- end }}
}

// New{{ $op.ID }} creates a new {{ $op.ID }} handler.
func New{{ $op.ID }}(
	repo {{ $.SchemasPrefix }}{{ $op.Tag }}Repository,
{{- if ne $op.Method "GET" }}
	publisher events.Publisher,
{{- end }}
) {{ $op.ID }} {
	return &{{ $op.ID }}Impl{
		repo: repo,
{{- if ne $op.Method "GET" }}
		publisher: publisher,
{{- end }}
	}
}

// Execute performs the {{ $op.ID }} operation.
{{- if and $successResponse (eq $successResponse.StatusCode "204") }}
func (h *{{ $op.ID }}Impl) Execute(ctx context.Context, input *{{ $op.ID }}Input) error {
{{- if eq $op.Method "DELETE" }}
	// Delete from repository
	if err := h.repo.Delete(ctx, input.ID); err != nil {
		return fmt.Errorf("failed to delete {{ lower $op.Tag }}: %w", err)
	}

	// Publish domain event
	event := {{ $.SchemasPrefix }}New{{ $op.Tag }}DeletedEvent(input.ID)
	_ = h.publisher.Publish(ctx, event)

	return nil
{{- else }}
	return fmt.Errorf("not implemented")
{{- end }}
}
{{- else }}
func (h *{{ $op.ID }}Impl) Execute(ctx context.Context, input *{{ $op.ID }}Input) (*{{ $op.ID }}Output, error) {
{{- if eq $op.Method "GET" }}
{{- if hasPrefix $op.ID "List" }}
	// Pagination parameters with defaults
	limit := int32(100)
	offset := int32(0)
	if input.Page.Limit != nil {
		limit = *input.Page.Limit
	}
	if input.Page.Offset != nil {
		offset = *input.Page.Offset
	}

	// List from repository
	results, total, err := h.repo.List(ctx, limit, offset)
	if err != nil {
		return nil, fmt.Errorf("failed to list {{ lower $op.Tag }}s: %w", err)
	}

	// Convert pointer slice to value slice
	data := make([]{{ $.SchemasPrefix }}{{ $op.Tag }}, len(results))
	for i, r := range results {
		data[i] = *r
	}

	output := &{{ $op.ID }}Output{
		Data: data,
		Meta: serverschemas.PaginationMeta{
			Total: int32(total),
		},
	}

	return output, nil
{{- else }}
	// Get from repository
	{{- $hasID := false }}
	{{- range $op.GetPathParams }}
	{{- if eq (lower .Title) "id" }}
	{{- $hasID = true }}
	result, err := h.repo.Get(ctx, input.{{ pascalCase .Title }})
	{{- end }}
	{{- end }}
	{{- if not $hasID }}
	result, err := h.repo.Get(ctx, uuid.Nil) // TODO: Get correct ID
	{{- end }}
	if err != nil {
		return nil, fmt.Errorf("failed to get {{ lower $op.Tag }}: %w", err)
	}

	// Map to output
	output := &{{ $op.ID }}Output{
		// TODO: Map result fields to output
	}
	_ = result

	return output, nil
{{- end }}
{{- else if eq $op.Method "POST" }}
	// Create entity
	entity := &{{ $.SchemasPrefix }}{{ $op.Tag }}{
		ID:        uuid.New(),
		CreatedAt: time.Now().UTC(),
		UpdatedAt: time.Now().UTC(),
		// TODO: Map input fields to entity
	}

	// Save to repository
	created, err := h.repo.Create(ctx, entity)
	if err != nil {
		return nil, fmt.Errorf("failed to create {{ lower $op.Tag }}: %w", err)
	}

	// Publish event
	event := {{ $.SchemasPrefix }}New{{ $op.Tag }}CreatedEvent(created.ID)
	_ = h.publisher.Publish(ctx, event)

	// Map to output
	output := &{{ $op.ID }}Output{
		// TODO: Map created entity to output
	}
	_ = created

	return output, nil
{{- else if eq $op.Method "PATCH" }}
	// Get existing entity
	existing, err := h.repo.Get(ctx, input.ID)
	if err != nil {
		return nil, fmt.Errorf("failed to get {{ lower $op.Tag }}: %w", err)
	}

	// Update fields
	// TODO: Map input fields to entity
	existing.UpdatedAt = time.Now().UTC()

	// Save to repository
	updated, err := h.repo.Update(ctx, input.ID, existing)
	if err != nil {
		return nil, fmt.Errorf("failed to update {{ lower $op.Tag }}: %w", err)
	}

	// Publish event
	event := {{ $.SchemasPrefix }}New{{ $op.Tag }}UpdatedEvent(updated.ID)
	_ = h.publisher.Publish(ctx, event)

	// Map to output
	output := &{{ $op.ID }}Output{
		// TODO: Map updated entity to output
	}
	_ = updated

	return output, nil
{{- else }}
	return nil, fmt.Errorf("not implemented")
{{- end }}
}
{{- end }}
{{- end }}
{{- end }}
