// Code generated by mockery; DO NOT EDIT.
// github.com/vektra/mockery
// template: testify

package auth

import (
	"context"
	"time"

	"github.com/google/uuid"
	mock "github.com/stretchr/testify/mock"
)

// NewMockCache creates a new instance of MockCache. It also registers a testing interface on the mock and a cleanup function to assert the mocks expectations.
// The first argument is typically a *testing.T value.
func NewMockCache(t interface {
	mock.TestingT
	Cleanup(func())
}) *MockCache {
	mock := &MockCache{}
	mock.Mock.Test(t)

	t.Cleanup(func() { mock.AssertExpectations(t) })

	return mock
}

// MockCache is an autogenerated mock type for the Cache type
type MockCache struct {
	mock.Mock
}

type MockCache_Expecter struct {
	mock *mock.Mock
}

func (_m *MockCache) EXPECT() *MockCache_Expecter {
	return &MockCache_Expecter{mock: &_m.Mock}
}

// DeleteAccount provides a mock function for the type MockCache
func (_mock *MockCache) DeleteAccount(ctx context.Context, id uuid.UUID) error {
	ret := _mock.Called(ctx, id)

	if len(ret) == 0 {
		panic("no return value specified for DeleteAccount")
	}

	var r0 error
	if returnFunc, ok := ret.Get(0).(func(context.Context, uuid.UUID) error); ok {
		r0 = returnFunc(ctx, id)
	} else {
		r0 = ret.Error(0)
	}
	return r0
}

// MockCache_DeleteAccount_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'DeleteAccount'
type MockCache_DeleteAccount_Call struct {
	*mock.Call
}

// DeleteAccount is a helper method to define mock.On call
//   - ctx context.Context
//   - id uuid.UUID
func (_e *MockCache_Expecter) DeleteAccount(ctx interface{}, id interface{}) *MockCache_DeleteAccount_Call {
	return &MockCache_DeleteAccount_Call{Call: _e.mock.On("DeleteAccount", ctx, id)}
}

func (_c *MockCache_DeleteAccount_Call) Run(run func(ctx context.Context, id uuid.UUID)) *MockCache_DeleteAccount_Call {
	_c.Call.Run(func(args mock.Arguments) {
		var arg0 context.Context
		if args[0] != nil {
			arg0 = args[0].(context.Context)
		}
		var arg1 uuid.UUID
		if args[1] != nil {
			arg1 = args[1].(uuid.UUID)
		}
		run(
			arg0,
			arg1,
		)
	})
	return _c
}

func (_c *MockCache_DeleteAccount_Call) Return(err error) *MockCache_DeleteAccount_Call {
	_c.Call.Return(err)
	return _c
}

func (_c *MockCache_DeleteAccount_Call) RunAndReturn(run func(ctx context.Context, id uuid.UUID) error) *MockCache_DeleteAccount_Call {
	_c.Call.Return(run)
	return _c
}

// DeleteSession provides a mock function for the type MockCache
func (_mock *MockCache) DeleteSession(ctx context.Context, id uuid.UUID) error {
	ret := _mock.Called(ctx, id)

	if len(ret) == 0 {
		panic("no return value specified for DeleteSession")
	}

	var r0 error
	if returnFunc, ok := ret.Get(0).(func(context.Context, uuid.UUID) error); ok {
		r0 = returnFunc(ctx, id)
	} else {
		r0 = ret.Error(0)
	}
	return r0
}

// MockCache_DeleteSession_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'DeleteSession'
type MockCache_DeleteSession_Call struct {
	*mock.Call
}

// DeleteSession is a helper method to define mock.On call
//   - ctx context.Context
//   - id uuid.UUID
func (_e *MockCache_Expecter) DeleteSession(ctx interface{}, id interface{}) *MockCache_DeleteSession_Call {
	return &MockCache_DeleteSession_Call{Call: _e.mock.On("DeleteSession", ctx, id)}
}

func (_c *MockCache_DeleteSession_Call) Run(run func(ctx context.Context, id uuid.UUID)) *MockCache_DeleteSession_Call {
	_c.Call.Run(func(args mock.Arguments) {
		var arg0 context.Context
		if args[0] != nil {
			arg0 = args[0].(context.Context)
		}
		var arg1 uuid.UUID
		if args[1] != nil {
			arg1 = args[1].(uuid.UUID)
		}
		run(
			arg0,
			arg1,
		)
	})
	return _c
}

func (_c *MockCache_DeleteSession_Call) Return(err error) *MockCache_DeleteSession_Call {
	_c.Call.Return(err)
	return _c
}

func (_c *MockCache_DeleteSession_Call) RunAndReturn(run func(ctx context.Context, id uuid.UUID) error) *MockCache_DeleteSession_Call {
	_c.Call.Return(run)
	return _c
}

// DeleteSessionByToken provides a mock function for the type MockCache
func (_mock *MockCache) DeleteSessionByToken(ctx context.Context, token string) error {
	ret := _mock.Called(ctx, token)

	if len(ret) == 0 {
		panic("no return value specified for DeleteSessionByToken")
	}

	var r0 error
	if returnFunc, ok := ret.Get(0).(func(context.Context, string) error); ok {
		r0 = returnFunc(ctx, token)
	} else {
		r0 = ret.Error(0)
	}
	return r0
}

// MockCache_DeleteSessionByToken_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'DeleteSessionByToken'
type MockCache_DeleteSessionByToken_Call struct {
	*mock.Call
}

// DeleteSessionByToken is a helper method to define mock.On call
//   - ctx context.Context
//   - token string
func (_e *MockCache_Expecter) DeleteSessionByToken(ctx interface{}, token interface{}) *MockCache_DeleteSessionByToken_Call {
	return &MockCache_DeleteSessionByToken_Call{Call: _e.mock.On("DeleteSessionByToken", ctx, token)}
}

func (_c *MockCache_DeleteSessionByToken_Call) Run(run func(ctx context.Context, token string)) *MockCache_DeleteSessionByToken_Call {
	_c.Call.Run(func(args mock.Arguments) {
		var arg0 context.Context
		if args[0] != nil {
			arg0 = args[0].(context.Context)
		}
		var arg1 string
		if args[1] != nil {
			arg1 = args[1].(string)
		}
		run(
			arg0,
			arg1,
		)
	})
	return _c
}

func (_c *MockCache_DeleteSessionByToken_Call) Return(err error) *MockCache_DeleteSessionByToken_Call {
	_c.Call.Return(err)
	return _c
}

func (_c *MockCache_DeleteSessionByToken_Call) RunAndReturn(run func(ctx context.Context, token string) error) *MockCache_DeleteSessionByToken_Call {
	_c.Call.Return(run)
	return _c
}

// DeleteUserSessions provides a mock function for the type MockCache
func (_mock *MockCache) DeleteUserSessions(ctx context.Context, userID uuid.UUID) error {
	ret := _mock.Called(ctx, userID)

	if len(ret) == 0 {
		panic("no return value specified for DeleteUserSessions")
	}

	var r0 error
	if returnFunc, ok := ret.Get(0).(func(context.Context, uuid.UUID) error); ok {
		r0 = returnFunc(ctx, userID)
	} else {
		r0 = ret.Error(0)
	}
	return r0
}

// MockCache_DeleteUserSessions_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'DeleteUserSessions'
type MockCache_DeleteUserSessions_Call struct {
	*mock.Call
}

// DeleteUserSessions is a helper method to define mock.On call
//   - ctx context.Context
//   - userID uuid.UUID
func (_e *MockCache_Expecter) DeleteUserSessions(ctx interface{}, userID interface{}) *MockCache_DeleteUserSessions_Call {
	return &MockCache_DeleteUserSessions_Call{Call: _e.mock.On("DeleteUserSessions", ctx, userID)}
}

func (_c *MockCache_DeleteUserSessions_Call) Run(run func(ctx context.Context, userID uuid.UUID)) *MockCache_DeleteUserSessions_Call {
	_c.Call.Run(func(args mock.Arguments) {
		var arg0 context.Context
		if args[0] != nil {
			arg0 = args[0].(context.Context)
		}
		var arg1 uuid.UUID
		if args[1] != nil {
			arg1 = args[1].(uuid.UUID)
		}
		run(
			arg0,
			arg1,
		)
	})
	return _c
}

func (_c *MockCache_DeleteUserSessions_Call) Return(err error) *MockCache_DeleteUserSessions_Call {
	_c.Call.Return(err)
	return _c
}

func (_c *MockCache_DeleteUserSessions_Call) RunAndReturn(run func(ctx context.Context, userID uuid.UUID) error) *MockCache_DeleteUserSessions_Call {
	_c.Call.Return(run)
	return _c
}

// FlushAll provides a mock function for the type MockCache
func (_mock *MockCache) FlushAll(ctx context.Context) error {
	ret := _mock.Called(ctx)

	if len(ret) == 0 {
		panic("no return value specified for FlushAll")
	}

	var r0 error
	if returnFunc, ok := ret.Get(0).(func(context.Context) error); ok {
		r0 = returnFunc(ctx)
	} else {
		r0 = ret.Error(0)
	}
	return r0
}

// MockCache_FlushAll_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'FlushAll'
type MockCache_FlushAll_Call struct {
	*mock.Call
}

// FlushAll is a helper method to define mock.On call
//   - ctx context.Context
func (_e *MockCache_Expecter) FlushAll(ctx interface{}) *MockCache_FlushAll_Call {
	return &MockCache_FlushAll_Call{Call: _e.mock.On("FlushAll", ctx)}
}

func (_c *MockCache_FlushAll_Call) Run(run func(ctx context.Context)) *MockCache_FlushAll_Call {
	_c.Call.Run(func(args mock.Arguments) {
		var arg0 context.Context
		if args[0] != nil {
			arg0 = args[0].(context.Context)
		}
		run(
			arg0,
		)
	})
	return _c
}

func (_c *MockCache_FlushAll_Call) Return(err error) *MockCache_FlushAll_Call {
	_c.Call.Return(err)
	return _c
}

func (_c *MockCache_FlushAll_Call) RunAndReturn(run func(ctx context.Context) error) *MockCache_FlushAll_Call {
	_c.Call.Return(run)
	return _c
}

// GetAccount provides a mock function for the type MockCache
func (_mock *MockCache) GetAccount(ctx context.Context, id uuid.UUID) (*Account, error) {
	ret := _mock.Called(ctx, id)

	if len(ret) == 0 {
		panic("no return value specified for GetAccount")
	}

	var r0 *Account
	var r1 error
	if returnFunc, ok := ret.Get(0).(func(context.Context, uuid.UUID) (*Account, error)); ok {
		return returnFunc(ctx, id)
	}
	if returnFunc, ok := ret.Get(0).(func(context.Context, uuid.UUID) *Account); ok {
		r0 = returnFunc(ctx, id)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*Account)
		}
	}
	if returnFunc, ok := ret.Get(1).(func(context.Context, uuid.UUID) error); ok {
		r1 = returnFunc(ctx, id)
	} else {
		r1 = ret.Error(1)
	}
	return r0, r1
}

// MockCache_GetAccount_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'GetAccount'
type MockCache_GetAccount_Call struct {
	*mock.Call
}

// GetAccount is a helper method to define mock.On call
//   - ctx context.Context
//   - id uuid.UUID
func (_e *MockCache_Expecter) GetAccount(ctx interface{}, id interface{}) *MockCache_GetAccount_Call {
	return &MockCache_GetAccount_Call{Call: _e.mock.On("GetAccount", ctx, id)}
}

func (_c *MockCache_GetAccount_Call) Run(run func(ctx context.Context, id uuid.UUID)) *MockCache_GetAccount_Call {
	_c.Call.Run(func(args mock.Arguments) {
		var arg0 context.Context
		if args[0] != nil {
			arg0 = args[0].(context.Context)
		}
		var arg1 uuid.UUID
		if args[1] != nil {
			arg1 = args[1].(uuid.UUID)
		}
		run(
			arg0,
			arg1,
		)
	})
	return _c
}

func (_c *MockCache_GetAccount_Call) Return(account *Account, err error) *MockCache_GetAccount_Call {
	_c.Call.Return(account, err)
	return _c
}

func (_c *MockCache_GetAccount_Call) RunAndReturn(run func(ctx context.Context, id uuid.UUID) (*Account, error)) *MockCache_GetAccount_Call {
	_c.Call.Return(run)
	return _c
}

// GetSession provides a mock function for the type MockCache
func (_mock *MockCache) GetSession(ctx context.Context, id uuid.UUID) (*Session, error) {
	ret := _mock.Called(ctx, id)

	if len(ret) == 0 {
		panic("no return value specified for GetSession")
	}

	var r0 *Session
	var r1 error
	if returnFunc, ok := ret.Get(0).(func(context.Context, uuid.UUID) (*Session, error)); ok {
		return returnFunc(ctx, id)
	}
	if returnFunc, ok := ret.Get(0).(func(context.Context, uuid.UUID) *Session); ok {
		r0 = returnFunc(ctx, id)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*Session)
		}
	}
	if returnFunc, ok := ret.Get(1).(func(context.Context, uuid.UUID) error); ok {
		r1 = returnFunc(ctx, id)
	} else {
		r1 = ret.Error(1)
	}
	return r0, r1
}

// MockCache_GetSession_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'GetSession'
type MockCache_GetSession_Call struct {
	*mock.Call
}

// GetSession is a helper method to define mock.On call
//   - ctx context.Context
//   - id uuid.UUID
func (_e *MockCache_Expecter) GetSession(ctx interface{}, id interface{}) *MockCache_GetSession_Call {
	return &MockCache_GetSession_Call{Call: _e.mock.On("GetSession", ctx, id)}
}

func (_c *MockCache_GetSession_Call) Run(run func(ctx context.Context, id uuid.UUID)) *MockCache_GetSession_Call {
	_c.Call.Run(func(args mock.Arguments) {
		var arg0 context.Context
		if args[0] != nil {
			arg0 = args[0].(context.Context)
		}
		var arg1 uuid.UUID
		if args[1] != nil {
			arg1 = args[1].(uuid.UUID)
		}
		run(
			arg0,
			arg1,
		)
	})
	return _c
}

func (_c *MockCache_GetSession_Call) Return(session *Session, err error) *MockCache_GetSession_Call {
	_c.Call.Return(session, err)
	return _c
}

func (_c *MockCache_GetSession_Call) RunAndReturn(run func(ctx context.Context, id uuid.UUID) (*Session, error)) *MockCache_GetSession_Call {
	_c.Call.Return(run)
	return _c
}

// GetSessionByToken provides a mock function for the type MockCache
func (_mock *MockCache) GetSessionByToken(ctx context.Context, token string) (*Session, error) {
	ret := _mock.Called(ctx, token)

	if len(ret) == 0 {
		panic("no return value specified for GetSessionByToken")
	}

	var r0 *Session
	var r1 error
	if returnFunc, ok := ret.Get(0).(func(context.Context, string) (*Session, error)); ok {
		return returnFunc(ctx, token)
	}
	if returnFunc, ok := ret.Get(0).(func(context.Context, string) *Session); ok {
		r0 = returnFunc(ctx, token)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*Session)
		}
	}
	if returnFunc, ok := ret.Get(1).(func(context.Context, string) error); ok {
		r1 = returnFunc(ctx, token)
	} else {
		r1 = ret.Error(1)
	}
	return r0, r1
}

// MockCache_GetSessionByToken_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'GetSessionByToken'
type MockCache_GetSessionByToken_Call struct {
	*mock.Call
}

// GetSessionByToken is a helper method to define mock.On call
//   - ctx context.Context
//   - token string
func (_e *MockCache_Expecter) GetSessionByToken(ctx interface{}, token interface{}) *MockCache_GetSessionByToken_Call {
	return &MockCache_GetSessionByToken_Call{Call: _e.mock.On("GetSessionByToken", ctx, token)}
}

func (_c *MockCache_GetSessionByToken_Call) Run(run func(ctx context.Context, token string)) *MockCache_GetSessionByToken_Call {
	_c.Call.Run(func(args mock.Arguments) {
		var arg0 context.Context
		if args[0] != nil {
			arg0 = args[0].(context.Context)
		}
		var arg1 string
		if args[1] != nil {
			arg1 = args[1].(string)
		}
		run(
			arg0,
			arg1,
		)
	})
	return _c
}

func (_c *MockCache_GetSessionByToken_Call) Return(session *Session, err error) *MockCache_GetSessionByToken_Call {
	_c.Call.Return(session, err)
	return _c
}

func (_c *MockCache_GetSessionByToken_Call) RunAndReturn(run func(ctx context.Context, token string) (*Session, error)) *MockCache_GetSessionByToken_Call {
	_c.Call.Return(run)
	return _c
}

// SetAccount provides a mock function for the type MockCache
func (_mock *MockCache) SetAccount(ctx context.Context, entity *Account, ttl time.Duration) error {
	ret := _mock.Called(ctx, entity, ttl)

	if len(ret) == 0 {
		panic("no return value specified for SetAccount")
	}

	var r0 error
	if returnFunc, ok := ret.Get(0).(func(context.Context, *Account, time.Duration) error); ok {
		r0 = returnFunc(ctx, entity, ttl)
	} else {
		r0 = ret.Error(0)
	}
	return r0
}

// MockCache_SetAccount_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'SetAccount'
type MockCache_SetAccount_Call struct {
	*mock.Call
}

// SetAccount is a helper method to define mock.On call
//   - ctx context.Context
//   - entity *Account
//   - ttl time.Duration
func (_e *MockCache_Expecter) SetAccount(ctx interface{}, entity interface{}, ttl interface{}) *MockCache_SetAccount_Call {
	return &MockCache_SetAccount_Call{Call: _e.mock.On("SetAccount", ctx, entity, ttl)}
}

func (_c *MockCache_SetAccount_Call) Run(run func(ctx context.Context, entity *Account, ttl time.Duration)) *MockCache_SetAccount_Call {
	_c.Call.Run(func(args mock.Arguments) {
		var arg0 context.Context
		if args[0] != nil {
			arg0 = args[0].(context.Context)
		}
		var arg1 *Account
		if args[1] != nil {
			arg1 = args[1].(*Account)
		}
		var arg2 time.Duration
		if args[2] != nil {
			arg2 = args[2].(time.Duration)
		}
		run(
			arg0,
			arg1,
			arg2,
		)
	})
	return _c
}

func (_c *MockCache_SetAccount_Call) Return(err error) *MockCache_SetAccount_Call {
	_c.Call.Return(err)
	return _c
}

func (_c *MockCache_SetAccount_Call) RunAndReturn(run func(ctx context.Context, entity *Account, ttl time.Duration) error) *MockCache_SetAccount_Call {
	_c.Call.Return(run)
	return _c
}

// SetSession provides a mock function for the type MockCache
func (_mock *MockCache) SetSession(ctx context.Context, entity *Session, ttl time.Duration) error {
	ret := _mock.Called(ctx, entity, ttl)

	if len(ret) == 0 {
		panic("no return value specified for SetSession")
	}

	var r0 error
	if returnFunc, ok := ret.Get(0).(func(context.Context, *Session, time.Duration) error); ok {
		r0 = returnFunc(ctx, entity, ttl)
	} else {
		r0 = ret.Error(0)
	}
	return r0
}

// MockCache_SetSession_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'SetSession'
type MockCache_SetSession_Call struct {
	*mock.Call
}

// SetSession is a helper method to define mock.On call
//   - ctx context.Context
//   - entity *Session
//   - ttl time.Duration
func (_e *MockCache_Expecter) SetSession(ctx interface{}, entity interface{}, ttl interface{}) *MockCache_SetSession_Call {
	return &MockCache_SetSession_Call{Call: _e.mock.On("SetSession", ctx, entity, ttl)}
}

func (_c *MockCache_SetSession_Call) Run(run func(ctx context.Context, entity *Session, ttl time.Duration)) *MockCache_SetSession_Call {
	_c.Call.Run(func(args mock.Arguments) {
		var arg0 context.Context
		if args[0] != nil {
			arg0 = args[0].(context.Context)
		}
		var arg1 *Session
		if args[1] != nil {
			arg1 = args[1].(*Session)
		}
		var arg2 time.Duration
		if args[2] != nil {
			arg2 = args[2].(time.Duration)
		}
		run(
			arg0,
			arg1,
			arg2,
		)
	})
	return _c
}

func (_c *MockCache_SetSession_Call) Return(err error) *MockCache_SetSession_Call {
	_c.Call.Return(err)
	return _c
}

func (_c *MockCache_SetSession_Call) RunAndReturn(run func(ctx context.Context, entity *Session, ttl time.Duration) error) *MockCache_SetSession_Call {
	_c.Call.Return(run)
	return _c
}

// SetSessionByToken provides a mock function for the type MockCache
func (_mock *MockCache) SetSessionByToken(ctx context.Context, token string, entity *Session, ttl time.Duration) error {
	ret := _mock.Called(ctx, token, entity, ttl)

	if len(ret) == 0 {
		panic("no return value specified for SetSessionByToken")
	}

	var r0 error
	if returnFunc, ok := ret.Get(0).(func(context.Context, string, *Session, time.Duration) error); ok {
		r0 = returnFunc(ctx, token, entity, ttl)
	} else {
		r0 = ret.Error(0)
	}
	return r0
}

// MockCache_SetSessionByToken_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'SetSessionByToken'
type MockCache_SetSessionByToken_Call struct {
	*mock.Call
}

// SetSessionByToken is a helper method to define mock.On call
//   - ctx context.Context
//   - token string
//   - entity *Session
//   - ttl time.Duration
func (_e *MockCache_Expecter) SetSessionByToken(ctx interface{}, token interface{}, entity interface{}, ttl interface{}) *MockCache_SetSessionByToken_Call {
	return &MockCache_SetSessionByToken_Call{Call: _e.mock.On("SetSessionByToken", ctx, token, entity, ttl)}
}

func (_c *MockCache_SetSessionByToken_Call) Run(run func(ctx context.Context, token string, entity *Session, ttl time.Duration)) *MockCache_SetSessionByToken_Call {
	_c.Call.Run(func(args mock.Arguments) {
		var arg0 context.Context
		if args[0] != nil {
			arg0 = args[0].(context.Context)
		}
		var arg1 string
		if args[1] != nil {
			arg1 = args[1].(string)
		}
		var arg2 *Session
		if args[2] != nil {
			arg2 = args[2].(*Session)
		}
		var arg3 time.Duration
		if args[3] != nil {
			arg3 = args[3].(time.Duration)
		}
		run(
			arg0,
			arg1,
			arg2,
			arg3,
		)
	})
	return _c
}

func (_c *MockCache_SetSessionByToken_Call) Return(err error) *MockCache_SetSessionByToken_Call {
	_c.Call.Return(err)
	return _c
}

func (_c *MockCache_SetSessionByToken_Call) RunAndReturn(run func(ctx context.Context, token string, entity *Session, ttl time.Duration) error) *MockCache_SetSessionByToken_Call {
	_c.Call.Return(run)
	return _c
}

// NewMockEventPublisher creates a new instance of MockEventPublisher. It also registers a testing interface on the mock and a cleanup function to assert the mocks expectations.
// The first argument is typically a *testing.T value.
func NewMockEventPublisher(t interface {
	mock.TestingT
	Cleanup(func())
}) *MockEventPublisher {
	mock := &MockEventPublisher{}
	mock.Mock.Test(t)

	t.Cleanup(func() { mock.AssertExpectations(t) })

	return mock
}

// MockEventPublisher is an autogenerated mock type for the EventPublisher type
type MockEventPublisher struct {
	mock.Mock
}

type MockEventPublisher_Expecter struct {
	mock *mock.Mock
}

func (_m *MockEventPublisher) EXPECT() *MockEventPublisher_Expecter {
	return &MockEventPublisher_Expecter{mock: &_m.Mock}
}

// PublishAccountCreated provides a mock function for the type MockEventPublisher
func (_mock *MockEventPublisher) PublishAccountCreated(ctx context.Context, entity *Account) error {
	ret := _mock.Called(ctx, entity)

	if len(ret) == 0 {
		panic("no return value specified for PublishAccountCreated")
	}

	var r0 error
	if returnFunc, ok := ret.Get(0).(func(context.Context, *Account) error); ok {
		r0 = returnFunc(ctx, entity)
	} else {
		r0 = ret.Error(0)
	}
	return r0
}

// MockEventPublisher_PublishAccountCreated_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'PublishAccountCreated'
type MockEventPublisher_PublishAccountCreated_Call struct {
	*mock.Call
}

// PublishAccountCreated is a helper method to define mock.On call
//   - ctx context.Context
//   - entity *Account
func (_e *MockEventPublisher_Expecter) PublishAccountCreated(ctx interface{}, entity interface{}) *MockEventPublisher_PublishAccountCreated_Call {
	return &MockEventPublisher_PublishAccountCreated_Call{Call: _e.mock.On("PublishAccountCreated", ctx, entity)}
}

func (_c *MockEventPublisher_PublishAccountCreated_Call) Run(run func(ctx context.Context, entity *Account)) *MockEventPublisher_PublishAccountCreated_Call {
	_c.Call.Run(func(args mock.Arguments) {
		var arg0 context.Context
		if args[0] != nil {
			arg0 = args[0].(context.Context)
		}
		var arg1 *Account
		if args[1] != nil {
			arg1 = args[1].(*Account)
		}
		run(
			arg0,
			arg1,
		)
	})
	return _c
}

func (_c *MockEventPublisher_PublishAccountCreated_Call) Return(err error) *MockEventPublisher_PublishAccountCreated_Call {
	_c.Call.Return(err)
	return _c
}

func (_c *MockEventPublisher_PublishAccountCreated_Call) RunAndReturn(run func(ctx context.Context, entity *Account) error) *MockEventPublisher_PublishAccountCreated_Call {
	_c.Call.Return(run)
	return _c
}

// PublishAccountDeleted provides a mock function for the type MockEventPublisher
func (_mock *MockEventPublisher) PublishAccountDeleted(ctx context.Context, entity *Account) error {
	ret := _mock.Called(ctx, entity)

	if len(ret) == 0 {
		panic("no return value specified for PublishAccountDeleted")
	}

	var r0 error
	if returnFunc, ok := ret.Get(0).(func(context.Context, *Account) error); ok {
		r0 = returnFunc(ctx, entity)
	} else {
		r0 = ret.Error(0)
	}
	return r0
}

// MockEventPublisher_PublishAccountDeleted_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'PublishAccountDeleted'
type MockEventPublisher_PublishAccountDeleted_Call struct {
	*mock.Call
}

// PublishAccountDeleted is a helper method to define mock.On call
//   - ctx context.Context
//   - entity *Account
func (_e *MockEventPublisher_Expecter) PublishAccountDeleted(ctx interface{}, entity interface{}) *MockEventPublisher_PublishAccountDeleted_Call {
	return &MockEventPublisher_PublishAccountDeleted_Call{Call: _e.mock.On("PublishAccountDeleted", ctx, entity)}
}

func (_c *MockEventPublisher_PublishAccountDeleted_Call) Run(run func(ctx context.Context, entity *Account)) *MockEventPublisher_PublishAccountDeleted_Call {
	_c.Call.Run(func(args mock.Arguments) {
		var arg0 context.Context
		if args[0] != nil {
			arg0 = args[0].(context.Context)
		}
		var arg1 *Account
		if args[1] != nil {
			arg1 = args[1].(*Account)
		}
		run(
			arg0,
			arg1,
		)
	})
	return _c
}

func (_c *MockEventPublisher_PublishAccountDeleted_Call) Return(err error) *MockEventPublisher_PublishAccountDeleted_Call {
	_c.Call.Return(err)
	return _c
}

func (_c *MockEventPublisher_PublishAccountDeleted_Call) RunAndReturn(run func(ctx context.Context, entity *Account) error) *MockEventPublisher_PublishAccountDeleted_Call {
	_c.Call.Return(run)
	return _c
}

// PublishAccountLinked provides a mock function for the type MockEventPublisher
func (_mock *MockEventPublisher) PublishAccountLinked(ctx context.Context, entity *Account) error {
	ret := _mock.Called(ctx, entity)

	if len(ret) == 0 {
		panic("no return value specified for PublishAccountLinked")
	}

	var r0 error
	if returnFunc, ok := ret.Get(0).(func(context.Context, *Account) error); ok {
		r0 = returnFunc(ctx, entity)
	} else {
		r0 = ret.Error(0)
	}
	return r0
}

// MockEventPublisher_PublishAccountLinked_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'PublishAccountLinked'
type MockEventPublisher_PublishAccountLinked_Call struct {
	*mock.Call
}

// PublishAccountLinked is a helper method to define mock.On call
//   - ctx context.Context
//   - entity *Account
func (_e *MockEventPublisher_Expecter) PublishAccountLinked(ctx interface{}, entity interface{}) *MockEventPublisher_PublishAccountLinked_Call {
	return &MockEventPublisher_PublishAccountLinked_Call{Call: _e.mock.On("PublishAccountLinked", ctx, entity)}
}

func (_c *MockEventPublisher_PublishAccountLinked_Call) Run(run func(ctx context.Context, entity *Account)) *MockEventPublisher_PublishAccountLinked_Call {
	_c.Call.Run(func(args mock.Arguments) {
		var arg0 context.Context
		if args[0] != nil {
			arg0 = args[0].(context.Context)
		}
		var arg1 *Account
		if args[1] != nil {
			arg1 = args[1].(*Account)
		}
		run(
			arg0,
			arg1,
		)
	})
	return _c
}

func (_c *MockEventPublisher_PublishAccountLinked_Call) Return(err error) *MockEventPublisher_PublishAccountLinked_Call {
	_c.Call.Return(err)
	return _c
}

func (_c *MockEventPublisher_PublishAccountLinked_Call) RunAndReturn(run func(ctx context.Context, entity *Account) error) *MockEventPublisher_PublishAccountLinked_Call {
	_c.Call.Return(run)
	return _c
}

// PublishAccountUnlinked provides a mock function for the type MockEventPublisher
func (_mock *MockEventPublisher) PublishAccountUnlinked(ctx context.Context, entity *Account) error {
	ret := _mock.Called(ctx, entity)

	if len(ret) == 0 {
		panic("no return value specified for PublishAccountUnlinked")
	}

	var r0 error
	if returnFunc, ok := ret.Get(0).(func(context.Context, *Account) error); ok {
		r0 = returnFunc(ctx, entity)
	} else {
		r0 = ret.Error(0)
	}
	return r0
}

// MockEventPublisher_PublishAccountUnlinked_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'PublishAccountUnlinked'
type MockEventPublisher_PublishAccountUnlinked_Call struct {
	*mock.Call
}

// PublishAccountUnlinked is a helper method to define mock.On call
//   - ctx context.Context
//   - entity *Account
func (_e *MockEventPublisher_Expecter) PublishAccountUnlinked(ctx interface{}, entity interface{}) *MockEventPublisher_PublishAccountUnlinked_Call {
	return &MockEventPublisher_PublishAccountUnlinked_Call{Call: _e.mock.On("PublishAccountUnlinked", ctx, entity)}
}

func (_c *MockEventPublisher_PublishAccountUnlinked_Call) Run(run func(ctx context.Context, entity *Account)) *MockEventPublisher_PublishAccountUnlinked_Call {
	_c.Call.Run(func(args mock.Arguments) {
		var arg0 context.Context
		if args[0] != nil {
			arg0 = args[0].(context.Context)
		}
		var arg1 *Account
		if args[1] != nil {
			arg1 = args[1].(*Account)
		}
		run(
			arg0,
			arg1,
		)
	})
	return _c
}

func (_c *MockEventPublisher_PublishAccountUnlinked_Call) Return(err error) *MockEventPublisher_PublishAccountUnlinked_Call {
	_c.Call.Return(err)
	return _c
}

func (_c *MockEventPublisher_PublishAccountUnlinked_Call) RunAndReturn(run func(ctx context.Context, entity *Account) error) *MockEventPublisher_PublishAccountUnlinked_Call {
	_c.Call.Return(run)
	return _c
}

// PublishAccountUpdated provides a mock function for the type MockEventPublisher
func (_mock *MockEventPublisher) PublishAccountUpdated(ctx context.Context, entity *Account) error {
	ret := _mock.Called(ctx, entity)

	if len(ret) == 0 {
		panic("no return value specified for PublishAccountUpdated")
	}

	var r0 error
	if returnFunc, ok := ret.Get(0).(func(context.Context, *Account) error); ok {
		r0 = returnFunc(ctx, entity)
	} else {
		r0 = ret.Error(0)
	}
	return r0
}

// MockEventPublisher_PublishAccountUpdated_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'PublishAccountUpdated'
type MockEventPublisher_PublishAccountUpdated_Call struct {
	*mock.Call
}

// PublishAccountUpdated is a helper method to define mock.On call
//   - ctx context.Context
//   - entity *Account
func (_e *MockEventPublisher_Expecter) PublishAccountUpdated(ctx interface{}, entity interface{}) *MockEventPublisher_PublishAccountUpdated_Call {
	return &MockEventPublisher_PublishAccountUpdated_Call{Call: _e.mock.On("PublishAccountUpdated", ctx, entity)}
}

func (_c *MockEventPublisher_PublishAccountUpdated_Call) Run(run func(ctx context.Context, entity *Account)) *MockEventPublisher_PublishAccountUpdated_Call {
	_c.Call.Run(func(args mock.Arguments) {
		var arg0 context.Context
		if args[0] != nil {
			arg0 = args[0].(context.Context)
		}
		var arg1 *Account
		if args[1] != nil {
			arg1 = args[1].(*Account)
		}
		run(
			arg0,
			arg1,
		)
	})
	return _c
}

func (_c *MockEventPublisher_PublishAccountUpdated_Call) Return(err error) *MockEventPublisher_PublishAccountUpdated_Call {
	_c.Call.Return(err)
	return _c
}

func (_c *MockEventPublisher_PublishAccountUpdated_Call) RunAndReturn(run func(ctx context.Context, entity *Account) error) *MockEventPublisher_PublishAccountUpdated_Call {
	_c.Call.Return(run)
	return _c
}

// PublishSessionCreated provides a mock function for the type MockEventPublisher
func (_mock *MockEventPublisher) PublishSessionCreated(ctx context.Context, entity *Session) error {
	ret := _mock.Called(ctx, entity)

	if len(ret) == 0 {
		panic("no return value specified for PublishSessionCreated")
	}

	var r0 error
	if returnFunc, ok := ret.Get(0).(func(context.Context, *Session) error); ok {
		r0 = returnFunc(ctx, entity)
	} else {
		r0 = ret.Error(0)
	}
	return r0
}

// MockEventPublisher_PublishSessionCreated_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'PublishSessionCreated'
type MockEventPublisher_PublishSessionCreated_Call struct {
	*mock.Call
}

// PublishSessionCreated is a helper method to define mock.On call
//   - ctx context.Context
//   - entity *Session
func (_e *MockEventPublisher_Expecter) PublishSessionCreated(ctx interface{}, entity interface{}) *MockEventPublisher_PublishSessionCreated_Call {
	return &MockEventPublisher_PublishSessionCreated_Call{Call: _e.mock.On("PublishSessionCreated", ctx, entity)}
}

func (_c *MockEventPublisher_PublishSessionCreated_Call) Run(run func(ctx context.Context, entity *Session)) *MockEventPublisher_PublishSessionCreated_Call {
	_c.Call.Run(func(args mock.Arguments) {
		var arg0 context.Context
		if args[0] != nil {
			arg0 = args[0].(context.Context)
		}
		var arg1 *Session
		if args[1] != nil {
			arg1 = args[1].(*Session)
		}
		run(
			arg0,
			arg1,
		)
	})
	return _c
}

func (_c *MockEventPublisher_PublishSessionCreated_Call) Return(err error) *MockEventPublisher_PublishSessionCreated_Call {
	_c.Call.Return(err)
	return _c
}

func (_c *MockEventPublisher_PublishSessionCreated_Call) RunAndReturn(run func(ctx context.Context, entity *Session) error) *MockEventPublisher_PublishSessionCreated_Call {
	_c.Call.Return(run)
	return _c
}

// PublishSessionDeleted provides a mock function for the type MockEventPublisher
func (_mock *MockEventPublisher) PublishSessionDeleted(ctx context.Context, entity *Session) error {
	ret := _mock.Called(ctx, entity)

	if len(ret) == 0 {
		panic("no return value specified for PublishSessionDeleted")
	}

	var r0 error
	if returnFunc, ok := ret.Get(0).(func(context.Context, *Session) error); ok {
		r0 = returnFunc(ctx, entity)
	} else {
		r0 = ret.Error(0)
	}
	return r0
}

// MockEventPublisher_PublishSessionDeleted_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'PublishSessionDeleted'
type MockEventPublisher_PublishSessionDeleted_Call struct {
	*mock.Call
}

// PublishSessionDeleted is a helper method to define mock.On call
//   - ctx context.Context
//   - entity *Session
func (_e *MockEventPublisher_Expecter) PublishSessionDeleted(ctx interface{}, entity interface{}) *MockEventPublisher_PublishSessionDeleted_Call {
	return &MockEventPublisher_PublishSessionDeleted_Call{Call: _e.mock.On("PublishSessionDeleted", ctx, entity)}
}

func (_c *MockEventPublisher_PublishSessionDeleted_Call) Run(run func(ctx context.Context, entity *Session)) *MockEventPublisher_PublishSessionDeleted_Call {
	_c.Call.Run(func(args mock.Arguments) {
		var arg0 context.Context
		if args[0] != nil {
			arg0 = args[0].(context.Context)
		}
		var arg1 *Session
		if args[1] != nil {
			arg1 = args[1].(*Session)
		}
		run(
			arg0,
			arg1,
		)
	})
	return _c
}

func (_c *MockEventPublisher_PublishSessionDeleted_Call) Return(err error) *MockEventPublisher_PublishSessionDeleted_Call {
	_c.Call.Return(err)
	return _c
}

func (_c *MockEventPublisher_PublishSessionDeleted_Call) RunAndReturn(run func(ctx context.Context, entity *Session) error) *MockEventPublisher_PublishSessionDeleted_Call {
	_c.Call.Return(run)
	return _c
}

// PublishSessionExpired provides a mock function for the type MockEventPublisher
func (_mock *MockEventPublisher) PublishSessionExpired(ctx context.Context, entity *Session) error {
	ret := _mock.Called(ctx, entity)

	if len(ret) == 0 {
		panic("no return value specified for PublishSessionExpired")
	}

	var r0 error
	if returnFunc, ok := ret.Get(0).(func(context.Context, *Session) error); ok {
		r0 = returnFunc(ctx, entity)
	} else {
		r0 = ret.Error(0)
	}
	return r0
}

// MockEventPublisher_PublishSessionExpired_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'PublishSessionExpired'
type MockEventPublisher_PublishSessionExpired_Call struct {
	*mock.Call
}

// PublishSessionExpired is a helper method to define mock.On call
//   - ctx context.Context
//   - entity *Session
func (_e *MockEventPublisher_Expecter) PublishSessionExpired(ctx interface{}, entity interface{}) *MockEventPublisher_PublishSessionExpired_Call {
	return &MockEventPublisher_PublishSessionExpired_Call{Call: _e.mock.On("PublishSessionExpired", ctx, entity)}
}

func (_c *MockEventPublisher_PublishSessionExpired_Call) Run(run func(ctx context.Context, entity *Session)) *MockEventPublisher_PublishSessionExpired_Call {
	_c.Call.Run(func(args mock.Arguments) {
		var arg0 context.Context
		if args[0] != nil {
			arg0 = args[0].(context.Context)
		}
		var arg1 *Session
		if args[1] != nil {
			arg1 = args[1].(*Session)
		}
		run(
			arg0,
			arg1,
		)
	})
	return _c
}

func (_c *MockEventPublisher_PublishSessionExpired_Call) Return(err error) *MockEventPublisher_PublishSessionExpired_Call {
	_c.Call.Return(err)
	return _c
}

func (_c *MockEventPublisher_PublishSessionExpired_Call) RunAndReturn(run func(ctx context.Context, entity *Session) error) *MockEventPublisher_PublishSessionExpired_Call {
	_c.Call.Return(run)
	return _c
}

// PublishSessionRefreshed provides a mock function for the type MockEventPublisher
func (_mock *MockEventPublisher) PublishSessionRefreshed(ctx context.Context, entity *Session) error {
	ret := _mock.Called(ctx, entity)

	if len(ret) == 0 {
		panic("no return value specified for PublishSessionRefreshed")
	}

	var r0 error
	if returnFunc, ok := ret.Get(0).(func(context.Context, *Session) error); ok {
		r0 = returnFunc(ctx, entity)
	} else {
		r0 = ret.Error(0)
	}
	return r0
}

// MockEventPublisher_PublishSessionRefreshed_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'PublishSessionRefreshed'
type MockEventPublisher_PublishSessionRefreshed_Call struct {
	*mock.Call
}

// PublishSessionRefreshed is a helper method to define mock.On call
//   - ctx context.Context
//   - entity *Session
func (_e *MockEventPublisher_Expecter) PublishSessionRefreshed(ctx interface{}, entity interface{}) *MockEventPublisher_PublishSessionRefreshed_Call {
	return &MockEventPublisher_PublishSessionRefreshed_Call{Call: _e.mock.On("PublishSessionRefreshed", ctx, entity)}
}

func (_c *MockEventPublisher_PublishSessionRefreshed_Call) Run(run func(ctx context.Context, entity *Session)) *MockEventPublisher_PublishSessionRefreshed_Call {
	_c.Call.Run(func(args mock.Arguments) {
		var arg0 context.Context
		if args[0] != nil {
			arg0 = args[0].(context.Context)
		}
		var arg1 *Session
		if args[1] != nil {
			arg1 = args[1].(*Session)
		}
		run(
			arg0,
			arg1,
		)
	})
	return _c
}

func (_c *MockEventPublisher_PublishSessionRefreshed_Call) Return(err error) *MockEventPublisher_PublishSessionRefreshed_Call {
	_c.Call.Return(err)
	return _c
}

func (_c *MockEventPublisher_PublishSessionRefreshed_Call) RunAndReturn(run func(ctx context.Context, entity *Session) error) *MockEventPublisher_PublishSessionRefreshed_Call {
	_c.Call.Return(run)
	return _c
}

// NewMockRepository creates a new instance of MockRepository. It also registers a testing interface on the mock and a cleanup function to assert the mocks expectations.
// The first argument is typically a *testing.T value.
func NewMockRepository(t interface {
	mock.TestingT
	Cleanup(func())
}) *MockRepository {
	mock := &MockRepository{}
	mock.Mock.Test(t)

	t.Cleanup(func() { mock.AssertExpectations(t) })

	return mock
}

// MockRepository is an autogenerated mock type for the Repository type
type MockRepository struct {
	mock.Mock
}

type MockRepository_Expecter struct {
	mock *mock.Mock
}

func (_m *MockRepository) EXPECT() *MockRepository_Expecter {
	return &MockRepository_Expecter{mock: &_m.Mock}
}

// CreateAccount provides a mock function for the type MockRepository
func (_mock *MockRepository) CreateAccount(ctx context.Context, entity *Account) (*Account, error) {
	ret := _mock.Called(ctx, entity)

	if len(ret) == 0 {
		panic("no return value specified for CreateAccount")
	}

	var r0 *Account
	var r1 error
	if returnFunc, ok := ret.Get(0).(func(context.Context, *Account) (*Account, error)); ok {
		return returnFunc(ctx, entity)
	}
	if returnFunc, ok := ret.Get(0).(func(context.Context, *Account) *Account); ok {
		r0 = returnFunc(ctx, entity)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*Account)
		}
	}
	if returnFunc, ok := ret.Get(1).(func(context.Context, *Account) error); ok {
		r1 = returnFunc(ctx, entity)
	} else {
		r1 = ret.Error(1)
	}
	return r0, r1
}

// MockRepository_CreateAccount_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'CreateAccount'
type MockRepository_CreateAccount_Call struct {
	*mock.Call
}

// CreateAccount is a helper method to define mock.On call
//   - ctx context.Context
//   - entity *Account
func (_e *MockRepository_Expecter) CreateAccount(ctx interface{}, entity interface{}) *MockRepository_CreateAccount_Call {
	return &MockRepository_CreateAccount_Call{Call: _e.mock.On("CreateAccount", ctx, entity)}
}

func (_c *MockRepository_CreateAccount_Call) Run(run func(ctx context.Context, entity *Account)) *MockRepository_CreateAccount_Call {
	_c.Call.Run(func(args mock.Arguments) {
		var arg0 context.Context
		if args[0] != nil {
			arg0 = args[0].(context.Context)
		}
		var arg1 *Account
		if args[1] != nil {
			arg1 = args[1].(*Account)
		}
		run(
			arg0,
			arg1,
		)
	})
	return _c
}

func (_c *MockRepository_CreateAccount_Call) Return(account *Account, err error) *MockRepository_CreateAccount_Call {
	_c.Call.Return(account, err)
	return _c
}

func (_c *MockRepository_CreateAccount_Call) RunAndReturn(run func(ctx context.Context, entity *Account) (*Account, error)) *MockRepository_CreateAccount_Call {
	_c.Call.Return(run)
	return _c
}

// CreateSession provides a mock function for the type MockRepository
func (_mock *MockRepository) CreateSession(ctx context.Context, entity *Session) (*Session, error) {
	ret := _mock.Called(ctx, entity)

	if len(ret) == 0 {
		panic("no return value specified for CreateSession")
	}

	var r0 *Session
	var r1 error
	if returnFunc, ok := ret.Get(0).(func(context.Context, *Session) (*Session, error)); ok {
		return returnFunc(ctx, entity)
	}
	if returnFunc, ok := ret.Get(0).(func(context.Context, *Session) *Session); ok {
		r0 = returnFunc(ctx, entity)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*Session)
		}
	}
	if returnFunc, ok := ret.Get(1).(func(context.Context, *Session) error); ok {
		r1 = returnFunc(ctx, entity)
	} else {
		r1 = ret.Error(1)
	}
	return r0, r1
}

// MockRepository_CreateSession_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'CreateSession'
type MockRepository_CreateSession_Call struct {
	*mock.Call
}

// CreateSession is a helper method to define mock.On call
//   - ctx context.Context
//   - entity *Session
func (_e *MockRepository_Expecter) CreateSession(ctx interface{}, entity interface{}) *MockRepository_CreateSession_Call {
	return &MockRepository_CreateSession_Call{Call: _e.mock.On("CreateSession", ctx, entity)}
}

func (_c *MockRepository_CreateSession_Call) Run(run func(ctx context.Context, entity *Session)) *MockRepository_CreateSession_Call {
	_c.Call.Run(func(args mock.Arguments) {
		var arg0 context.Context
		if args[0] != nil {
			arg0 = args[0].(context.Context)
		}
		var arg1 *Session
		if args[1] != nil {
			arg1 = args[1].(*Session)
		}
		run(
			arg0,
			arg1,
		)
	})
	return _c
}

func (_c *MockRepository_CreateSession_Call) Return(session *Session, err error) *MockRepository_CreateSession_Call {
	_c.Call.Return(session, err)
	return _c
}

func (_c *MockRepository_CreateSession_Call) RunAndReturn(run func(ctx context.Context, entity *Session) (*Session, error)) *MockRepository_CreateSession_Call {
	_c.Call.Return(run)
	return _c
}

// DeleteAccount provides a mock function for the type MockRepository
func (_mock *MockRepository) DeleteAccount(ctx context.Context, id uuid.UUID) error {
	ret := _mock.Called(ctx, id)

	if len(ret) == 0 {
		panic("no return value specified for DeleteAccount")
	}

	var r0 error
	if returnFunc, ok := ret.Get(0).(func(context.Context, uuid.UUID) error); ok {
		r0 = returnFunc(ctx, id)
	} else {
		r0 = ret.Error(0)
	}
	return r0
}

// MockRepository_DeleteAccount_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'DeleteAccount'
type MockRepository_DeleteAccount_Call struct {
	*mock.Call
}

// DeleteAccount is a helper method to define mock.On call
//   - ctx context.Context
//   - id uuid.UUID
func (_e *MockRepository_Expecter) DeleteAccount(ctx interface{}, id interface{}) *MockRepository_DeleteAccount_Call {
	return &MockRepository_DeleteAccount_Call{Call: _e.mock.On("DeleteAccount", ctx, id)}
}

func (_c *MockRepository_DeleteAccount_Call) Run(run func(ctx context.Context, id uuid.UUID)) *MockRepository_DeleteAccount_Call {
	_c.Call.Run(func(args mock.Arguments) {
		var arg0 context.Context
		if args[0] != nil {
			arg0 = args[0].(context.Context)
		}
		var arg1 uuid.UUID
		if args[1] != nil {
			arg1 = args[1].(uuid.UUID)
		}
		run(
			arg0,
			arg1,
		)
	})
	return _c
}

func (_c *MockRepository_DeleteAccount_Call) Return(err error) *MockRepository_DeleteAccount_Call {
	_c.Call.Return(err)
	return _c
}

func (_c *MockRepository_DeleteAccount_Call) RunAndReturn(run func(ctx context.Context, id uuid.UUID) error) *MockRepository_DeleteAccount_Call {
	_c.Call.Return(run)
	return _c
}

// DeleteExpiredSessions provides a mock function for the type MockRepository
func (_mock *MockRepository) DeleteExpiredSessions(ctx context.Context) error {
	ret := _mock.Called(ctx)

	if len(ret) == 0 {
		panic("no return value specified for DeleteExpiredSessions")
	}

	var r0 error
	if returnFunc, ok := ret.Get(0).(func(context.Context) error); ok {
		r0 = returnFunc(ctx)
	} else {
		r0 = ret.Error(0)
	}
	return r0
}

// MockRepository_DeleteExpiredSessions_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'DeleteExpiredSessions'
type MockRepository_DeleteExpiredSessions_Call struct {
	*mock.Call
}

// DeleteExpiredSessions is a helper method to define mock.On call
//   - ctx context.Context
func (_e *MockRepository_Expecter) DeleteExpiredSessions(ctx interface{}) *MockRepository_DeleteExpiredSessions_Call {
	return &MockRepository_DeleteExpiredSessions_Call{Call: _e.mock.On("DeleteExpiredSessions", ctx)}
}

func (_c *MockRepository_DeleteExpiredSessions_Call) Run(run func(ctx context.Context)) *MockRepository_DeleteExpiredSessions_Call {
	_c.Call.Run(func(args mock.Arguments) {
		var arg0 context.Context
		if args[0] != nil {
			arg0 = args[0].(context.Context)
		}
		run(
			arg0,
		)
	})
	return _c
}

func (_c *MockRepository_DeleteExpiredSessions_Call) Return(err error) *MockRepository_DeleteExpiredSessions_Call {
	_c.Call.Return(err)
	return _c
}

func (_c *MockRepository_DeleteExpiredSessions_Call) RunAndReturn(run func(ctx context.Context) error) *MockRepository_DeleteExpiredSessions_Call {
	_c.Call.Return(run)
	return _c
}

// DeleteSession provides a mock function for the type MockRepository
func (_mock *MockRepository) DeleteSession(ctx context.Context, id uuid.UUID) error {
	ret := _mock.Called(ctx, id)

	if len(ret) == 0 {
		panic("no return value specified for DeleteSession")
	}

	var r0 error
	if returnFunc, ok := ret.Get(0).(func(context.Context, uuid.UUID) error); ok {
		r0 = returnFunc(ctx, id)
	} else {
		r0 = ret.Error(0)
	}
	return r0
}

// MockRepository_DeleteSession_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'DeleteSession'
type MockRepository_DeleteSession_Call struct {
	*mock.Call
}

// DeleteSession is a helper method to define mock.On call
//   - ctx context.Context
//   - id uuid.UUID
func (_e *MockRepository_Expecter) DeleteSession(ctx interface{}, id interface{}) *MockRepository_DeleteSession_Call {
	return &MockRepository_DeleteSession_Call{Call: _e.mock.On("DeleteSession", ctx, id)}
}

func (_c *MockRepository_DeleteSession_Call) Run(run func(ctx context.Context, id uuid.UUID)) *MockRepository_DeleteSession_Call {
	_c.Call.Run(func(args mock.Arguments) {
		var arg0 context.Context
		if args[0] != nil {
			arg0 = args[0].(context.Context)
		}
		var arg1 uuid.UUID
		if args[1] != nil {
			arg1 = args[1].(uuid.UUID)
		}
		run(
			arg0,
			arg1,
		)
	})
	return _c
}

func (_c *MockRepository_DeleteSession_Call) Return(err error) *MockRepository_DeleteSession_Call {
	_c.Call.Return(err)
	return _c
}

func (_c *MockRepository_DeleteSession_Call) RunAndReturn(run func(ctx context.Context, id uuid.UUID) error) *MockRepository_DeleteSession_Call {
	_c.Call.Return(run)
	return _c
}

// DeleteSessionByToken provides a mock function for the type MockRepository
func (_mock *MockRepository) DeleteSessionByToken(ctx context.Context, token string) error {
	ret := _mock.Called(ctx, token)

	if len(ret) == 0 {
		panic("no return value specified for DeleteSessionByToken")
	}

	var r0 error
	if returnFunc, ok := ret.Get(0).(func(context.Context, string) error); ok {
		r0 = returnFunc(ctx, token)
	} else {
		r0 = ret.Error(0)
	}
	return r0
}

// MockRepository_DeleteSessionByToken_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'DeleteSessionByToken'
type MockRepository_DeleteSessionByToken_Call struct {
	*mock.Call
}

// DeleteSessionByToken is a helper method to define mock.On call
//   - ctx context.Context
//   - token string
func (_e *MockRepository_Expecter) DeleteSessionByToken(ctx interface{}, token interface{}) *MockRepository_DeleteSessionByToken_Call {
	return &MockRepository_DeleteSessionByToken_Call{Call: _e.mock.On("DeleteSessionByToken", ctx, token)}
}

func (_c *MockRepository_DeleteSessionByToken_Call) Run(run func(ctx context.Context, token string)) *MockRepository_DeleteSessionByToken_Call {
	_c.Call.Run(func(args mock.Arguments) {
		var arg0 context.Context
		if args[0] != nil {
			arg0 = args[0].(context.Context)
		}
		var arg1 string
		if args[1] != nil {
			arg1 = args[1].(string)
		}
		run(
			arg0,
			arg1,
		)
	})
	return _c
}

func (_c *MockRepository_DeleteSessionByToken_Call) Return(err error) *MockRepository_DeleteSessionByToken_Call {
	_c.Call.Return(err)
	return _c
}

func (_c *MockRepository_DeleteSessionByToken_Call) RunAndReturn(run func(ctx context.Context, token string) error) *MockRepository_DeleteSessionByToken_Call {
	_c.Call.Return(run)
	return _c
}

// DeleteUserSessions provides a mock function for the type MockRepository
func (_mock *MockRepository) DeleteUserSessions(ctx context.Context, userID uuid.UUID) error {
	ret := _mock.Called(ctx, userID)

	if len(ret) == 0 {
		panic("no return value specified for DeleteUserSessions")
	}

	var r0 error
	if returnFunc, ok := ret.Get(0).(func(context.Context, uuid.UUID) error); ok {
		r0 = returnFunc(ctx, userID)
	} else {
		r0 = ret.Error(0)
	}
	return r0
}

// MockRepository_DeleteUserSessions_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'DeleteUserSessions'
type MockRepository_DeleteUserSessions_Call struct {
	*mock.Call
}

// DeleteUserSessions is a helper method to define mock.On call
//   - ctx context.Context
//   - userID uuid.UUID
func (_e *MockRepository_Expecter) DeleteUserSessions(ctx interface{}, userID interface{}) *MockRepository_DeleteUserSessions_Call {
	return &MockRepository_DeleteUserSessions_Call{Call: _e.mock.On("DeleteUserSessions", ctx, userID)}
}

func (_c *MockRepository_DeleteUserSessions_Call) Run(run func(ctx context.Context, userID uuid.UUID)) *MockRepository_DeleteUserSessions_Call {
	_c.Call.Run(func(args mock.Arguments) {
		var arg0 context.Context
		if args[0] != nil {
			arg0 = args[0].(context.Context)
		}
		var arg1 uuid.UUID
		if args[1] != nil {
			arg1 = args[1].(uuid.UUID)
		}
		run(
			arg0,
			arg1,
		)
	})
	return _c
}

func (_c *MockRepository_DeleteUserSessions_Call) Return(err error) *MockRepository_DeleteUserSessions_Call {
	_c.Call.Return(err)
	return _c
}

func (_c *MockRepository_DeleteUserSessions_Call) RunAndReturn(run func(ctx context.Context, userID uuid.UUID) error) *MockRepository_DeleteUserSessions_Call {
	_c.Call.Return(run)
	return _c
}

// GetAccount provides a mock function for the type MockRepository
func (_mock *MockRepository) GetAccount(ctx context.Context, id uuid.UUID) (*Account, error) {
	ret := _mock.Called(ctx, id)

	if len(ret) == 0 {
		panic("no return value specified for GetAccount")
	}

	var r0 *Account
	var r1 error
	if returnFunc, ok := ret.Get(0).(func(context.Context, uuid.UUID) (*Account, error)); ok {
		return returnFunc(ctx, id)
	}
	if returnFunc, ok := ret.Get(0).(func(context.Context, uuid.UUID) *Account); ok {
		r0 = returnFunc(ctx, id)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*Account)
		}
	}
	if returnFunc, ok := ret.Get(1).(func(context.Context, uuid.UUID) error); ok {
		r1 = returnFunc(ctx, id)
	} else {
		r1 = ret.Error(1)
	}
	return r0, r1
}

// MockRepository_GetAccount_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'GetAccount'
type MockRepository_GetAccount_Call struct {
	*mock.Call
}

// GetAccount is a helper method to define mock.On call
//   - ctx context.Context
//   - id uuid.UUID
func (_e *MockRepository_Expecter) GetAccount(ctx interface{}, id interface{}) *MockRepository_GetAccount_Call {
	return &MockRepository_GetAccount_Call{Call: _e.mock.On("GetAccount", ctx, id)}
}

func (_c *MockRepository_GetAccount_Call) Run(run func(ctx context.Context, id uuid.UUID)) *MockRepository_GetAccount_Call {
	_c.Call.Run(func(args mock.Arguments) {
		var arg0 context.Context
		if args[0] != nil {
			arg0 = args[0].(context.Context)
		}
		var arg1 uuid.UUID
		if args[1] != nil {
			arg1 = args[1].(uuid.UUID)
		}
		run(
			arg0,
			arg1,
		)
	})
	return _c
}

func (_c *MockRepository_GetAccount_Call) Return(account *Account, err error) *MockRepository_GetAccount_Call {
	_c.Call.Return(account, err)
	return _c
}

func (_c *MockRepository_GetAccount_Call) RunAndReturn(run func(ctx context.Context, id uuid.UUID) (*Account, error)) *MockRepository_GetAccount_Call {
	_c.Call.Return(run)
	return _c
}

// GetAccountByProviderAndProviderID provides a mock function for the type MockRepository
func (_mock *MockRepository) GetAccountByProviderAndProviderID(ctx context.Context, provider string, providerID string) (*Account, error) {
	ret := _mock.Called(ctx, provider, providerID)

	if len(ret) == 0 {
		panic("no return value specified for GetAccountByProviderAndProviderID")
	}

	var r0 *Account
	var r1 error
	if returnFunc, ok := ret.Get(0).(func(context.Context, string, string) (*Account, error)); ok {
		return returnFunc(ctx, provider, providerID)
	}
	if returnFunc, ok := ret.Get(0).(func(context.Context, string, string) *Account); ok {
		r0 = returnFunc(ctx, provider, providerID)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*Account)
		}
	}
	if returnFunc, ok := ret.Get(1).(func(context.Context, string, string) error); ok {
		r1 = returnFunc(ctx, provider, providerID)
	} else {
		r1 = ret.Error(1)
	}
	return r0, r1
}

// MockRepository_GetAccountByProviderAndProviderID_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'GetAccountByProviderAndProviderID'
type MockRepository_GetAccountByProviderAndProviderID_Call struct {
	*mock.Call
}

// GetAccountByProviderAndProviderID is a helper method to define mock.On call
//   - ctx context.Context
//   - provider string
//   - providerID string
func (_e *MockRepository_Expecter) GetAccountByProviderAndProviderID(ctx interface{}, provider interface{}, providerID interface{}) *MockRepository_GetAccountByProviderAndProviderID_Call {
	return &MockRepository_GetAccountByProviderAndProviderID_Call{Call: _e.mock.On("GetAccountByProviderAndProviderID", ctx, provider, providerID)}
}

func (_c *MockRepository_GetAccountByProviderAndProviderID_Call) Run(run func(ctx context.Context, provider string, providerID string)) *MockRepository_GetAccountByProviderAndProviderID_Call {
	_c.Call.Run(func(args mock.Arguments) {
		var arg0 context.Context
		if args[0] != nil {
			arg0 = args[0].(context.Context)
		}
		var arg1 string
		if args[1] != nil {
			arg1 = args[1].(string)
		}
		var arg2 string
		if args[2] != nil {
			arg2 = args[2].(string)
		}
		run(
			arg0,
			arg1,
			arg2,
		)
	})
	return _c
}

func (_c *MockRepository_GetAccountByProviderAndProviderID_Call) Return(account *Account, err error) *MockRepository_GetAccountByProviderAndProviderID_Call {
	_c.Call.Return(account, err)
	return _c
}

func (_c *MockRepository_GetAccountByProviderAndProviderID_Call) RunAndReturn(run func(ctx context.Context, provider string, providerID string) (*Account, error)) *MockRepository_GetAccountByProviderAndProviderID_Call {
	_c.Call.Return(run)
	return _c
}

// GetSession provides a mock function for the type MockRepository
func (_mock *MockRepository) GetSession(ctx context.Context, id uuid.UUID) (*Session, error) {
	ret := _mock.Called(ctx, id)

	if len(ret) == 0 {
		panic("no return value specified for GetSession")
	}

	var r0 *Session
	var r1 error
	if returnFunc, ok := ret.Get(0).(func(context.Context, uuid.UUID) (*Session, error)); ok {
		return returnFunc(ctx, id)
	}
	if returnFunc, ok := ret.Get(0).(func(context.Context, uuid.UUID) *Session); ok {
		r0 = returnFunc(ctx, id)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*Session)
		}
	}
	if returnFunc, ok := ret.Get(1).(func(context.Context, uuid.UUID) error); ok {
		r1 = returnFunc(ctx, id)
	} else {
		r1 = ret.Error(1)
	}
	return r0, r1
}

// MockRepository_GetSession_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'GetSession'
type MockRepository_GetSession_Call struct {
	*mock.Call
}

// GetSession is a helper method to define mock.On call
//   - ctx context.Context
//   - id uuid.UUID
func (_e *MockRepository_Expecter) GetSession(ctx interface{}, id interface{}) *MockRepository_GetSession_Call {
	return &MockRepository_GetSession_Call{Call: _e.mock.On("GetSession", ctx, id)}
}

func (_c *MockRepository_GetSession_Call) Run(run func(ctx context.Context, id uuid.UUID)) *MockRepository_GetSession_Call {
	_c.Call.Run(func(args mock.Arguments) {
		var arg0 context.Context
		if args[0] != nil {
			arg0 = args[0].(context.Context)
		}
		var arg1 uuid.UUID
		if args[1] != nil {
			arg1 = args[1].(uuid.UUID)
		}
		run(
			arg0,
			arg1,
		)
	})
	return _c
}

func (_c *MockRepository_GetSession_Call) Return(session *Session, err error) *MockRepository_GetSession_Call {
	_c.Call.Return(session, err)
	return _c
}

func (_c *MockRepository_GetSession_Call) RunAndReturn(run func(ctx context.Context, id uuid.UUID) (*Session, error)) *MockRepository_GetSession_Call {
	_c.Call.Return(run)
	return _c
}

// GetSessionByToken provides a mock function for the type MockRepository
func (_mock *MockRepository) GetSessionByToken(ctx context.Context, token string) (*Session, error) {
	ret := _mock.Called(ctx, token)

	if len(ret) == 0 {
		panic("no return value specified for GetSessionByToken")
	}

	var r0 *Session
	var r1 error
	if returnFunc, ok := ret.Get(0).(func(context.Context, string) (*Session, error)); ok {
		return returnFunc(ctx, token)
	}
	if returnFunc, ok := ret.Get(0).(func(context.Context, string) *Session); ok {
		r0 = returnFunc(ctx, token)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*Session)
		}
	}
	if returnFunc, ok := ret.Get(1).(func(context.Context, string) error); ok {
		r1 = returnFunc(ctx, token)
	} else {
		r1 = ret.Error(1)
	}
	return r0, r1
}

// MockRepository_GetSessionByToken_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'GetSessionByToken'
type MockRepository_GetSessionByToken_Call struct {
	*mock.Call
}

// GetSessionByToken is a helper method to define mock.On call
//   - ctx context.Context
//   - token string
func (_e *MockRepository_Expecter) GetSessionByToken(ctx interface{}, token interface{}) *MockRepository_GetSessionByToken_Call {
	return &MockRepository_GetSessionByToken_Call{Call: _e.mock.On("GetSessionByToken", ctx, token)}
}

func (_c *MockRepository_GetSessionByToken_Call) Run(run func(ctx context.Context, token string)) *MockRepository_GetSessionByToken_Call {
	_c.Call.Run(func(args mock.Arguments) {
		var arg0 context.Context
		if args[0] != nil {
			arg0 = args[0].(context.Context)
		}
		var arg1 string
		if args[1] != nil {
			arg1 = args[1].(string)
		}
		run(
			arg0,
			arg1,
		)
	})
	return _c
}

func (_c *MockRepository_GetSessionByToken_Call) Return(session *Session, err error) *MockRepository_GetSessionByToken_Call {
	_c.Call.Return(session, err)
	return _c
}

func (_c *MockRepository_GetSessionByToken_Call) RunAndReturn(run func(ctx context.Context, token string) (*Session, error)) *MockRepository_GetSessionByToken_Call {
	_c.Call.Return(run)
	return _c
}

// ListAccounts provides a mock function for the type MockRepository
func (_mock *MockRepository) ListAccounts(ctx context.Context, params ListAccountsParams) ([]*Account, int64, error) {
	ret := _mock.Called(ctx, params)

	if len(ret) == 0 {
		panic("no return value specified for ListAccounts")
	}

	var r0 []*Account
	var r1 int64
	var r2 error
	if returnFunc, ok := ret.Get(0).(func(context.Context, ListAccountsParams) ([]*Account, int64, error)); ok {
		return returnFunc(ctx, params)
	}
	if returnFunc, ok := ret.Get(0).(func(context.Context, ListAccountsParams) []*Account); ok {
		r0 = returnFunc(ctx, params)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).([]*Account)
		}
	}
	if returnFunc, ok := ret.Get(1).(func(context.Context, ListAccountsParams) int64); ok {
		r1 = returnFunc(ctx, params)
	} else {
		r1 = ret.Get(1).(int64)
	}
	if returnFunc, ok := ret.Get(2).(func(context.Context, ListAccountsParams) error); ok {
		r2 = returnFunc(ctx, params)
	} else {
		r2 = ret.Error(2)
	}
	return r0, r1, r2
}

// MockRepository_ListAccounts_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'ListAccounts'
type MockRepository_ListAccounts_Call struct {
	*mock.Call
}

// ListAccounts is a helper method to define mock.On call
//   - ctx context.Context
//   - params ListAccountsParams
func (_e *MockRepository_Expecter) ListAccounts(ctx interface{}, params interface{}) *MockRepository_ListAccounts_Call {
	return &MockRepository_ListAccounts_Call{Call: _e.mock.On("ListAccounts", ctx, params)}
}

func (_c *MockRepository_ListAccounts_Call) Run(run func(ctx context.Context, params ListAccountsParams)) *MockRepository_ListAccounts_Call {
	_c.Call.Run(func(args mock.Arguments) {
		var arg0 context.Context
		if args[0] != nil {
			arg0 = args[0].(context.Context)
		}
		var arg1 ListAccountsParams
		if args[1] != nil {
			arg1 = args[1].(ListAccountsParams)
		}
		run(
			arg0,
			arg1,
		)
	})
	return _c
}

func (_c *MockRepository_ListAccounts_Call) Return(accounts []*Account, n int64, err error) *MockRepository_ListAccounts_Call {
	_c.Call.Return(accounts, n, err)
	return _c
}

func (_c *MockRepository_ListAccounts_Call) RunAndReturn(run func(ctx context.Context, params ListAccountsParams) ([]*Account, int64, error)) *MockRepository_ListAccounts_Call {
	_c.Call.Return(run)
	return _c
}

// ListSessions provides a mock function for the type MockRepository
func (_mock *MockRepository) ListSessions(ctx context.Context, params ListSessionsParams) ([]*Session, int64, error) {
	ret := _mock.Called(ctx, params)

	if len(ret) == 0 {
		panic("no return value specified for ListSessions")
	}

	var r0 []*Session
	var r1 int64
	var r2 error
	if returnFunc, ok := ret.Get(0).(func(context.Context, ListSessionsParams) ([]*Session, int64, error)); ok {
		return returnFunc(ctx, params)
	}
	if returnFunc, ok := ret.Get(0).(func(context.Context, ListSessionsParams) []*Session); ok {
		r0 = returnFunc(ctx, params)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).([]*Session)
		}
	}
	if returnFunc, ok := ret.Get(1).(func(context.Context, ListSessionsParams) int64); ok {
		r1 = returnFunc(ctx, params)
	} else {
		r1 = ret.Get(1).(int64)
	}
	if returnFunc, ok := ret.Get(2).(func(context.Context, ListSessionsParams) error); ok {
		r2 = returnFunc(ctx, params)
	} else {
		r2 = ret.Error(2)
	}
	return r0, r1, r2
}

// MockRepository_ListSessions_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'ListSessions'
type MockRepository_ListSessions_Call struct {
	*mock.Call
}

// ListSessions is a helper method to define mock.On call
//   - ctx context.Context
//   - params ListSessionsParams
func (_e *MockRepository_Expecter) ListSessions(ctx interface{}, params interface{}) *MockRepository_ListSessions_Call {
	return &MockRepository_ListSessions_Call{Call: _e.mock.On("ListSessions", ctx, params)}
}

func (_c *MockRepository_ListSessions_Call) Run(run func(ctx context.Context, params ListSessionsParams)) *MockRepository_ListSessions_Call {
	_c.Call.Run(func(args mock.Arguments) {
		var arg0 context.Context
		if args[0] != nil {
			arg0 = args[0].(context.Context)
		}
		var arg1 ListSessionsParams
		if args[1] != nil {
			arg1 = args[1].(ListSessionsParams)
		}
		run(
			arg0,
			arg1,
		)
	})
	return _c
}

func (_c *MockRepository_ListSessions_Call) Return(sessions []*Session, n int64, err error) *MockRepository_ListSessions_Call {
	_c.Call.Return(sessions, n, err)
	return _c
}

func (_c *MockRepository_ListSessions_Call) RunAndReturn(run func(ctx context.Context, params ListSessionsParams) ([]*Session, int64, error)) *MockRepository_ListSessions_Call {
	_c.Call.Return(run)
	return _c
}

// ListUserAccounts provides a mock function for the type MockRepository
func (_mock *MockRepository) ListUserAccounts(ctx context.Context, userID uuid.UUID) ([]*Account, error) {
	ret := _mock.Called(ctx, userID)

	if len(ret) == 0 {
		panic("no return value specified for ListUserAccounts")
	}

	var r0 []*Account
	var r1 error
	if returnFunc, ok := ret.Get(0).(func(context.Context, uuid.UUID) ([]*Account, error)); ok {
		return returnFunc(ctx, userID)
	}
	if returnFunc, ok := ret.Get(0).(func(context.Context, uuid.UUID) []*Account); ok {
		r0 = returnFunc(ctx, userID)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).([]*Account)
		}
	}
	if returnFunc, ok := ret.Get(1).(func(context.Context, uuid.UUID) error); ok {
		r1 = returnFunc(ctx, userID)
	} else {
		r1 = ret.Error(1)
	}
	return r0, r1
}

// MockRepository_ListUserAccounts_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'ListUserAccounts'
type MockRepository_ListUserAccounts_Call struct {
	*mock.Call
}

// ListUserAccounts is a helper method to define mock.On call
//   - ctx context.Context
//   - userID uuid.UUID
func (_e *MockRepository_Expecter) ListUserAccounts(ctx interface{}, userID interface{}) *MockRepository_ListUserAccounts_Call {
	return &MockRepository_ListUserAccounts_Call{Call: _e.mock.On("ListUserAccounts", ctx, userID)}
}

func (_c *MockRepository_ListUserAccounts_Call) Run(run func(ctx context.Context, userID uuid.UUID)) *MockRepository_ListUserAccounts_Call {
	_c.Call.Run(func(args mock.Arguments) {
		var arg0 context.Context
		if args[0] != nil {
			arg0 = args[0].(context.Context)
		}
		var arg1 uuid.UUID
		if args[1] != nil {
			arg1 = args[1].(uuid.UUID)
		}
		run(
			arg0,
			arg1,
		)
	})
	return _c
}

func (_c *MockRepository_ListUserAccounts_Call) Return(accounts []*Account, err error) *MockRepository_ListUserAccounts_Call {
	_c.Call.Return(accounts, err)
	return _c
}

func (_c *MockRepository_ListUserAccounts_Call) RunAndReturn(run func(ctx context.Context, userID uuid.UUID) ([]*Account, error)) *MockRepository_ListUserAccounts_Call {
	_c.Call.Return(run)
	return _c
}

// UpdateAccount provides a mock function for the type MockRepository
func (_mock *MockRepository) UpdateAccount(ctx context.Context, id uuid.UUID, entity *Account) (*Account, error) {
	ret := _mock.Called(ctx, id, entity)

	if len(ret) == 0 {
		panic("no return value specified for UpdateAccount")
	}

	var r0 *Account
	var r1 error
	if returnFunc, ok := ret.Get(0).(func(context.Context, uuid.UUID, *Account) (*Account, error)); ok {
		return returnFunc(ctx, id, entity)
	}
	if returnFunc, ok := ret.Get(0).(func(context.Context, uuid.UUID, *Account) *Account); ok {
		r0 = returnFunc(ctx, id, entity)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*Account)
		}
	}
	if returnFunc, ok := ret.Get(1).(func(context.Context, uuid.UUID, *Account) error); ok {
		r1 = returnFunc(ctx, id, entity)
	} else {
		r1 = ret.Error(1)
	}
	return r0, r1
}

// MockRepository_UpdateAccount_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'UpdateAccount'
type MockRepository_UpdateAccount_Call struct {
	*mock.Call
}

// UpdateAccount is a helper method to define mock.On call
//   - ctx context.Context
//   - id uuid.UUID
//   - entity *Account
func (_e *MockRepository_Expecter) UpdateAccount(ctx interface{}, id interface{}, entity interface{}) *MockRepository_UpdateAccount_Call {
	return &MockRepository_UpdateAccount_Call{Call: _e.mock.On("UpdateAccount", ctx, id, entity)}
}

func (_c *MockRepository_UpdateAccount_Call) Run(run func(ctx context.Context, id uuid.UUID, entity *Account)) *MockRepository_UpdateAccount_Call {
	_c.Call.Run(func(args mock.Arguments) {
		var arg0 context.Context
		if args[0] != nil {
			arg0 = args[0].(context.Context)
		}
		var arg1 uuid.UUID
		if args[1] != nil {
			arg1 = args[1].(uuid.UUID)
		}
		var arg2 *Account
		if args[2] != nil {
			arg2 = args[2].(*Account)
		}
		run(
			arg0,
			arg1,
			arg2,
		)
	})
	return _c
}

func (_c *MockRepository_UpdateAccount_Call) Return(account *Account, err error) *MockRepository_UpdateAccount_Call {
	_c.Call.Return(account, err)
	return _c
}

func (_c *MockRepository_UpdateAccount_Call) RunAndReturn(run func(ctx context.Context, id uuid.UUID, entity *Account) (*Account, error)) *MockRepository_UpdateAccount_Call {
	_c.Call.Return(run)
	return _c
}

// UpdateSession provides a mock function for the type MockRepository
func (_mock *MockRepository) UpdateSession(ctx context.Context, id uuid.UUID, entity *Session) (*Session, error) {
	ret := _mock.Called(ctx, id, entity)

	if len(ret) == 0 {
		panic("no return value specified for UpdateSession")
	}

	var r0 *Session
	var r1 error
	if returnFunc, ok := ret.Get(0).(func(context.Context, uuid.UUID, *Session) (*Session, error)); ok {
		return returnFunc(ctx, id, entity)
	}
	if returnFunc, ok := ret.Get(0).(func(context.Context, uuid.UUID, *Session) *Session); ok {
		r0 = returnFunc(ctx, id, entity)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*Session)
		}
	}
	if returnFunc, ok := ret.Get(1).(func(context.Context, uuid.UUID, *Session) error); ok {
		r1 = returnFunc(ctx, id, entity)
	} else {
		r1 = ret.Error(1)
	}
	return r0, r1
}

// MockRepository_UpdateSession_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'UpdateSession'
type MockRepository_UpdateSession_Call struct {
	*mock.Call
}

// UpdateSession is a helper method to define mock.On call
//   - ctx context.Context
//   - id uuid.UUID
//   - entity *Session
func (_e *MockRepository_Expecter) UpdateSession(ctx interface{}, id interface{}, entity interface{}) *MockRepository_UpdateSession_Call {
	return &MockRepository_UpdateSession_Call{Call: _e.mock.On("UpdateSession", ctx, id, entity)}
}

func (_c *MockRepository_UpdateSession_Call) Run(run func(ctx context.Context, id uuid.UUID, entity *Session)) *MockRepository_UpdateSession_Call {
	_c.Call.Run(func(args mock.Arguments) {
		var arg0 context.Context
		if args[0] != nil {
			arg0 = args[0].(context.Context)
		}
		var arg1 uuid.UUID
		if args[1] != nil {
			arg1 = args[1].(uuid.UUID)
		}
		var arg2 *Session
		if args[2] != nil {
			arg2 = args[2].(*Session)
		}
		run(
			arg0,
			arg1,
			arg2,
		)
	})
	return _c
}

func (_c *MockRepository_UpdateSession_Call) Return(session *Session, err error) *MockRepository_UpdateSession_Call {
	_c.Call.Return(session, err)
	return _c
}

func (_c *MockRepository_UpdateSession_Call) RunAndReturn(run func(ctx context.Context, id uuid.UUID, entity *Session) (*Session, error)) *MockRepository_UpdateSession_Call {
	_c.Call.Return(run)
	return _c
}
