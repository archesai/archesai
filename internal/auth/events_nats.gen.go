// Code generated by codegen events. DO NOT EDIT.
package auth

import (
	"context"
	"encoding/json"
	"fmt"
	"time"

	"github.com/google/uuid"
	"github.com/nats-io/nats.go"
)

// NATSEventPublisher implements EventPublisher using NATS.
type NATSEventPublisher struct {
	conn    *nats.Conn
	subject string
}

// NewNATSEventPublisher creates a new NATS event publisher.
func NewNATSEventPublisher(conn *nats.Conn) EventPublisher {
	subject := "auth.events"

	return &NATSEventPublisher{
		conn:    conn,
		subject: subject,
	}
}

// NewNATSEventPublisherWithSubject creates a new NATS event publisher with custom subject.
func NewNATSEventPublisherWithSubject(conn *nats.Conn, subject string) EventPublisher {
	return &NATSEventPublisher{
		conn:    conn,
		subject: subject,
	}
}

// Publishaccountcreated publishes a Account created event event.
func (p *NATSEventPublisher) Publishaccountcreated(ctx context.Context, entity *Account) error {
	if entity == nil {
		return fmt.Errorf("entity cannot be nil")
	}

	event := &Event{
		ID:        uuid.New().String(),
		Type:      Eventaccountcreated,
		Timestamp: time.Now().UTC(),
		Source:    "auth",
		Data:      entity,
		Metadata: map[string]string{
			"entity_id":   entity.Id.String(),
			"entity_type": "Account",
		},
	}

	return p.PublishRaw(ctx, event)
}

// Publishaccountupdated publishes a Account updated event event.
func (p *NATSEventPublisher) Publishaccountupdated(ctx context.Context, entity *Account) error {
	if entity == nil {
		return fmt.Errorf("entity cannot be nil")
	}

	event := &Event{
		ID:        uuid.New().String(),
		Type:      Eventaccountupdated,
		Timestamp: time.Now().UTC(),
		Source:    "auth",
		Data:      entity,
		Metadata: map[string]string{
			"entity_id":   entity.Id.String(),
			"entity_type": "Account",
		},
	}

	return p.PublishRaw(ctx, event)
}

// Publishaccountdeleted publishes a Account deleted event event.
func (p *NATSEventPublisher) Publishaccountdeleted(ctx context.Context, entity *Account) error {
	if entity == nil {
		return fmt.Errorf("entity cannot be nil")
	}

	event := &Event{
		ID:        uuid.New().String(),
		Type:      Eventaccountdeleted,
		Timestamp: time.Now().UTC(),
		Source:    "auth",
		Data:      entity,
		Metadata: map[string]string{
			"entity_id":   entity.Id.String(),
			"entity_type": "Account",
		},
	}

	return p.PublishRaw(ctx, event)
}

// Publishaccountlinked publishes a Account linked event event.
func (p *NATSEventPublisher) Publishaccountlinked(ctx context.Context, entity *Account) error {
	if entity == nil {
		return fmt.Errorf("entity cannot be nil")
	}

	event := &Event{
		ID:        uuid.New().String(),
		Type:      Eventaccountlinked,
		Timestamp: time.Now().UTC(),
		Source:    "auth",
		Data:      entity,
		Metadata: map[string]string{
			"entity_id":   entity.Id.String(),
			"entity_type": "Account",
		},
	}

	return p.PublishRaw(ctx, event)
}

// Publishaccountunlinked publishes a Account unlinked event event.
func (p *NATSEventPublisher) Publishaccountunlinked(ctx context.Context, entity *Account) error {
	if entity == nil {
		return fmt.Errorf("entity cannot be nil")
	}

	event := &Event{
		ID:        uuid.New().String(),
		Type:      Eventaccountunlinked,
		Timestamp: time.Now().UTC(),
		Source:    "auth",
		Data:      entity,
		Metadata: map[string]string{
			"entity_id":   entity.Id.String(),
			"entity_type": "Account",
		},
	}

	return p.PublishRaw(ctx, event)
}

// Publishsessioncreated publishes a Session created event event.
func (p *NATSEventPublisher) Publishsessioncreated(ctx context.Context, entity *Session) error {
	if entity == nil {
		return fmt.Errorf("entity cannot be nil")
	}

	event := &Event{
		ID:        uuid.New().String(),
		Type:      Eventsessioncreated,
		Timestamp: time.Now().UTC(),
		Source:    "auth",
		Data:      entity,
		Metadata: map[string]string{
			"entity_id":   entity.Id.String(),
			"entity_type": "Session",
		},
	}

	return p.PublishRaw(ctx, event)
}

// Publishsessionrefreshed publishes a Session refreshed event event.
func (p *NATSEventPublisher) Publishsessionrefreshed(ctx context.Context, entity *Session) error {
	if entity == nil {
		return fmt.Errorf("entity cannot be nil")
	}

	event := &Event{
		ID:        uuid.New().String(),
		Type:      Eventsessionrefreshed,
		Timestamp: time.Now().UTC(),
		Source:    "auth",
		Data:      entity,
		Metadata: map[string]string{
			"entity_id":   entity.Id.String(),
			"entity_type": "Session",
		},
	}

	return p.PublishRaw(ctx, event)
}

// Publishsessionexpired publishes a Session expired event event.
func (p *NATSEventPublisher) Publishsessionexpired(ctx context.Context, entity *Session) error {
	if entity == nil {
		return fmt.Errorf("entity cannot be nil")
	}

	event := &Event{
		ID:        uuid.New().String(),
		Type:      Eventsessionexpired,
		Timestamp: time.Now().UTC(),
		Source:    "auth",
		Data:      entity,
		Metadata: map[string]string{
			"entity_id":   entity.Id.String(),
			"entity_type": "Session",
		},
	}

	return p.PublishRaw(ctx, event)
}

// Publishsessiondeleted publishes a Session deleted event event.
func (p *NATSEventPublisher) Publishsessiondeleted(ctx context.Context, entity *Session) error {
	if entity == nil {
		return fmt.Errorf("entity cannot be nil")
	}

	event := &Event{
		ID:        uuid.New().String(),
		Type:      Eventsessiondeleted,
		Timestamp: time.Now().UTC(),
		Source:    "auth",
		Data:      entity,
		Metadata: map[string]string{
			"entity_id":   entity.Id.String(),
			"entity_type": "Session",
		},
	}

	return p.PublishRaw(ctx, event)
}

// Publishusercreated publishes a User created event event.
func (p *NATSEventPublisher) Publishusercreated(ctx context.Context, entity *User) error {
	if entity == nil {
		return fmt.Errorf("entity cannot be nil")
	}

	event := &Event{
		ID:        uuid.New().String(),
		Type:      Eventusercreated,
		Timestamp: time.Now().UTC(),
		Source:    "auth",
		Data:      entity,
		Metadata: map[string]string{
			"entity_id":   entity.Id.String(),
			"entity_type": "User",
		},
	}

	return p.PublishRaw(ctx, event)
}

// Publishuserupdated publishes a User updated event event.
func (p *NATSEventPublisher) Publishuserupdated(ctx context.Context, entity *User) error {
	if entity == nil {
		return fmt.Errorf("entity cannot be nil")
	}

	event := &Event{
		ID:        uuid.New().String(),
		Type:      Eventuserupdated,
		Timestamp: time.Now().UTC(),
		Source:    "auth",
		Data:      entity,
		Metadata: map[string]string{
			"entity_id":   entity.Id.String(),
			"entity_type": "User",
		},
	}

	return p.PublishRaw(ctx, event)
}

// Publishuserdeleted publishes a User deleted event event.
func (p *NATSEventPublisher) Publishuserdeleted(ctx context.Context, entity *User) error {
	if entity == nil {
		return fmt.Errorf("entity cannot be nil")
	}

	event := &Event{
		ID:        uuid.New().String(),
		Type:      Eventuserdeleted,
		Timestamp: time.Now().UTC(),
		Source:    "auth",
		Data:      entity,
		Metadata: map[string]string{
			"entity_id":   entity.Id.String(),
			"entity_type": "User",
		},
	}

	return p.PublishRaw(ctx, event)
}

// PublishuseremailVerified publishes a User email_verified event event.
func (p *NATSEventPublisher) PublishuseremailVerified(ctx context.Context, entity *User) error {
	if entity == nil {
		return fmt.Errorf("entity cannot be nil")
	}

	event := &Event{
		ID:        uuid.New().String(),
		Type:      EventuseremailVerified,
		Timestamp: time.Now().UTC(),
		Source:    "auth",
		Data:      entity,
		Metadata: map[string]string{
			"entity_id":   entity.Id.String(),
			"entity_type": "User",
		},
	}

	return p.PublishRaw(ctx, event)
}

// PublishRaw publishes a raw event to NATS.
func (p *NATSEventPublisher) PublishRaw(ctx context.Context, event *Event) error {
	if event == nil {
		return fmt.Errorf("event cannot be nil")
	}

	// Ensure event has required fields
	if event.ID == "" {
		event.ID = uuid.New().String()
	}
	if event.Timestamp.IsZero() {
		event.Timestamp = time.Now().UTC()
	}
	if event.Source == "" {
		event.Source = "auth"
	}

	// Marshal event to JSON
	data, err := json.Marshal(event)
	if err != nil {
		return fmt.Errorf("failed to marshal event: %w", err)
	}

	// Publish to NATS subject
	subject := p.subject
	if err := p.conn.Publish(subject, data); err != nil {
		return fmt.Errorf("failed to publish event to NATS: %w", err)
	}

	// Also publish to type-specific subject for selective subscription
	typeSubject := fmt.Sprintf("%s.%s", p.subject, string(event.Type))
	if err := p.conn.Publish(typeSubject, data); err != nil {
		// Log error but don't fail - type-specific subject is optional
		// In production, you'd use proper logging here
		_ = err
	}

	return nil
}

// Subscribe subscribes to domain events.
func (p *NATSEventPublisher) Subscribe(ctx context.Context, handler func(event *Event) error) error {
	// Create subscription
	sub, err := p.conn.Subscribe(p.subject, func(msg *nats.Msg) {
		// Unmarshal event
		var event Event
		if err := json.Unmarshal(msg.Data, &event); err != nil {
			// Log error but continue processing
			// In production, you'd use proper logging here
			return
		}

		// Handle event
		if err := handler(&event); err != nil {
			// Log error but continue processing
			// In production, you'd use proper logging here
			return
		}
	})
	if err != nil {
		return fmt.Errorf("failed to subscribe to subject: %w", err)
	}
	defer sub.Unsubscribe()

	// Wait for context cancellation
	<-ctx.Done()
	return ctx.Err()
}

// SubscribeToType subscribes to specific event types.
func (p *NATSEventPublisher) SubscribeToType(ctx context.Context, eventType EventType, handler func(event *Event) error) error {
	// Subscribe to type-specific subject
	typeSubject := fmt.Sprintf("%s.%s", p.subject, string(eventType))

	// Create subscription
	sub, err := p.conn.Subscribe(typeSubject, func(msg *nats.Msg) {
		// Unmarshal event
		var event Event
		if err := json.Unmarshal(msg.Data, &event); err != nil {
			// Log error but continue processing
			return
		}

		// Handle event
		if err := handler(&event); err != nil {
			// Log error but continue processing
			return
		}
	})
	if err != nil {
		return fmt.Errorf("failed to subscribe to type subject: %w", err)
	}
	defer sub.Unsubscribe()

	// Wait for context cancellation
	<-ctx.Done()
	return ctx.Err()
}

// QueueSubscribe subscribes to domain events with queue group for load balancing.
func (p *NATSEventPublisher) QueueSubscribe(ctx context.Context, queueGroup string, handler func(event *Event) error) error {
	// Create queue subscription
	sub, err := p.conn.QueueSubscribe(p.subject, queueGroup, func(msg *nats.Msg) {
		// Unmarshal event
		var event Event
		if err := json.Unmarshal(msg.Data, &event); err != nil {
			// Log error but continue processing
			return
		}

		// Handle event
		if err := handler(&event); err != nil {
			// Log error but continue processing
			return
		}
	})
	if err != nil {
		return fmt.Errorf("failed to create queue subscription: %w", err)
	}
	defer sub.Unsubscribe()

	// Wait for context cancellation
	<-ctx.Done()
	return ctx.Err()
}
