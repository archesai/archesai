// Code generated by codegen events. DO NOT EDIT.
package auth

import (
	"context"
	"encoding/json"
	"fmt"
	"time"

	"github.com/google/uuid"
	"github.com/redis/go-redis/v9"
)

// RedisEventPublisher implements EventPublisher using Redis pub/sub.
type RedisEventPublisher struct {
	client  *redis.Client
	channel string
}

// NewRedisEventPublisher creates a new Redis event publisher.
func NewRedisEventPublisher(client *redis.Client) EventPublisher {
	channel := "auth-events"
	channel = "auth-events"

	return &RedisEventPublisher{
		client:  client,
		channel: channel,
	}
}

// NewRedisEventPublisherWithChannel creates a new Redis event publisher with custom channel.
func NewRedisEventPublisherWithChannel(client *redis.Client, channel string) EventPublisher {
	return &RedisEventPublisher{
		client:  client,
		channel: channel,
	}
}

// PublishUserCreated publishes a User was created event.
func (p *RedisEventPublisher) PublishUserCreated(ctx context.Context, entity *UserEntity) error {
	if entity == nil {
		return fmt.Errorf("entity cannot be nil")
	}

	event := &Event{
		ID:        uuid.New().String(),
		Type:      EventUserCreated,
		Timestamp: time.Now().UTC(),
		Source:    "auth",
		Data:      entity,
		Metadata: map[string]string{
			"entity_id":   entity.Id.String(),
			"entity_type": "User",
		},
	}

	return p.PublishRaw(ctx, event)
}

// PublishUserUpdated publishes a User was updated event.
func (p *RedisEventPublisher) PublishUserUpdated(ctx context.Context, entity *UserEntity) error {
	if entity == nil {
		return fmt.Errorf("entity cannot be nil")
	}

	event := &Event{
		ID:        uuid.New().String(),
		Type:      EventUserUpdated,
		Timestamp: time.Now().UTC(),
		Source:    "auth",
		Data:      entity,
		Metadata: map[string]string{
			"entity_id":   entity.Id.String(),
			"entity_type": "User",
		},
	}

	return p.PublishRaw(ctx, event)
}

// PublishUserDeleted publishes a User was deleted event.
func (p *RedisEventPublisher) PublishUserDeleted(ctx context.Context, entity *UserEntity) error {
	if entity == nil {
		return fmt.Errorf("entity cannot be nil")
	}

	event := &Event{
		ID:        uuid.New().String(),
		Type:      EventUserDeleted,
		Timestamp: time.Now().UTC(),
		Source:    "auth",
		Data:      entity,
		Metadata: map[string]string{
			"entity_id":   entity.Id.String(),
			"entity_type": "User",
		},
	}

	return p.PublishRaw(ctx, event)
}

// PublishUserEmailVerified publishes a User email was verified event.
func (p *RedisEventPublisher) PublishUserEmailVerified(ctx context.Context, entity *UserEntity) error {
	if entity == nil {
		return fmt.Errorf("entity cannot be nil")
	}

	event := &Event{
		ID:        uuid.New().String(),
		Type:      EventUserEmailVerified,
		Timestamp: time.Now().UTC(),
		Source:    "auth",
		Data:      entity,
		Metadata: map[string]string{
			"entity_id":   entity.Id.String(),
			"entity_type": "User",
		},
	}

	return p.PublishRaw(ctx, event)
}

// PublishUserPasswordChanged publishes a User password was changed event.
func (p *RedisEventPublisher) PublishUserPasswordChanged(ctx context.Context, entity *UserEntity) error {
	if entity == nil {
		return fmt.Errorf("entity cannot be nil")
	}

	event := &Event{
		ID:        uuid.New().String(),
		Type:      EventUserPasswordChanged,
		Timestamp: time.Now().UTC(),
		Source:    "auth",
		Data:      entity,
		Metadata: map[string]string{
			"entity_id":   entity.Id.String(),
			"entity_type": "User",
		},
	}

	return p.PublishRaw(ctx, event)
}

// PublishSessionCreated publishes a Session was created event.
func (p *RedisEventPublisher) PublishSessionCreated(ctx context.Context, entity *SessionEntity) error {
	if entity == nil {
		return fmt.Errorf("entity cannot be nil")
	}

	event := &Event{
		ID:        uuid.New().String(),
		Type:      EventSessionCreated,
		Timestamp: time.Now().UTC(),
		Source:    "auth",
		Data:      entity,
		Metadata: map[string]string{
			"entity_id":   entity.Id.String(),
			"entity_type": "Session",
		},
	}

	return p.PublishRaw(ctx, event)
}

// PublishSessionDeleted publishes a Session was deleted event.
func (p *RedisEventPublisher) PublishSessionDeleted(ctx context.Context, entity *SessionEntity) error {
	if entity == nil {
		return fmt.Errorf("entity cannot be nil")
	}

	event := &Event{
		ID:        uuid.New().String(),
		Type:      EventSessionDeleted,
		Timestamp: time.Now().UTC(),
		Source:    "auth",
		Data:      entity,
		Metadata: map[string]string{
			"entity_id":   entity.Id.String(),
			"entity_type": "Session",
		},
	}

	return p.PublishRaw(ctx, event)
}

// PublishSessionExpired publishes a Session expired event.
func (p *RedisEventPublisher) PublishSessionExpired(ctx context.Context, entity *SessionEntity) error {
	if entity == nil {
		return fmt.Errorf("entity cannot be nil")
	}

	event := &Event{
		ID:        uuid.New().String(),
		Type:      EventSessionExpired,
		Timestamp: time.Now().UTC(),
		Source:    "auth",
		Data:      entity,
		Metadata: map[string]string{
			"entity_id":   entity.Id.String(),
			"entity_type": "Session",
		},
	}

	return p.PublishRaw(ctx, event)
}

// PublishAccountLinked publishes a Account was linked event.
func (p *RedisEventPublisher) PublishAccountLinked(ctx context.Context, entity *AccountEntity) error {
	if entity == nil {
		return fmt.Errorf("entity cannot be nil")
	}

	event := &Event{
		ID:        uuid.New().String(),
		Type:      EventAccountLinked,
		Timestamp: time.Now().UTC(),
		Source:    "auth",
		Data:      entity,
		Metadata: map[string]string{
			"entity_id":   entity.Id.String(),
			"entity_type": "Account",
		},
	}

	return p.PublishRaw(ctx, event)
}

// PublishAccountUnlinked publishes a Account was unlinked event.
func (p *RedisEventPublisher) PublishAccountUnlinked(ctx context.Context, entity *AccountEntity) error {
	if entity == nil {
		return fmt.Errorf("entity cannot be nil")
	}

	event := &Event{
		ID:        uuid.New().String(),
		Type:      EventAccountUnlinked,
		Timestamp: time.Now().UTC(),
		Source:    "auth",
		Data:      entity,
		Metadata: map[string]string{
			"entity_id":   entity.Id.String(),
			"entity_type": "Account",
		},
	}

	return p.PublishRaw(ctx, event)
}

// PublishAccountTokensRefreshed publishes a Account tokens were refreshed event.
func (p *RedisEventPublisher) PublishAccountTokensRefreshed(ctx context.Context, entity *AccountEntity) error {
	if entity == nil {
		return fmt.Errorf("entity cannot be nil")
	}

	event := &Event{
		ID:        uuid.New().String(),
		Type:      EventAccountTokensRefreshed,
		Timestamp: time.Now().UTC(),
		Source:    "auth",
		Data:      entity,
		Metadata: map[string]string{
			"entity_id":   entity.Id.String(),
			"entity_type": "Account",
		},
	}

	return p.PublishRaw(ctx, event)
}

// PublishRaw publishes a raw event to Redis.
func (p *RedisEventPublisher) PublishRaw(ctx context.Context, event *Event) error {
	if event == nil {
		return fmt.Errorf("event cannot be nil")
	}

	// Ensure event has required fields
	if event.ID == "" {
		event.ID = uuid.New().String()
	}
	if event.Timestamp.IsZero() {
		event.Timestamp = time.Now().UTC()
	}
	if event.Source == "" {
		event.Source = "auth"
	}

	// Marshal event to JSON
	data, err := json.Marshal(event)
	if err != nil {
		return fmt.Errorf("failed to marshal event: %w", err)
	}

	// Publish to Redis channel
	if err := p.client.Publish(ctx, p.channel, data).Err(); err != nil {
		return fmt.Errorf("failed to publish event to Redis: %w", err)
	}

	// Also publish to type-specific channel for selective subscription
	typeChannel := fmt.Sprintf("%s:%s", p.channel, string(event.Type))
	if err := p.client.Publish(ctx, typeChannel, data).Err(); err != nil {
		// Log error but don't fail - type-specific channel is optional
		// In production, you'd use proper logging here
		_ = err
	}

	return nil
}

// Subscribe subscribes to domain events.
func (p *RedisEventPublisher) Subscribe(ctx context.Context, handler func(event *Event) error) error {
	// Create subscription
	pubsub := p.client.Subscribe(ctx, p.channel)
	defer pubsub.Close()

	// Wait for subscription confirmation
	_, err := pubsub.Receive(ctx)
	if err != nil {
		return fmt.Errorf("failed to subscribe to channel: %w", err)
	}

	// Get channel for messages
	ch := pubsub.Channel()

	// Process messages
	for {
		select {
		case <-ctx.Done():
			return ctx.Err()
		case msg := <-ch:
			if msg == nil {
				continue
			}

			// Unmarshal event
			var event Event
			if err := json.Unmarshal([]byte(msg.Payload), &event); err != nil {
				// Log error but continue processing
				// In production, you'd use proper logging here
				continue
			}

			// Handle event
			if err := handler(&event); err != nil {
				// Log error but continue processing
				// In production, you'd use proper logging here
				continue
			}
		}
	}
}

// SubscribeToType subscribes to specific event types.
func (p *RedisEventPublisher) SubscribeToType(ctx context.Context, eventType EventType, handler func(event *Event) error) error {
	// Subscribe to type-specific channel
	typeChannel := fmt.Sprintf("%s:%s", p.channel, string(eventType))

	// Create subscription
	pubsub := p.client.Subscribe(ctx, typeChannel)
	defer pubsub.Close()

	// Wait for subscription confirmation
	_, err := pubsub.Receive(ctx)
	if err != nil {
		return fmt.Errorf("failed to subscribe to type channel: %w", err)
	}

	// Get channel for messages
	ch := pubsub.Channel()

	// Process messages
	for {
		select {
		case <-ctx.Done():
			return ctx.Err()
		case msg := <-ch:
			if msg == nil {
				continue
			}

			// Unmarshal event
			var event Event
			if err := json.Unmarshal([]byte(msg.Payload), &event); err != nil {
				// Log error but continue processing
				continue
			}

			// Handle event
			if err := handler(&event); err != nil {
				// Log error but continue processing
				continue
			}
		}
	}
}
