// Code generated by codegen cache. DO NOT EDIT.
package auth

import (
	"context"
	"fmt"
	"sync"
	"time"

	"github.com/google/uuid"
)

// cacheItem represents a cached item with expiration.
type cacheItem struct {
	data      interface{}
	expiresAt time.Time
}

// isExpired checks if the cache item has expired.
func (i *cacheItem) isExpired() bool {
	return time.Now().After(i.expiresAt)
}

// MemoryCache implements Cache using in-memory storage.
type MemoryCache struct {
	mu       sync.RWMutex
	items    map[string]*cacheItem
	maxItems int
	ttl      time.Duration
}

// NewMemoryCache creates a new in-memory cache.
func NewMemoryCache() Cache {
	maxItems := 1000
	ttl := 5 * time.Minute

	cache := &MemoryCache{
		items:    make(map[string]*cacheItem),
		maxItems: maxItems,
		ttl:      ttl,
	}

	// Start cleanup goroutine
	go cache.cleanupExpired()

	return cache
}

// NewMemoryCacheWithOptions creates a new in-memory cache with custom options.
func NewMemoryCacheWithOptions(maxItems int, ttl time.Duration) Cache {
	cache := &MemoryCache{
		items:    make(map[string]*cacheItem),
		maxItems: maxItems,
		ttl:      ttl,
	}

	// Start cleanup goroutine
	go cache.cleanupExpired()

	return cache
}

// cleanupExpired periodically removes expired items.
func (c *MemoryCache) cleanupExpired() {
	ticker := time.NewTicker(1 * time.Minute)
	defer ticker.Stop()

	for range ticker.C {
		c.mu.Lock()
		for key, item := range c.items {
			if item.isExpired() {
				delete(c.items, key)
			}
		}
		c.mu.Unlock()
	}
}

// evictOldest removes the oldest items when cache is full.
func (c *MemoryCache) evictOldest() {
	if len(c.items) < c.maxItems {
		return
	}

	// Simple eviction: remove 10% of oldest items
	toRemove := c.maxItems / 10
	if toRemove < 1 {
		toRemove = 1
	}

	var oldestKeys []string
	now := time.Now()

	for key, item := range c.items {
		if now.After(item.expiresAt) || len(oldestKeys) < toRemove {
			oldestKeys = append(oldestKeys, key)
		} else {
			// Replace if this item is older
			for i, oldKey := range oldestKeys {
				if c.items[oldKey].expiresAt.After(item.expiresAt) {
					oldestKeys[i] = key
					break
				}
			}
		}
	}

	for _, key := range oldestKeys {
		delete(c.items, key)
	}
}

// Account caching operations

func (c *MemoryCache) GetAccount(ctx context.Context, id uuid.UUID) (*Account, error) {
	c.mu.RLock()
	defer c.mu.RUnlock()

	key := fmt.Sprintf("account:%s", id.String())
	item, exists := c.items[key]

	if !exists || item.isExpired() {
		return nil, ErrCacheMiss
	}

	entity, ok := item.data.(*Account)
	if !ok {
		return nil, fmt.Errorf("invalid cached type for account")
	}

	return entity, nil
}

func (c *MemoryCache) SetAccount(ctx context.Context, entity *Account, ttl time.Duration) error {
	if entity == nil {
		return nil
	}

	c.mu.Lock()
	defer c.mu.Unlock()

	// Check if we need to evict items
	if len(c.items) >= c.maxItems {
		c.evictOldest()
	}

	key := fmt.Sprintf("account:%s", entity.Id.String())

	if ttl == 0 {
		ttl = c.ttl
	}

	c.items[key] = &cacheItem{
		data:      entity,
		expiresAt: time.Now().Add(ttl),
	}

	return nil
}

func (c *MemoryCache) DeleteAccount(ctx context.Context, id uuid.UUID) error {
	c.mu.Lock()
	defer c.mu.Unlock()

	key := fmt.Sprintf("account:%s", id.String())
	delete(c.items, key)

	return nil
}

// Session caching operations

func (c *MemoryCache) GetSession(ctx context.Context, id uuid.UUID) (*Session, error) {
	c.mu.RLock()
	defer c.mu.RUnlock()

	key := fmt.Sprintf("session:%s", id.String())
	item, exists := c.items[key]

	if !exists || item.isExpired() {
		return nil, ErrCacheMiss
	}

	entity, ok := item.data.(*Session)
	if !ok {
		return nil, fmt.Errorf("invalid cached type for session")
	}

	return entity, nil
}

func (c *MemoryCache) SetSession(ctx context.Context, entity *Session, ttl time.Duration) error {
	if entity == nil {
		return nil
	}

	c.mu.Lock()
	defer c.mu.Unlock()

	// Check if we need to evict items
	if len(c.items) >= c.maxItems {
		c.evictOldest()
	}

	key := fmt.Sprintf("session:%s", entity.Id.String())

	if ttl == 0 {
		ttl = c.ttl
	}

	c.items[key] = &cacheItem{
		data:      entity,
		expiresAt: time.Now().Add(ttl),
	}

	return nil
}

func (c *MemoryCache) DeleteSession(ctx context.Context, id uuid.UUID) error {
	c.mu.Lock()
	defer c.mu.Unlock()

	key := fmt.Sprintf("session:%s", id.String())
	delete(c.items, key)

	return nil
}

// Additional Session cache operations
func (c *MemoryCache) GetSessionByToken(ctx context.Context, token string) (*Session, error) {
	c.mu.RLock()
	defer c.mu.RUnlock()

	key := fmt.Sprintf("session:token:%s", token)
	item, exists := c.items[key]

	if !exists || item.isExpired() {
		return nil, ErrCacheMiss
	}

	entity, ok := item.data.(*Session)
	if !ok {
		return nil, fmt.Errorf("invalid cached type for session")
	}

	return entity, nil
}

func (c *MemoryCache) SetSessionByToken(ctx context.Context, token string, entity *Session, ttl time.Duration) error {
	if entity == nil {
		return nil
	}

	c.mu.Lock()
	defer c.mu.Unlock()

	// Check if we need to evict items
	if len(c.items) >= c.maxItems {
		c.evictOldest()
	}

	key := fmt.Sprintf("session:token:%s", token)

	if ttl == 0 {
		ttl = c.ttl
	}

	c.items[key] = &cacheItem{
		data:      entity,
		expiresAt: time.Now().Add(ttl),
	}

	// Also cache by ID
	idKey := fmt.Sprintf("session:%s", entity.Id.String())
	c.items[idKey] = &cacheItem{
		data:      entity,
		expiresAt: time.Now().Add(ttl),
	}

	// Track by user ID for bulk deletion
	userKey := fmt.Sprintf("session:user:%s:%s", entity.UserId, entity.Id.String())
	c.items[userKey] = &cacheItem{
		data:      entity,
		expiresAt: time.Now().Add(ttl),
	}

	return nil
}

func (c *MemoryCache) DeleteSessionByToken(ctx context.Context, token string) error {
	c.mu.Lock()
	defer c.mu.Unlock()

	key := fmt.Sprintf("session:token:%s", token)
	delete(c.items, key)

	return nil
}

func (c *MemoryCache) DeleteUserSessions(ctx context.Context, userID uuid.UUID) error {
	c.mu.Lock()
	defer c.mu.Unlock()

	prefix := fmt.Sprintf("session:user:%s:", userID.String())

	// Find and delete all matching keys
	for key := range c.items {
		if len(key) >= len(prefix) && key[:len(prefix)] == prefix {
			delete(c.items, key)
		}
	}

	return nil
}

// User caching operations

func (c *MemoryCache) GetUser(ctx context.Context, id uuid.UUID) (*User, error) {
	c.mu.RLock()
	defer c.mu.RUnlock()

	key := fmt.Sprintf("user:%s", id.String())
	item, exists := c.items[key]

	if !exists || item.isExpired() {
		return nil, ErrCacheMiss
	}

	entity, ok := item.data.(*User)
	if !ok {
		return nil, fmt.Errorf("invalid cached type for user")
	}

	return entity, nil
}

func (c *MemoryCache) SetUser(ctx context.Context, entity *User, ttl time.Duration) error {
	if entity == nil {
		return nil
	}

	c.mu.Lock()
	defer c.mu.Unlock()

	// Check if we need to evict items
	if len(c.items) >= c.maxItems {
		c.evictOldest()
	}

	key := fmt.Sprintf("user:%s", entity.Id.String())

	if ttl == 0 {
		ttl = c.ttl
	}

	c.items[key] = &cacheItem{
		data:      entity,
		expiresAt: time.Now().Add(ttl),
	}

	return nil
}

func (c *MemoryCache) DeleteUser(ctx context.Context, id uuid.UUID) error {
	c.mu.Lock()
	defer c.mu.Unlock()

	key := fmt.Sprintf("user:%s", id.String())
	delete(c.items, key)

	return nil
}

// Additional User cache operations
func (c *MemoryCache) GetUserByEmail(ctx context.Context, email string) (*User, error) {
	c.mu.RLock()
	defer c.mu.RUnlock()

	key := fmt.Sprintf("user:email:%s", email)
	item, exists := c.items[key]

	if !exists || item.isExpired() {
		return nil, ErrCacheMiss
	}

	entity, ok := item.data.(*User)
	if !ok {
		return nil, fmt.Errorf("invalid cached type for user")
	}

	return entity, nil
}

func (c *MemoryCache) SetUserByEmail(ctx context.Context, email string, entity *User, ttl time.Duration) error {
	if entity == nil {
		return nil
	}

	c.mu.Lock()
	defer c.mu.Unlock()

	// Check if we need to evict items
	if len(c.items) >= c.maxItems {
		c.evictOldest()
	}

	key := fmt.Sprintf("user:email:%s", email)

	if ttl == 0 {
		ttl = c.ttl
	}

	c.items[key] = &cacheItem{
		data:      entity,
		expiresAt: time.Now().Add(ttl),
	}

	// Also cache by ID
	idKey := fmt.Sprintf("user:%s", entity.Id.String())
	c.items[idKey] = &cacheItem{
		data:      entity,
		expiresAt: time.Now().Add(ttl),
	}

	return nil
}

func (c *MemoryCache) DeleteUserByEmail(ctx context.Context, email string) error {
	c.mu.Lock()
	defer c.mu.Unlock()

	key := fmt.Sprintf("user:email:%s", email)
	delete(c.items, key)

	return nil
}

// FlushAll removes all cached items.
func (c *MemoryCache) FlushAll(ctx context.Context) error {
	c.mu.Lock()
	defer c.mu.Unlock()

	c.items = make(map[string]*cacheItem)

	return nil
}
