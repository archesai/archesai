// Code generated by codegen cache. DO NOT EDIT.
package cache

import (
	"context"
	"fmt"
	"sync"
	"time"

	"github.com/archesai/archesai/internal/organizations"
	"github.com/google/uuid"
)

// cacheItem represents a cached item with expiration.
type cacheItem struct {
	data      interface{}
	expiresAt time.Time
}

// isExpired checks if the cache item has expired.
func (i *cacheItem) isExpired() bool {
	return time.Now().After(i.expiresAt)
}

// MemoryCache implements Cache using in-memory storage.
type MemoryCache struct {
	mu       sync.RWMutex
	items    map[string]*cacheItem
	maxItems int
	ttl      time.Duration
}

// NewMemoryCache creates a new in-memory cache.
func NewMemoryCache() organizations.Cache {
	maxItems := 1000
	ttl := 5 * time.Minute

	cache := &MemoryCache{
		items:    make(map[string]*cacheItem),
		maxItems: maxItems,
		ttl:      ttl,
	}

	// Start cleanup goroutine
	go cache.cleanupExpired()

	return cache
}

// NewMemoryCacheWithOptions creates a new in-memory cache with custom options.
func NewMemoryCacheWithOptions(maxItems int, ttl time.Duration) organizations.Cache {
	cache := &MemoryCache{
		items:    make(map[string]*cacheItem),
		maxItems: maxItems,
		ttl:      ttl,
	}

	// Start cleanup goroutine
	go cache.cleanupExpired()

	return cache
}

// cleanupExpired periodically removes expired items.
func (c *MemoryCache) cleanupExpired() {
	ticker := time.NewTicker(1 * time.Minute)
	defer ticker.Stop()

	for range ticker.C {
		c.mu.Lock()
		for key, item := range c.items {
			if item.isExpired() {
				delete(c.items, key)
			}
		}
		c.mu.Unlock()
	}
}

// evictOldest removes the oldest items when cache is full.
func (c *MemoryCache) evictOldest() {
	if len(c.items) < c.maxItems {
		return
	}

	// Simple eviction: remove 10% of oldest items
	toRemove := c.maxItems / 10
	if toRemove < 1 {
		toRemove = 1
	}

	var oldestKeys []string
	now := time.Now()

	for key, item := range c.items {
		if now.After(item.expiresAt) || len(oldestKeys) < toRemove {
			oldestKeys = append(oldestKeys, key)
		} else {
			// Replace if this item is older
			for i, oldKey := range oldestKeys {
				if c.items[oldKey].expiresAt.After(item.expiresAt) {
					oldestKeys[i] = key
					break
				}
			}
		}
	}

	for _, key := range oldestKeys {
		delete(c.items, key)
	}
}

// Organization caching operations

func (c *MemoryCache) GetOrganization(ctx context.Context, id uuid.UUID) (*organizations.Organization, error) {
	c.mu.RLock()
	defer c.mu.RUnlock()

	key := fmt.Sprintf("organization:%s", id.String())
	item, exists := c.items[key]

	if !exists || item.isExpired() {
		return nil, organizations.ErrCacheMiss
	}

	entity, ok := item.data.(*organizations.Organization)
	if !ok {
		return nil, fmt.Errorf("invalid cached type for organization")
	}

	return entity, nil
}

func (c *MemoryCache) SetOrganization(ctx context.Context, entity *organizations.Organization, ttl time.Duration) error {
	if entity == nil {
		return nil
	}

	c.mu.Lock()
	defer c.mu.Unlock()

	// Check if we need to evict items
	if len(c.items) >= c.maxItems {
		c.evictOldest()
	}

	key := fmt.Sprintf("organization:%s", entity.Id.String())

	if ttl == 0 {
		ttl = c.ttl
	}

	c.items[key] = &cacheItem{
		data:      entity,
		expiresAt: time.Now().Add(ttl),
	}

	return nil
}

func (c *MemoryCache) DeleteOrganization(ctx context.Context, id uuid.UUID) error {
	c.mu.Lock()
	defer c.mu.Unlock()

	key := fmt.Sprintf("organization:%s", id.String())
	delete(c.items, key)

	return nil
}

// FlushAll removes all cached items.
func (c *MemoryCache) FlushAll(ctx context.Context) error {
	c.mu.Lock()
	defer c.mu.Unlock()

	c.items = make(map[string]*cacheItem)

	return nil
}
