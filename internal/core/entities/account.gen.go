// Code generated by archesai/codegen. DO NOT EDIT.

package entities

import (
	"fmt"
	"time"

	"github.com/archesai/archesai/internal/core/events"
	"github.com/google/uuid"
)

// AccountProviderID represents the enumeration of valid values for ProviderID
type AccountProviderID string

// Valid ProviderID values
const (
	AccountProviderIDLocal     AccountProviderID = "local"
	AccountProviderIDGoogle    AccountProviderID = "google"
	AccountProviderIDGithub    AccountProviderID = "github"
	AccountProviderIDMicrosoft AccountProviderID = "microsoft"
	AccountProviderIDApple     AccountProviderID = "apple"
)

// String returns the string representation
func (e AccountProviderID) String() string {
	return string(e)
}

// IsValid checks if the value is valid
func (e AccountProviderID) IsValid() bool {
	switch e {
	case AccountProviderIDLocal:
		return true
	case AccountProviderIDGoogle:
		return true
	case AccountProviderIDGithub:
		return true
	case AccountProviderIDMicrosoft:
		return true
	case AccountProviderIDApple:
		return true
	default:
		return false
	}
}

// ParseAccountProviderID parses a string into the enum type
func ParseAccountProviderID(s string) (AccountProviderID, error) {
	v := AccountProviderID(s)
	if !v.IsValid() {
		return "", fmt.Errorf("invalid ProviderID: %s", s)
	}
	return v, nil
}

// Account represents Schema for Account entity (authentication provider account)
type Account struct {
	AccessToken           *string              `json:"accessToken,omitempty" yaml:"accessToken,omitempty"`                     // The OAuth access token
	AccessTokenExpiresAt  *time.Time           `json:"accessTokenExpiresAt,omitempty" yaml:"accessTokenExpiresAt,omitempty"`   // The access token expiration timestamp
	AccountID             string               `json:"accountID" yaml:"accountID"`                                             // The unique identifier for the account from the provider
	CreatedAt             time.Time            `json:"createdAt" yaml:"createdAt"`                                             // The date and time when the resource was created
	ID                    uuid.UUID            `json:"id" yaml:"id"`                                                           // Unique identifier for the resource
	IdToken               *string              `json:"idToken,omitempty" yaml:"idToken,omitempty"`                             // The OpenID Connect ID token
	ProviderID            AccountProviderID    `json:"providerID" yaml:"providerID"`                                           // The authentication provider identifier
	RefreshToken          *string              `json:"refreshToken,omitempty" yaml:"refreshToken,omitempty"`                   // The OAuth refresh token
	RefreshTokenExpiresAt *time.Time           `json:"refreshTokenExpiresAt,omitempty" yaml:"refreshTokenExpiresAt,omitempty"` // The refresh token expiration timestamp
	Scope                 *string              `json:"scope,omitempty" yaml:"scope,omitempty"`                                 // The OAuth scope granted
	UpdatedAt             time.Time            `json:"updatedAt" yaml:"updatedAt"`                                             // The date and time when the resource was last updated
	UserID                uuid.UUID            `json:"userID" yaml:"userID"`                                                   // The user ID this account belongs to
	events                []events.DomainEvent `json:"-" yaml:"-"`
}

// NewAccount creates a new Account entity with validation.
// All required fields must be provided and valid.
func NewAccount(
	accountID string,
	providerID AccountProviderID,
	userID uuid.UUID,
) (*Account, error) {
	// Validate required fields
	if accountID == "" {
		return nil, fmt.Errorf("AccountID cannot be empty")
	}
	if !providerID.IsValid() {
		return nil, fmt.Errorf("invalid ProviderID: %s", providerID)
	}

	now := time.Now().UTC()
	account := &Account{
		AccountID:  accountID,
		CreatedAt:  now,
		ID:         uuid.New(),
		ProviderID: providerID,
		UpdatedAt:  now,
		UserID:     userID,
		events:     []events.DomainEvent{},
	}
	account.addEvent(events.NewAccountCreatedEvent(account.ID))

	return account, nil
}

// GetAccessToken returns the AccessToken
func (e *Account) GetAccessToken() *string {
	return e.AccessToken
}

// GetAccessTokenExpiresAt returns the AccessTokenExpiresAt
func (e *Account) GetAccessTokenExpiresAt() *time.Time {
	return e.AccessTokenExpiresAt
}

// GetAccountID returns the AccountID
func (e *Account) GetAccountID() string {
	return e.AccountID
}

// GetCreatedAt returns the CreatedAt
func (e *Account) GetCreatedAt() time.Time {
	return e.CreatedAt
}

// GetID returns the ID
func (e *Account) GetID() uuid.UUID {
	return e.ID
}

// GetIdToken returns the IdToken
func (e *Account) GetIdToken() *string {
	return e.IdToken
}

// GetProviderID returns the ProviderID
func (e *Account) GetProviderID() string {
	return string(e.ProviderID)
}

// GetRefreshToken returns the RefreshToken
func (e *Account) GetRefreshToken() *string {
	return e.RefreshToken
}

// GetRefreshTokenExpiresAt returns the RefreshTokenExpiresAt
func (e *Account) GetRefreshTokenExpiresAt() *time.Time {
	return e.RefreshTokenExpiresAt
}

// GetScope returns the Scope
func (e *Account) GetScope() *string {
	return e.Scope
}

// GetUpdatedAt returns the UpdatedAt
func (e *Account) GetUpdatedAt() time.Time {
	return e.UpdatedAt
}

// GetUserID returns the UserID
func (e *Account) GetUserID() uuid.UUID {
	return e.UserID
}

// Events returns the domain events
func (e *Account) Events() []events.DomainEvent {
	return e.events
}

// ClearEvents clears the domain events
func (e *Account) ClearEvents() {
	e.events = []events.DomainEvent{}
}

// addEvent adds a domain event
func (e *Account) addEvent(event events.DomainEvent) {
	e.events = append(e.events, event)
}

// ReconstructAccount reconstructs a Account from persistence
func ReconstructAccount(
	accessToken *string,
	accessTokenExpiresAt *time.Time,
	accountID string,
	createdAt time.Time,
	id uuid.UUID,
	idToken *string,
	providerID string,
	refreshToken *string,
	refreshTokenExpiresAt *time.Time,
	scope *string,
	updatedAt time.Time,
	userID uuid.UUID,
) *Account {
	return &Account{
		AccessToken:           accessToken,
		AccessTokenExpiresAt:  accessTokenExpiresAt,
		AccountID:             accountID,
		CreatedAt:             createdAt,
		ID:                    id,
		IdToken:               idToken,
		ProviderID:            AccountProviderID(providerID),
		RefreshToken:          refreshToken,
		RefreshTokenExpiresAt: refreshTokenExpiresAt,
		Scope:                 scope,
		UpdatedAt:             updatedAt,
		UserID:                userID,
		events:                []events.DomainEvent{},
	}
}
