// Code generated by archesai/codegen. DO NOT EDIT.

package valueobjects

import (
	"fmt"
	"strings"
)

// ConfigLLMType represents the enumeration of valid values for Type
type ConfigLLMType string

// Valid Type values
const (
	ConfigLLMTypeOllama ConfigLLMType = "ollama"
	ConfigLLMTypeOpenai ConfigLLMType = "openai"
)

// String returns the string representation
func (e ConfigLLMType) String() string {
	return string(e)
}

// IsValid checks if the value is valid
func (e ConfigLLMType) IsValid() bool {
	switch e {
	case ConfigLLMTypeOllama:
		return true
	case ConfigLLMTypeOpenai:
		return true
	default:
		return false
	}
}

// ParseConfigLLMType parses a string into the enum type
func ParseConfigLLMType(s string) (ConfigLLMType, error) {
	v := ConfigLLMType(s)
	if !v.IsValid() {
		return "", fmt.Errorf("invalid Type: %s", s)
	}
	return v, nil
}

// ConfigLLM represents Large Language Model configuration
type ConfigLLM struct {
	Endpoint *string       `json:"endpoint,omitempty" yaml:"endpoint,omitempty"` // LLM service endpoint URL
	Token    *string       `json:"token,omitempty" yaml:"token,omitempty"`       // Authentication token for LLM service
	Type     ConfigLLMType `json:"type" yaml:"type"`                             // LLM provider type
}

// NewConfigLLM creates a new immutable ConfigLLM value object.
// Value objects are immutable and validated upon creation.
func NewConfigLLM(endpoint *string, token *string, type_ string) (ConfigLLM, error) {
	// Validate all fields
	type_Enum := ConfigLLMType(type_)
	if !type_Enum.IsValid() {
		return ConfigLLM{}, fmt.Errorf("invalid Type: %s", type_)
	}

	return ConfigLLM{
		Endpoint: endpoint,
		Token:    token,
		Type:     type_Enum,
	}, nil
}

// MustConfigLLM creates a new ConfigLLM value object and panics on validation error.
// Use this only when you are certain the values are valid (e.g., in tests or with hardcoded values).
func MustConfigLLM(endpoint *string, token *string, type_ string) ConfigLLM {
	v, err := NewConfigLLM(endpoint, token, type_)
	if err != nil {
		panic(fmt.Sprintf("failed to create ConfigLLM: %v", err))
	}
	return v
}

// ZeroConfigLLM returns the zero value for ConfigLLM.
// This is useful for comparisons and as a default value.
func ZeroConfigLLM() ConfigLLM {
	return ConfigLLM{}
}

// GetEndpoint returns the Endpoint value.
// Value objects are immutable, so this returns a copy of the value.
func (v ConfigLLM) GetEndpoint() *string {
	return v.Endpoint
}

// GetToken returns the Token value.
// Value objects are immutable, so this returns a copy of the value.
func (v ConfigLLM) GetToken() *string {
	return v.Token
}

// GetType returns the Type value.
// Value objects are immutable, so this returns a copy of the value.
func (v ConfigLLM) GetType() string {
	return string(v.Type)
}

// IsZero returns true if this is the zero value.
func (v ConfigLLM) IsZero() bool {
	zero := ZeroConfigLLM()
	// Compare using string representation as a simple equality check
	return v.String() == zero.String()
}

// Validate checks if the value object is valid.
// This is automatically called during construction but can be used for explicit validation.
func (v ConfigLLM) Validate() error {
	if v.Type == "" {
		return fmt.Errorf("Type cannot be empty")
	}
	return nil
}

// String returns a string representation of ConfigLLM
func (v ConfigLLM) String() string {
	var fields []string
	if v.Endpoint != nil {
		fields = append(fields, fmt.Sprintf("Endpoint: %v", *v.Endpoint))
	} else {
		fields = append(fields, "Endpoint: <nil>")
	}
	if v.Token != nil {
		fields = append(fields, fmt.Sprintf("Token: %v", *v.Token))
	} else {
		fields = append(fields, "Token: <nil>")
	}
	fields = append(fields, fmt.Sprintf("Type: %v", v.Type))
	return fmt.Sprintf("ConfigLLM{%s}", strings.Join(fields, ", "))
}
