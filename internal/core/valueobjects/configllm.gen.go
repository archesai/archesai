// Code generated by archesai/codegen. DO NOT EDIT.

package valueobjects

import (
	"fmt"
	"strings"
)

// ConfigLLM represents Large Language Model configuration
type ConfigLLM struct {
	Endpoint *string `json:"endpoint,omitempty" yaml:"endpoint,omitempty"` // LLM service endpoint URL
	Token    *string `json:"token,omitempty" yaml:"token,omitempty"`       // Authentication token for LLM service
	Type     string  `json:"type" yaml:"type"`                             // LLM provider type
}

// NewConfigLLM creates a new ConfigLLM value object
func NewConfigLLM(endpoint *string, token *string, type_ string) (ConfigLLM, error) {
	if type_ == "" {
		return ConfigLLM{}, fmt.Errorf("Type cannot be empty")
	}

	return ConfigLLM{
		Endpoint: endpoint,
		Token:    token,
		Type:     type_,
	}, nil
}

// GetEndpoint returns the Endpoint
func (v ConfigLLM) GetEndpoint() *string {
	return v.Endpoint
}

// GetToken returns the Token
func (v ConfigLLM) GetToken() *string {
	return v.Token
}

// GetType returns the Type
func (v ConfigLLM) GetType() string {
	return v.Type
}

// Equals checks if two ConfigLLM value objects are equal
// func (v ConfigLLM) Equals(other ConfigLLM) bool {
//	return v.Endpoint == other.Endpoint && v.Token == other.Token && v.Type == other.Type
// }

// String returns a string representation of ConfigLLM
func (v ConfigLLM) String() string {
	// Build string representation field by field to avoid recursion
	var fields []string
	fields = append(fields, fmt.Sprintf("Endpoint: %v", v.Endpoint))
	fields = append(fields, fmt.Sprintf("Token: %v", v.Token))
	fields = append(fields, fmt.Sprintf("Type: %v", v.Type))
	return fmt.Sprintf("ConfigLLM{%s}", strings.Join(fields, ", "))
}
