// Code generated by archesai/codegen. DO NOT EDIT.

package valueobjects

import "fmt"

// FilterNode represents A recursive filter node that can be a condition or group
type FilterNode struct {
	Children []interface{} `json:"children,omitempty" yaml:"children,omitempty"` // Child filter nodes (for logical operators)
	Field    *string       `json:"field,omitempty" yaml:"field,omitempty"`       // The field to filter on (for leaf conditions)
	Type     string        `json:"type" yaml:"type"`                             // The type of filter operation
	Value    *interface{}  `json:"value,omitempty" yaml:"value,omitempty"`       // The value to compare against (for leaf conditions)
}

// NewFilterNode creates a new FilterNode value object
func NewFilterNode(children []interface{}, field *string, type_ string, value *interface{}) (FilterNode, error) {
	if type_ == "" {
		return FilterNode{}, fmt.Errorf("Type cannot be empty")
	}

	return FilterNode{
		Children: children,
		Field:    field,
		Type:     type_,
		Value:    value,
	}, nil
}

// GetChildren returns the Children
func (v FilterNode) GetChildren() []interface{} {
	return v.Children
}

// GetField returns the Field
func (v FilterNode) GetField() *string {
	return v.Field
}

// GetType returns the Type
func (v FilterNode) GetType() string {
	return v.Type
}

// GetValue returns the Value
func (v FilterNode) GetValue() *interface{} {
	return v.Value
}

// Equals checks if two FilterNode value objects are equal
func (v FilterNode) Equals(other FilterNode) bool {
	// Can't directly compare slices, so skip Children comparison for now
	// A proper implementation would need to recursively compare children
	return v.Field == other.Field && v.Type == other.Type && len(v.Children) == len(other.Children)
}

// String returns a string representation of FilterNode
func (v FilterNode) String() string {
	return fmt.Sprintf("%+v", v)
}
