// Code generated by archesai-codegen. DO NOT EDIT.

package valueobjects

import (
	"fmt"
	"strings"
)

// FilterNodeType represents the enumeration of valid values for Type
type FilterNodeType string

// Valid Type values
const (
	FilterNodeTypeAnd        FilterNodeType = "and"
	FilterNodeTypeOr         FilterNodeType = "or"
	FilterNodeTypeEq         FilterNodeType = "eq"
	FilterNodeTypeNe         FilterNodeType = "ne"
	FilterNodeTypeGt         FilterNodeType = "gt"
	FilterNodeTypeGte        FilterNodeType = "gte"
	FilterNodeTypeLt         FilterNodeType = "lt"
	FilterNodeTypeLte        FilterNodeType = "lte"
	FilterNodeTypeContains   FilterNodeType = "contains"
	FilterNodeTypeStartsWith FilterNodeType = "startsWith"
	FilterNodeTypeEndsWith   FilterNodeType = "endsWith"
)

// String returns the string representation
func (e FilterNodeType) String() string {
	return string(e)
}

// IsValid checks if the value is valid
func (e FilterNodeType) IsValid() bool {
	switch e {
	case FilterNodeTypeAnd:
		return true
	case FilterNodeTypeOr:
		return true
	case FilterNodeTypeEq:
		return true
	case FilterNodeTypeNe:
		return true
	case FilterNodeTypeGt:
		return true
	case FilterNodeTypeGte:
		return true
	case FilterNodeTypeLt:
		return true
	case FilterNodeTypeLte:
		return true
	case FilterNodeTypeContains:
		return true
	case FilterNodeTypeStartsWith:
		return true
	case FilterNodeTypeEndsWith:
		return true
	default:
		return false
	}
}

// ParseFilterNodeType parses a string into the enum type
func ParseFilterNodeType(s string) (FilterNodeType, error) {
	v := FilterNodeType(s)
	if !v.IsValid() {
		return "", fmt.Errorf("invalid Type: %s", s)
	}
	return v, nil
}

// FilterNode represents A recursive filter node that can be a condition or group
type FilterNode struct {
	Children []FilterNode   `json:"children,omitempty" yaml:"children,omitempty"` // Child filter nodes (for logical operators)
	Field    *string        `json:"field,omitempty" yaml:"field,omitempty"`       // The field to filter on (for leaf conditions)
	Type     FilterNodeType `json:"type" yaml:"type"`                             // The type of filter operation
	Value    *any           `json:"value,omitempty" yaml:"value,omitempty"`       // The value to compare against (for leaf conditions)
}

// NewFilterNode creates a new immutable FilterNode value object.
// Value objects are immutable and validated upon creation.
func NewFilterNode(children []FilterNode, field *string, type_ FilterNodeType, value *any) (FilterNode, error) {
	// Validate required fields
	if !type_.IsValid() {
		return FilterNode{}, fmt.Errorf("invalid Type: %s", type_)
	}
	return FilterNode{
		Children: children,
		Field:    field,
		Type:     type_,
		Value:    value,
	}, nil
}

// ZeroFilterNode returns the zero value for FilterNode.
// This is useful for comparisons and as a default value.
func ZeroFilterNode() FilterNode {
	return FilterNode{}
}

// GetChildren returns the Children value.
// Value objects are immutable, so this returns a copy of the value.
func (v FilterNode) GetChildren() []FilterNode {
	// Return a copy for slices and maps to maintain immutability
	result := make([]FilterNode, len(v.Children))
	copy(result, v.Children)
	return result
}

// GetField returns the Field value.
// Value objects are immutable, so this returns a copy of the value.
func (v FilterNode) GetField() *string {
	return v.Field
}

// GetType returns the Type value.
// Value objects are immutable, so this returns a copy of the value.
func (v FilterNode) GetType() FilterNodeType {
	return v.Type
}

// GetValue returns the Value value.
// Value objects are immutable, so this returns a copy of the value.
func (v FilterNode) GetValue() *any {
	return v.Value
}

// Validate validates the FilterNode value object.
// Returns an error if any field fails validation.
func (v FilterNode) Validate() error {
	if !v.Type.IsValid() {
		return fmt.Errorf("invalid Type: %s", v.Type)
	}
	return nil
}

// IsZero returns true if this is the zero value.
func (v FilterNode) IsZero() bool {
	zero := ZeroFilterNode()
	// Compare using string representation as a simple equality check
	return v.String() == zero.String()
}

// String returns a string representation of FilterNode
func (v FilterNode) String() string {
	var fields []string
	fields = append(fields, fmt.Sprintf("Children: %v", v.Children))
	fields = append(fields, fmt.Sprintf("Field: %v", v.Field))
	fields = append(fields, fmt.Sprintf("Type: %v", v.Type))
	fields = append(fields, fmt.Sprintf("Value: %v", v.Value))
	return fmt.Sprintf("FilterNode{%s}", strings.Join(fields, ", "))
}
