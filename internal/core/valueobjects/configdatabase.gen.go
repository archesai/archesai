// Code generated by archesai/codegen. DO NOT EDIT.

package valueobjects

import (
	"fmt"
	"strings"
)

// ConfigDatabaseType represents the enumeration of valid values for Type
type ConfigDatabaseType string

// Valid Type values
const (
	ConfigDatabaseTypePostgresql ConfigDatabaseType = "postgresql"
	ConfigDatabaseTypeSQLite     ConfigDatabaseType = "sqlite"
)

// String returns the string representation
func (e ConfigDatabaseType) String() string {
	return string(e)
}

// IsValid checks if the value is valid
func (e ConfigDatabaseType) IsValid() bool {
	switch e {
	case ConfigDatabaseTypePostgresql:
		return true
	case ConfigDatabaseTypeSQLite:
		return true
	default:
		return false
	}
}

// ParseConfigDatabaseType parses a string into the enum type
func ParseConfigDatabaseType(s string) (ConfigDatabaseType, error) {
	v := ConfigDatabaseType(s)
	if !v.IsValid() {
		return "", fmt.Errorf("invalid Type: %s", s)
	}
	return v, nil
}

// ConfigDatabase represents Database configuration for PostgreSQL
type ConfigDatabase struct {
	ConnMaxIdleTime   *string            `json:"connMaxIdleTime,omitempty" yaml:"connMaxIdleTime,omitempty"`     // Maximum connection idle time (e.g., "5m")
	ConnMaxLifetime   *string            `json:"connMaxLifetime,omitempty" yaml:"connMaxLifetime,omitempty"`     // Maximum connection lifetime (e.g., "30m")
	Enabled           bool               `json:"enabled" yaml:"enabled"`                                         // Enable database
	HealthCheckPeriod *string            `json:"healthCheckPeriod,omitempty" yaml:"healthCheckPeriod,omitempty"` // Health check period for connections (PostgreSQL)
	Image             *ConfigImage       `json:"image,omitempty" yaml:"image,omitempty"`
	Managed           bool               `json:"managed" yaml:"managed"`   // Use managed database deployment
	MaxConns          int32              `json:"maxConns" yaml:"maxConns"` // Maximum number of connections in pool (PostgreSQL)
	MinConns          int32              `json:"minConns" yaml:"minConns"` // Minimum number of connections in pool (PostgreSQL)
	Persistence       *ConfigPersistence `json:"persistence,omitempty" yaml:"persistence,omitempty"`
	Resources         *ConfigResource    `json:"resources,omitempty" yaml:"resources,omitempty"`
	RunMigrations     bool               `json:"runMigrations" yaml:"runMigrations"` // Automatically run database migrations on startup
	Type              ConfigDatabaseType `json:"type" yaml:"type"`                   // Database type (postgresql or sqlite)
	URL               string             `json:"url" yaml:"url"`                     // Database connection url/string
}

// NewConfigDatabase creates a new immutable ConfigDatabase value object.
// Value objects are immutable and validated upon creation.
func NewConfigDatabase(connMaxIdleTime *string, connMaxLifetime *string, enabled bool, healthCheckPeriod *string, image *ConfigImage, managed bool, maxConns int32, minConns int32, persistence *ConfigPersistence, resources *ConfigResource, runMigrations bool, type_ string, url string) (ConfigDatabase, error) {
	// Validate all fields
	type_Enum := ConfigDatabaseType(type_)
	if !type_Enum.IsValid() {
		return ConfigDatabase{}, fmt.Errorf("invalid Type: %s", type_)
	}
	if url == "" {
		return ConfigDatabase{}, fmt.Errorf("URL cannot be empty")
	}

	return ConfigDatabase{
		ConnMaxIdleTime:   connMaxIdleTime,
		ConnMaxLifetime:   connMaxLifetime,
		Enabled:           enabled,
		HealthCheckPeriod: healthCheckPeriod,
		Image:             image,
		Managed:           managed,
		MaxConns:          maxConns,
		MinConns:          minConns,
		Persistence:       persistence,
		Resources:         resources,
		RunMigrations:     runMigrations,
		Type:              type_Enum,
		URL:               url,
	}, nil
}

// MustConfigDatabase creates a new ConfigDatabase value object and panics on validation error.
// Use this only when you are certain the values are valid (e.g., in tests or with hardcoded values).
func MustConfigDatabase(connMaxIdleTime *string, connMaxLifetime *string, enabled bool, healthCheckPeriod *string, image *ConfigImage, managed bool, maxConns int32, minConns int32, persistence *ConfigPersistence, resources *ConfigResource, runMigrations bool, type_ string, url string) ConfigDatabase {
	v, err := NewConfigDatabase(connMaxIdleTime, connMaxLifetime, enabled, healthCheckPeriod, image, managed, maxConns, minConns, persistence, resources, runMigrations, type_, url)
	if err != nil {
		panic(fmt.Sprintf("failed to create ConfigDatabase: %v", err))
	}
	return v
}

// ZeroConfigDatabase returns the zero value for ConfigDatabase.
// This is useful for comparisons and as a default value.
func ZeroConfigDatabase() ConfigDatabase {
	return ConfigDatabase{}
}

// GetConnMaxIdleTime returns the ConnMaxIdleTime value.
// Value objects are immutable, so this returns a copy of the value.
func (v ConfigDatabase) GetConnMaxIdleTime() *string {
	return v.ConnMaxIdleTime
}

// GetConnMaxLifetime returns the ConnMaxLifetime value.
// Value objects are immutable, so this returns a copy of the value.
func (v ConfigDatabase) GetConnMaxLifetime() *string {
	return v.ConnMaxLifetime
}

// GetEnabled returns the Enabled value.
// Value objects are immutable, so this returns a copy of the value.
func (v ConfigDatabase) GetEnabled() bool {
	return v.Enabled
}

// GetHealthCheckPeriod returns the HealthCheckPeriod value.
// Value objects are immutable, so this returns a copy of the value.
func (v ConfigDatabase) GetHealthCheckPeriod() *string {
	return v.HealthCheckPeriod
}

// GetImage returns the Image value.
// Value objects are immutable, so this returns a copy of the value.
func (v ConfigDatabase) GetImage() *ConfigImage {
	return v.Image
}

// GetManaged returns the Managed value.
// Value objects are immutable, so this returns a copy of the value.
func (v ConfigDatabase) GetManaged() bool {
	return v.Managed
}

// GetMaxConns returns the MaxConns value.
// Value objects are immutable, so this returns a copy of the value.
func (v ConfigDatabase) GetMaxConns() int32 {
	return v.MaxConns
}

// GetMinConns returns the MinConns value.
// Value objects are immutable, so this returns a copy of the value.
func (v ConfigDatabase) GetMinConns() int32 {
	return v.MinConns
}

// GetPersistence returns the Persistence value.
// Value objects are immutable, so this returns a copy of the value.
func (v ConfigDatabase) GetPersistence() *ConfigPersistence {
	return v.Persistence
}

// GetResources returns the Resources value.
// Value objects are immutable, so this returns a copy of the value.
func (v ConfigDatabase) GetResources() *ConfigResource {
	return v.Resources
}

// GetRunMigrations returns the RunMigrations value.
// Value objects are immutable, so this returns a copy of the value.
func (v ConfigDatabase) GetRunMigrations() bool {
	return v.RunMigrations
}

// GetType returns the Type value.
// Value objects are immutable, so this returns a copy of the value.
func (v ConfigDatabase) GetType() string {
	return string(v.Type)
}

// GetURL returns the URL value.
// Value objects are immutable, so this returns a copy of the value.
func (v ConfigDatabase) GetURL() string {
	return v.URL
}

// IsZero returns true if this is the zero value.
func (v ConfigDatabase) IsZero() bool {
	zero := ZeroConfigDatabase()
	// Compare using string representation as a simple equality check
	return v.String() == zero.String()
}

// Validate checks if the value object is valid.
// This is automatically called during construction but can be used for explicit validation.
func (v ConfigDatabase) Validate() error {
	if v.Type == "" {
		return fmt.Errorf("Type cannot be empty")
	}
	if v.URL == "" {
		return fmt.Errorf("URL cannot be empty")
	}
	return nil
}

// String returns a string representation of ConfigDatabase
func (v ConfigDatabase) String() string {
	var fields []string
	if v.ConnMaxIdleTime != nil {
		fields = append(fields, fmt.Sprintf("ConnMaxIdleTime: %v", *v.ConnMaxIdleTime))
	} else {
		fields = append(fields, "ConnMaxIdleTime: <nil>")
	}
	if v.ConnMaxLifetime != nil {
		fields = append(fields, fmt.Sprintf("ConnMaxLifetime: %v", *v.ConnMaxLifetime))
	} else {
		fields = append(fields, "ConnMaxLifetime: <nil>")
	}
	fields = append(fields, fmt.Sprintf("Enabled: %v", v.Enabled))
	if v.HealthCheckPeriod != nil {
		fields = append(fields, fmt.Sprintf("HealthCheckPeriod: %v", *v.HealthCheckPeriod))
	} else {
		fields = append(fields, "HealthCheckPeriod: <nil>")
	}
	if v.Image != nil {
		fields = append(fields, fmt.Sprintf("Image: %v", *v.Image))
	} else {
		fields = append(fields, "Image: <nil>")
	}
	fields = append(fields, fmt.Sprintf("Managed: %v", v.Managed))
	fields = append(fields, fmt.Sprintf("MaxConns: %v", v.MaxConns))
	fields = append(fields, fmt.Sprintf("MinConns: %v", v.MinConns))
	if v.Persistence != nil {
		fields = append(fields, fmt.Sprintf("Persistence: %v", *v.Persistence))
	} else {
		fields = append(fields, "Persistence: <nil>")
	}
	if v.Resources != nil {
		fields = append(fields, fmt.Sprintf("Resources: %v", *v.Resources))
	} else {
		fields = append(fields, "Resources: <nil>")
	}
	fields = append(fields, fmt.Sprintf("RunMigrations: %v", v.RunMigrations))
	fields = append(fields, fmt.Sprintf("Type: %v", v.Type))
	fields = append(fields, fmt.Sprintf("URL: %v", v.URL))
	return fmt.Sprintf("ConfigDatabase{%s}", strings.Join(fields, ", "))
}
