// Code generated by archesai. DO NOT EDIT.

package controllers

import (
	"encoding/json"
	"fmt"
	"net/http"

	"github.com/google/uuid"
	"github.com/oapi-codegen/runtime"

	"github.com/archesai/archesai/internal/adapters/http/server"
	commands "github.com/archesai/archesai/internal/application/commands/executor"
	queries "github.com/archesai/archesai/internal/application/queries/executor"
	"github.com/archesai/archesai/internal/core/models"
)

// ExecutorController handles HTTP requests for executor endpoints.
type ExecutorController struct {
	createExecutorHandler  *commands.CreateExecutorCommandHandler
	executeExecutorHandler *commands.ExecuteExecutorCommandHandler
	updateExecutorHandler  *commands.UpdateExecutorCommandHandler
	deleteExecutorHandler  *commands.DeleteExecutorCommandHandler
	getExecutorHandler     *queries.GetExecutorQueryHandler
	listExecutorsHandler   *queries.ListExecutorsQueryHandler
}

// NewExecutorController creates a new executor controller with injected handlers.
func NewExecutorController(
	createExecutorHandler *commands.CreateExecutorCommandHandler,
	executeExecutorHandler *commands.ExecuteExecutorCommandHandler,
	updateExecutorHandler *commands.UpdateExecutorCommandHandler,
	deleteExecutorHandler *commands.DeleteExecutorCommandHandler,
	getExecutorHandler *queries.GetExecutorQueryHandler,
	listExecutorsHandler *queries.ListExecutorsQueryHandler,
) *ExecutorController {
	return &ExecutorController{
		createExecutorHandler:  createExecutorHandler,
		executeExecutorHandler: executeExecutorHandler,
		updateExecutorHandler:  updateExecutorHandler,
		deleteExecutorHandler:  deleteExecutorHandler,
		getExecutorHandler:     getExecutorHandler,
		listExecutorsHandler:   listExecutorsHandler,
	}
}

// RegisterExecutorRoutes registers all HTTP routes for the executor domain.
func RegisterExecutorRoutes(mux *http.ServeMux, controller *ExecutorController) {
	mux.HandleFunc("POST /executors", controller.CreateExecutor)
	mux.HandleFunc("POST /executors/{id}/execute", controller.ExecuteExecutor)
	mux.HandleFunc("GET /executors/{id}", controller.GetExecutor)
	mux.HandleFunc("GET /executors", controller.ListExecutors)
	mux.HandleFunc("PATCH /executors/{id}", controller.UpdateExecutor)
	mux.HandleFunc("DELETE /executors/{id}", controller.DeleteExecutor)
}

// ============================================================================
// CreateExecutor - POST /executors
// ============================================================================

// Request types
// CreateExecutorRequestBody defines the request body for CreateExecutor
type CreateExecutorRequestBody struct {
	CPUShares    *int    `json:"cpuShares,omitempty"`
	Dependencies *string `json:"dependencies,omitempty"`
	Description  string  `json:"description"`
	Env          *string `json:"env,omitempty"`
	ExecuteCode  string  `json:"executeCode"`
	ExtraFiles   *string `json:"extraFiles,omitempty"`
	Language     string  `json:"language"`
	MemoryMB     *int    `json:"memoryMB,omitempty"`
	Name         string  `json:"name"`
	SchemaIn     *string `json:"schemaIn,omitempty"`
	SchemaOut    *string `json:"schemaOut,omitempty"`
	Timeout      *int    `json:"timeout,omitempty"`
}

type CreateExecutorRequest struct {
	Body *CreateExecutorRequestBody
}

// Response types

type CreateExecutorResponse interface {
	VisitCreateExecutorResponse(w http.ResponseWriter) error
}

type CreateExecutor201Response struct {
	Data models.Executor `json:"data"`
}

func (response CreateExecutor201Response) VisitCreateExecutorResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json")
	w.Header().Set("X-RateLimit-Limit", "")     // TODO: Set actual value for X-RateLimit-Limit
	w.Header().Set("X-RateLimit-Remaining", "") // TODO: Set actual value for X-RateLimit-Remaining
	w.Header().Set("X-RateLimit-Reset", "")     // TODO: Set actual value for X-RateLimit-Reset
	w.WriteHeader(201)

	return json.NewEncoder(w).Encode(response)
}

type CreateExecutor400Response struct {
	server.ProblemDetails
}

func (response CreateExecutor400Response) VisitCreateExecutorResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/problem+json")
	w.Header().Set("X-RateLimit-Limit", "")     // TODO: Set actual value for X-RateLimit-Limit
	w.Header().Set("X-RateLimit-Remaining", "") // TODO: Set actual value for X-RateLimit-Remaining
	w.Header().Set("X-RateLimit-Reset", "")     // TODO: Set actual value for X-RateLimit-Reset
	w.WriteHeader(400)

	return json.NewEncoder(w).Encode(response.ProblemDetails)
}

type CreateExecutor401Response struct {
	server.ProblemDetails
}

func (response CreateExecutor401Response) VisitCreateExecutorResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/problem+json")
	w.Header().Set("X-RateLimit-Limit", "")     // TODO: Set actual value for X-RateLimit-Limit
	w.Header().Set("X-RateLimit-Remaining", "") // TODO: Set actual value for X-RateLimit-Remaining
	w.Header().Set("X-RateLimit-Reset", "")     // TODO: Set actual value for X-RateLimit-Reset
	w.WriteHeader(401)

	return json.NewEncoder(w).Encode(response.ProblemDetails)
}

type CreateExecutor422Response struct {
	server.ProblemDetails
}

func (response CreateExecutor422Response) VisitCreateExecutorResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/problem+json")
	w.Header().Set("X-RateLimit-Limit", "")     // TODO: Set actual value for X-RateLimit-Limit
	w.Header().Set("X-RateLimit-Remaining", "") // TODO: Set actual value for X-RateLimit-Remaining
	w.Header().Set("X-RateLimit-Reset", "")     // TODO: Set actual value for X-RateLimit-Reset
	w.WriteHeader(422)

	return json.NewEncoder(w).Encode(response.ProblemDetails)
}

type CreateExecutor429Response struct {
	server.ProblemDetails
}

func (response CreateExecutor429Response) VisitCreateExecutorResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/problem+json")
	w.Header().Set("Retry-After", "")           // TODO: Set actual value for Retry-After
	w.Header().Set("X-RateLimit-Limit", "")     // TODO: Set actual value for X-RateLimit-Limit
	w.Header().Set("X-RateLimit-Remaining", "") // TODO: Set actual value for X-RateLimit-Remaining
	w.Header().Set("X-RateLimit-Reset", "")     // TODO: Set actual value for X-RateLimit-Reset
	w.WriteHeader(429)

	return json.NewEncoder(w).Encode(response.ProblemDetails)
}

type CreateExecutor500Response struct {
	server.ProblemDetails
}

func (response CreateExecutor500Response) VisitCreateExecutorResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/problem+json")
	w.Header().Set("X-RateLimit-Limit", "")     // TODO: Set actual value for X-RateLimit-Limit
	w.Header().Set("X-RateLimit-Remaining", "") // TODO: Set actual value for X-RateLimit-Remaining
	w.Header().Set("X-RateLimit-Reset", "")     // TODO: Set actual value for X-RateLimit-Reset
	w.WriteHeader(500)

	return json.NewEncoder(w).Encode(response.ProblemDetails)
}

// Handler method

// CreateExecutor handles the POST /executors endpoint.
func (c *ExecutorController) CreateExecutor(w http.ResponseWriter, r *http.Request) {
	ctx := r.Context()
	request := CreateExecutorRequest{}

	// Extract session ID from context for authenticated operations
	sessionID, ok := ctx.Value(server.SessionIDContextKey).(uuid.UUID)
	if !ok {
		errorResp := CreateExecutor401Response{
			ProblemDetails: server.NewUnauthorizedResponse("session required", r.URL.Path),
		}
		if err := errorResp.VisitCreateExecutorResponse(w); err != nil {
			// Log error - response may have already been partially written
			fmt.Fprintf(w, "error writing response: %v", err)
		}
		return
	}

	// Request body
	request.Body = &CreateExecutorRequestBody{}
	if err := json.NewDecoder(r.Body).Decode(request.Body); err != nil {
		errorResp := CreateExecutor400Response{
			ProblemDetails: server.NewBadRequestResponse(err.Error(), r.URL.Path),
		}
		if err := errorResp.VisitCreateExecutorResponse(w); err != nil {
			fmt.Fprintf(w, "error writing response: %v", err)
		}
		return
	}

	// Determine which handler to call based on operation
	// Command handler

	// Map request to command parameters
	cmd := commands.NewCreateExecutorCommand(
		sessionID,                 // SessionID for authenticated operations
		request.Body.CPUShares,    // CPUShares
		request.Body.Dependencies, // Dependencies
		request.Body.Description,  // Description
		request.Body.Env,          // Env
		request.Body.ExecuteCode,  // ExecuteCode
		request.Body.ExtraFiles,   // ExtraFiles
		request.Body.Language,     // Language
		request.Body.MemoryMB,     // MemoryMB
		request.Body.Name,         // Name
		request.Body.SchemaIn,     // SchemaIn
		request.Body.SchemaOut,    // SchemaOut
		request.Body.Timeout,      // Timeout
	)
	result, err := c.createExecutorHandler.Handle(ctx, cmd)
	if err != nil {
		errorResp := CreateExecutor500Response{
			ProblemDetails: server.NewInternalServerErrorResponse(err.Error(), r.URL.Path),
		}
		if err := errorResp.VisitCreateExecutorResponse(w); err != nil {
			fmt.Fprintf(w, "error writing response: %v", err)
		}
		return
	}

	response := CreateExecutor201Response{Data: *result}
	if err := response.VisitCreateExecutorResponse(w); err != nil {
		fmt.Fprintf(w, "error writing response: %v", err)
	}
}

// ============================================================================
// ExecuteExecutor - POST /executors/{id}/execute
// ============================================================================

// Request types
// ExecuteExecutorRequestBody defines the request body for ExecuteExecutor
type ExecuteExecutorRequestBody struct {
	Input map[string]any `json:"input"`
}

type ExecuteExecutorRequest struct {
	ID   uuid.UUID `json:"id"`
	Body *ExecuteExecutorRequestBody
}

// Response types

type ExecuteExecutorResponse interface {
	VisitExecuteExecutorResponse(w http.ResponseWriter) error
}

// ExecuteExecutor200ResponseData defines the data structure
type ExecuteExecutor200ResponseData struct {
	ExecutionTimeMs int            `json:"executionTimeMs,omitempty"`
	Logs            string         `json:"logs,omitempty"`
	Output          map[string]any `json:"output"`
}

type ExecuteExecutor200Response struct {
	Data ExecuteExecutor200ResponseData `json:"data,omitempty"`
}

func (response ExecuteExecutor200Response) VisitExecuteExecutorResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json")
	w.WriteHeader(200)

	return json.NewEncoder(w).Encode(response)
}

type ExecuteExecutor400Response struct {
	server.ProblemDetails
}

func (response ExecuteExecutor400Response) VisitExecuteExecutorResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/problem+json")
	w.Header().Set("X-RateLimit-Limit", "")     // TODO: Set actual value for X-RateLimit-Limit
	w.Header().Set("X-RateLimit-Remaining", "") // TODO: Set actual value for X-RateLimit-Remaining
	w.Header().Set("X-RateLimit-Reset", "")     // TODO: Set actual value for X-RateLimit-Reset
	w.WriteHeader(400)

	return json.NewEncoder(w).Encode(response.ProblemDetails)
}

type ExecuteExecutor401Response struct {
	server.ProblemDetails
}

func (response ExecuteExecutor401Response) VisitExecuteExecutorResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/problem+json")
	w.Header().Set("X-RateLimit-Limit", "")     // TODO: Set actual value for X-RateLimit-Limit
	w.Header().Set("X-RateLimit-Remaining", "") // TODO: Set actual value for X-RateLimit-Remaining
	w.Header().Set("X-RateLimit-Reset", "")     // TODO: Set actual value for X-RateLimit-Reset
	w.WriteHeader(401)

	return json.NewEncoder(w).Encode(response.ProblemDetails)
}

type ExecuteExecutor404Response struct {
	server.ProblemDetails
}

func (response ExecuteExecutor404Response) VisitExecuteExecutorResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/problem+json")
	w.Header().Set("X-RateLimit-Limit", "")     // TODO: Set actual value for X-RateLimit-Limit
	w.Header().Set("X-RateLimit-Remaining", "") // TODO: Set actual value for X-RateLimit-Remaining
	w.Header().Set("X-RateLimit-Reset", "")     // TODO: Set actual value for X-RateLimit-Reset
	w.WriteHeader(404)

	return json.NewEncoder(w).Encode(response.ProblemDetails)
}

type ExecuteExecutor422Response struct {
	server.ProblemDetails
}

func (response ExecuteExecutor422Response) VisitExecuteExecutorResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/problem+json")
	w.Header().Set("X-RateLimit-Limit", "")     // TODO: Set actual value for X-RateLimit-Limit
	w.Header().Set("X-RateLimit-Remaining", "") // TODO: Set actual value for X-RateLimit-Remaining
	w.Header().Set("X-RateLimit-Reset", "")     // TODO: Set actual value for X-RateLimit-Reset
	w.WriteHeader(422)

	return json.NewEncoder(w).Encode(response.ProblemDetails)
}

type ExecuteExecutor429Response struct {
	server.ProblemDetails
}

func (response ExecuteExecutor429Response) VisitExecuteExecutorResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/problem+json")
	w.Header().Set("Retry-After", "")           // TODO: Set actual value for Retry-After
	w.Header().Set("X-RateLimit-Limit", "")     // TODO: Set actual value for X-RateLimit-Limit
	w.Header().Set("X-RateLimit-Remaining", "") // TODO: Set actual value for X-RateLimit-Remaining
	w.Header().Set("X-RateLimit-Reset", "")     // TODO: Set actual value for X-RateLimit-Reset
	w.WriteHeader(429)

	return json.NewEncoder(w).Encode(response.ProblemDetails)
}

type ExecuteExecutor500Response struct {
	server.ProblemDetails
}

func (response ExecuteExecutor500Response) VisitExecuteExecutorResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/problem+json")
	w.Header().Set("X-RateLimit-Limit", "")     // TODO: Set actual value for X-RateLimit-Limit
	w.Header().Set("X-RateLimit-Remaining", "") // TODO: Set actual value for X-RateLimit-Remaining
	w.Header().Set("X-RateLimit-Reset", "")     // TODO: Set actual value for X-RateLimit-Reset
	w.WriteHeader(500)

	return json.NewEncoder(w).Encode(response.ProblemDetails)
}

// Handler method

// ExecuteExecutor handles the POST /executors/{id}/execute endpoint.
func (c *ExecutorController) ExecuteExecutor(w http.ResponseWriter, r *http.Request) {
	ctx := r.Context()
	request := ExecuteExecutorRequest{}

	// Extract session ID from context for authenticated operations
	sessionID, ok := ctx.Value(server.SessionIDContextKey).(uuid.UUID)
	if !ok {
		errorResp := ExecuteExecutor401Response{
			ProblemDetails: server.NewUnauthorizedResponse("session required", r.URL.Path),
		}
		if err := errorResp.VisitExecuteExecutorResponse(w); err != nil {
			// Log error - response may have already been partially written
			fmt.Fprintf(w, "error writing response: %v", err)
		}
		return
	}

	// Path parameter "id"
	var id uuid.UUID
	if err := runtime.BindStyledParameterWithOptions("simple", "id", r.PathValue("id"), &id, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true}); err != nil {
		errorResp := ExecuteExecutor400Response{
			ProblemDetails: server.NewBadRequestResponse(fmt.Sprintf("Invalid format for parameter id: %s", err), r.URL.Path),
		}
		if err := errorResp.VisitExecuteExecutorResponse(w); err != nil {
			fmt.Fprintf(w, "error writing response: %v", err)
		}
		return
	}
	request.ID = id

	// Request body
	request.Body = &ExecuteExecutorRequestBody{}
	if err := json.NewDecoder(r.Body).Decode(request.Body); err != nil {
		errorResp := ExecuteExecutor400Response{
			ProblemDetails: server.NewBadRequestResponse(err.Error(), r.URL.Path),
		}
		if err := errorResp.VisitExecuteExecutorResponse(w); err != nil {
			fmt.Fprintf(w, "error writing response: %v", err)
		}
		return
	}

	// Determine which handler to call based on operation
	// Command handler

	// Map request to command parameters
	cmd := commands.NewExecuteExecutorCommand(
		sessionID,          // SessionID for authenticated operations
		request.ID,         // ID
		request.Body.Input, // Input
	)
	result, err := c.executeExecutorHandler.Handle(ctx, cmd)
	if err != nil {
		errorResp := ExecuteExecutor500Response{
			ProblemDetails: server.NewInternalServerErrorResponse(err.Error(), r.URL.Path),
		}
		if err := errorResp.VisitExecuteExecutorResponse(w); err != nil {
			fmt.Fprintf(w, "error writing response: %v", err)
		}
		return
	}

	// Custom handler - result type varies, response structure not standardized
	// TODO: Implement proper type assertion and response mapping
	_ = result
	response := ExecuteExecutor200Response{}
	if err := response.VisitExecuteExecutorResponse(w); err != nil {
		fmt.Fprintf(w, "error writing response: %v", err)
	}
}

// ============================================================================
// GetExecutor - GET /executors/{id}
// ============================================================================

// Request types

type GetExecutorRequest struct {
	ID uuid.UUID `json:"id"`
}

// Response types

type GetExecutorResponse interface {
	VisitGetExecutorResponse(w http.ResponseWriter) error
}

type GetExecutor200Response struct {
	Data models.Executor `json:"data"`
}

func (response GetExecutor200Response) VisitGetExecutorResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json")
	w.Header().Set("X-RateLimit-Limit", "")     // TODO: Set actual value for X-RateLimit-Limit
	w.Header().Set("X-RateLimit-Remaining", "") // TODO: Set actual value for X-RateLimit-Remaining
	w.Header().Set("X-RateLimit-Reset", "")     // TODO: Set actual value for X-RateLimit-Reset
	w.WriteHeader(200)

	return json.NewEncoder(w).Encode(response)
}

type GetExecutor400Response struct {
	server.ProblemDetails
}

func (response GetExecutor400Response) VisitGetExecutorResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/problem+json")
	w.Header().Set("X-RateLimit-Limit", "")     // TODO: Set actual value for X-RateLimit-Limit
	w.Header().Set("X-RateLimit-Remaining", "") // TODO: Set actual value for X-RateLimit-Remaining
	w.Header().Set("X-RateLimit-Reset", "")     // TODO: Set actual value for X-RateLimit-Reset
	w.WriteHeader(400)

	return json.NewEncoder(w).Encode(response.ProblemDetails)
}

type GetExecutor401Response struct {
	server.ProblemDetails
}

func (response GetExecutor401Response) VisitGetExecutorResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/problem+json")
	w.Header().Set("X-RateLimit-Limit", "")     // TODO: Set actual value for X-RateLimit-Limit
	w.Header().Set("X-RateLimit-Remaining", "") // TODO: Set actual value for X-RateLimit-Remaining
	w.Header().Set("X-RateLimit-Reset", "")     // TODO: Set actual value for X-RateLimit-Reset
	w.WriteHeader(401)

	return json.NewEncoder(w).Encode(response.ProblemDetails)
}

type GetExecutor404Response struct {
	server.ProblemDetails
}

func (response GetExecutor404Response) VisitGetExecutorResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/problem+json")
	w.Header().Set("X-RateLimit-Limit", "")     // TODO: Set actual value for X-RateLimit-Limit
	w.Header().Set("X-RateLimit-Remaining", "") // TODO: Set actual value for X-RateLimit-Remaining
	w.Header().Set("X-RateLimit-Reset", "")     // TODO: Set actual value for X-RateLimit-Reset
	w.WriteHeader(404)

	return json.NewEncoder(w).Encode(response.ProblemDetails)
}

type GetExecutor422Response struct {
	server.ProblemDetails
}

func (response GetExecutor422Response) VisitGetExecutorResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/problem+json")
	w.Header().Set("X-RateLimit-Limit", "")     // TODO: Set actual value for X-RateLimit-Limit
	w.Header().Set("X-RateLimit-Remaining", "") // TODO: Set actual value for X-RateLimit-Remaining
	w.Header().Set("X-RateLimit-Reset", "")     // TODO: Set actual value for X-RateLimit-Reset
	w.WriteHeader(422)

	return json.NewEncoder(w).Encode(response.ProblemDetails)
}

type GetExecutor429Response struct {
	server.ProblemDetails
}

func (response GetExecutor429Response) VisitGetExecutorResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/problem+json")
	w.Header().Set("Retry-After", "")           // TODO: Set actual value for Retry-After
	w.Header().Set("X-RateLimit-Limit", "")     // TODO: Set actual value for X-RateLimit-Limit
	w.Header().Set("X-RateLimit-Remaining", "") // TODO: Set actual value for X-RateLimit-Remaining
	w.Header().Set("X-RateLimit-Reset", "")     // TODO: Set actual value for X-RateLimit-Reset
	w.WriteHeader(429)

	return json.NewEncoder(w).Encode(response.ProblemDetails)
}

type GetExecutor500Response struct {
	server.ProblemDetails
}

func (response GetExecutor500Response) VisitGetExecutorResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/problem+json")
	w.Header().Set("X-RateLimit-Limit", "")     // TODO: Set actual value for X-RateLimit-Limit
	w.Header().Set("X-RateLimit-Remaining", "") // TODO: Set actual value for X-RateLimit-Remaining
	w.Header().Set("X-RateLimit-Reset", "")     // TODO: Set actual value for X-RateLimit-Reset
	w.WriteHeader(500)

	return json.NewEncoder(w).Encode(response.ProblemDetails)
}

// Handler method

// GetExecutor handles the GET /executors/{id} endpoint.
func (c *ExecutorController) GetExecutor(w http.ResponseWriter, r *http.Request) {
	ctx := r.Context()
	request := GetExecutorRequest{}

	// Extract session ID from context for authenticated operations
	sessionID, ok := ctx.Value(server.SessionIDContextKey).(uuid.UUID)
	if !ok {
		errorResp := GetExecutor401Response{
			ProblemDetails: server.NewUnauthorizedResponse("session required", r.URL.Path),
		}
		if err := errorResp.VisitGetExecutorResponse(w); err != nil {
			// Log error - response may have already been partially written
			fmt.Fprintf(w, "error writing response: %v", err)
		}
		return
	}

	// Path parameter "id"
	var id uuid.UUID
	if err := runtime.BindStyledParameterWithOptions("simple", "id", r.PathValue("id"), &id, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true}); err != nil {
		errorResp := GetExecutor400Response{
			ProblemDetails: server.NewBadRequestResponse(fmt.Sprintf("Invalid format for parameter id: %s", err), r.URL.Path),
		}
		if err := errorResp.VisitGetExecutorResponse(w); err != nil {
			fmt.Fprintf(w, "error writing response: %v", err)
		}
		return
	}
	request.ID = id

	// Determine which handler to call based on operation
	// Query handler
	query := queries.NewGetExecutorQuery(
		sessionID,  // SessionID for authenticated operations
		request.ID, // ID
	)

	result, err := c.getExecutorHandler.Handle(ctx, query)
	if err != nil {
		errorResp := GetExecutor500Response{
			ProblemDetails: server.NewInternalServerErrorResponse(err.Error(), r.URL.Path),
		}
		if err := errorResp.VisitGetExecutorResponse(w); err != nil {
			fmt.Fprintf(w, "error writing response: %v", err)
		}
		return
	}

	response := GetExecutor200Response{Data: *result}
	if err := response.VisitGetExecutorResponse(w); err != nil {
		fmt.Fprintf(w, "error writing response: %v", err)
	}
}

// ============================================================================
// ListExecutors - GET /executors
// ============================================================================

// Request types
// ListExecutorsParams defines parameters for ListExecutors
type ListExecutorsParams struct {
	Filter map[string]any   `json:"filter,omitempty"`
	Page   map[string]any   `json:"page,omitempty"`
	Sort   []map[string]any `json:"sort,omitempty"`
}

type ListExecutorsRequest struct {
	Params ListExecutorsParams
}

// Response types

type ListExecutorsResponse interface {
	VisitListExecutorsResponse(w http.ResponseWriter) error
}

type ListExecutors200Response struct {
	Data []models.Executor     `json:"data"`
	Meta models.PaginationMeta `json:"meta"`
}

func (response ListExecutors200Response) VisitListExecutorsResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json")
	w.Header().Set("X-RateLimit-Limit", "")     // TODO: Set actual value for X-RateLimit-Limit
	w.Header().Set("X-RateLimit-Remaining", "") // TODO: Set actual value for X-RateLimit-Remaining
	w.Header().Set("X-RateLimit-Reset", "")     // TODO: Set actual value for X-RateLimit-Reset
	w.WriteHeader(200)

	return json.NewEncoder(w).Encode(response)
}

type ListExecutors400Response struct {
	server.ProblemDetails
}

func (response ListExecutors400Response) VisitListExecutorsResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/problem+json")
	w.Header().Set("X-RateLimit-Limit", "")     // TODO: Set actual value for X-RateLimit-Limit
	w.Header().Set("X-RateLimit-Remaining", "") // TODO: Set actual value for X-RateLimit-Remaining
	w.Header().Set("X-RateLimit-Reset", "")     // TODO: Set actual value for X-RateLimit-Reset
	w.WriteHeader(400)

	return json.NewEncoder(w).Encode(response.ProblemDetails)
}

type ListExecutors401Response struct {
	server.ProblemDetails
}

func (response ListExecutors401Response) VisitListExecutorsResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/problem+json")
	w.Header().Set("X-RateLimit-Limit", "")     // TODO: Set actual value for X-RateLimit-Limit
	w.Header().Set("X-RateLimit-Remaining", "") // TODO: Set actual value for X-RateLimit-Remaining
	w.Header().Set("X-RateLimit-Reset", "")     // TODO: Set actual value for X-RateLimit-Reset
	w.WriteHeader(401)

	return json.NewEncoder(w).Encode(response.ProblemDetails)
}

type ListExecutors422Response struct {
	server.ProblemDetails
}

func (response ListExecutors422Response) VisitListExecutorsResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/problem+json")
	w.Header().Set("X-RateLimit-Limit", "")     // TODO: Set actual value for X-RateLimit-Limit
	w.Header().Set("X-RateLimit-Remaining", "") // TODO: Set actual value for X-RateLimit-Remaining
	w.Header().Set("X-RateLimit-Reset", "")     // TODO: Set actual value for X-RateLimit-Reset
	w.WriteHeader(422)

	return json.NewEncoder(w).Encode(response.ProblemDetails)
}

type ListExecutors429Response struct {
	server.ProblemDetails
}

func (response ListExecutors429Response) VisitListExecutorsResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/problem+json")
	w.Header().Set("Retry-After", "")           // TODO: Set actual value for Retry-After
	w.Header().Set("X-RateLimit-Limit", "")     // TODO: Set actual value for X-RateLimit-Limit
	w.Header().Set("X-RateLimit-Remaining", "") // TODO: Set actual value for X-RateLimit-Remaining
	w.Header().Set("X-RateLimit-Reset", "")     // TODO: Set actual value for X-RateLimit-Reset
	w.WriteHeader(429)

	return json.NewEncoder(w).Encode(response.ProblemDetails)
}

type ListExecutors500Response struct {
	server.ProblemDetails
}

func (response ListExecutors500Response) VisitListExecutorsResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/problem+json")
	w.Header().Set("X-RateLimit-Limit", "")     // TODO: Set actual value for X-RateLimit-Limit
	w.Header().Set("X-RateLimit-Remaining", "") // TODO: Set actual value for X-RateLimit-Remaining
	w.Header().Set("X-RateLimit-Reset", "")     // TODO: Set actual value for X-RateLimit-Reset
	w.WriteHeader(500)

	return json.NewEncoder(w).Encode(response.ProblemDetails)
}

// Handler method

// ListExecutors handles the GET /executors endpoint.
func (c *ExecutorController) ListExecutors(w http.ResponseWriter, r *http.Request) {
	ctx := r.Context()
	request := ListExecutorsRequest{}

	// Extract session ID from context for authenticated operations
	sessionID, ok := ctx.Value(server.SessionIDContextKey).(uuid.UUID)
	if !ok {
		errorResp := ListExecutors401Response{
			ProblemDetails: server.NewUnauthorizedResponse("session required", r.URL.Path),
		}
		if err := errorResp.VisitListExecutorsResponse(w); err != nil {
			// Log error - response may have already been partially written
			fmt.Fprintf(w, "error writing response: %v", err)
		}
		return
	}

	// Query parameters
	var params ListExecutorsParams

	// Optional query parameter "filter"
	if err := runtime.BindQueryParameter("deepObject", true, false, "filter", r.URL.Query(), &params.Filter); err != nil {
		errorResp := ListExecutors400Response{
			ProblemDetails: server.NewBadRequestResponse(fmt.Sprintf("Invalid format for parameter filter: %s", err), r.URL.Path),
		}
		if err := errorResp.VisitListExecutorsResponse(w); err != nil {
			fmt.Fprintf(w, "error writing response: %v", err)
		}
		return
	}

	// Optional query parameter "page"
	if err := runtime.BindQueryParameter("form", true, false, "page", r.URL.Query(), &params.Page); err != nil {
		errorResp := ListExecutors400Response{
			ProblemDetails: server.NewBadRequestResponse(fmt.Sprintf("Invalid format for parameter page: %s", err), r.URL.Path),
		}
		if err := errorResp.VisitListExecutorsResponse(w); err != nil {
			fmt.Fprintf(w, "error writing response: %v", err)
		}
		return
	}

	// Optional query parameter "sort"
	if err := runtime.BindQueryParameter("form", true, false, "sort", r.URL.Query(), &params.Sort); err != nil {
		errorResp := ListExecutors400Response{
			ProblemDetails: server.NewBadRequestResponse(fmt.Sprintf("Invalid format for parameter sort: %s", err), r.URL.Path),
		}
		if err := errorResp.VisitListExecutorsResponse(w); err != nil {
			fmt.Fprintf(w, "error writing response: %v", err)
		}
		return
	}
	request.Params = params

	// Determine which handler to call based on operation
	// Query handler
	query := queries.NewListExecutorsQuery(
		sessionID, // SessionID for authenticated operations
	)
	// TODO: Apply filters, pagination, sorting from request.Params

	results, total, err := c.listExecutorsHandler.Handle(ctx, query)
	if err != nil {
		errorResp := ListExecutors500Response{
			ProblemDetails: server.NewInternalServerErrorResponse(err.Error(), r.URL.Path),
		}
		if err := errorResp.VisitListExecutorsResponse(w); err != nil {
			fmt.Fprintf(w, "error writing response: %v", err)
		}
		return
	}

	// Convert pointer slice to value slice for response
	data := make([]models.Executor, len(results))
	for i, item := range results {
		if item != nil {
			data[i] = *item
		}
	}

	response := ListExecutors200Response{
		Data: data,
		Meta: models.PaginationMeta{Total: int32(total)},
	}
	if err := response.VisitListExecutorsResponse(w); err != nil {
		fmt.Fprintf(w, "error writing response: %v", err)
	}
}

// ============================================================================
// UpdateExecutor - PATCH /executors/{id}
// ============================================================================

// Request types
// UpdateExecutorRequestBody defines the request body for UpdateExecutor
type UpdateExecutorRequestBody struct {
	CPUShares    *int    `json:"cpuShares,omitempty"`
	Dependencies *string `json:"dependencies,omitempty"`
	Description  *string `json:"description,omitempty"`
	Env          *string `json:"env,omitempty"`
	ExecuteCode  *string `json:"executeCode,omitempty"`
	ExtraFiles   *string `json:"extraFiles,omitempty"`
	IsActive     *bool   `json:"isActive,omitempty"`
	Language     *string `json:"language,omitempty"`
	MemoryMB     *int    `json:"memoryMB,omitempty"`
	Name         *string `json:"name,omitempty"`
	SchemaIn     *string `json:"schemaIn,omitempty"`
	SchemaOut    *string `json:"schemaOut,omitempty"`
	Timeout      *int    `json:"timeout,omitempty"`
}

type UpdateExecutorRequest struct {
	ID   uuid.UUID `json:"id"`
	Body *UpdateExecutorRequestBody
}

// Response types

type UpdateExecutorResponse interface {
	VisitUpdateExecutorResponse(w http.ResponseWriter) error
}

type UpdateExecutor200Response struct {
	Data models.Executor `json:"data"`
}

func (response UpdateExecutor200Response) VisitUpdateExecutorResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json")
	w.Header().Set("X-RateLimit-Limit", "")     // TODO: Set actual value for X-RateLimit-Limit
	w.Header().Set("X-RateLimit-Remaining", "") // TODO: Set actual value for X-RateLimit-Remaining
	w.Header().Set("X-RateLimit-Reset", "")     // TODO: Set actual value for X-RateLimit-Reset
	w.WriteHeader(200)

	return json.NewEncoder(w).Encode(response)
}

type UpdateExecutor400Response struct {
	server.ProblemDetails
}

func (response UpdateExecutor400Response) VisitUpdateExecutorResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/problem+json")
	w.Header().Set("X-RateLimit-Limit", "")     // TODO: Set actual value for X-RateLimit-Limit
	w.Header().Set("X-RateLimit-Remaining", "") // TODO: Set actual value for X-RateLimit-Remaining
	w.Header().Set("X-RateLimit-Reset", "")     // TODO: Set actual value for X-RateLimit-Reset
	w.WriteHeader(400)

	return json.NewEncoder(w).Encode(response.ProblemDetails)
}

type UpdateExecutor401Response struct {
	server.ProblemDetails
}

func (response UpdateExecutor401Response) VisitUpdateExecutorResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/problem+json")
	w.Header().Set("X-RateLimit-Limit", "")     // TODO: Set actual value for X-RateLimit-Limit
	w.Header().Set("X-RateLimit-Remaining", "") // TODO: Set actual value for X-RateLimit-Remaining
	w.Header().Set("X-RateLimit-Reset", "")     // TODO: Set actual value for X-RateLimit-Reset
	w.WriteHeader(401)

	return json.NewEncoder(w).Encode(response.ProblemDetails)
}

type UpdateExecutor404Response struct {
	server.ProblemDetails
}

func (response UpdateExecutor404Response) VisitUpdateExecutorResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/problem+json")
	w.Header().Set("X-RateLimit-Limit", "")     // TODO: Set actual value for X-RateLimit-Limit
	w.Header().Set("X-RateLimit-Remaining", "") // TODO: Set actual value for X-RateLimit-Remaining
	w.Header().Set("X-RateLimit-Reset", "")     // TODO: Set actual value for X-RateLimit-Reset
	w.WriteHeader(404)

	return json.NewEncoder(w).Encode(response.ProblemDetails)
}

type UpdateExecutor422Response struct {
	server.ProblemDetails
}

func (response UpdateExecutor422Response) VisitUpdateExecutorResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/problem+json")
	w.Header().Set("X-RateLimit-Limit", "")     // TODO: Set actual value for X-RateLimit-Limit
	w.Header().Set("X-RateLimit-Remaining", "") // TODO: Set actual value for X-RateLimit-Remaining
	w.Header().Set("X-RateLimit-Reset", "")     // TODO: Set actual value for X-RateLimit-Reset
	w.WriteHeader(422)

	return json.NewEncoder(w).Encode(response.ProblemDetails)
}

type UpdateExecutor429Response struct {
	server.ProblemDetails
}

func (response UpdateExecutor429Response) VisitUpdateExecutorResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/problem+json")
	w.Header().Set("Retry-After", "")           // TODO: Set actual value for Retry-After
	w.Header().Set("X-RateLimit-Limit", "")     // TODO: Set actual value for X-RateLimit-Limit
	w.Header().Set("X-RateLimit-Remaining", "") // TODO: Set actual value for X-RateLimit-Remaining
	w.Header().Set("X-RateLimit-Reset", "")     // TODO: Set actual value for X-RateLimit-Reset
	w.WriteHeader(429)

	return json.NewEncoder(w).Encode(response.ProblemDetails)
}

type UpdateExecutor500Response struct {
	server.ProblemDetails
}

func (response UpdateExecutor500Response) VisitUpdateExecutorResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/problem+json")
	w.Header().Set("X-RateLimit-Limit", "")     // TODO: Set actual value for X-RateLimit-Limit
	w.Header().Set("X-RateLimit-Remaining", "") // TODO: Set actual value for X-RateLimit-Remaining
	w.Header().Set("X-RateLimit-Reset", "")     // TODO: Set actual value for X-RateLimit-Reset
	w.WriteHeader(500)

	return json.NewEncoder(w).Encode(response.ProblemDetails)
}

// Handler method

// UpdateExecutor handles the PATCH /executors/{id} endpoint.
func (c *ExecutorController) UpdateExecutor(w http.ResponseWriter, r *http.Request) {
	ctx := r.Context()
	request := UpdateExecutorRequest{}

	// Extract session ID from context for authenticated operations
	sessionID, ok := ctx.Value(server.SessionIDContextKey).(uuid.UUID)
	if !ok {
		errorResp := UpdateExecutor401Response{
			ProblemDetails: server.NewUnauthorizedResponse("session required", r.URL.Path),
		}
		if err := errorResp.VisitUpdateExecutorResponse(w); err != nil {
			// Log error - response may have already been partially written
			fmt.Fprintf(w, "error writing response: %v", err)
		}
		return
	}

	// Path parameter "id"
	var id uuid.UUID
	if err := runtime.BindStyledParameterWithOptions("simple", "id", r.PathValue("id"), &id, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true}); err != nil {
		errorResp := UpdateExecutor400Response{
			ProblemDetails: server.NewBadRequestResponse(fmt.Sprintf("Invalid format for parameter id: %s", err), r.URL.Path),
		}
		if err := errorResp.VisitUpdateExecutorResponse(w); err != nil {
			fmt.Fprintf(w, "error writing response: %v", err)
		}
		return
	}
	request.ID = id

	// Request body
	request.Body = &UpdateExecutorRequestBody{}
	if err := json.NewDecoder(r.Body).Decode(request.Body); err != nil {
		errorResp := UpdateExecutor400Response{
			ProblemDetails: server.NewBadRequestResponse(err.Error(), r.URL.Path),
		}
		if err := errorResp.VisitUpdateExecutorResponse(w); err != nil {
			fmt.Fprintf(w, "error writing response: %v", err)
		}
		return
	}

	// Determine which handler to call based on operation
	// Command handler

	// Map request to command parameters
	cmd := commands.NewUpdateExecutorCommand(
		sessionID,                 // SessionID for authenticated operations
		request.ID,                // ID
		request.Body.CPUShares,    // CPUShares
		request.Body.Dependencies, // Dependencies
		request.Body.Description,  // Description
		request.Body.Env,          // Env
		request.Body.ExecuteCode,  // ExecuteCode
		request.Body.ExtraFiles,   // ExtraFiles
		request.Body.IsActive,     // IsActive
		request.Body.Language,     // Language
		request.Body.MemoryMB,     // MemoryMB
		request.Body.Name,         // Name
		request.Body.SchemaIn,     // SchemaIn
		request.Body.SchemaOut,    // SchemaOut
		request.Body.Timeout,      // Timeout
	)
	result, err := c.updateExecutorHandler.Handle(ctx, cmd)
	if err != nil {
		errorResp := UpdateExecutor500Response{
			ProblemDetails: server.NewInternalServerErrorResponse(err.Error(), r.URL.Path),
		}
		if err := errorResp.VisitUpdateExecutorResponse(w); err != nil {
			fmt.Fprintf(w, "error writing response: %v", err)
		}
		return
	}

	response := UpdateExecutor200Response{Data: *result}
	if err := response.VisitUpdateExecutorResponse(w); err != nil {
		fmt.Fprintf(w, "error writing response: %v", err)
	}
}

// ============================================================================
// DeleteExecutor - DELETE /executors/{id}
// ============================================================================

// Request types

type DeleteExecutorRequest struct {
	ID uuid.UUID `json:"id"`
}

// Response types

type DeleteExecutorResponse interface {
	VisitDeleteExecutorResponse(w http.ResponseWriter) error
}

type DeleteExecutor204Response struct {
}

func (response DeleteExecutor204Response) VisitDeleteExecutorResponse(w http.ResponseWriter) error {
	w.Header().Set("X-RateLimit-Limit", "")     // TODO: Set actual value for X-RateLimit-Limit
	w.Header().Set("X-RateLimit-Remaining", "") // TODO: Set actual value for X-RateLimit-Remaining
	w.Header().Set("X-RateLimit-Reset", "")     // TODO: Set actual value for X-RateLimit-Reset
	w.WriteHeader(204)

	return nil
}

type DeleteExecutor400Response struct {
	server.ProblemDetails
}

func (response DeleteExecutor400Response) VisitDeleteExecutorResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/problem+json")
	w.Header().Set("X-RateLimit-Limit", "")     // TODO: Set actual value for X-RateLimit-Limit
	w.Header().Set("X-RateLimit-Remaining", "") // TODO: Set actual value for X-RateLimit-Remaining
	w.Header().Set("X-RateLimit-Reset", "")     // TODO: Set actual value for X-RateLimit-Reset
	w.WriteHeader(400)

	return json.NewEncoder(w).Encode(response.ProblemDetails)
}

type DeleteExecutor401Response struct {
	server.ProblemDetails
}

func (response DeleteExecutor401Response) VisitDeleteExecutorResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/problem+json")
	w.Header().Set("X-RateLimit-Limit", "")     // TODO: Set actual value for X-RateLimit-Limit
	w.Header().Set("X-RateLimit-Remaining", "") // TODO: Set actual value for X-RateLimit-Remaining
	w.Header().Set("X-RateLimit-Reset", "")     // TODO: Set actual value for X-RateLimit-Reset
	w.WriteHeader(401)

	return json.NewEncoder(w).Encode(response.ProblemDetails)
}

type DeleteExecutor404Response struct {
	server.ProblemDetails
}

func (response DeleteExecutor404Response) VisitDeleteExecutorResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/problem+json")
	w.Header().Set("X-RateLimit-Limit", "")     // TODO: Set actual value for X-RateLimit-Limit
	w.Header().Set("X-RateLimit-Remaining", "") // TODO: Set actual value for X-RateLimit-Remaining
	w.Header().Set("X-RateLimit-Reset", "")     // TODO: Set actual value for X-RateLimit-Reset
	w.WriteHeader(404)

	return json.NewEncoder(w).Encode(response.ProblemDetails)
}

type DeleteExecutor422Response struct {
	server.ProblemDetails
}

func (response DeleteExecutor422Response) VisitDeleteExecutorResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/problem+json")
	w.Header().Set("X-RateLimit-Limit", "")     // TODO: Set actual value for X-RateLimit-Limit
	w.Header().Set("X-RateLimit-Remaining", "") // TODO: Set actual value for X-RateLimit-Remaining
	w.Header().Set("X-RateLimit-Reset", "")     // TODO: Set actual value for X-RateLimit-Reset
	w.WriteHeader(422)

	return json.NewEncoder(w).Encode(response.ProblemDetails)
}

type DeleteExecutor429Response struct {
	server.ProblemDetails
}

func (response DeleteExecutor429Response) VisitDeleteExecutorResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/problem+json")
	w.Header().Set("Retry-After", "")           // TODO: Set actual value for Retry-After
	w.Header().Set("X-RateLimit-Limit", "")     // TODO: Set actual value for X-RateLimit-Limit
	w.Header().Set("X-RateLimit-Remaining", "") // TODO: Set actual value for X-RateLimit-Remaining
	w.Header().Set("X-RateLimit-Reset", "")     // TODO: Set actual value for X-RateLimit-Reset
	w.WriteHeader(429)

	return json.NewEncoder(w).Encode(response.ProblemDetails)
}

type DeleteExecutor500Response struct {
	server.ProblemDetails
}

func (response DeleteExecutor500Response) VisitDeleteExecutorResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/problem+json")
	w.Header().Set("X-RateLimit-Limit", "")     // TODO: Set actual value for X-RateLimit-Limit
	w.Header().Set("X-RateLimit-Remaining", "") // TODO: Set actual value for X-RateLimit-Remaining
	w.Header().Set("X-RateLimit-Reset", "")     // TODO: Set actual value for X-RateLimit-Reset
	w.WriteHeader(500)

	return json.NewEncoder(w).Encode(response.ProblemDetails)
}

// Handler method

// DeleteExecutor handles the DELETE /executors/{id} endpoint.
func (c *ExecutorController) DeleteExecutor(w http.ResponseWriter, r *http.Request) {
	ctx := r.Context()
	request := DeleteExecutorRequest{}

	// Extract session ID from context for authenticated operations
	sessionID, ok := ctx.Value(server.SessionIDContextKey).(uuid.UUID)
	if !ok {
		errorResp := DeleteExecutor401Response{
			ProblemDetails: server.NewUnauthorizedResponse("session required", r.URL.Path),
		}
		if err := errorResp.VisitDeleteExecutorResponse(w); err != nil {
			// Log error - response may have already been partially written
			fmt.Fprintf(w, "error writing response: %v", err)
		}
		return
	}

	// Path parameter "id"
	var id uuid.UUID
	if err := runtime.BindStyledParameterWithOptions("simple", "id", r.PathValue("id"), &id, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true}); err != nil {
		errorResp := DeleteExecutor400Response{
			ProblemDetails: server.NewBadRequestResponse(fmt.Sprintf("Invalid format for parameter id: %s", err), r.URL.Path),
		}
		if err := errorResp.VisitDeleteExecutorResponse(w); err != nil {
			fmt.Fprintf(w, "error writing response: %v", err)
		}
		return
	}
	request.ID = id

	// Determine which handler to call based on operation
	// Command handler

	// Map request to command parameters
	cmd := commands.NewDeleteExecutorCommand(
		sessionID,  // SessionID for authenticated operations
		request.ID, // ID
	)
	if err := c.deleteExecutorHandler.Handle(ctx, cmd); err != nil {
		errorResp := DeleteExecutor500Response{
			ProblemDetails: server.NewInternalServerErrorResponse(err.Error(), r.URL.Path),
		}
		if err := errorResp.VisitDeleteExecutorResponse(w); err != nil {
			fmt.Fprintf(w, "error writing response: %v", err)
		}
		return
	}

	response := DeleteExecutor204Response{}
	if err := response.VisitDeleteExecutorResponse(w); err != nil {
		fmt.Fprintf(w, "error writing response: %v", err)
	}
}
