// Code generated by archesai. DO NOT EDIT.

package controllers

import (
	"encoding/json"
	"fmt"
	"net/http"
	"time"

	"github.com/google/uuid"
	"github.com/labstack/echo/v4"
	"github.com/oapi-codegen/runtime"

	"github.com/archesai/archesai/internal/adapters/http/server"
	commands "github.com/archesai/archesai/internal/application/commands/auth"
	queries "github.com/archesai/archesai/internal/application/queries/auth"
	"github.com/archesai/archesai/internal/core/entities"
	"github.com/archesai/archesai/internal/core/valueobjects"
)

// AuthController handles HTTP requests for auth endpoints.
type AuthController struct {
	confirmEmailChangeHandler       *commands.ConfirmEmailChangeCommandHandler
	confirmEmailVerificationHandler *commands.ConfirmEmailVerificationCommandHandler
	confirmPasswordResetHandler     *commands.ConfirmPasswordResetCommandHandler
	linkAccountHandler              *commands.LinkAccountCommandHandler
	loginHandler                    *commands.LoginCommandHandler
	logoutHandler                   *commands.LogoutCommandHandler
	logoutAllHandler                *commands.LogoutAllCommandHandler
	registerHandler                 *commands.RegisterCommandHandler
	requestEmailChangeHandler       *commands.RequestEmailChangeCommandHandler
	requestEmailVerificationHandler *commands.RequestEmailVerificationCommandHandler
	requestMagicLinkHandler         *commands.RequestMagicLinkCommandHandler
	requestPasswordResetHandler     *commands.RequestPasswordResetCommandHandler
	verifyMagicLinkHandler          *commands.VerifyMagicLinkCommandHandler
	updateAccountHandler            *commands.UpdateAccountCommandHandler
	updateSessionHandler            *commands.UpdateSessionCommandHandler
	deleteAccountHandler            *commands.DeleteAccountCommandHandler
	deleteSessionHandler            *commands.DeleteSessionCommandHandler
	getAccountHandler               *queries.GetAccountQueryHandler
	getSessionHandler               *queries.GetSessionQueryHandler
	oauthAuthorizeHandler           *queries.OAuthAuthorizeQueryHandler
	oauthCallbackHandler            *queries.OAuthCallbackQueryHandler
	listAccountsHandler             *queries.ListAccountsQueryHandler
	listSessionsHandler             *queries.ListSessionsQueryHandler
}

// NewAuthController creates a new auth controller with injected handlers.
func NewAuthController(
	confirmEmailChangeHandler *commands.ConfirmEmailChangeCommandHandler,
	confirmEmailVerificationHandler *commands.ConfirmEmailVerificationCommandHandler,
	confirmPasswordResetHandler *commands.ConfirmPasswordResetCommandHandler,
	linkAccountHandler *commands.LinkAccountCommandHandler,
	loginHandler *commands.LoginCommandHandler,
	logoutHandler *commands.LogoutCommandHandler,
	logoutAllHandler *commands.LogoutAllCommandHandler,
	registerHandler *commands.RegisterCommandHandler,
	requestEmailChangeHandler *commands.RequestEmailChangeCommandHandler,
	requestEmailVerificationHandler *commands.RequestEmailVerificationCommandHandler,
	requestMagicLinkHandler *commands.RequestMagicLinkCommandHandler,
	requestPasswordResetHandler *commands.RequestPasswordResetCommandHandler,
	verifyMagicLinkHandler *commands.VerifyMagicLinkCommandHandler,
	updateAccountHandler *commands.UpdateAccountCommandHandler,
	updateSessionHandler *commands.UpdateSessionCommandHandler,
	deleteAccountHandler *commands.DeleteAccountCommandHandler,
	deleteSessionHandler *commands.DeleteSessionCommandHandler,
	getAccountHandler *queries.GetAccountQueryHandler,
	getSessionHandler *queries.GetSessionQueryHandler,
	oauthAuthorizeHandler *queries.OAuthAuthorizeQueryHandler,
	oauthCallbackHandler *queries.OAuthCallbackQueryHandler,
	listAccountsHandler *queries.ListAccountsQueryHandler,
	listSessionsHandler *queries.ListSessionsQueryHandler,
) *AuthController {
	return &AuthController{
		confirmEmailChangeHandler:       confirmEmailChangeHandler,
		confirmEmailVerificationHandler: confirmEmailVerificationHandler,
		confirmPasswordResetHandler:     confirmPasswordResetHandler,
		linkAccountHandler:              linkAccountHandler,
		loginHandler:                    loginHandler,
		logoutHandler:                   logoutHandler,
		logoutAllHandler:                logoutAllHandler,
		registerHandler:                 registerHandler,
		requestEmailChangeHandler:       requestEmailChangeHandler,
		requestEmailVerificationHandler: requestEmailVerificationHandler,
		requestMagicLinkHandler:         requestMagicLinkHandler,
		requestPasswordResetHandler:     requestPasswordResetHandler,
		verifyMagicLinkHandler:          verifyMagicLinkHandler,
		updateAccountHandler:            updateAccountHandler,
		updateSessionHandler:            updateSessionHandler,
		deleteAccountHandler:            deleteAccountHandler,
		deleteSessionHandler:            deleteSessionHandler,
		getAccountHandler:               getAccountHandler,
		getSessionHandler:               getSessionHandler,
		oauthAuthorizeHandler:           oauthAuthorizeHandler,
		oauthCallbackHandler:            oauthCallbackHandler,
		listAccountsHandler:             listAccountsHandler,
		listSessionsHandler:             listSessionsHandler,
	}
}

// RegisterAuthRoutes registers all HTTP routes for the auth domain.
func RegisterAuthRoutes(router server.EchoRouter, controller *AuthController) {
	router.POST("/auth/confirm-email", controller.ConfirmEmailChange)
	router.POST("/auth/verify-email", controller.ConfirmEmailVerification)
	router.POST("/auth/reset-password", controller.ConfirmPasswordReset)
	router.POST("/auth/link", controller.LinkAccount)
	router.POST("/auth/login", controller.Login)
	router.POST("/auth/logout", controller.Logout)
	router.POST("/auth/logout-all", controller.LogoutAll)
	router.POST("/auth/register", controller.Register)
	router.POST("/auth/change-email", controller.RequestEmailChange)
	router.POST("/auth/request-verification", controller.RequestEmailVerification)
	router.POST("/auth/magic-links/request", controller.RequestMagicLink)
	router.POST("/auth/forgot-password", controller.RequestPasswordReset)
	router.POST("/auth/magic-links/verify", controller.VerifyMagicLink)
	router.GET("/auth/accounts/:id", controller.GetAccount)
	router.GET("/auth/sessions/:id", controller.GetSession)
	router.GET("/auth/oauth/:provider/authorize", controller.OauthAuthorize)
	router.GET("/auth/oauth/:provider/callback", controller.OauthCallback)
	router.GET("/auth/accounts", controller.ListAccounts)
	router.GET("/auth/sessions", controller.ListSessions)
	router.PATCH("/auth/accounts/:id", controller.UpdateAccount)
	router.PATCH("/auth/sessions/:id", controller.UpdateSession)
	router.DELETE("/auth/accounts/:id", controller.DeleteAccount)
	router.DELETE("/auth/sessions/:id", controller.DeleteSession)
}

// ============================================================================
// ConfirmEmailChange - POST /auth/confirm-email
// ============================================================================

// Request types
// ConfirmEmailChangeRequestBody defines the request body for ConfirmEmailChange
type ConfirmEmailChangeRequestBody struct {
	NewEmail string    `json:"newEmail"`
	Token    string    `json:"token"`
	UserID   uuid.UUID `json:"userID"`
}

type ConfirmEmailChangeRequest struct {
	Body *ConfirmEmailChangeRequestBody
}

// Response types

type ConfirmEmailChangeResponse interface {
	VisitConfirmEmailChangeResponse(w http.ResponseWriter) error
}

type ConfirmEmailChange204Response struct {
}

func (response ConfirmEmailChange204Response) VisitConfirmEmailChangeResponse(w http.ResponseWriter) error {
	w.WriteHeader(204)

	return nil
}

type ConfirmEmailChange401Response struct {
	server.UnauthorizedResponse
}

func (response ConfirmEmailChange401Response) VisitConfirmEmailChangeResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/problem+json")
	w.WriteHeader(401)

	return json.NewEncoder(w).Encode(response.UnauthorizedResponse)
}

type ConfirmEmailChange404Response struct {
	server.NotFoundResponse
}

func (response ConfirmEmailChange404Response) VisitConfirmEmailChangeResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/problem+json")
	w.WriteHeader(404)

	return json.NewEncoder(w).Encode(response.NotFoundResponse)
}

// Handler method

// ConfirmEmailChange handles the POST /auth/confirm-email endpoint.
func (c *AuthController) ConfirmEmailChange(ctx echo.Context) error {
	reqCtx := ctx.Request().Context()
	request := ConfirmEmailChangeRequest{}

	// Extract session ID from context for authenticated operations
	var sessionID uuid.UUID
	if sid := ctx.Get("sessionID"); sid != nil {
		sessionID = sid.(uuid.UUID)
	} else {
		return echo.NewHTTPError(http.StatusUnauthorized, "session required")
	}

	// Request body
	request.Body = &ConfirmEmailChangeRequestBody{}
	if err := ctx.Bind(request.Body); err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, err.Error())
	}

	// Set auth scopes
	ctx.Set(server.BearerAuthScopes, []string{})
	ctx.Set(server.SessionCookieScopes, []string{})

	// Determine which handler to call based on operation
	// Command handler

	// Map request to command parameters
	cmd := commands.NewConfirmEmailChangeCommand(
		sessionID,             // SessionID for authenticated operations
		request.Body.NewEmail, // NewEmail
		request.Body.Token,    // Token
		request.Body.UserID,   // UserID
	)
	result, err := c.confirmEmailChangeHandler.Handle(reqCtx, cmd)
	if err != nil {
		return err
	}
	return ctx.JSON(http.StatusCreated, map[string]interface{}{
		"data": result,
	})
}

// ============================================================================
// ConfirmEmailVerification - POST /auth/verify-email
// ============================================================================

// Request types
// ConfirmEmailVerificationRequestBody defines the request body for ConfirmEmailVerification
type ConfirmEmailVerificationRequestBody struct {
	Token string `json:"token"`
}

type ConfirmEmailVerificationRequest struct {
	Body *ConfirmEmailVerificationRequestBody
}

// Response types

type ConfirmEmailVerificationResponse interface {
	VisitConfirmEmailVerificationResponse(w http.ResponseWriter) error
}

type ConfirmEmailVerification200Response struct {
	Session entities.Session `json:"session"`
	User    entities.User    `json:"user"`
}

func (response ConfirmEmailVerification200Response) VisitConfirmEmailVerificationResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json")
	w.WriteHeader(200)

	return json.NewEncoder(w).Encode(response)
}

type ConfirmEmailVerification401Response struct {
	server.UnauthorizedResponse
}

func (response ConfirmEmailVerification401Response) VisitConfirmEmailVerificationResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/problem+json")
	w.WriteHeader(401)

	return json.NewEncoder(w).Encode(response.UnauthorizedResponse)
}

type ConfirmEmailVerification404Response struct {
	server.NotFoundResponse
}

func (response ConfirmEmailVerification404Response) VisitConfirmEmailVerificationResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/problem+json")
	w.WriteHeader(404)

	return json.NewEncoder(w).Encode(response.NotFoundResponse)
}

// Handler method

// ConfirmEmailVerification handles the POST /auth/verify-email endpoint.
func (c *AuthController) ConfirmEmailVerification(ctx echo.Context) error {
	reqCtx := ctx.Request().Context()
	request := ConfirmEmailVerificationRequest{}

	// Extract session ID from context for authenticated operations
	var sessionID uuid.UUID
	if sid := ctx.Get("sessionID"); sid != nil {
		sessionID = sid.(uuid.UUID)
	} else {
		return echo.NewHTTPError(http.StatusUnauthorized, "session required")
	}

	// Request body
	request.Body = &ConfirmEmailVerificationRequestBody{}
	if err := ctx.Bind(request.Body); err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, err.Error())
	}

	// Set auth scopes
	ctx.Set(server.BearerAuthScopes, []string{})
	ctx.Set(server.SessionCookieScopes, []string{})

	// Determine which handler to call based on operation
	// Command handler

	// Map request to command parameters
	cmd := commands.NewConfirmEmailVerificationCommand(
		sessionID,          // SessionID for authenticated operations
		request.Body.Token, // Token
	)
	result, err := c.confirmEmailVerificationHandler.Handle(reqCtx, cmd)
	if err != nil {
		return err
	}
	return ctx.JSON(http.StatusCreated, map[string]interface{}{
		"data": result,
	})
}

// ============================================================================
// ConfirmPasswordReset - POST /auth/reset-password
// ============================================================================

// Request types
// ConfirmPasswordResetRequestBody defines the request body for ConfirmPasswordReset
type ConfirmPasswordResetRequestBody struct {
	NewPassword string `json:"newPassword"`
	Token       string `json:"token"`
}

type ConfirmPasswordResetRequest struct {
	Body *ConfirmPasswordResetRequestBody
}

// Response types

type ConfirmPasswordResetResponse interface {
	VisitConfirmPasswordResetResponse(w http.ResponseWriter) error
}

type ConfirmPasswordReset204Response struct {
}

func (response ConfirmPasswordReset204Response) VisitConfirmPasswordResetResponse(w http.ResponseWriter) error {
	w.WriteHeader(204)

	return nil
}

type ConfirmPasswordReset401Response struct {
	server.UnauthorizedResponse
}

func (response ConfirmPasswordReset401Response) VisitConfirmPasswordResetResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/problem+json")
	w.WriteHeader(401)

	return json.NewEncoder(w).Encode(response.UnauthorizedResponse)
}

type ConfirmPasswordReset404Response struct {
	server.NotFoundResponse
}

func (response ConfirmPasswordReset404Response) VisitConfirmPasswordResetResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/problem+json")
	w.WriteHeader(404)

	return json.NewEncoder(w).Encode(response.NotFoundResponse)
}

// Handler method

// ConfirmPasswordReset handles the POST /auth/reset-password endpoint.
func (c *AuthController) ConfirmPasswordReset(ctx echo.Context) error {
	reqCtx := ctx.Request().Context()
	request := ConfirmPasswordResetRequest{}

	// Request body
	request.Body = &ConfirmPasswordResetRequestBody{}
	if err := ctx.Bind(request.Body); err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, err.Error())
	}

	// Determine which handler to call based on operation
	// Command handler

	// Map request to command parameters
	cmd := commands.NewConfirmPasswordResetCommand(
		request.Body.NewPassword, // NewPassword
		request.Body.Token,       // Token
	)
	result, err := c.confirmPasswordResetHandler.Handle(reqCtx, cmd)
	if err != nil {
		return err
	}
	return ctx.JSON(http.StatusCreated, map[string]interface{}{
		"data": result,
	})
}

// ============================================================================
// LinkAccount - POST /auth/link
// ============================================================================

// Request types
// LinkAccountRequestBody defines the request body for LinkAccount
type LinkAccountRequestBody struct {
	Provider    string  `json:"provider"`
	RedirectURL *string `json:"redirectUrl,omitempty"`
}

type LinkAccountRequest struct {
	Body *LinkAccountRequestBody
}

// Response types

type LinkAccountResponse interface {
	VisitLinkAccountResponse(w http.ResponseWriter) error
}

type LinkAccount200Response struct {
	AuthorizationURL string `json:"authorizationURL"`
}

func (response LinkAccount200Response) VisitLinkAccountResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json")
	w.WriteHeader(200)

	return json.NewEncoder(w).Encode(response)
}

type LinkAccount400Response struct {
	server.BadRequestResponse
}

func (response LinkAccount400Response) VisitLinkAccountResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/problem+json")
	w.WriteHeader(400)

	return json.NewEncoder(w).Encode(response.BadRequestResponse)
}

type LinkAccount401Response struct {
	server.UnauthorizedResponse
}

func (response LinkAccount401Response) VisitLinkAccountResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/problem+json")
	w.WriteHeader(401)

	return json.NewEncoder(w).Encode(response.UnauthorizedResponse)
}

type LinkAccount409Response struct {
	server.ConflictResponse
}

func (response LinkAccount409Response) VisitLinkAccountResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/problem+json")
	w.WriteHeader(409)

	return json.NewEncoder(w).Encode(response.ConflictResponse)
}

// Handler method

// LinkAccount handles the POST /auth/link endpoint.
func (c *AuthController) LinkAccount(ctx echo.Context) error {
	reqCtx := ctx.Request().Context()
	request := LinkAccountRequest{}

	// Extract session ID from context for authenticated operations
	var sessionID uuid.UUID
	if sid := ctx.Get("sessionID"); sid != nil {
		sessionID = sid.(uuid.UUID)
	} else {
		return echo.NewHTTPError(http.StatusUnauthorized, "session required")
	}

	// Request body
	request.Body = &LinkAccountRequestBody{}
	if err := ctx.Bind(request.Body); err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, err.Error())
	}

	// Set auth scopes
	ctx.Set(server.BearerAuthScopes, []string{})
	ctx.Set(server.SessionCookieScopes, []string{})

	// Determine which handler to call based on operation
	// Command handler

	// Map request to command parameters
	cmd := commands.NewLinkAccountCommand(
		sessionID,                // SessionID for authenticated operations
		request.Body.Provider,    // Provider
		request.Body.RedirectURL, // RedirectURL
	)
	result, err := c.linkAccountHandler.Handle(reqCtx, cmd)
	if err != nil {
		return err
	}
	return ctx.JSON(http.StatusCreated, map[string]interface{}{
		"data": result,
	})
}

// ============================================================================
// Login - POST /auth/login
// ============================================================================

// Request types
// LoginRequestBody defines the request body for Login
type LoginRequestBody struct {
	Email      string `json:"email"`
	Password   string `json:"password"`
	RememberMe *bool  `json:"rememberMe,omitempty"`
}

type LoginRequest struct {
	Body *LoginRequestBody
}

// Response types

type LoginResponse interface {
	VisitLoginResponse(w http.ResponseWriter) error
}

type Login201Response struct {
	ID             uuid.UUID `json:"id"`
	AuthMethod     string    `json:"authMethod,omitempty"`
	AuthProvider   string    `json:"authProvider,omitempty"`
	CreatedAt      time.Time `json:"createdAt"`
	ExpiresAt      time.Time `json:"expiresAt"`
	IPAddress      string    `json:"ipAddress,omitempty"`
	OrganizationID uuid.UUID `json:"organizationID,omitempty"`
	Token          string    `json:"token"`
	UpdatedAt      time.Time `json:"updatedAt"`
	UserAgent      string    `json:"userAgent,omitempty"`
	UserID         uuid.UUID `json:"userID"`
}

func (response Login201Response) VisitLoginResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json")
	w.WriteHeader(201)

	return json.NewEncoder(w).Encode(response)
}

type Login400Response struct {
	server.BadRequestResponse
}

func (response Login400Response) VisitLoginResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/problem+json")
	w.WriteHeader(400)

	return json.NewEncoder(w).Encode(response.BadRequestResponse)
}

type Login401Response struct {
	server.UnauthorizedResponse
}

func (response Login401Response) VisitLoginResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/problem+json")
	w.WriteHeader(401)

	return json.NewEncoder(w).Encode(response.UnauthorizedResponse)
}

// Handler method

// Login handles the POST /auth/login endpoint.
func (c *AuthController) Login(ctx echo.Context) error {
	reqCtx := ctx.Request().Context()
	request := LoginRequest{}

	// Request body
	request.Body = &LoginRequestBody{}
	if err := ctx.Bind(request.Body); err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, err.Error())
	}

	// Determine which handler to call based on operation
	// Command handler

	// Map request to command parameters
	cmd := commands.NewLoginCommand(
		request.Body.Email,      // Email
		request.Body.Password,   // Password
		request.Body.RememberMe, // RememberMe
	)
	result, err := c.loginHandler.Handle(reqCtx, cmd)
	if err != nil {
		return err
	}
	return ctx.JSON(http.StatusCreated, map[string]interface{}{
		"data": result,
	})
}

// ============================================================================
// Logout - POST /auth/logout
// ============================================================================

// Request types

type LogoutRequest struct {
}

// Response types

type LogoutResponse interface {
	VisitLogoutResponse(w http.ResponseWriter) error
}

type Logout200Response struct {
	Message string `json:"message"`
}

func (response Logout200Response) VisitLogoutResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json")
	w.WriteHeader(200)

	return json.NewEncoder(w).Encode(response)
}

type Logout401Response struct {
	server.UnauthorizedResponse
}

func (response Logout401Response) VisitLogoutResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/problem+json")
	w.WriteHeader(401)

	return json.NewEncoder(w).Encode(response.UnauthorizedResponse)
}

// Handler method

// Logout handles the POST /auth/logout endpoint.
func (c *AuthController) Logout(ctx echo.Context) error {
	reqCtx := ctx.Request().Context()

	// Extract session ID from context for authenticated operations
	var sessionID uuid.UUID
	if sid := ctx.Get("sessionID"); sid != nil {
		sessionID = sid.(uuid.UUID)
	} else {
		return echo.NewHTTPError(http.StatusUnauthorized, "session required")
	}

	// Set auth scopes
	ctx.Set(server.BearerAuthScopes, []string{})
	ctx.Set(server.SessionCookieScopes, []string{})

	// Determine which handler to call based on operation
	// Command handler

	// Map request to command parameters
	cmd := commands.NewLogoutCommand(
		sessionID, // SessionID for authenticated operations
	)
	result, err := c.logoutHandler.Handle(reqCtx, cmd)
	if err != nil {
		return err
	}
	return ctx.JSON(http.StatusCreated, map[string]interface{}{
		"data": result,
	})
}

// ============================================================================
// LogoutAll - POST /auth/logout-all
// ============================================================================

// Request types

type LogoutAllRequest struct {
}

// Response types

type LogoutAllResponse interface {
	VisitLogoutAllResponse(w http.ResponseWriter) error
}

type LogoutAll200Response struct {
	Count   int    `json:"count"`
	Message string `json:"message"`
}

func (response LogoutAll200Response) VisitLogoutAllResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json")
	w.WriteHeader(200)

	return json.NewEncoder(w).Encode(response)
}

type LogoutAll401Response struct {
	server.UnauthorizedResponse
}

func (response LogoutAll401Response) VisitLogoutAllResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/problem+json")
	w.WriteHeader(401)

	return json.NewEncoder(w).Encode(response.UnauthorizedResponse)
}

// Handler method

// LogoutAll handles the POST /auth/logout-all endpoint.
func (c *AuthController) LogoutAll(ctx echo.Context) error {
	reqCtx := ctx.Request().Context()

	// Extract session ID from context for authenticated operations
	var sessionID uuid.UUID
	if sid := ctx.Get("sessionID"); sid != nil {
		sessionID = sid.(uuid.UUID)
	} else {
		return echo.NewHTTPError(http.StatusUnauthorized, "session required")
	}

	// Set auth scopes
	ctx.Set(server.BearerAuthScopes, []string{})
	ctx.Set(server.SessionCookieScopes, []string{})

	// Determine which handler to call based on operation
	// Command handler

	// Map request to command parameters
	cmd := commands.NewLogoutAllCommand(
		sessionID, // SessionID for authenticated operations
	)
	result, err := c.logoutAllHandler.Handle(reqCtx, cmd)
	if err != nil {
		return err
	}
	return ctx.JSON(http.StatusCreated, map[string]interface{}{
		"data": result,
	})
}

// ============================================================================
// Register - POST /auth/register
// ============================================================================

// Request types
// RegisterRequestBody defines the request body for Register
type RegisterRequestBody struct {
	Email    string `json:"email"`
	Name     string `json:"name"`
	Password string `json:"password"`
}

type RegisterRequest struct {
	Body *RegisterRequestBody
}

// Response types

type RegisterResponse interface {
	VisitRegisterResponse(w http.ResponseWriter) error
}

type Register201Response struct {
	ID            uuid.UUID `json:"id"`
	CreatedAt     time.Time `json:"createdAt"`
	Email         string    `json:"email"`
	EmailVerified bool      `json:"emailVerified"`
	Image         string    `json:"image,omitempty"`
	Name          string    `json:"name"`
	UpdatedAt     time.Time `json:"updatedAt"`
}

func (response Register201Response) VisitRegisterResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json")
	w.WriteHeader(201)

	return json.NewEncoder(w).Encode(response)
}

type Register400Response struct {
	server.BadRequestResponse
}

func (response Register400Response) VisitRegisterResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/problem+json")
	w.WriteHeader(400)

	return json.NewEncoder(w).Encode(response.BadRequestResponse)
}

type Register409Response struct {
	server.ConflictResponse
}

func (response Register409Response) VisitRegisterResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/problem+json")
	w.WriteHeader(409)

	return json.NewEncoder(w).Encode(response.ConflictResponse)
}

// Handler method

// Register handles the POST /auth/register endpoint.
func (c *AuthController) Register(ctx echo.Context) error {
	reqCtx := ctx.Request().Context()
	request := RegisterRequest{}

	// Request body
	request.Body = &RegisterRequestBody{}
	if err := ctx.Bind(request.Body); err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, err.Error())
	}

	// Determine which handler to call based on operation
	// Command handler

	// Map request to command parameters
	cmd := commands.NewRegisterCommand(
		request.Body.Email,    // Email
		request.Body.Name,     // Name
		request.Body.Password, // Password
	)
	result, err := c.registerHandler.Handle(reqCtx, cmd)
	if err != nil {
		return err
	}
	return ctx.JSON(http.StatusCreated, map[string]interface{}{
		"data": result,
	})
}

// ============================================================================
// RequestEmailChange - POST /auth/change-email
// ============================================================================

// Request types
// RequestEmailChangeRequestBody defines the request body for RequestEmailChange
type RequestEmailChangeRequestBody struct {
	NewEmail string    `json:"newEmail"`
	UserID   uuid.UUID `json:"userID"`
}

type RequestEmailChangeRequest struct {
	Body *RequestEmailChangeRequestBody
}

// Response types

type RequestEmailChangeResponse interface {
	VisitRequestEmailChangeResponse(w http.ResponseWriter) error
}

type RequestEmailChange204Response struct {
}

func (response RequestEmailChange204Response) VisitRequestEmailChangeResponse(w http.ResponseWriter) error {
	w.WriteHeader(204)

	return nil
}

type RequestEmailChange400Response struct {
	server.BadRequestResponse
}

func (response RequestEmailChange400Response) VisitRequestEmailChangeResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/problem+json")
	w.WriteHeader(400)

	return json.NewEncoder(w).Encode(response.BadRequestResponse)
}

type RequestEmailChange401Response struct {
	server.UnauthorizedResponse
}

func (response RequestEmailChange401Response) VisitRequestEmailChangeResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/problem+json")
	w.WriteHeader(401)

	return json.NewEncoder(w).Encode(response.UnauthorizedResponse)
}

// Handler method

// RequestEmailChange handles the POST /auth/change-email endpoint.
func (c *AuthController) RequestEmailChange(ctx echo.Context) error {
	reqCtx := ctx.Request().Context()
	request := RequestEmailChangeRequest{}

	// Extract session ID from context for authenticated operations
	var sessionID uuid.UUID
	if sid := ctx.Get("sessionID"); sid != nil {
		sessionID = sid.(uuid.UUID)
	} else {
		return echo.NewHTTPError(http.StatusUnauthorized, "session required")
	}

	// Request body
	request.Body = &RequestEmailChangeRequestBody{}
	if err := ctx.Bind(request.Body); err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, err.Error())
	}

	// Set auth scopes
	ctx.Set(server.BearerAuthScopes, []string{})
	ctx.Set(server.SessionCookieScopes, []string{})

	// Determine which handler to call based on operation
	// Command handler

	// Map request to command parameters
	cmd := commands.NewRequestEmailChangeCommand(
		sessionID,             // SessionID for authenticated operations
		request.Body.NewEmail, // NewEmail
		request.Body.UserID,   // UserID
	)
	result, err := c.requestEmailChangeHandler.Handle(reqCtx, cmd)
	if err != nil {
		return err
	}
	return ctx.JSON(http.StatusCreated, map[string]interface{}{
		"data": result,
	})
}

// ============================================================================
// RequestEmailVerification - POST /auth/request-verification
// ============================================================================

// Request types

type RequestEmailVerificationRequest struct {
}

// Response types

type RequestEmailVerificationResponse interface {
	VisitRequestEmailVerificationResponse(w http.ResponseWriter) error
}

type RequestEmailVerification204Response struct {
}

func (response RequestEmailVerification204Response) VisitRequestEmailVerificationResponse(w http.ResponseWriter) error {
	w.WriteHeader(204)

	return nil
}

type RequestEmailVerification400Response struct {
	server.BadRequestResponse
}

func (response RequestEmailVerification400Response) VisitRequestEmailVerificationResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/problem+json")
	w.WriteHeader(400)

	return json.NewEncoder(w).Encode(response.BadRequestResponse)
}

type RequestEmailVerification401Response struct {
	server.UnauthorizedResponse
}

func (response RequestEmailVerification401Response) VisitRequestEmailVerificationResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/problem+json")
	w.WriteHeader(401)

	return json.NewEncoder(w).Encode(response.UnauthorizedResponse)
}

// Handler method

// RequestEmailVerification handles the POST /auth/request-verification endpoint.
func (c *AuthController) RequestEmailVerification(ctx echo.Context) error {
	reqCtx := ctx.Request().Context()

	// Extract session ID from context for authenticated operations
	var sessionID uuid.UUID
	if sid := ctx.Get("sessionID"); sid != nil {
		sessionID = sid.(uuid.UUID)
	} else {
		return echo.NewHTTPError(http.StatusUnauthorized, "session required")
	}

	// Set auth scopes
	ctx.Set(server.BearerAuthScopes, []string{})

	// Determine which handler to call based on operation
	// Command handler

	// Map request to command parameters
	cmd := commands.NewRequestEmailVerificationCommand(
		sessionID, // SessionID for authenticated operations
	)
	result, err := c.requestEmailVerificationHandler.Handle(reqCtx, cmd)
	if err != nil {
		return err
	}
	return ctx.JSON(http.StatusCreated, map[string]interface{}{
		"data": result,
	})
}

// ============================================================================
// RequestMagicLink - POST /auth/magic-links/request
// ============================================================================

// Request types
// RequestMagicLinkRequestBody defines the request body for RequestMagicLink
type RequestMagicLinkRequestBody struct {
	DeliveryMethod *string `json:"deliveryMethod,omitempty"`
	Identifier     string  `json:"identifier"`
	RedirectURL    *string `json:"redirectUrl,omitempty"`
}

type RequestMagicLinkRequest struct {
	Body *RequestMagicLinkRequestBody
}

// Response types

type RequestMagicLinkResponse interface {
	VisitRequestMagicLinkResponse(w http.ResponseWriter) error
}

type RequestMagicLink200Response struct {
	ExpiresIn int                         `json:"expiresIn,omitempty"`
	Message   string                      `json:"message,omitempty"`
	OtpCode   string                      `json:"otpCode,omitempty"`
	Token     valueobjects.MagicLinkToken `json:"token,omitempty"`
}

func (response RequestMagicLink200Response) VisitRequestMagicLinkResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json")
	w.WriteHeader(200)

	return json.NewEncoder(w).Encode(response)
}

type RequestMagicLink400Response struct {
	server.BadRequestResponse
}

func (response RequestMagicLink400Response) VisitRequestMagicLinkResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/problem+json")
	w.WriteHeader(400)

	return json.NewEncoder(w).Encode(response.BadRequestResponse)
}

type RequestMagicLink429Response struct {
	server.ProblemDetails
}

func (response RequestMagicLink429Response) VisitRequestMagicLinkResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/problem+json")
	w.WriteHeader(429)

	return json.NewEncoder(w).Encode(response)
}

type RequestMagicLink500Response struct {
	server.InternalServerErrorResponse
}

func (response RequestMagicLink500Response) VisitRequestMagicLinkResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/problem+json")
	w.WriteHeader(500)

	return json.NewEncoder(w).Encode(response.InternalServerErrorResponse)
}

// Handler method

// RequestMagicLink handles the POST /auth/magic-links/request endpoint.
func (c *AuthController) RequestMagicLink(ctx echo.Context) error {
	reqCtx := ctx.Request().Context()
	request := RequestMagicLinkRequest{}

	// Request body
	request.Body = &RequestMagicLinkRequestBody{}
	if err := ctx.Bind(request.Body); err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, err.Error())
	}

	// Determine which handler to call based on operation
	// Command handler

	// Map request to command parameters
	cmd := commands.NewRequestMagicLinkCommand(
		request.Body.DeliveryMethod, // DeliveryMethod
		request.Body.Identifier,     // Identifier
		request.Body.RedirectURL,    // RedirectURL
	)
	result, err := c.requestMagicLinkHandler.Handle(reqCtx, cmd)
	if err != nil {
		return err
	}
	return ctx.JSON(http.StatusCreated, map[string]interface{}{
		"data": result,
	})
}

// ============================================================================
// RequestPasswordReset - POST /auth/forgot-password
// ============================================================================

// Request types
// RequestPasswordResetRequestBody defines the request body for RequestPasswordReset
type RequestPasswordResetRequestBody struct {
	Email string `json:"email"`
}

type RequestPasswordResetRequest struct {
	Body *RequestPasswordResetRequestBody
}

// Response types

type RequestPasswordResetResponse interface {
	VisitRequestPasswordResetResponse(w http.ResponseWriter) error
}

type RequestPasswordReset204Response struct {
}

func (response RequestPasswordReset204Response) VisitRequestPasswordResetResponse(w http.ResponseWriter) error {
	w.WriteHeader(204)

	return nil
}

type RequestPasswordReset400Response struct {
	server.BadRequestResponse
}

func (response RequestPasswordReset400Response) VisitRequestPasswordResetResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/problem+json")
	w.WriteHeader(400)

	return json.NewEncoder(w).Encode(response.BadRequestResponse)
}

// Handler method

// RequestPasswordReset handles the POST /auth/forgot-password endpoint.
func (c *AuthController) RequestPasswordReset(ctx echo.Context) error {
	reqCtx := ctx.Request().Context()
	request := RequestPasswordResetRequest{}

	// Request body
	request.Body = &RequestPasswordResetRequestBody{}
	if err := ctx.Bind(request.Body); err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, err.Error())
	}

	// Determine which handler to call based on operation
	// Command handler

	// Map request to command parameters
	cmd := commands.NewRequestPasswordResetCommand(
		request.Body.Email, // Email
	)
	result, err := c.requestPasswordResetHandler.Handle(reqCtx, cmd)
	if err != nil {
		return err
	}
	return ctx.JSON(http.StatusCreated, map[string]interface{}{
		"data": result,
	})
}

// ============================================================================
// VerifyMagicLink - POST /auth/magic-links/verify
// ============================================================================

// Request types
// VerifyMagicLinkRequestBody defines the request body for VerifyMagicLink
type VerifyMagicLinkRequestBody struct {
	Code       *string `json:"code,omitempty"`
	Identifier *string `json:"identifier,omitempty"`
	Token      *string `json:"token,omitempty"`
}

type VerifyMagicLinkRequest struct {
	Body *VerifyMagicLinkRequestBody
}

// Response types

type VerifyMagicLinkResponse interface {
	VisitVerifyMagicLinkResponse(w http.ResponseWriter) error
}

type VerifyMagicLink201Response struct {
	ID             uuid.UUID `json:"id"`
	AuthMethod     string    `json:"authMethod,omitempty"`
	AuthProvider   string    `json:"authProvider,omitempty"`
	CreatedAt      time.Time `json:"createdAt"`
	ExpiresAt      time.Time `json:"expiresAt"`
	IPAddress      string    `json:"ipAddress,omitempty"`
	OrganizationID uuid.UUID `json:"organizationID,omitempty"`
	Token          string    `json:"token"`
	UpdatedAt      time.Time `json:"updatedAt"`
	UserAgent      string    `json:"userAgent,omitempty"`
	UserID         uuid.UUID `json:"userID"`
}

func (response VerifyMagicLink201Response) VisitVerifyMagicLinkResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json")
	w.WriteHeader(201)

	return json.NewEncoder(w).Encode(response)
}

type VerifyMagicLink400Response struct {
	server.BadRequestResponse
}

func (response VerifyMagicLink400Response) VisitVerifyMagicLinkResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/problem+json")
	w.WriteHeader(400)

	return json.NewEncoder(w).Encode(response.BadRequestResponse)
}

type VerifyMagicLink401Response struct {
	server.UnauthorizedResponse
}

func (response VerifyMagicLink401Response) VisitVerifyMagicLinkResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/problem+json")
	w.WriteHeader(401)

	return json.NewEncoder(w).Encode(response.UnauthorizedResponse)
}

type VerifyMagicLink404Response struct {
	server.NotFoundResponse
}

func (response VerifyMagicLink404Response) VisitVerifyMagicLinkResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/problem+json")
	w.WriteHeader(404)

	return json.NewEncoder(w).Encode(response.NotFoundResponse)
}

type VerifyMagicLink500Response struct {
	server.InternalServerErrorResponse
}

func (response VerifyMagicLink500Response) VisitVerifyMagicLinkResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/problem+json")
	w.WriteHeader(500)

	return json.NewEncoder(w).Encode(response.InternalServerErrorResponse)
}

// Handler method

// VerifyMagicLink handles the POST /auth/magic-links/verify endpoint.
func (c *AuthController) VerifyMagicLink(ctx echo.Context) error {
	reqCtx := ctx.Request().Context()
	request := VerifyMagicLinkRequest{}

	// Request body
	request.Body = &VerifyMagicLinkRequestBody{}
	if err := ctx.Bind(request.Body); err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, err.Error())
	}

	// Determine which handler to call based on operation
	// Command handler

	// Map request to command parameters
	cmd := commands.NewVerifyMagicLinkCommand(
		request.Body.Code,       // Code
		request.Body.Identifier, // Identifier
		request.Body.Token,      // Token
	)
	result, err := c.verifyMagicLinkHandler.Handle(reqCtx, cmd)
	if err != nil {
		return err
	}
	return ctx.JSON(http.StatusCreated, map[string]interface{}{
		"data": result,
	})
}

// ============================================================================
// GetAccount - GET /auth/accounts/{id}
// ============================================================================

// Request types

type GetAccountRequest struct {
	ID uuid.UUID `json:"id"`
}

// Response types

type GetAccountResponse interface {
	VisitGetAccountResponse(w http.ResponseWriter) error
}

type GetAccount200Response struct {
	Data entities.Account `json:"data"`
}

func (response GetAccount200Response) VisitGetAccountResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json")
	w.WriteHeader(200)

	return json.NewEncoder(w).Encode(response)
}

type GetAccount404Response struct {
	server.NotFoundResponse
}

func (response GetAccount404Response) VisitGetAccountResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/problem+json")
	w.WriteHeader(404)

	return json.NewEncoder(w).Encode(response.NotFoundResponse)
}

// Handler method

// GetAccount handles the GET /auth/accounts/{id} endpoint.
func (c *AuthController) GetAccount(ctx echo.Context) error {
	reqCtx := ctx.Request().Context()
	request := GetAccountRequest{}

	// Extract session ID from context for authenticated operations
	var sessionID uuid.UUID
	if sid := ctx.Get("sessionID"); sid != nil {
		sessionID = sid.(uuid.UUID)
	} else {
		return echo.NewHTTPError(http.StatusUnauthorized, "session required")
	}

	// Path parameter "id"
	var id uuid.UUID
	if err := runtime.BindStyledParameterWithOptions("simple", "id", ctx.Param("id"), &id, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true}); err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter id: %s", err))
	}
	request.ID = id

	// Set auth scopes
	ctx.Set(server.BearerAuthScopes, []string{})

	// Determine which handler to call based on operation
	// Query handler
	query := queries.NewGetAccountQuery(
		sessionID,  // SessionID for authenticated operations
		request.ID, // ID
	)

	result, err := c.getAccountHandler.Handle(reqCtx, query)
	if err != nil {
		return err
	}

	return ctx.JSON(http.StatusOK, map[string]interface{}{
		"data": result,
	})
}

// ============================================================================
// GetSession - GET /auth/sessions/{id}
// ============================================================================

// Request types

type GetSessionRequest struct {
	ID uuid.UUID `json:"id"`
}

// Response types

type GetSessionResponse interface {
	VisitGetSessionResponse(w http.ResponseWriter) error
}

type GetSession200Response struct {
	Data entities.Session `json:"data"`
}

func (response GetSession200Response) VisitGetSessionResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json")
	w.WriteHeader(200)

	return json.NewEncoder(w).Encode(response)
}

type GetSession404Response struct {
	server.NotFoundResponse
}

func (response GetSession404Response) VisitGetSessionResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/problem+json")
	w.WriteHeader(404)

	return json.NewEncoder(w).Encode(response.NotFoundResponse)
}

// Handler method

// GetSession handles the GET /auth/sessions/{id} endpoint.
func (c *AuthController) GetSession(ctx echo.Context) error {
	reqCtx := ctx.Request().Context()
	request := GetSessionRequest{}

	// Extract session ID from context for authenticated operations
	var sessionID uuid.UUID
	if sid := ctx.Get("sessionID"); sid != nil {
		sessionID = sid.(uuid.UUID)
	} else {
		return echo.NewHTTPError(http.StatusUnauthorized, "session required")
	}

	// Path parameter "id"
	var id uuid.UUID
	if err := runtime.BindStyledParameterWithOptions("simple", "id", ctx.Param("id"), &id, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true}); err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter id: %s", err))
	}
	request.ID = id

	// Set auth scopes
	ctx.Set(server.BearerAuthScopes, []string{})

	// Determine which handler to call based on operation
	// Query handler
	query := queries.NewGetSessionQuery(
		sessionID,  // SessionID for authenticated operations
		request.ID, // ID
	)

	result, err := c.getSessionHandler.Handle(reqCtx, query)
	if err != nil {
		return err
	}

	return ctx.JSON(http.StatusOK, map[string]interface{}{
		"data": result,
	})
}

// ============================================================================
// OauthAuthorize - GET /auth/oauth/{provider}/authorize
// ============================================================================

// Request types
// OauthAuthorizeParams defines parameters for OauthAuthorize
type OauthAuthorizeParams struct {
	RedirectURI *string `json:"redirectURI,omitempty"`
	Scope       *string `json:"scope,omitempty"`
	State       *string `json:"state,omitempty"`
}

type OauthAuthorizeRequest struct {
	Provider string `json:"provider"`
	Params   OauthAuthorizeParams
}

// Response types

type OauthAuthorizeResponse interface {
	VisitOauthAuthorizeResponse(w http.ResponseWriter) error
}

type OauthAuthorize200Response struct {
	AuthorizationURL string `json:"authorizationURL"`
}

func (response OauthAuthorize200Response) VisitOauthAuthorizeResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json")
	w.WriteHeader(200)

	return json.NewEncoder(w).Encode(response)
}

type OauthAuthorize302Response struct {
	server.ProblemDetails
}

func (response OauthAuthorize302Response) VisitOauthAuthorizeResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/problem+json")
	w.WriteHeader(302)

	return json.NewEncoder(w).Encode(response)
}

type OauthAuthorize400Response struct {
	server.BadRequestResponse
}

func (response OauthAuthorize400Response) VisitOauthAuthorizeResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/problem+json")
	w.WriteHeader(400)

	return json.NewEncoder(w).Encode(response.BadRequestResponse)
}

type OauthAuthorize404Response struct {
	server.NotFoundResponse
}

func (response OauthAuthorize404Response) VisitOauthAuthorizeResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/problem+json")
	w.WriteHeader(404)

	return json.NewEncoder(w).Encode(response.NotFoundResponse)
}

// Handler method

// OauthAuthorize handles the GET /auth/oauth/{provider}/authorize endpoint.
func (c *AuthController) OauthAuthorize(ctx echo.Context) error {
	reqCtx := ctx.Request().Context()
	request := OauthAuthorizeRequest{}

	// Extract session ID from context for authenticated operations
	var sessionID uuid.UUID
	if sid := ctx.Get("sessionID"); sid != nil {
		sessionID = sid.(uuid.UUID)
	} else {
		return echo.NewHTTPError(http.StatusUnauthorized, "session required")
	}

	// Path parameter "provider"
	var provider string
	if err := runtime.BindStyledParameterWithOptions("simple", "provider", ctx.Param("provider"), &provider, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true}); err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter provider: %s", err))
	}
	request.Provider = provider

	// Query parameters
	var params OauthAuthorizeParams
	// Optional query parameter "RedirectURI"
	if err := runtime.BindQueryParameter("form", true, false, "redirecturi", ctx.QueryParams(), &params.RedirectURI); err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter redirecturi: %s", err))
	}
	// Optional query parameter "Scope"
	if err := runtime.BindQueryParameter("form", true, false, "scope", ctx.QueryParams(), &params.Scope); err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter scope: %s", err))
	}
	// Optional query parameter "State"
	if err := runtime.BindQueryParameter("form", true, false, "state", ctx.QueryParams(), &params.State); err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter state: %s", err))
	}
	request.Params = params

	// Set auth scopes
	ctx.Set(server.BearerAuthScopes, []string{})
	ctx.Set(server.SessionCookieScopes, []string{})

	// Determine which handler to call based on operation
	// Query handler
	query := queries.NewOauthAuthorizeQuery(
		sessionID,        // SessionID for authenticated operations
		request.Provider, // Provider
	)

	result, err := c.oauthAuthorizeHandler.Handle(reqCtx, query)
	if err != nil {
		return err
	}

	return ctx.JSON(http.StatusOK, map[string]interface{}{
		"data": result,
	})
}

// ============================================================================
// OauthCallback - GET /auth/oauth/{provider}/callback
// ============================================================================

// Request types
// OauthCallbackParams defines parameters for OauthCallback
type OauthCallbackParams struct {
	Code             *string `json:"code,omitempty"`
	State            *string `json:"state,omitempty"`
	Error            *string `json:"error,omitempty"`
	ErrorDescription *string `json:"errorDescription,omitempty"`
}

type OauthCallbackRequest struct {
	Provider string `json:"provider"`
	Params   OauthCallbackParams
}

// Response types

type OauthCallbackResponse interface {
	VisitOauthCallbackResponse(w http.ResponseWriter) error
}

type OauthCallback200Response struct {
	ID             uuid.UUID `json:"id"`
	AuthMethod     string    `json:"authMethod,omitempty"`
	AuthProvider   string    `json:"authProvider,omitempty"`
	CreatedAt      time.Time `json:"createdAt"`
	ExpiresAt      time.Time `json:"expiresAt"`
	IPAddress      string    `json:"ipAddress,omitempty"`
	OrganizationID uuid.UUID `json:"organizationID,omitempty"`
	Token          string    `json:"token"`
	UpdatedAt      time.Time `json:"updatedAt"`
	UserAgent      string    `json:"userAgent,omitempty"`
	UserID         uuid.UUID `json:"userID"`
}

func (response OauthCallback200Response) VisitOauthCallbackResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json")
	w.WriteHeader(200)

	return json.NewEncoder(w).Encode(response)
}

type OauthCallback302Response struct {
	server.ProblemDetails
}

func (response OauthCallback302Response) VisitOauthCallbackResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/problem+json")
	w.WriteHeader(302)

	return json.NewEncoder(w).Encode(response)
}

type OauthCallback400Response struct {
	server.BadRequestResponse
}

func (response OauthCallback400Response) VisitOauthCallbackResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/problem+json")
	w.WriteHeader(400)

	return json.NewEncoder(w).Encode(response.BadRequestResponse)
}

type OauthCallback401Response struct {
	server.UnauthorizedResponse
}

func (response OauthCallback401Response) VisitOauthCallbackResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/problem+json")
	w.WriteHeader(401)

	return json.NewEncoder(w).Encode(response.UnauthorizedResponse)
}

type OauthCallback404Response struct {
	server.NotFoundResponse
}

func (response OauthCallback404Response) VisitOauthCallbackResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/problem+json")
	w.WriteHeader(404)

	return json.NewEncoder(w).Encode(response.NotFoundResponse)
}

// Handler method

// OauthCallback handles the GET /auth/oauth/{provider}/callback endpoint.
func (c *AuthController) OauthCallback(ctx echo.Context) error {
	reqCtx := ctx.Request().Context()
	request := OauthCallbackRequest{}

	// Extract session ID from context for authenticated operations
	var sessionID uuid.UUID
	if sid := ctx.Get("sessionID"); sid != nil {
		sessionID = sid.(uuid.UUID)
	} else {
		return echo.NewHTTPError(http.StatusUnauthorized, "session required")
	}

	// Path parameter "provider"
	var provider string
	if err := runtime.BindStyledParameterWithOptions("simple", "provider", ctx.Param("provider"), &provider, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true}); err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter provider: %s", err))
	}
	request.Provider = provider

	// Query parameters
	var params OauthCallbackParams
	// Optional query parameter "Code"
	if err := runtime.BindQueryParameter("form", true, false, "code", ctx.QueryParams(), &params.Code); err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter code: %s", err))
	}
	// Optional query parameter "State"
	if err := runtime.BindQueryParameter("form", true, false, "state", ctx.QueryParams(), &params.State); err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter state: %s", err))
	}
	// Optional query parameter "Error"
	if err := runtime.BindQueryParameter("form", true, false, "error", ctx.QueryParams(), &params.Error); err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter error: %s", err))
	}
	// Optional query parameter "ErrorDescription"
	if err := runtime.BindQueryParameter("form", true, false, "errordescription", ctx.QueryParams(), &params.ErrorDescription); err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter errordescription: %s", err))
	}
	request.Params = params

	// Set auth scopes
	ctx.Set(server.BearerAuthScopes, []string{})
	ctx.Set(server.SessionCookieScopes, []string{})

	// Determine which handler to call based on operation
	// Query handler
	query := queries.NewOauthCallbackQuery(
		sessionID,        // SessionID for authenticated operations
		request.Provider, // Provider
	)

	result, err := c.oauthCallbackHandler.Handle(reqCtx, query)
	if err != nil {
		return err
	}

	return ctx.JSON(http.StatusOK, map[string]interface{}{
		"data": result,
	})
}

// ============================================================================
// ListAccounts - GET /auth/accounts
// ============================================================================

// Request types

type ListAccountsRequest struct {
}

// Response types

type ListAccountsResponse interface {
	VisitListAccountsResponse(w http.ResponseWriter) error
}

// ListAccounts200ResponseMeta defines the meta structure
type ListAccounts200ResponseMeta struct {
	Total int `json:"total"`
}

type ListAccounts200Response struct {
	Data []entities.Account          `json:"data"`
	Meta ListAccounts200ResponseMeta `json:"meta"`
}

func (response ListAccounts200Response) VisitListAccountsResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json")
	w.WriteHeader(200)

	return json.NewEncoder(w).Encode(response)
}

type ListAccounts401Response struct {
	server.UnauthorizedResponse
}

func (response ListAccounts401Response) VisitListAccountsResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/problem+json")
	w.WriteHeader(401)

	return json.NewEncoder(w).Encode(response.UnauthorizedResponse)
}

// Handler method

// ListAccounts handles the GET /auth/accounts endpoint.
func (c *AuthController) ListAccounts(ctx echo.Context) error {
	reqCtx := ctx.Request().Context()

	// Extract session ID from context for authenticated operations
	var sessionID uuid.UUID
	if sid := ctx.Get("sessionID"); sid != nil {
		sessionID = sid.(uuid.UUID)
	} else {
		return echo.NewHTTPError(http.StatusUnauthorized, "session required")
	}

	// Set auth scopes
	ctx.Set(server.BearerAuthScopes, []string{})
	ctx.Set(server.SessionCookieScopes, []string{})

	// Determine which handler to call based on operation
	// Query handler
	query := queries.NewListAccountsQuery(
		sessionID, // SessionID for authenticated operations
	)
	// TODO: Apply filters, pagination, sorting from request.Params

	results, total, err := c.listAccountsHandler.Handle(reqCtx, query)
	if err != nil {
		return err
	}

	return ctx.JSON(http.StatusOK, map[string]interface{}{
		"data": results,
		"meta": map[string]interface{}{
			"total": total,
		},
	})
}

// ============================================================================
// ListSessions - GET /auth/sessions
// ============================================================================

// Request types
// ListSessionsParams defines parameters for ListSessions
type ListSessionsParams struct {
	Page map[string]any   `json:"page,omitempty"`
	Sort []map[string]any `json:"sort,omitempty"`
}

type ListSessionsRequest struct {
	Params ListSessionsParams
}

// Response types

type ListSessionsResponse interface {
	VisitListSessionsResponse(w http.ResponseWriter) error
}

// ListSessions200ResponseMeta defines the meta structure
type ListSessions200ResponseMeta struct {
	Total int `json:"total"`
}

type ListSessions200Response struct {
	Data []entities.Session          `json:"data"`
	Meta ListSessions200ResponseMeta `json:"meta"`
}

func (response ListSessions200Response) VisitListSessionsResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json")
	w.WriteHeader(200)

	return json.NewEncoder(w).Encode(response)
}

type ListSessions401Response struct {
	server.UnauthorizedResponse
}

func (response ListSessions401Response) VisitListSessionsResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/problem+json")
	w.WriteHeader(401)

	return json.NewEncoder(w).Encode(response.UnauthorizedResponse)
}

// Handler method

// ListSessions handles the GET /auth/sessions endpoint.
func (c *AuthController) ListSessions(ctx echo.Context) error {
	reqCtx := ctx.Request().Context()
	request := ListSessionsRequest{}

	// Extract session ID from context for authenticated operations
	var sessionID uuid.UUID
	if sid := ctx.Get("sessionID"); sid != nil {
		sessionID = sid.(uuid.UUID)
	} else {
		return echo.NewHTTPError(http.StatusUnauthorized, "session required")
	}

	// Query parameters
	var params ListSessionsParams
	// Optional query parameter "Page"
	if err := runtime.BindQueryParameter("form", true, false, "page", ctx.QueryParams(), &params.Page); err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter page: %s", err))
	}
	// Optional query parameter "Sort"
	if err := runtime.BindQueryParameter("form", true, false, "sort", ctx.QueryParams(), &params.Sort); err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter sort: %s", err))
	}
	request.Params = params

	// Set auth scopes
	ctx.Set(server.BearerAuthScopes, []string{})
	ctx.Set(server.SessionCookieScopes, []string{})

	// Determine which handler to call based on operation
	// Query handler
	query := queries.NewListSessionsQuery(
		sessionID, // SessionID for authenticated operations
	)
	// TODO: Apply filters, pagination, sorting from request.Params

	results, total, err := c.listSessionsHandler.Handle(reqCtx, query)
	if err != nil {
		return err
	}

	return ctx.JSON(http.StatusOK, map[string]interface{}{
		"data": results,
		"meta": map[string]interface{}{
			"total": total,
		},
	})
}

// ============================================================================
// UpdateAccount - PATCH /auth/accounts/{id}
// ============================================================================

// Request types
// UpdateAccountRequestBody defines the request body for UpdateAccount
type UpdateAccountRequestBody struct {
	Provider                  *string `json:"provider,omitempty"`
	ProviderAccountIdentifier *string `json:"providerAccountIdentifier,omitempty"`
	Type                      *string `json:"type,omitempty"`
}

type UpdateAccountRequest struct {
	ID   uuid.UUID `json:"id"`
	Body *UpdateAccountRequestBody
}

// Response types

type UpdateAccountResponse interface {
	VisitUpdateAccountResponse(w http.ResponseWriter) error
}

type UpdateAccount200Response struct {
	Data entities.Account `json:"data"`
}

func (response UpdateAccount200Response) VisitUpdateAccountResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json")
	w.WriteHeader(200)

	return json.NewEncoder(w).Encode(response)
}

type UpdateAccount404Response struct {
	server.NotFoundResponse
}

func (response UpdateAccount404Response) VisitUpdateAccountResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/problem+json")
	w.WriteHeader(404)

	return json.NewEncoder(w).Encode(response.NotFoundResponse)
}

// Handler method

// UpdateAccount handles the PATCH /auth/accounts/{id} endpoint.
func (c *AuthController) UpdateAccount(ctx echo.Context) error {
	reqCtx := ctx.Request().Context()
	request := UpdateAccountRequest{}

	// Extract session ID from context for authenticated operations
	var sessionID uuid.UUID
	if sid := ctx.Get("sessionID"); sid != nil {
		sessionID = sid.(uuid.UUID)
	} else {
		return echo.NewHTTPError(http.StatusUnauthorized, "session required")
	}

	// Path parameter "id"
	var id uuid.UUID
	if err := runtime.BindStyledParameterWithOptions("simple", "id", ctx.Param("id"), &id, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true}); err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter id: %s", err))
	}
	request.ID = id

	// Request body
	request.Body = &UpdateAccountRequestBody{}
	if err := ctx.Bind(request.Body); err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, err.Error())
	}

	// Set auth scopes
	ctx.Set(server.BearerAuthScopes, []string{})

	// Determine which handler to call based on operation
	// Command handler

	// Map request to command parameters
	cmd := commands.NewUpdateAccountCommand(
		sessionID,                              // SessionID for authenticated operations
		request.ID,                             // ID
		request.Body.Provider,                  // Provider
		request.Body.ProviderAccountIdentifier, // ProviderAccountIdentifier
		request.Body.Type,                      // Type
	)
	result, err := c.updateAccountHandler.Handle(reqCtx, cmd)
	if err != nil {
		return err
	}
	return ctx.JSON(http.StatusOK, map[string]interface{}{
		"data": result,
	})
}

// ============================================================================
// UpdateSession - PATCH /auth/sessions/{id}
// ============================================================================

// Request types
// UpdateSessionRequestBody defines the request body for UpdateSession
type UpdateSessionRequestBody struct {
	OrganizationID uuid.UUID `json:"organizationID"`
}

type UpdateSessionRequest struct {
	ID   uuid.UUID `json:"id"`
	Body *UpdateSessionRequestBody
}

// Response types

type UpdateSessionResponse interface {
	VisitUpdateSessionResponse(w http.ResponseWriter) error
}

type UpdateSession200Response struct {
	Data entities.Session `json:"data"`
}

func (response UpdateSession200Response) VisitUpdateSessionResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json")
	w.WriteHeader(200)

	return json.NewEncoder(w).Encode(response)
}

type UpdateSession401Response struct {
	server.UnauthorizedResponse
}

func (response UpdateSession401Response) VisitUpdateSessionResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/problem+json")
	w.WriteHeader(401)

	return json.NewEncoder(w).Encode(response.UnauthorizedResponse)
}

type UpdateSession404Response struct {
	server.NotFoundResponse
}

func (response UpdateSession404Response) VisitUpdateSessionResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/problem+json")
	w.WriteHeader(404)

	return json.NewEncoder(w).Encode(response.NotFoundResponse)
}

// Handler method

// UpdateSession handles the PATCH /auth/sessions/{id} endpoint.
func (c *AuthController) UpdateSession(ctx echo.Context) error {
	reqCtx := ctx.Request().Context()
	request := UpdateSessionRequest{}

	// Extract session ID from context for authenticated operations
	var sessionID uuid.UUID
	if sid := ctx.Get("sessionID"); sid != nil {
		sessionID = sid.(uuid.UUID)
	} else {
		return echo.NewHTTPError(http.StatusUnauthorized, "session required")
	}

	// Path parameter "id"
	var id uuid.UUID
	if err := runtime.BindStyledParameterWithOptions("simple", "id", ctx.Param("id"), &id, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true}); err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter id: %s", err))
	}
	request.ID = id

	// Request body
	request.Body = &UpdateSessionRequestBody{}
	if err := ctx.Bind(request.Body); err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, err.Error())
	}

	// Set auth scopes
	ctx.Set(server.BearerAuthScopes, []string{})
	ctx.Set(server.SessionCookieScopes, []string{})

	// Determine which handler to call based on operation
	// Command handler

	// Map request to command parameters
	cmd := commands.NewUpdateSessionCommand(
		sessionID,                   // SessionID for authenticated operations
		request.ID,                  // ID
		request.Body.OrganizationID, // OrganizationID
	)
	result, err := c.updateSessionHandler.Handle(reqCtx, cmd)
	if err != nil {
		return err
	}
	return ctx.JSON(http.StatusOK, map[string]interface{}{
		"data": result,
	})
}

// ============================================================================
// DeleteAccount - DELETE /auth/accounts/{id}
// ============================================================================

// Request types

type DeleteAccountRequest struct {
	ID uuid.UUID `json:"id"`
}

// Response types

type DeleteAccountResponse interface {
	VisitDeleteAccountResponse(w http.ResponseWriter) error
}

type DeleteAccount200Response struct {
	Data entities.Account `json:"data"`
}

func (response DeleteAccount200Response) VisitDeleteAccountResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json")
	w.WriteHeader(200)

	return json.NewEncoder(w).Encode(response)
}

type DeleteAccount404Response struct {
	server.NotFoundResponse
}

func (response DeleteAccount404Response) VisitDeleteAccountResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/problem+json")
	w.WriteHeader(404)

	return json.NewEncoder(w).Encode(response.NotFoundResponse)
}

// Handler method

// DeleteAccount handles the DELETE /auth/accounts/{id} endpoint.
func (c *AuthController) DeleteAccount(ctx echo.Context) error {
	reqCtx := ctx.Request().Context()
	request := DeleteAccountRequest{}

	// Extract session ID from context for authenticated operations
	var sessionID uuid.UUID
	if sid := ctx.Get("sessionID"); sid != nil {
		sessionID = sid.(uuid.UUID)
	} else {
		return echo.NewHTTPError(http.StatusUnauthorized, "session required")
	}

	// Path parameter "id"
	var id uuid.UUID
	if err := runtime.BindStyledParameterWithOptions("simple", "id", ctx.Param("id"), &id, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true}); err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter id: %s", err))
	}
	request.ID = id

	// Set auth scopes
	ctx.Set(server.BearerAuthScopes, []string{})

	// Determine which handler to call based on operation
	// Command handler

	// Map request to command parameters
	cmd := commands.NewDeleteAccountCommand(
		sessionID,  // SessionID for authenticated operations
		request.ID, // ID
	)
	if err := c.deleteAccountHandler.Handle(reqCtx, cmd); err != nil {
		return err
	}
	return ctx.NoContent(http.StatusNoContent)
}

// ============================================================================
// DeleteSession - DELETE /auth/sessions/{id}
// ============================================================================

// Request types

type DeleteSessionRequest struct {
	ID uuid.UUID `json:"id"`
}

// Response types

type DeleteSessionResponse interface {
	VisitDeleteSessionResponse(w http.ResponseWriter) error
}

type DeleteSession200Response struct {
	Data entities.Session `json:"data"`
}

func (response DeleteSession200Response) VisitDeleteSessionResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json")
	w.WriteHeader(200)

	return json.NewEncoder(w).Encode(response)
}

type DeleteSession401Response struct {
	server.UnauthorizedResponse
}

func (response DeleteSession401Response) VisitDeleteSessionResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/problem+json")
	w.WriteHeader(401)

	return json.NewEncoder(w).Encode(response.UnauthorizedResponse)
}

type DeleteSession404Response struct {
	server.NotFoundResponse
}

func (response DeleteSession404Response) VisitDeleteSessionResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/problem+json")
	w.WriteHeader(404)

	return json.NewEncoder(w).Encode(response.NotFoundResponse)
}

// Handler method

// DeleteSession handles the DELETE /auth/sessions/{id} endpoint.
func (c *AuthController) DeleteSession(ctx echo.Context) error {
	reqCtx := ctx.Request().Context()
	request := DeleteSessionRequest{}

	// Extract session ID from context for authenticated operations
	var sessionID uuid.UUID
	if sid := ctx.Get("sessionID"); sid != nil {
		sessionID = sid.(uuid.UUID)
	} else {
		return echo.NewHTTPError(http.StatusUnauthorized, "session required")
	}

	// Path parameter "id"
	var id uuid.UUID
	if err := runtime.BindStyledParameterWithOptions("simple", "id", ctx.Param("id"), &id, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true}); err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter id: %s", err))
	}
	request.ID = id

	// Set auth scopes
	ctx.Set(server.BearerAuthScopes, []string{})

	// Determine which handler to call based on operation
	// Command handler

	// Map request to command parameters
	cmd := commands.NewDeleteSessionCommand(
		sessionID,  // SessionID for authenticated operations
		request.ID, // ID
	)
	if err := c.deleteSessionHandler.Handle(reqCtx, cmd); err != nil {
		return err
	}
	return ctx.NoContent(http.StatusNoContent)
}
