// Code generated by archesai. DO NOT EDIT.

package controllers

import (
	"encoding/json"
	"fmt"
	"net/http"

	"github.com/google/uuid"
	"github.com/labstack/echo/v4"
	"github.com/oapi-codegen/runtime"

	"github.com/archesai/archesai/internal/adapters/http/server"
	commands "github.com/archesai/archesai/internal/application/commands/member"
	queries "github.com/archesai/archesai/internal/application/queries/member"
	"github.com/archesai/archesai/internal/core/entities"
)

// MemberController handles HTTP requests for member endpoints.
type MemberController struct {
	createMemberHandler *commands.CreateMemberCommandHandler
	updateMemberHandler *commands.UpdateMemberCommandHandler
	deleteMemberHandler *commands.DeleteMemberCommandHandler
	getMemberHandler    *queries.GetMemberQueryHandler
	listMembersHandler  *queries.ListMembersQueryHandler
}

// NewMemberController creates a new member controller with injected handlers.
func NewMemberController(
	createMemberHandler *commands.CreateMemberCommandHandler,
	updateMemberHandler *commands.UpdateMemberCommandHandler,
	deleteMemberHandler *commands.DeleteMemberCommandHandler,
	getMemberHandler *queries.GetMemberQueryHandler,
	listMembersHandler *queries.ListMembersQueryHandler,
) *MemberController {
	return &MemberController{
		createMemberHandler: createMemberHandler,
		updateMemberHandler: updateMemberHandler,
		deleteMemberHandler: deleteMemberHandler,
		getMemberHandler:    getMemberHandler,
		listMembersHandler:  listMembersHandler,
	}
}

// RegisterMemberRoutes registers all HTTP routes for the member domain.
func RegisterMemberRoutes(router server.EchoRouter, controller *MemberController) {
	router.POST("/organizations/:organizationID/members", controller.CreateMember)
	router.GET("/organizations/:organizationID/members/:id", controller.GetMember)
	router.GET("/organizations/:organizationID/members", controller.ListMembers)
	router.PATCH("/organizations/:organizationID/members/:id", controller.UpdateMember)
	router.DELETE("/organizations/:organizationID/members/:id", controller.DeleteMember)
}

// ============================================================================
// CreateMember - POST /organizations/{organizationID}/members
// ============================================================================

// Request types
// CreateMemberRequestBody defines the request body for CreateMember
type CreateMemberRequestBody struct {
	Role string `json:"role"`
}

type CreateMemberRequest struct {
	OrganizationID uuid.UUID `json:"organizationID"`
	Body           *CreateMemberRequestBody
}

// Response types

type CreateMemberResponse interface {
	VisitCreateMemberResponse(w http.ResponseWriter) error
}

type CreateMember201Response struct {
	Data entities.Member `json:"data"`
}

func (response CreateMember201Response) VisitCreateMemberResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json")
	w.WriteHeader(201)

	return json.NewEncoder(w).Encode(response)
}

type CreateMember400Response struct {
	server.BadRequestResponse
}

func (response CreateMember400Response) VisitCreateMemberResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/problem+json")
	w.WriteHeader(400)

	return json.NewEncoder(w).Encode(response.BadRequestResponse)
}

type CreateMember401Response struct {
	server.UnauthorizedResponse
}

func (response CreateMember401Response) VisitCreateMemberResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/problem+json")
	w.WriteHeader(401)

	return json.NewEncoder(w).Encode(response.UnauthorizedResponse)
}

// Handler method

// CreateMember handles the POST /organizations/{organizationID}/members endpoint.
func (c *MemberController) CreateMember(ctx echo.Context) error {
	reqCtx := ctx.Request().Context()
	request := CreateMemberRequest{}

	// Extract session ID from context for authenticated operations
	var sessionID uuid.UUID
	if sid := ctx.Get("sessionID"); sid != nil {
		sessionID = sid.(uuid.UUID)
	} else {
		return echo.NewHTTPError(http.StatusUnauthorized, "session required")
	}

	// Path parameter "organizationID"
	var organizationID uuid.UUID
	if err := runtime.BindStyledParameterWithOptions("simple", "organizationID", ctx.Param("organizationID"), &organizationID, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true}); err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter organizationID: %s", err))
	}
	request.OrganizationID = organizationID

	// Request body
	request.Body = &CreateMemberRequestBody{}
	if err := ctx.Bind(request.Body); err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, err.Error())
	}

	// Set auth scopes
	ctx.Set(server.BearerAuthScopes, []string{})

	// Determine which handler to call based on operation
	// Command handler

	// Map request to command parameters
	cmd := commands.NewCreateMemberCommand(
		sessionID,              // SessionID for authenticated operations
		request.OrganizationID, // OrganizationID
		request.Body.Role,      // Role
	)
	result, err := c.createMemberHandler.Handle(reqCtx, cmd)
	if err != nil {
		return err
	}
	return ctx.JSON(http.StatusCreated, map[string]interface{}{
		"data": result,
	})
}

// ============================================================================
// GetMember - GET /organizations/{organizationID}/members/{id}
// ============================================================================

// Request types

type GetMemberRequest struct {
	OrganizationID uuid.UUID `json:"organizationID"`
	ID             uuid.UUID `json:"id"`
}

// Response types

type GetMemberResponse interface {
	VisitGetMemberResponse(w http.ResponseWriter) error
}

type GetMember200Response struct {
	Data entities.Member `json:"data"`
}

func (response GetMember200Response) VisitGetMemberResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json")
	w.WriteHeader(200)

	return json.NewEncoder(w).Encode(response)
}

type GetMember404Response struct {
	server.NotFoundResponse
}

func (response GetMember404Response) VisitGetMemberResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/problem+json")
	w.WriteHeader(404)

	return json.NewEncoder(w).Encode(response.NotFoundResponse)
}

// Handler method

// GetMember handles the GET /organizations/{organizationID}/members/{id} endpoint.
func (c *MemberController) GetMember(ctx echo.Context) error {
	reqCtx := ctx.Request().Context()
	request := GetMemberRequest{}

	// Extract session ID from context for authenticated operations
	var sessionID uuid.UUID
	if sid := ctx.Get("sessionID"); sid != nil {
		sessionID = sid.(uuid.UUID)
	} else {
		return echo.NewHTTPError(http.StatusUnauthorized, "session required")
	}

	// Path parameter "organizationID"
	var organizationID uuid.UUID
	if err := runtime.BindStyledParameterWithOptions("simple", "organizationID", ctx.Param("organizationID"), &organizationID, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true}); err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter organizationID: %s", err))
	}
	request.OrganizationID = organizationID

	// Path parameter "id"
	var id uuid.UUID
	if err := runtime.BindStyledParameterWithOptions("simple", "id", ctx.Param("id"), &id, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true}); err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter id: %s", err))
	}
	request.ID = id

	// Set auth scopes
	ctx.Set(server.BearerAuthScopes, []string{})

	// Determine which handler to call based on operation
	// Query handler
	query := queries.NewGetMemberQuery(
		sessionID,              // SessionID for authenticated operations
		request.OrganizationID, // OrganizationID
		request.ID,             // ID
	)

	result, err := c.getMemberHandler.Handle(reqCtx, query)
	if err != nil {
		return err
	}

	return ctx.JSON(http.StatusOK, map[string]interface{}{
		"data": result,
	})
}

// ============================================================================
// ListMembers - GET /organizations/{organizationID}/members
// ============================================================================

// Request types
// ListMembersParams defines parameters for ListMembers
type ListMembersParams struct {
	Filter map[string]any   `json:"filter,omitempty"`
	Page   map[string]any   `json:"page,omitempty"`
	Sort   []map[string]any `json:"sort,omitempty"`
}

type ListMembersRequest struct {
	OrganizationID uuid.UUID `json:"organizationID"`
	Params         ListMembersParams
}

// Response types

type ListMembersResponse interface {
	VisitListMembersResponse(w http.ResponseWriter) error
}

// ListMembers200ResponseMeta defines the meta structure
type ListMembers200ResponseMeta struct {
	Total float64 `json:"total"`
}

type ListMembers200Response struct {
	Data []entities.Member          `json:"data"`
	Meta ListMembers200ResponseMeta `json:"meta"`
}

func (response ListMembers200Response) VisitListMembersResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json")
	w.WriteHeader(200)

	return json.NewEncoder(w).Encode(response)
}

type ListMembers400Response struct {
	server.BadRequestResponse
}

func (response ListMembers400Response) VisitListMembersResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/problem+json")
	w.WriteHeader(400)

	return json.NewEncoder(w).Encode(response.BadRequestResponse)
}

type ListMembers401Response struct {
	server.UnauthorizedResponse
}

func (response ListMembers401Response) VisitListMembersResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/problem+json")
	w.WriteHeader(401)

	return json.NewEncoder(w).Encode(response.UnauthorizedResponse)
}

// Handler method

// ListMembers handles the GET /organizations/{organizationID}/members endpoint.
func (c *MemberController) ListMembers(ctx echo.Context) error {
	reqCtx := ctx.Request().Context()
	request := ListMembersRequest{}

	// Extract session ID from context for authenticated operations
	var sessionID uuid.UUID
	if sid := ctx.Get("sessionID"); sid != nil {
		sessionID = sid.(uuid.UUID)
	} else {
		return echo.NewHTTPError(http.StatusUnauthorized, "session required")
	}

	// Path parameter "organizationID"
	var organizationID uuid.UUID
	if err := runtime.BindStyledParameterWithOptions("simple", "organizationID", ctx.Param("organizationID"), &organizationID, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true}); err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter organizationID: %s", err))
	}
	request.OrganizationID = organizationID

	// Query parameters
	var params ListMembersParams
	// Optional query parameter "Filter"
	if err := runtime.BindQueryParameter("deepObject", true, false, "filter", ctx.QueryParams(), &params.Filter); err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter filter: %s", err))
	}
	// Optional query parameter "Page"
	if err := runtime.BindQueryParameter("form", true, false, "page", ctx.QueryParams(), &params.Page); err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter page: %s", err))
	}
	// Optional query parameter "Sort"
	if err := runtime.BindQueryParameter("form", true, false, "sort", ctx.QueryParams(), &params.Sort); err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter sort: %s", err))
	}
	request.Params = params

	// Set auth scopes
	ctx.Set(server.BearerAuthScopes, []string{})

	// Determine which handler to call based on operation
	// Query handler
	query := queries.NewListMembersQuery(
		sessionID,              // SessionID for authenticated operations
		request.OrganizationID, // OrganizationID
	)
	// TODO: Apply filters, pagination, sorting from request.Params

	results, total, err := c.listMembersHandler.Handle(reqCtx, query)
	if err != nil {
		return err
	}

	return ctx.JSON(http.StatusOK, map[string]interface{}{
		"data": results,
		"meta": map[string]interface{}{
			"total": total,
		},
	})
}

// ============================================================================
// UpdateMember - PATCH /organizations/{organizationID}/members/{id}
// ============================================================================

// Request types
// UpdateMemberRequestBody defines the request body for UpdateMember
type UpdateMemberRequestBody struct {
	Role *string `json:"role,omitempty"`
}

type UpdateMemberRequest struct {
	OrganizationID uuid.UUID `json:"organizationID"`
	ID             uuid.UUID `json:"id"`
	Body           *UpdateMemberRequestBody
}

// Response types

type UpdateMemberResponse interface {
	VisitUpdateMemberResponse(w http.ResponseWriter) error
}

type UpdateMember200Response struct {
	Data entities.Member `json:"data"`
}

func (response UpdateMember200Response) VisitUpdateMemberResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json")
	w.WriteHeader(200)

	return json.NewEncoder(w).Encode(response)
}

type UpdateMember404Response struct {
	server.NotFoundResponse
}

func (response UpdateMember404Response) VisitUpdateMemberResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/problem+json")
	w.WriteHeader(404)

	return json.NewEncoder(w).Encode(response.NotFoundResponse)
}

// Handler method

// UpdateMember handles the PATCH /organizations/{organizationID}/members/{id} endpoint.
func (c *MemberController) UpdateMember(ctx echo.Context) error {
	reqCtx := ctx.Request().Context()
	request := UpdateMemberRequest{}

	// Extract session ID from context for authenticated operations
	var sessionID uuid.UUID
	if sid := ctx.Get("sessionID"); sid != nil {
		sessionID = sid.(uuid.UUID)
	} else {
		return echo.NewHTTPError(http.StatusUnauthorized, "session required")
	}

	// Path parameter "organizationID"
	var organizationID uuid.UUID
	if err := runtime.BindStyledParameterWithOptions("simple", "organizationID", ctx.Param("organizationID"), &organizationID, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true}); err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter organizationID: %s", err))
	}
	request.OrganizationID = organizationID

	// Path parameter "id"
	var id uuid.UUID
	if err := runtime.BindStyledParameterWithOptions("simple", "id", ctx.Param("id"), &id, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true}); err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter id: %s", err))
	}
	request.ID = id

	// Request body
	request.Body = &UpdateMemberRequestBody{}
	if err := ctx.Bind(request.Body); err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, err.Error())
	}

	// Set auth scopes
	ctx.Set(server.BearerAuthScopes, []string{})

	// Determine which handler to call based on operation
	// Command handler

	// Map request to command parameters
	cmd := commands.NewUpdateMemberCommand(
		sessionID,              // SessionID for authenticated operations
		request.OrganizationID, // OrganizationID
		request.ID,             // ID
		request.Body.Role,      // Role
	)
	result, err := c.updateMemberHandler.Handle(reqCtx, cmd)
	if err != nil {
		return err
	}
	return ctx.JSON(http.StatusOK, map[string]interface{}{
		"data": result,
	})
}

// ============================================================================
// DeleteMember - DELETE /organizations/{organizationID}/members/{id}
// ============================================================================

// Request types

type DeleteMemberRequest struct {
	OrganizationID uuid.UUID `json:"organizationID"`
	ID             uuid.UUID `json:"id"`
}

// Response types

type DeleteMemberResponse interface {
	VisitDeleteMemberResponse(w http.ResponseWriter) error
}

type DeleteMember200Response struct {
	Data entities.Member `json:"data"`
}

func (response DeleteMember200Response) VisitDeleteMemberResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json")
	w.WriteHeader(200)

	return json.NewEncoder(w).Encode(response)
}

type DeleteMember404Response struct {
	server.NotFoundResponse
}

func (response DeleteMember404Response) VisitDeleteMemberResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/problem+json")
	w.WriteHeader(404)

	return json.NewEncoder(w).Encode(response.NotFoundResponse)
}

// Handler method

// DeleteMember handles the DELETE /organizations/{organizationID}/members/{id} endpoint.
func (c *MemberController) DeleteMember(ctx echo.Context) error {
	reqCtx := ctx.Request().Context()
	request := DeleteMemberRequest{}

	// Extract session ID from context for authenticated operations
	var sessionID uuid.UUID
	if sid := ctx.Get("sessionID"); sid != nil {
		sessionID = sid.(uuid.UUID)
	} else {
		return echo.NewHTTPError(http.StatusUnauthorized, "session required")
	}

	// Path parameter "organizationID"
	var organizationID uuid.UUID
	if err := runtime.BindStyledParameterWithOptions("simple", "organizationID", ctx.Param("organizationID"), &organizationID, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true}); err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter organizationID: %s", err))
	}
	request.OrganizationID = organizationID

	// Path parameter "id"
	var id uuid.UUID
	if err := runtime.BindStyledParameterWithOptions("simple", "id", ctx.Param("id"), &id, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true}); err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter id: %s", err))
	}
	request.ID = id

	// Set auth scopes
	ctx.Set(server.BearerAuthScopes, []string{})

	// Determine which handler to call based on operation
	// Command handler

	// Map request to command parameters
	cmd := commands.NewDeleteMemberCommand(
		sessionID,              // SessionID for authenticated operations
		request.OrganizationID, // OrganizationID
		request.ID,             // ID
	)
	if err := c.deleteMemberHandler.Handle(reqCtx, cmd); err != nil {
		return err
	}
	return ctx.NoContent(http.StatusNoContent)
}
