// Code generated by codegen repository. DO NOT EDIT.
package {{.Package}}

import (
	"context"
	"database/sql"
	"fmt"
	
	"github.com/archesai/archesai/internal/database/sqlite"
	"github.com/google/uuid"
)

// SQLiteRepository implements Repository using SQLite.
type SQLiteRepository struct {
	db      *sql.DB
	queries *sqlite.Queries
}

// NewSQLiteRepository creates a new SQLite repository.
func NewSQLiteRepository(db *sql.DB) Repository {
	return &SQLiteRepository{
		db:      db,
		queries: sqlite.New(db),
	}
}

{{range .Entities}}
// {{.Name}} operations

{{if contains .Operations "create"}}
func (r *SQLiteRepository) Create{{.Name}}(ctx context.Context, entity *{{.Type}}) (*{{.Type}}, error) {
	{{if eq .Name "User"}}params := sqlite.CreateUserParams{
		Id:            entity.Id.String(),
		Email:         string(entity.Email),
		Name:          entity.Name,
		EmailVerified: entity.EmailVerified,
		Image:         entity.Image,
	}
	
	result, err := r.queries.CreateUser(ctx, params){{else if eq .Name "Session"}}params := sqlite.CreateSessionParams{
		Id:                     entity.Id.String(),
		UserId:                 entity.UserId,
		ExpiresAt:              entity.ExpiresAt,
		ActiveOrganizationId:   entity.ActiveOrganizationId,
	}
	
	result, err := r.queries.CreateSession(ctx, params){{else if eq .Name "Account"}}params := sqlite.CreateAccountParams{
		Id:           entity.Id.String(),
		UserId:       entity.UserId.String(),
		ProviderId:   string(entity.ProviderId),
		AccountId:    entity.AccountId,
		AccessToken:  entity.AccessToken,
		RefreshToken: entity.RefreshToken,
		IdToken:      entity.IdToken,
		Password:     entity.Password,
	}
	
	result, err := r.queries.CreateAccount(ctx, params){{end}}
	if err != nil {
		return nil, NewRepositoryError("create {{lower .Name}}", err)
	}
	
	// SQLite returns last insert ID, need to fetch the created record
	// This is a simplified version; in production you'd fetch by ID
	return {{.Name}}DBToAPI(&result), nil
}
{{end}}

{{if contains .Operations "read"}}
func (r *SQLiteRepository) Get{{.Name}}ByID(ctx context.Context, id uuid.UUID) (*{{.Type}}, error) {
	{{if eq .Name "User"}}result, err := r.queries.GetUserById(ctx, id.String()){{else if eq .Name "Session"}}result, err := r.queries.GetSessionById(ctx, id.String()){{else if eq .Name "Account"}}result, err := r.queries.GetAccountById(ctx, id.String()){{end}}
	if err != nil {
		if err == sql.ErrNoRows {
			return nil, NewRepositoryError("{{lower .Name}} not found", err)
		}
		return nil, NewRepositoryError("get {{lower .Name}}", err)
	}
	
	return {{.Name}}DBToAPI(&result), nil
}
{{end}}

{{if contains .Operations "update"}}
func (r *SQLiteRepository) Update{{.Name}}(ctx context.Context, id uuid.UUID, entity *{{.Type}}) (*{{.Type}}, error) {
	{{if eq .Name "User"}}params := sqlite.UpdateUserParams{
		Id:            id.String(),
		Email:         string(entity.Email),
		Name:          entity.Name,
		EmailVerified: entity.EmailVerified,
		Image:         entity.Image,
	}
	
	err := r.queries.UpdateUser(ctx, params){{else if eq .Name "Session"}}params := sqlite.UpdateSessionParams{
		Id:                     id.String(),
		ActiveOrganizationId:   entity.ActiveOrganizationId,
	}
	
	err := r.queries.UpdateSession(ctx, params){{else if eq .Name "Account"}}params := sqlite.UpdateAccountParams{
		Id:           id.String(),
		AccessToken:  entity.AccessToken,
		RefreshToken: entity.RefreshToken,
		IdToken:      entity.IdToken,
		Password:     entity.Password,
	}
	
	err := r.queries.UpdateAccount(ctx, params){{end}}
	if err != nil {
		return nil, NewRepositoryError("update {{lower .Name}}", err)
	}
	
	// Fetch the updated record
	return r.Get{{.Name}}ByID(ctx, id)
}
{{end}}

{{if contains .Operations "delete"}}
func (r *SQLiteRepository) Delete{{.Name}}(ctx context.Context, id uuid.UUID) error {
	{{if eq .Name "User"}}err := r.queries.DeleteUser(ctx, id.String()){{else if eq .Name "Session"}}err := r.queries.DeleteSession(ctx, id.String()){{else if eq .Name "Account"}}err := r.queries.DeleteAccount(ctx, id.String()){{end}}
	if err != nil {
		return NewRepositoryError("delete {{lower .Name}}", err)
	}
	return nil
}
{{end}}

{{if contains .Operations "list"}}
func (r *SQLiteRepository) List{{.Name}}s(ctx context.Context, params List{{.Name}}sParams) ([]*{{.Type}}, int64, error) {
	{{if eq .Name "User"}}listParams := sqlite.ListUsersParams{
		Limit:  int64(params.Limit),
		Offset: int64(params.Offset),
	}
	
	results, err := r.queries.ListUsers(ctx, listParams){{else if eq .Name "Session"}}listParams := sqlite.ListSessionsParams{
		Limit:  int64(params.Limit),
		Offset: int64(params.Offset),
	}
	
	results, err := r.queries.ListSessions(ctx, listParams){{else if eq .Name "Account"}}listParams := sqlite.ListAccountsParams{
		Limit:  int64(params.Limit),
		Offset: int64(params.Offset),
	}
	
	results, err := r.queries.ListAccounts(ctx, listParams){{end}}
	if err != nil {
		return nil, 0, NewRepositoryError("list {{lower .Name}}s", err)
	}
	
	entities := make([]*{{.Type}}, len(results))
	for i, result := range results {
		entities[i] = {{.Name}}DBToAPI(&result)
	}
	
	// Get total count
	{{if eq .Name "User"}}count, err := r.queries.CountUsers(ctx){{else if eq .Name "Session"}}count, err := r.queries.CountSessions(ctx){{else if eq .Name "Account"}}count, err := r.queries.CountAccounts(ctx){{end}}
	if err != nil {
		// Return results without count on error
		return entities, int64(len(entities)), nil
	}
	
	return entities, count, nil
}
{{end}}

{{if eq .Name "User"}}
// Additional User operations
func (r *SQLiteRepository) GetUserByEmail(ctx context.Context, email string) (*{{.Type}}, error) {
	result, err := r.queries.GetUserByEmail(ctx, email)
	if err != nil {
		if err == sql.ErrNoRows {
			return nil, NewRepositoryError("user not found", err)
		}
		return nil, NewRepositoryError("get user by email", err)
	}
	
	return {{.Name}}DBToAPI(&result), nil
}
{{end}}

{{if eq .Name "Session"}}
// Additional Session operations
func (r *SQLiteRepository) GetSessionByToken(ctx context.Context, token string) (*{{.Type}}, error) {
	result, err := r.queries.GetSessionByToken(ctx, token)
	if err != nil {
		if err == sql.ErrNoRows {
			return nil, NewRepositoryError("session not found", err)
		}
		return nil, NewRepositoryError("get session by token", err)
	}
	
	return {{.Name}}DBToAPI(&result), nil
}

func (r *SQLiteRepository) DeleteSessionByToken(ctx context.Context, token string) error {
	err := r.queries.DeleteSessionByToken(ctx, token)
	if err != nil {
		return NewRepositoryError("delete session by token", err)
	}
	return nil
}

func (r *SQLiteRepository) DeleteUserSessions(ctx context.Context, userID uuid.UUID) error {
	err := r.queries.DeleteUserSessions(ctx, userID.String())
	if err != nil {
		return NewRepositoryError("delete user sessions", err)
	}
	return nil
}
{{end}}

{{if eq .Name "Account"}}
// Additional Account operations
func (r *SQLiteRepository) GetAccountByProviderID(ctx context.Context, provider, providerID string) (*{{.Type}}, error) {
	params := sqlite.GetAccountByProviderParams{
		ProviderId: provider,
		AccountId:  providerID,
	}
	
	result, err := r.queries.GetAccountByProvider(ctx, params)
	if err != nil {
		if err == sql.ErrNoRows {
			return nil, NewRepositoryError("account not found", err)
		}
		return nil, NewRepositoryError("get account by provider", err)
	}
	
	return {{.Name}}DBToAPI(&result), nil
}

func (r *SQLiteRepository) ListUserAccounts(ctx context.Context, userID uuid.UUID) ([]*{{.Type}}, error) {
	results, err := r.queries.ListUserAccounts(ctx, userID.String())
	if err != nil {
		return nil, NewRepositoryError("list user accounts", err)
	}
	
	entities := make([]*{{.Type}}, len(results))
	for i, result := range results {
		entities[i] = {{.Name}}DBToAPI(&result)
	}
	
	return entities, nil
}
{{end}}
{{end}}