{{- /*
Template: bootstrap.tmpl
Generates: Main application wiring and dependency injection
Expects:
- Domains: []DomainData
  - Name: string 
  - HasController: bool
  - HasRepository: bool
  - HasCommands: bool
  - HasQueries: bool
  - Commands: []string (e.g., ["Create", "Update", "Delete"])
  - Queries: []string (e.g., ["Get", "List"])
*/ -}}
// Code generated by archesai. DO NOT EDIT.

package bootstrap

import (
	"context"
	"fmt"
	"io/fs"
	"log/slog"
	"net/http"

	"golang.org/x/sync/errgroup"

	"{{ .OutputPath }}/generated/adapters/http/controllers"
{{- range .Domains }}
{{- if .HasCommands }}
	{{ lower .Name }}Commands "{{ $.OutputPath }}/generated/application/commands/{{ lower .Name }}"
{{- end }}
{{- if .HasQueries }}
	{{ lower .Name }}Queries "{{ $.OutputPath }}/generated/application/queries/{{ lower .Name }}"
{{- end }}
{{- end }}
	"{{ .OutputPath }}/generated/core/models"
	"github.com/archesai/archesai/pkg/executor"
	"github.com/archesai/archesai/pkg/server"

	// Custom handlers for specific domains
	authHandlers "github.com/archesai/archesai/apps/studio/handlers/auth"
	configHandlers "github.com/archesai/archesai/apps/studio/handlers/config"
	executorHandlers "github.com/archesai/archesai/apps/studio/handlers/executor"
	healthHandlers "github.com/archesai/archesai/apps/studio/handlers/health"
	pipelineHandlers "github.com/archesai/archesai/apps/studio/handlers/pipeline"
	userHandlers "github.com/archesai/archesai/apps/studio/handlers/user"

	// These are not in the loop above since they have custom handlers
	authQueries "{{ .OutputPath }}/generated/application/queries/auth"
	pgmigrations "{{ .OutputPath }}/generated/infrastructure/persistence/postgres"
	sqlitemigrations "{{ .OutputPath }}/generated/infrastructure/persistence/sqlite"
	"github.com/archesai/archesai/pkg/auth"
	"github.com/archesai/archesai/pkg/cache"
	"github.com/archesai/archesai/pkg/notifications"
	"github.com/archesai/archesai/pkg/database"
)

// App holds all application dependencies.
type App struct {
	// Core infrastructure
	infra *Infrastructure

	// Public infrastructure access
	Config *models.Config
	Server *server.Server

	// HTTP Controllers
	AuthController *controllers.AuthController
{{- range .Domains }}
{{- if .HasController }}
	{{ pascalCase .Name }}Controller *controllers.{{ pascalCase .Name }}Controller
{{- end }}
{{- end }}
}

// NewApp creates and initializes all application dependencies.
func NewApp(cfg *models.Config) (*App, error) {
	// Initialize infrastructure
	infra, err := NewInfrastructure(cfg)
	if err != nil {
		return nil, fmt.Errorf("failed to initialize infrastructure: %w", err)
	}

	// Run migrations if enabled
	if cfg.Database.RunMigrations {
		slog.Info("running database migrations")

		// Select the appropriate migrations filesystem based on database type
		var migrationsFS fs.FS
		switch cfg.Database.Type {
		case "postgres", "postgresql":
			migrationsFS = pgmigrations.Migrations
		case "sqlite":
			migrationsFS = sqlitemigrations.Migrations
		default:
			return nil, fmt.Errorf("unsupported database type for migrations: %s", cfg.Database.Type)
		}

		if err := database.RunMigrations(infra.Database, migrationsFS); err != nil {
			slog.Error("failed to run migrations", "error", err)
			isProduction := cfg.API.Environment == "production"
			if isProduction {
				return nil, fmt.Errorf("failed to run migrations: %w", err)
			}
		}
		slog.Info("database migrations completed")
	}

	// Create repositories
	slog.Info("creating repositories")
	repos, err := NewRepositories(infra)
	if err != nil {
		return nil, fmt.Errorf("failed to create repositories: %w", err)
	}

	// Initialize auth service after repositories are available
	slog.Info("initializing auth service")
	var stringCache cache.Cache[string]
	if infra.redisClient != nil {
		stringCache = cache.NewRedisCache[string](infra.redisClient.GetRedisClient(), "auth:tokens")
	} else {
		stringCache = cache.NewMemoryCache[string]()
	}

	// Initialize notification deliverers
	magicLinkDeliverer := notifications.NewConsoleDeliverer()
	otpDeliverer := notifications.NewOTPDeliverer()

	infra.AuthService = auth.NewService(cfg, repos.Sessions, repos.Users, repos.Accounts, stringCache, magicLinkDeliverer, otpDeliverer)
	slog.Info("auth service ready")

	// Create app instance to populate
	app := &App{
		// Infrastructure
		infra:  infra,
		Config: cfg,
	}

	// Initialize all domain handlers in parallel where possible
	g, _ := errgroup.WithContext(context.Background())

	// Initialize config domain (infrastructure query - needs special handling)
	slog.Info("initializing config domain")
	getConfigHandler := configHandlers.NewGetConfigQueryHandler(cfg)
	app.ConfigController = controllers.NewConfigController(getConfigHandler)
	slog.Info("config domain ready")

	// Initialize health domain (infrastructure query - needs special handling)
	slog.Info("initializing health domain")
	getHealthHandler := healthHandlers.NewGetHealthQueryHandler()
	app.HealthController = controllers.NewHealthController(getHealthHandler)
	slog.Info("health domain ready")

	// Initialize auth domain (cross-cutting concern spanning multiple entities)
	g.Go(func() error {
		slog.Info("initializing auth domain")

		// Create command handlers using custom handlers (in REST operation order matching controller signature)
		confirmEmailChangeHandler := authHandlers.NewConfirmEmailChangeCommandHandler(infra.AuthService)
		confirmEmailVerificationHandler := authHandlers.NewConfirmEmailVerificationCommandHandler(infra.AuthService)
		confirmPasswordResetHandler := authHandlers.NewConfirmPasswordResetCommandHandler(infra.AuthService)
		linkAccountHandler := authHandlers.NewLinkAccountCommandHandler(infra.AuthService)
		loginHandler := authHandlers.NewLoginCommandHandler(infra.AuthService)
		logoutHandler := authHandlers.NewLogoutCommandHandler(infra.AuthService)
		logoutAllHandler := authHandlers.NewLogoutAllCommandHandler(infra.AuthService)
		registerHandler := authHandlers.NewRegisterCommandHandler(infra.AuthService, repos.Users, repos.Accounts)
		requestEmailChangeHandler := authHandlers.NewRequestEmailChangeCommandHandler(infra.AuthService)
		requestEmailVerificationHandler := authHandlers.NewRequestEmailVerificationCommandHandler(infra.AuthService)
		requestMagicLinkHandler := authHandlers.NewRequestMagicLinkCommandHandler(infra.AuthService)
		requestPasswordResetHandler := authHandlers.NewRequestPasswordResetCommandHandler(infra.AuthService)
		verifyMagicLinkHandler := authHandlers.NewVerifyMagicLinkCommandHandler(infra.AuthService)
		updateAccountHandler := authHandlers.NewUpdateAccountCommandHandler(infra.AuthService)
		updateSessionHandler := authHandlers.NewUpdateSessionCommandHandler(repos.Sessions)
		deleteAccountHandler := authHandlers.NewDeleteAccountCommandHandler(infra.AuthService)
		deleteSessionHandler := authHandlers.NewDeleteSessionCommandHandler(repos.Sessions)

		// Create query handlers using custom handlers (in REST operation order matching controller signature)
		getAccountHandler := authQueries.NewGetAccountQueryHandler(repos.Accounts)
		getSessionHandler := authQueries.NewGetSessionQueryHandler(repos.Sessions)
		oauthAuthorizeHandler := authHandlers.NewOAuthAuthorizeQueryHandler(infra.AuthService)
		oauthCallbackHandler := authHandlers.NewOAuthCallbackQueryHandler(infra.AuthService, infra.EventPublisher)
		listAccountsHandler := authQueries.NewListAccountsQueryHandler(repos.Accounts)
		listSessionsHandler := authQueries.NewListSessionsQueryHandler(repos.Sessions)

		// Create controller with handlers in order matching NewAuthController signature
		app.AuthController = controllers.NewAuthController(
			confirmEmailChangeHandler,
			confirmEmailVerificationHandler,
			confirmPasswordResetHandler,
			linkAccountHandler,
			loginHandler,
			logoutHandler,
			logoutAllHandler,
			registerHandler,
			requestEmailChangeHandler,
			requestEmailVerificationHandler,
			requestMagicLinkHandler,
			requestPasswordResetHandler,
			verifyMagicLinkHandler,
			updateAccountHandler,
			updateSessionHandler,
			deleteAccountHandler,
			deleteSessionHandler,
			getAccountHandler,
			getSessionHandler,
			oauthAuthorizeHandler,
			oauthCallbackHandler,
			listAccountsHandler,
			listSessionsHandler,
		)

		slog.Info("auth domain ready")
		return nil
	})

	// Initialize executor domain (needs ExecutorService for execution)
	g.Go(func() error {
		slog.Info("initializing executor domain")

		// Create executor service
		executorBuilder, err := executor.NewBuilder()
		if err != nil {
			return fmt.Errorf("failed to create executor builder: %w", err)
		}
		infra.ExecutorService = executor.NewExecutorService[map[string]any, map[string]any](
			repos.Executors,
			executorBuilder,
		)

		// Create command handlers
		createExecutorHandler := executorCommands.NewCreateExecutorCommandHandler(
			repos.Executors,
			infra.EventPublisher,
		)
		deleteExecutorHandler := executorCommands.NewDeleteExecutorCommandHandler(
			repos.Executors,
			infra.EventPublisher,
		)
		executeExecutorHandler := executorHandlers.NewExecuteExecutorCommandHandler(
			repos.Executors,
			infra.ExecutorService,
			infra.EventPublisher,
		)
		updateExecutorHandler := executorCommands.NewUpdateExecutorCommandHandler(
			repos.Executors,
			infra.EventPublisher,
		)

		// Create query handlers
		getExecutorHandler := executorQueries.NewGetExecutorQueryHandler(
			repos.Executors,
		)
		listExecutorsHandler := executorQueries.NewListExecutorsQueryHandler(
			repos.Executors,
		)

		// Create controller with handlers (matching the controller constructor order)
		app.ExecutorController = controllers.NewExecutorController(
			createExecutorHandler,
			executeExecutorHandler,
			updateExecutorHandler,
			deleteExecutorHandler,
			getExecutorHandler,
			listExecutorsHandler,
		)

		slog.Info("executor domain ready")
		return nil
	})

{{- range .Domains }}
{{- if and .HasController (ne .Name "Config") (ne .Name "Health") (ne .Name "Executor") (ne .Name "Pipeline") (ne .Name "User") }}

	// Initialize {{ lower .Name }} domain
	g.Go(func() error {
		slog.Info("initializing {{ lower .Name }} domain")

		{{- if or .HasCommands .HasQueries }}
		// Create command and query handlers
		{{- end }}
		{{- $domain := . }}
		{{- range .Commands }}
		{{ camelCase . }}Handler := {{ lower $domain.Name }}Commands.New{{ pascalCase . }}CommandHandler(
			repos.{{ pluralize $domain.Name }},
			infra.EventPublisher,
		)
		{{- end }}
		{{- range .Queries }}
		{{ camelCase . }}Handler := {{ lower $domain.Name }}Queries.New{{ pascalCase . }}QueryHandler(
			repos.{{ pluralize $domain.Name }},
		)
		{{- end }}

		// Create controller with handlers
		app.{{ pascalCase .Name }}Controller = controllers.New{{ pascalCase .Name }}Controller(
			{{- range .Commands }}
			{{ camelCase . }}Handler,
			{{- end }}
			{{- range .Queries }}
			{{ camelCase . }}Handler,
			{{- end }}
		)

		slog.Info("{{ lower .Name }} domain ready")
		return nil
	})
{{- end }}
{{- end }}

	// Initialize pipeline domain (has mixed custom and generated handlers)
	g.Go(func() error {
		slog.Info("initializing pipeline domain")

		// Create command handlers
		createPipelineHandler := pipelineCommands.NewCreatePipelineCommandHandler(
			repos.Pipelines,
			infra.EventPublisher,
		)
		createPipelineStepHandler := pipelineHandlers.NewCreatePipelineStepCommandHandler(
			repos.Pipelines,
			infra.EventPublisher,
		)
		validatePipelineExecutionPlanHandler := pipelineHandlers.NewValidatePipelineExecutionPlanCommandHandler(
			repos.Pipelines,
			infra.EventPublisher,
		)
		updatePipelineHandler := pipelineCommands.NewUpdatePipelineCommandHandler(
			repos.Pipelines,
			infra.EventPublisher,
		)
		deletePipelineHandler := pipelineCommands.NewDeletePipelineCommandHandler(
			repos.Pipelines,
			infra.EventPublisher,
		)

		// Create query handlers
		getPipelineHandler := pipelineQueries.NewGetPipelineQueryHandler(
			repos.Pipelines,
		)
		getPipelineExecutionPlanHandler := pipelineHandlers.NewGetPipelineExecutionPlanQueryHandler(
			repos.Pipelines,
		)
		getPipelineStepsHandler := pipelineHandlers.NewGetPipelineStepsQueryHandler(
			repos.Pipelines,
		)
		listPipelinesHandler := pipelineQueries.NewListPipelinesQueryHandler(
			repos.Pipelines,
		)

		// Create controller with handlers
		app.PipelineController = controllers.NewPipelineController(
			createPipelineHandler,
			createPipelineStepHandler,
			validatePipelineExecutionPlanHandler,
			updatePipelineHandler,
			deletePipelineHandler,
			getPipelineHandler,
			getPipelineExecutionPlanHandler,
			getPipelineStepsHandler,
			listPipelinesHandler,
		)

		slog.Info("pipeline domain ready")
		return nil
	})

	// Initialize user domain (has mixed custom and generated handlers)
	g.Go(func() error {
		slog.Info("initializing user domain")

		// Create command handlers
		updateCurrentUserHandler := userHandlers.NewUpdateCurrentUserCommandHandler(
			repos.Users,
			infra.EventPublisher,
		)
		updateUserHandler := userCommands.NewUpdateUserCommandHandler(
			repos.Users,
			infra.EventPublisher,
		)
		deleteCurrentUserHandler := userHandlers.NewDeleteCurrentUserCommandHandler(
			repos.Users,
			infra.EventPublisher,
		)
		deleteUserHandler := userCommands.NewDeleteUserCommandHandler(
			repos.Users,
			infra.EventPublisher,
		)

		// Create query handlers
		getCurrentUserHandler := userHandlers.NewGetCurrentUserQueryHandler(
			repos.Users,
		)
		getUserHandler := userQueries.NewGetUserQueryHandler(
			repos.Users,
		)
		listUsersHandler := userQueries.NewListUsersQueryHandler(
			repos.Users,
		)

		// Create controller with handlers
		app.UserController = controllers.NewUserController(
			updateCurrentUserHandler,
			updateUserHandler,
			deleteCurrentUserHandler,
			deleteUserHandler,
			getCurrentUserHandler,
			getUserHandler,
			listUsersHandler,
		)

		slog.Info("user domain ready")
		return nil
	})

	// Wait for all parallel initializations to complete
	if err := g.Wait(); err != nil {
		return nil, fmt.Errorf("failed to initialize domains: %w", err)
	}

	// Create the HTTP server
	slog.Info("creating HTTP server")
	app.Server = server.NewServer(cfg.API)

	// Register all application routes
	app.registerRoutes()

	slog.Info("application initialized successfully")
	return app, nil
}

// Close cleans up all resources.
func (a *App) Close() error {
	slog.Info("shutting down application")
	if a.infra != nil {
		return a.infra.Close()
	}
	return nil
}

// registerRoutes registers all application routes with the server.
func (a *App) registerRoutes() {
	// Get the mux from the server
	mux := a.Server.Mux()

	// Register all application routes
	a.RegisterRoutes(mux)
	slog.Info("routes registered")
}

// RegisterRoutes registers all application routes with the http.ServeMux.
func (a *App) RegisterRoutes(mux *http.ServeMux) {
	slog.Info("registering API routes...")

	// ========================================
	// API ROUTES
	// ========================================
	// Auth routes
	slog.Info("registering auth routes")
	controllers.RegisterAuthRoutes(mux, a.AuthController)
{{- range .Domains }}
{{- if .HasController }}
	// {{ lower .Name }} routes
	slog.Info("registering {{ lower .Name }} routes")
	controllers.Register{{ .Name }}Routes(mux, a.{{ .Name }}Controller)
{{- end }}
{{- end }}

	slog.Info("all routes registered successfully")
}