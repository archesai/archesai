{{- /*
Template: controller.tmpl
Generates: A single controller implementation
Expected data: ControllersTemplateData
*/ -}}
// Code generated by archesai. DO NOT EDIT.

package controllers

import (
	"context"
	"encoding/json"
	"fmt"
	"net/http"

	"github.com/google/uuid"
	"github.com/labstack/echo/v4"
	"github.com/oapi-codegen/runtime"

	"github.com/archesai/archesai/internal/adapters/http/server"
	commands "github.com/archesai/archesai/internal/application/commands/{{ lower .Tag }}"
	queries "github.com/archesai/archesai/internal/application/queries/{{ lower .Tag }}"
	"github.com/archesai/archesai/internal/core/entities"
	"github.com/archesai/archesai/internal/core/valueobjects"
)

// {{ .Tag }}Controller handles HTTP requests for {{ lower .Tag }} endpoints.
type {{ .Tag }}Controller struct {
    {{- range .Operations }}
        {{- if ne .Method "GET" }}
    {{ camelCase .ID }}Handler *commands.{{ pascalCase .ID }}CommandHandler
        {{- end }}
    {{- end }}

    {{- range .Operations }}
        {{- if eq .Method "GET" }}
    {{ camelCase .ID }}Handler *queries.{{ pascalCase .ID }}QueryHandler
        {{- end }}
    {{- end }}
}


// New{{ .Tag }}Controller creates a new {{ lower .Tag }} controller with injected handlers.
func New{{ .Tag }}Controller(
    {{- range .Operations }}
        {{- if ne .Method "GET" }}
    {{ camelCase .ID }}Handler *commands.{{ pascalCase .ID }}CommandHandler,
        {{- end }}
    {{- end }}
    {{- range .Operations }}
        {{- if eq .Method "GET" }}
    {{ camelCase .ID }}Handler *queries.{{ pascalCase .ID }}QueryHandler,
        {{- end }}
    {{- end }}
) *{{ .Tag }}Controller {
    return &{{ .Tag }}Controller{
        {{- range .Operations }}
            {{- if ne .Method "GET" }}
        {{ camelCase .ID }}Handler: {{ camelCase .ID }}Handler,
            {{- end }}
        {{- end }}
        {{- range .Operations }}
            {{- if eq .Method "GET" }}
        {{ camelCase .ID }}Handler: {{ camelCase .ID }}Handler,
            {{- end }}
        {{- end }}
    }
}

// Register{{ .Tag }}Routes registers all HTTP routes for the {{ lower .Tag }} domain.
func Register{{ .Tag }}Routes(router server.EchoRouter, controller *{{ .Tag }}Controller) {

{{- range .Operations }}
{{- $operation := . }}
	router.{{ $operation.Method }}("{{ $operation.Path | echoPath }}", controller.{{ $operation.ID }})
{{- end }}
}

{{- range .Operations }}
{{- $operation := . }}
// ============================================================================
// {{ $operation.ID }} - {{ $operation.Method }} {{ $operation.Path }}
// ============================================================================

// Request types

{{- if $operation.GetQueryParams }}
// {{ $operation.ID }}Params defines parameters for {{ $operation.ID }}
type {{ $operation.ID }}Params struct {
{{- range $operation.GetQueryParams }}
{{- $param := . }}
	{{ $param.Name }} {{ $param.GoType }} `json:"{{ camelCase $param.Name }},omitempty"`
{{- end }}
}
{{- end }}

{{- if $operation.RequestBody }}
// {{ $operation.ID }}RequestBody defines the request body for {{ $operation.ID }}
type {{ $operation.ID }}RequestBody struct {
{{- range $operation.RequestBody.GetSortedProperties }}
{{- $field := . }}
	{{- $isOptional := stringContains .JSONTag ",omitempty" }}
	{{ $field.Name }} {{ if and $isOptional (not (hasPrefix .GoType "*")) (not (hasPrefix .GoType "[]")) (not (hasPrefix .GoType "map")) }}*{{ end }}{{ $field.GoType }} `json:"{{ $field.JSONTag }}"`
{{- end }}
}
{{- end }}

type {{ $operation.ID }}Request struct {
	{{- range $operation.GetPathParams }}
	{{- $param := . }}
	{{ $param.Name }} {{ $param.GoType }} `json:"{{ camelCase $param.Name }}"`
	{{- end }}
	{{- range $operation.GetHeaderParams }}
	{{- $param := . }}
	{{ $param.Name }} {{ $param.GoType }} `json:"{{ camelCase $param.Name }}"`
	{{- end }}
	{{- if $operation.GetQueryParams }}
	Params {{ $operation.ID }}Params
	{{- end }}
	{{- if $operation.RequestBody }}
	Body *{{ $operation.ID }}RequestBody
	{{- end }}
}

// Response types

type {{ $operation.ID }}Response interface {
    Visit{{ $operation.ID }}Response(w http.ResponseWriter) error
}
{{- range $operation.Responses }}
{{- $response := . }}

{{- /* Generate nested type definitions for inline object properties */ -}}
{{- if and $response.IsSuccess $response.Properties }}
{{- range $response.GetSortedProperties }}
{{- $field := . }}
{{- if and (eq $field.Type "object") (gt (len $field.Properties) 0) }}

// {{ $operation.ID }}{{ $response.StatusCode }}Response{{ $field.Name }} defines the {{ lower $field.Name }} structure
type {{ $operation.ID }}{{ $response.StatusCode }}Response{{ $field.Name }} struct {
{{- range $field.GetSortedProperties }}
{{- $nestedField := . }}
    {{ $nestedField.Name }} {{ $nestedField.GoType }} `json:"{{ camelCase $nestedField.JSONTag }}"`
{{- end }}
}

{{- /* Check if any nested field is an array with object items that need types generated */ -}}
{{- range $field.GetSortedProperties }}
{{- $nestedField := . }}
{{- if and (eq $nestedField.Type "array") $nestedField.Items }}
{{- if and (eq $nestedField.Items.Type "object") (gt (len $nestedField.Items.Properties) 0) }}
// {{ pascalCase $nestedField.Name }}Item defines an item in the {{ lower $nestedField.Name }} array
type {{ pascalCase $nestedField.Name }}Item struct {
{{- range $nestedField.Items.GetSortedProperties }}
{{- $itemField := . }}
    {{ $itemField.Name }} {{ $itemField.GoType }} `json:"{{ camelCase $itemField.JSONTag }}"`
{{- end }}
}

{{- end }}
{{- end }}
{{- end }}
{{- end }}
{{- end }}
{{- end }}

type {{ $operation.ID }}{{ $response.StatusCode }}Response struct {
{{- if $response.IsSuccess }}
    {{- if eq $response.StatusCode "204" }}
    {{- else if $response.Properties }}
        {{- range $response.GetSortedProperties }}
            {{- $field := . }}
    {{ $field.Name }} {{ $field.GoType }} `json:"{{ camelCase $field.JSONTag }}"`
        {{- end }}
    {{- end }}
{{- else }}
    {{- if eq $response.StatusCode "400" }}
    server.BadRequestResponse
    {{- else if eq $response.StatusCode "401" }}
    server.UnauthorizedResponse
    {{- else if eq $response.StatusCode "403" }}
    server.ForbiddenResponse
    {{- else if eq $response.StatusCode "404" }}
    server.NotFoundResponse
    {{- else if eq $response.StatusCode "409" }}
    server.ConflictResponse
    {{- else if eq $response.StatusCode "500" }}
    server.InternalServerErrorResponse
    {{- else }}
    server.ProblemDetails
    {{- end }}
{{- end }}
}

func (response {{ $operation.ID }}{{ $response.StatusCode }}Response) Visit{{ $operation.ID }}Response(w http.ResponseWriter) error {
{{- if eq $response.StatusCode "204" }}
    w.WriteHeader(204)
	
    return nil
{{- else if not $response.IsSuccess }}
    {{- /* For error responses, set problem+json content type */ -}}
    w.Header().Set("Content-Type", "application/problem+json")
    w.WriteHeader({{ $response.StatusCode }})
    {{- if eq $response.StatusCode "400" }}

    return json.NewEncoder(w).Encode(response.BadRequestResponse)
    {{- else if eq $response.StatusCode "401" }}

    return json.NewEncoder(w).Encode(response.UnauthorizedResponse)
    {{- else if eq $response.StatusCode "403" }}

    return json.NewEncoder(w).Encode(response.ForbiddenResponse)
    {{- else if eq $response.StatusCode "404" }}

    return json.NewEncoder(w).Encode(response.NotFoundResponse)
    {{- else if eq $response.StatusCode "409" }}

    return json.NewEncoder(w).Encode(response.ConflictResponse)
    {{- else if eq $response.StatusCode "500" }}

    return json.NewEncoder(w).Encode(response.InternalServerErrorResponse)
    {{- else }}
	
    return json.NewEncoder(w).Encode(response)
    {{- end }}
{{- else }}
    w.Header().Set("Content-Type", "application/json")
    w.WriteHeader({{ $response.StatusCode }})

    return json.NewEncoder(w).Encode(response)
{{- end }}
}
{{- end }}

// Handler method

// {{ $operation.ID }} handles the {{ $operation.Method }} {{ $operation.Path }} endpoint.
func (c *{{ $.Tag }}Controller) {{ $operation.ID }}(ctx echo.Context) error {
	reqCtx := ctx.Request().Context()
	{{- if or $operation.GetPathParams $operation.GetHeaderParams $operation.GetQueryParams $operation.RequestBody }}
	request := {{ $operation.ID }}Request{}
	{{- end }}
	{{- if or $operation.HasBearerAuth $operation.HasCookieAuth }}

	// Extract session ID from context for authenticated operations
	var sessionID uuid.UUID
	if sid := ctx.Get("sessionID"); sid != nil {
		sessionID = sid.(uuid.UUID)
	} else {
		return echo.NewHTTPError(http.StatusUnauthorized, "session required")
	}
	{{- end }}

	{{- range $operation.GetPathParams }}
	{{- $param := . }}

	// Path parameter "{{ camelCase $param.Name }}"
	var {{ camelCase $param.Name }} {{ $param.GoType }}
	if err := runtime.BindStyledParameterWithOptions("simple", "{{ camelCase $param.Name }}", ctx.Param("{{ camelCase $param.Name }}"), &{{ camelCase $param.Name }}, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true}); err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter {{ camelCase $param.Name }}: %s", err))
	}
	request.{{ $param.Name }} = {{ camelCase $param.Name }}
	{{- end }}

	{{- range $operation.GetHeaderParams }}
	{{- $param := . }}

	// Header parameter "{{ $param.Name }}"
	{{ camelCase $param.Name }} := ctx.Request().Header.Get("{{ $param.Name }}")
	{{- if $param.Required }}
	if {{ camelCase $param.Name }} == "" {
		return echo.NewHTTPError(http.StatusBadRequest, "Missing required header: {{ $param.Name }}")
	}
	{{- end }}
	request.{{ $param.Name }} = {{ camelCase $param.Name }}
	{{- end }}

	{{- if $operation.GetQueryParams }}

	// Query parameters
	var params {{ $operation.ID }}Params
	{{- range $operation.GetQueryParams }}
	{{- $param := . }}
	// {{ if $param.Required }}Required{{ else }}Optional{{ end }} query parameter "{{ $param.Name }}"
	{{- if eq $param.Name "Filter" }}
	if err := runtime.BindQueryParameter("deepObject", true, {{ if $param.Required }}true{{ else }}false{{ end }}, "filter", ctx.QueryParams(), &params.{{ $param.Name }}); err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter filter: %s", err))
	}
	{{- else }}
	if err := runtime.BindQueryParameter("form", true, {{ if $param.Required }}true{{ else }}false{{ end }}, "{{ lower $param.Name }}", ctx.QueryParams(), &params.{{ $param.Name }}); err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter {{ lower $param.Name }}: %s", err))
	}
	{{- end }}
	{{- end }}
	request.Params = params
	{{- end }}

	{{- if $operation.RequestBody }}

	// Request body
	request.Body = &{{ $operation.ID }}RequestBody{}
	if err := ctx.Bind(request.Body); err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, err.Error())
	}
	{{- end }}

	{{- if $operation.HasBearerAuth }}

	// Set auth scopes
	ctx.Set(server.BearerAuthScopes, []string{})
	{{- end }}
	{{- if $operation.HasCookieAuth }}
	ctx.Set(server.SessionCookieScopes, []string{})
	{{- end }}

	// Determine which handler to call based on operation
	{{- if ne $operation.Method "GET" }}
	// Command handler

	// Map request to command parameters
	cmd := commands.New{{ pascalCase $operation.ID }}Command(
		{{- if or $operation.HasBearerAuth $operation.HasCookieAuth }}
		sessionID, // SessionID for authenticated operations
		{{- end }}
		{{- range $operation.GetPathParams }}
		request.{{ .Name }}, // {{ .Name }}
		{{- end }}
		{{- range $operation.GetHeaderParams }}
		request.{{ .Name }}, // {{ .Name }}
		{{- end }}
		{{- if $operation.RequestBody }}
		{{- range $i, $field := $operation.RequestBody.GetSortedProperties }}
		request.Body.{{ $field.Name }}, // {{ $field.Name }}
		{{- end }}
		{{- end }}
	)

	{{- if eq $operation.Method "DELETE" }}
	if err := c.{{ camelCase $operation.ID }}Handler.Handle(reqCtx, cmd); err != nil {
		return err
	}
	return ctx.NoContent(http.StatusNoContent)
	{{- else }}
	result, err := c.{{ camelCase $operation.ID }}Handler.Handle(reqCtx, cmd)
	if err != nil {
		return err
	}
	{{- if eq $operation.Method "POST" }}
	return ctx.JSON(http.StatusCreated, map[string]interface{}{
		"data": result,
	})
	{{- else }}
	return ctx.JSON(http.StatusOK, map[string]interface{}{
		"data": result,
	})
	{{- end }}
	{{- end }}
	{{- else }}
	// Query handler
	query := queries.New{{ $operation.ID }}Query(
		{{- if or $operation.HasBearerAuth $operation.HasCookieAuth }}
		sessionID, // SessionID for authenticated operations
		{{- end }}
		{{- range .GetPathParams }}
		{{- $param := . }}
		request.{{ $param.Name }}, // {{ $param.Name }}
		{{- end }}
	)
	{{- if hasPrefix $operation.ID "List" }}
	// TODO: Apply filters, pagination, sorting from request.Params

	results, total, err := c.{{ camelCase $operation.ID }}Handler.Handle(reqCtx, query)
	if err != nil {
		return err
	}

	return ctx.JSON(http.StatusOK, map[string]interface{}{
		"data": results,
		"meta": map[string]interface{}{
			"total": total,
		},
	})
	{{- else }}

	result, err := c.{{ camelCase $operation.ID }}Handler.Handle(reqCtx, query)
	if err != nil {
		return err
	}

	return ctx.JSON(http.StatusOK, map[string]interface{}{
		"data": result,
	})
	{{- end }}
	{{- end }}
}
{{- end }}