{{- /*
Template: controller.tmpl
Expects: codegen.HandlerTemplateInput
Generates: Echo framework HTTP controllers with direct handler injection

Expected structure:
- Package: string (package name)
- Domain: string (domain name)
- DomainLower: string (lowercase domain name)
- DomainPlural: string (plural domain name)
- DomainPluralLower: string (lowercase plural domain name)
- Operations: []OperationData
  - Name: string (operation ID)
  - GoName: string (PascalCase operation name)
  - Method: string (GET, POST, etc.)
  - Path: string (URL path)
  - Description: string
  - HasRequestBody: bool
  - HasBearerAuth: bool
  - HasCookieAuth: bool
  - RequestBodySchema: string (type name)
  - ResponseType: string (response type name)
  - PathParams: []ParamData
  - QueryParams: []ParamData
    - Name: string
    - Type: string (Go type)
    - Required: bool
*/ -}}
// Code generated by archesai codegen. DO NOT EDIT.
package {{ .Package }}

import (
	"context"
	"encoding/json"
	"fmt"
	"net/http"

	"github.com/google/uuid"
	"github.com/labstack/echo/v4"
	"github.com/oapi-codegen/runtime"

	"github.com/archesai/archesai/internal/adapters/http/server"
	commands "github.com/archesai/archesai/internal/application/commands/{{ .DomainLower }}"
	queries "github.com/archesai/archesai/internal/application/queries/{{ .DomainLower }}"
	"github.com/archesai/archesai/internal/core/entities"
	"github.com/archesai/archesai/internal/core/valueobjects"
)

// {{ .Domain }}Controller handles HTTP requests for {{ .Domain | lower }} endpoints.
type {{ .Domain }}Controller struct {
{{- if .HasCreate }}
	// Command handlers
	createHandler *commands.Create{{ .DomainSingular }}CommandHandler
{{- end }}
{{- if .HasUpdate }}
	updateHandler *commands.Update{{ .DomainSingular }}CommandHandler
{{- end }}
{{- if .HasDelete }}
	deleteHandler *commands.Delete{{ .DomainSingular }}CommandHandler
{{- end }}
{{- if .HasGet }}
	// Query handlers
	getHandler    *queries.Get{{ .DomainSingular }}QueryHandler
{{- end }}
{{- if .HasList }}
	listHandler   *queries.List{{ .Domain }}QueryHandler
{{- end }}
}

// New{{ .Domain }}Controller creates a new {{ .Domain | lower }} controller with injected handlers.
func New{{ .Domain }}Controller(
{{- if .HasCreate }}
	createHandler *commands.Create{{ .DomainSingular }}CommandHandler,
{{- end }}
{{- if .HasUpdate }}
	updateHandler *commands.Update{{ .DomainSingular }}CommandHandler,
{{- end }}
{{- if .HasDelete }}
	deleteHandler *commands.Delete{{ .DomainSingular }}CommandHandler,
{{- end }}
{{- if .HasGet }}
	getHandler *queries.Get{{ .DomainSingular }}QueryHandler,
{{- end }}
{{- if .HasList }}
	listHandler *queries.List{{ .Domain }}QueryHandler,
{{- end }}
) *{{ .Domain }}Controller {
	return &{{ .Domain }}Controller{
{{- if .HasCreate }}
		createHandler: createHandler,
{{- end }}
{{- if .HasUpdate }}
		updateHandler: updateHandler,
{{- end }}
{{- if .HasDelete }}
		deleteHandler: deleteHandler,
{{- end }}
{{- if .HasGet }}
		getHandler:    getHandler,
{{- end }}
{{- if .HasList }}
		listHandler:   listHandler,
{{- end }}
	}
}

// Register{{ .Domain }}Routes registers all HTTP routes for the {{ .Domain | lower }} domain.
func Register{{ .Domain }}Routes(router server.EchoRouter, controller *{{ .Domain }}Controller) {

{{- range .Operations }}
	router.{{ .Method | upper }}("{{ .Path | echoPath }}", controller.{{ .GoName }})
{{- end }}
}

{{- range .Operations }}

// ============================================================================
// {{ .GoName }} - {{ .Method }} {{ .Path }}
// ============================================================================

// Request types

{{- if .QueryParams }}
// {{ .OperationID | title }}Params defines parameters for {{ .GoName }}
type {{ .OperationID | title }}Params struct {
{{- range .QueryParams }}
	{{ .Name | title }} {{ if not .Required }}*{{ end }}{{ .Type }} `json:"{{ .Name }},omitempty"`
{{- end }}
}
{{- end }}

{{- if .HasRequestBody }}
{{- if .RequestBodySchema }}
// {{ .GoName }}RequestBody defines the request body for {{ .GoName }}
type {{ .GoName }}RequestBody struct {
{{- range .RequestBodySchema.Fields }}
	{{ .FieldName }} {{ .GoType }} `json:"{{ .JSONTag }}"`
{{- end }}
}
{{- end }}
{{- end }}

type {{ .GoName }}Request struct {
	{{- if .PathParams }}
	{{- range .PathParams }}
	{{ .Name | title }} {{ .Type }} `json:"{{ .Name }}"`
	{{- end }}
	{{- end }}
	{{- if .QueryParams }}
	Params {{ .OperationID | title }}Params
	{{- end }}
	{{- if .HasRequestBody }}
	{{- if .RequestBodySchema }}
	Body *{{ .GoName }}RequestBody
	{{- end }}
	{{- end }}
}

// Response types

type {{ .GoName }}Response interface {
	Visit{{ .GoName }}Response(w http.ResponseWriter) error
}

{{- /* Generate success response based on actual response data */ -}}
{{- if .SuccessResponse }}
{{- $statusCode := .SuccessResponse.StatusCode }}
{{- if eq $statusCode "200" }}

type {{ .GoName }}200JSONResponse struct {
	{{- if .SuccessResponse.Schema }}
	{{- if .SuccessResponse.IsArray }}
	Data []entities.{{ .SuccessResponse.Schema }} `json:"data"`
	Meta struct {
		Total int64 `json:"total"`
	} `json:"meta"`
	{{- else }}
	Data {{ .SuccessResponse.Schema }} `json:"data"`
	{{- end }}
	{{- else if .ResponseType }}
	Data {{ .ResponseType }} `json:"data"`
	{{- else }}
	Data []entities.{{ $.Domain | title | singularize }} `json:"data"`
	Meta struct {
		Total int64 `json:"total"`
	} `json:"meta"`
	{{- end }}
}

func (response {{ .GoName }}200JSONResponse) Visit{{ .GoName }}Response(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json")
	w.WriteHeader(200)

	return json.NewEncoder(w).Encode(response)
}
{{- else if eq $statusCode "201" }}

type {{ .GoName }}201JSONResponse struct {
	{{- if .SuccessResponse.Schema }}
	Data {{ .SuccessResponse.Schema }} `json:"data"`
	{{- else if .ResponseType }}
	Data {{ .ResponseType }} `json:"data"`
	{{- else }}
	Data entities.{{ $.Domain | title | singularize }} `json:"data"`
	{{- end }}
}

func (response {{ .GoName }}201JSONResponse) Visit{{ .GoName }}Response(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json")
	w.WriteHeader(201)

	return json.NewEncoder(w).Encode(response)
}
{{- else if eq $statusCode "204" }}

type {{ .GoName }}204Response struct {}

func (response {{ .GoName }}204Response) Visit{{ .GoName }}Response(w http.ResponseWriter) error {
	w.WriteHeader(204)
	return nil
}
{{- end }}
{{- else }}
{{- /* Fallback for operations without success response - use method-based defaults */ -}}
{{- if eq .Method "GET" }}

type {{ .GoName }}200JSONResponse struct {
	{{- if .ResponseType }}
	{{- if .ResponsePackage }}
	Data {{ .ResponsePackage }}.{{ .ResponseType }} `json:"data"`
	{{- else }}
	Data {{ .ResponseType }} `json:"data"`
	{{- end }}
	{{- end }}
}

func (response {{ .GoName }}200JSONResponse) Visit{{ .GoName }}Response(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json")
	w.WriteHeader(200)

	return json.NewEncoder(w).Encode(response)
}
{{- else if eq .Method "POST" }}

type {{ .GoName }}201JSONResponse struct {
	{{- if .ResponseType }}
	{{- if .ResponsePackage }}
	Data {{ .ResponsePackage }}.{{ .ResponseType }} `json:"data"`
	{{- else }}
	Data {{ .ResponseType }} `json:"data"`
	{{- end }}
	{{- end }}
}

func (response {{ .GoName }}201JSONResponse) Visit{{ .GoName }}Response(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json")
	w.WriteHeader(201)

	return json.NewEncoder(w).Encode(response)
}
{{- else }}

type {{ .GoName }}200JSONResponse struct {
	{{- if .ResponseType }}
	{{- if .ResponsePackage }}
	Data {{ .ResponsePackage }}.{{ .ResponseType }} `json:"data"`
	{{- else }}
	Data {{ .ResponseType }} `json:"data"`
	{{- end }}
	{{- end }}
}

func (response {{ .GoName }}200JSONResponse) Visit{{ .GoName }}Response(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json")
	w.WriteHeader(200)

	return json.NewEncoder(w).Encode(response)
}
{{- end }}
{{- end }}

{{- /* Generate error responses */ -}}
{{- $opName := .GoName }}
{{- range .Responses }}
{{- if and (ne .StatusCode "200") (ne .StatusCode "201") (ne .StatusCode "204") }}
{{- $responseType := "" }}
{{- if eq .StatusCode "400" }}{{ $responseType = "BadRequestResponse" }}
{{- else if eq .StatusCode "401" }}{{ $responseType = "UnauthorizedResponse" }}
{{- else if eq .StatusCode "403" }}{{ $responseType = "ForbiddenResponse" }}
{{- else if eq .StatusCode "404" }}{{ $responseType = "NotFoundResponse" }}
{{- else if eq .StatusCode "409" }}{{ $responseType = "ConflictResponse" }}
{{- else if eq .StatusCode "500" }}{{ $responseType = "InternalServerErrorResponse" }}
{{- else if eq .StatusCode "503" }}{{ $responseType = "ServiceUnavailableResponse" }}
{{- else }}{{ $responseType = "BadRequestResponse" }}
{{- end }}

type {{ $opName }}{{ .StatusCode }}Response struct {
	server.{{ $responseType }}
}

func (response {{ $opName }}{{ .StatusCode }}Response) Visit{{ $opName }}Response(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/problem+json")
	w.WriteHeader({{ .StatusCode }})

	return json.NewEncoder(w).Encode(response.{{ $responseType }})
}
{{- end }}
{{- end }}

// Handler method

// {{ .GoName }} handles the {{ .Method }} {{ .Path }} endpoint.
func (c *{{ $.Domain }}Controller) {{ .GoName }}(ctx echo.Context) error {
	reqCtx := ctx.Request().Context()
	{{- if or .PathParams .QueryParams .HasRequestBody }}
	request := {{ .GoName }}Request{}
	{{- end }}

	{{- if .PathParams }}
	{{- range .PathParams }}

	// Path parameter "{{ .Name }}"
	var {{ .Name }} {{ .Type }}
	if err := runtime.BindStyledParameterWithOptions("simple", "{{ .Name }}", ctx.Param("{{ .Name }}"), &{{ .Name }}, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true}); err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter {{ .Name }}: %s", err))
	}
	request.{{ .Name | title }} = {{ .Name }}
	{{- end }}
	{{- end }}

	{{- if .QueryParams }}

	// Query parameters
	var params {{ .OperationID | title }}Params
	{{- range .QueryParams }}
	// {{ if .Required }}Required{{ else }}Optional{{ end }} query parameter "{{ .Name }}"
	{{- if eq .Name "filter" }}
	if err := runtime.BindQueryParameter("deepObject", true, {{ .Required }}, "{{ .Name }}", ctx.QueryParams(), &params.{{ .Name | title }}); err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter {{ .Name }}: %s", err))
	}
	{{- else }}
	if err := runtime.BindQueryParameter("form", true, {{ .Required }}, "{{ .Name }}", ctx.QueryParams(), &params.{{ .Name | title }}); err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter {{ .Name }}: %s", err))
	}
	{{- end }}
	{{- end }}
	request.Params = params
	{{- end }}

	{{- if .HasRequestBody }}

	// Request body
	var body {{ .GoName }}RequestBody
	if err := ctx.Bind(&body); err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, err.Error())
	}
	request.Body = &body
	{{- end }}

	{{- if .HasBearerAuth }}

	// Set auth scopes
	ctx.Set(middleware.BearerAuthScopes, []string{})
	{{- end }}
	{{- if .HasCookieAuth }}
	ctx.Set(middleware.SessionCookieScopes, []string{})
	{{- end }}

	// Determine which handler to call based on operation
	{{- if hasPrefix .GoName "Create" }}
	// Create handler
	{{- if .HasRequestBody }}
	{{- if .RequestBodySchema }}
	// Available request body fields: {{ range $i, $field := .RequestBodySchema.Fields }}{{ if $i }}, {{ end }}{{ $field.Name }}{{ end }}
	{{- end }}
	{{- end }}

	// TODO: Get organization ID from auth context
	orgID := uuid.New()

	// Create command - adjust field mapping based on your API
	cmd := commands.NewCreate{{ $.DomainSingular }}Command(
		orgID,
		"", // TODO: Map appropriate field from request.Body
		"", // TODO: Map appropriate field from request.Body
		nil, // TODO: Map metadata if available
	)

	result, err := c.createHandler.Handle(reqCtx, cmd)
	if err != nil {
		return err
	}

	return ctx.JSON(http.StatusCreated, map[string]interface{}{
		"data": result,
	})
	{{- else if hasPrefix .GoName "Update" }}
	// Update handler
	{{- if .HasRequestBody }}
	{{- if .RequestBodySchema }}
	// Available request body fields: {{ range $i, $field := .RequestBodySchema.Fields }}{{ if $i }}, {{ end }}{{ $field.Name }}{{ end }}
	{{- end }}
	{{- end }}

	// Create update command - adjust field mapping based on your API
	cmd := commands.NewUpdate{{ $.DomainSingular }}Command(
		request.ID, // Assumes all update operations have an ID path parameter
		nil, // TODO: Map appropriate field from request.Body
		nil, // TODO: Map appropriate field from request.Body
		nil, // TODO: Map metadata if available
	)

	result, err := c.updateHandler.Handle(reqCtx, cmd)
	if err != nil {
		return err
	}

	return ctx.JSON(http.StatusOK, map[string]interface{}{
		"data": result,
	})
	{{- else if hasPrefix .GoName "Delete" }}
	// Create delete command from request
	cmd := commands.NewDelete{{ $.DomainSingular }}Command(
		request.ID,
	)

	err := c.deleteHandler.Handle(reqCtx, cmd)
	if err != nil {
		return err
	}

	return ctx.NoContent(http.StatusNoContent)
	{{- else if hasPrefix .GoName "List" }}
	// Create list query from request
	query := queries.NewList{{ $.Domain }}Query()
	// TODO: Apply filters, pagination, sorting from request.Params

	results, total, err := c.listHandler.Handle(reqCtx, query)
	if err != nil {
		return err
	}

	return ctx.JSON(http.StatusOK, map[string]interface{}{
		"data": results,
		"meta": map[string]interface{}{
			"total": total,
		},
	})
	{{- else if hasPrefix .GoName "Get" }}
	// Create get query from request
	{{- if .PathParams }}
	query := queries.NewGet{{ $.DomainSingular }}Query(
		request.ID,
	)
	{{- else }}
	query := queries.NewGet{{ $.DomainSingular }}Query()
	{{- end }}

	result, err := c.getHandler.Handle(reqCtx, query)
	if err != nil {
		return err
	}

	return ctx.JSON(http.StatusOK, map[string]interface{}{
		"data": result,
	})
	{{- else }}
	// TODO: Handle custom operation {{ .GoName }}
	_ = reqCtx // Custom operation not yet implemented
	return echo.NewHTTPError(http.StatusNotImplemented, "Operation not implemented")
	{{- end }}
}
{{- end }}