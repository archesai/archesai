{{- /*
Template: controller.tmpl
Expects: codegen.HandlerTemplateInput
Generates: Echo framework HTTP controllers with direct handler injection

Expected structure:
- Package: string (package name)
- Domain: string (domain name)
- DomainLower: string (lowercase domain name)
- DomainPlural: string (plural domain name)
- DomainPluralLower: string (lowercase plural domain name)
- Operations: []OperationData
  - Name: string (operation ID)
  - GoName: string (PascalCase operation name)
  - Method: string (GET, POST, etc.)
  - Path: string (URL path)
  - Description: string
  - HasRequestBody: bool
  - HasBearerAuth: bool
  - HasCookieAuth: bool
  - RequestBodySchema: string (type name)
  - ResponseType: string (response type name)
  - PathParams: []ParamData
  - QueryParams: []ParamData
    - Name: string
    - Type: string (Go type)
    - Required: bool
*/ -}}
// Code generated by archesai codegen. DO NOT EDIT.
package {{ .Package }}

import (
	"context"
	"encoding/json"
	"fmt"
	"net/http"

	"github.com/google/uuid"
	"github.com/labstack/echo/v4"
	"github.com/oapi-codegen/runtime"

	"github.com/archesai/archesai/internal/adapters/http/server"
	commands "github.com/archesai/archesai/internal/application/commands/{{ .DomainLower }}"
	queries "github.com/archesai/archesai/internal/application/queries/{{ .DomainLower }}"
	"github.com/archesai/archesai/internal/core/entities"
	"github.com/archesai/archesai/internal/core/valueobjects"
)

// {{ .Domain }}Controller handles HTTP requests for {{ .Domain | lower }} endpoints.
type {{ .Domain }}Controller struct {
{{- if .Commands }}
	// Command handlers
{{- range .Commands }}
	{{ camelCase . }}Handler *commands.{{ pascalCase . }}CommandHandler
{{- end }}
{{- end }}
{{- if .Queries }}
	// Query handlers
{{- range .Queries }}
	{{ camelCase . }}Handler *queries.{{ pascalCase . }}QueryHandler
{{- end }}
{{- end }}
}

// New{{ .Domain }}Controller creates a new {{ .Domain | lower }} controller with injected handlers.
func New{{ .Domain }}Controller(
{{- range .Commands }}
	{{ camelCase . }}Handler *commands.{{ pascalCase . }}CommandHandler,
{{- end }}
{{- range .Queries }}
	{{ camelCase . }}Handler *queries.{{ pascalCase . }}QueryHandler,
{{- end }}
) *{{ .Domain }}Controller {
	return &{{ .Domain }}Controller{
{{- range .Commands }}
		{{ camelCase . }}Handler: {{ camelCase . }}Handler,
{{- end }}
{{- range .Queries }}
		{{ camelCase . }}Handler: {{ camelCase . }}Handler,
{{- end }}
	}
}

// Register{{ .Domain }}Routes registers all HTTP routes for the {{ .Domain | lower }} domain.
func Register{{ .Domain }}Routes(router server.EchoRouter, controller *{{ .Domain }}Controller) {

{{- range .Operations }}
	router.{{ .Method | upper }}("{{ .Path | echoPath }}", controller.{{ .GoName }})
{{- end }}
}

{{- range .Operations }}

// ============================================================================
// {{ .GoName }} - {{ .Method }} {{ .Path }}
// ============================================================================

// Request types

{{- if .QueryParams }}
// {{ .OperationID | title }}Params defines parameters for {{ .GoName }}
type {{ .OperationID | title }}Params struct {
{{- range .QueryParams }}
	{{ .Name | title }} {{ if not .Required }}*{{ end }}{{ .Type }} `json:"{{ .Name }},omitempty"`
{{- end }}
}
{{- end }}

{{- if .HasRequestBody }}
{{- if .RequestBodySchema }}
// {{ .GoName }}RequestBody defines the request body for {{ .GoName }}
type {{ .GoName }}RequestBody struct {
{{- range .RequestBodySchema.Fields }}
	{{ .FieldName }} {{ .GoType }} `json:"{{ .JSONTag }}"`
{{- end }}
}
{{- end }}
{{- end }}

type {{ .GoName }}Request struct {
	{{- if .PathParams }}
	{{- range .PathParams }}
	{{ .Name | title }} {{ .Type }} `json:"{{ .Name }}"`
	{{- end }}
	{{- end }}
	{{- if .QueryParams }}
	Params {{ .OperationID | title }}Params
	{{- end }}
	{{- if .HasRequestBody }}
	{{- if .RequestBodySchema }}
	Body *{{ .GoName }}RequestBody
	{{- end }}
	{{- end }}
}

// Response types

type {{ .GoName }}Response interface {
	Visit{{ .GoName }}Response(w http.ResponseWriter) error
}

{{- /* Generate success response based on actual response data */ -}}
{{- if .SuccessResponse }}
{{- $statusCode := .SuccessResponse.StatusCode }}
{{- if eq $statusCode "200" }}

type {{ .GoName }}200JSONResponse struct {
	{{- if .SuccessResponse.Schema }}
	{{- if .SuccessResponse.IsArray }}
	Data []entities.{{ .SuccessResponse.Schema }} `json:"data"`
	Meta struct {
		Total int64 `json:"total"`
	} `json:"meta"`
	{{- else }}
	Data {{ .SuccessResponse.Schema }} `json:"data"`
	{{- end }}
	{{- else if .ResponseType }}
	Data {{ .ResponseType }} `json:"data"`
	{{- else }}
	Data []entities.{{ $.Domain | title | singularize }} `json:"data"`
	Meta struct {
		Total int64 `json:"total"`
	} `json:"meta"`
	{{- end }}
}

func (response {{ .GoName }}200JSONResponse) Visit{{ .GoName }}Response(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json")
	w.WriteHeader(200)

	return json.NewEncoder(w).Encode(response)
}
{{- else if eq $statusCode "201" }}

type {{ .GoName }}201JSONResponse struct {
	{{- if .SuccessResponse.Schema }}
	Data {{ .SuccessResponse.Schema }} `json:"data"`
	{{- else if .ResponseType }}
	Data {{ .ResponseType }} `json:"data"`
	{{- else }}
	Data entities.{{ $.Domain | title | singularize }} `json:"data"`
	{{- end }}
}

func (response {{ .GoName }}201JSONResponse) Visit{{ .GoName }}Response(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json")
	w.WriteHeader(201)

	return json.NewEncoder(w).Encode(response)
}
{{- else if eq $statusCode "204" }}

type {{ .GoName }}204Response struct {}

func (response {{ .GoName }}204Response) Visit{{ .GoName }}Response(w http.ResponseWriter) error {
	w.WriteHeader(204)
	return nil
}
{{- end }}
{{- else }}
{{- /* Fallback for operations without success response - use method-based defaults */ -}}
{{- if eq .Method "GET" }}

type {{ .GoName }}200JSONResponse struct {
	{{- if .ResponseType }}
	{{- if .ResponsePackage }}
	Data {{ .ResponsePackage }}.{{ .ResponseType }} `json:"data"`
	{{- else }}
	Data {{ .ResponseType }} `json:"data"`
	{{- end }}
	{{- end }}
}

func (response {{ .GoName }}200JSONResponse) Visit{{ .GoName }}Response(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json")
	w.WriteHeader(200)

	return json.NewEncoder(w).Encode(response)
}
{{- else if eq .Method "POST" }}

type {{ .GoName }}201JSONResponse struct {
	{{- if .ResponseType }}
	{{- if .ResponsePackage }}
	Data {{ .ResponsePackage }}.{{ .ResponseType }} `json:"data"`
	{{- else }}
	Data {{ .ResponseType }} `json:"data"`
	{{- end }}
	{{- end }}
}

func (response {{ .GoName }}201JSONResponse) Visit{{ .GoName }}Response(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json")
	w.WriteHeader(201)

	return json.NewEncoder(w).Encode(response)
}
{{- else }}

type {{ .GoName }}200JSONResponse struct {
	{{- if .ResponseType }}
	{{- if .ResponsePackage }}
	Data {{ .ResponsePackage }}.{{ .ResponseType }} `json:"data"`
	{{- else }}
	Data {{ .ResponseType }} `json:"data"`
	{{- end }}
	{{- end }}
}

func (response {{ .GoName }}200JSONResponse) Visit{{ .GoName }}Response(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json")
	w.WriteHeader(200)

	return json.NewEncoder(w).Encode(response)
}
{{- end }}
{{- end }}

{{- /* Generate error responses */ -}}
{{- $opName := .GoName }}
{{- range .Responses }}
{{- if and (ne .StatusCode "200") (ne .StatusCode "201") (ne .StatusCode "204") }}
{{- $responseType := "" }}
{{- if eq .StatusCode "400" }}{{ $responseType = "BadRequestResponse" }}
{{- else if eq .StatusCode "401" }}{{ $responseType = "UnauthorizedResponse" }}
{{- else if eq .StatusCode "403" }}{{ $responseType = "ForbiddenResponse" }}
{{- else if eq .StatusCode "404" }}{{ $responseType = "NotFoundResponse" }}
{{- else if eq .StatusCode "409" }}{{ $responseType = "ConflictResponse" }}
{{- else if eq .StatusCode "500" }}{{ $responseType = "InternalServerErrorResponse" }}
{{- else if eq .StatusCode "503" }}{{ $responseType = "ServiceUnavailableResponse" }}
{{- else }}{{ $responseType = "BadRequestResponse" }}
{{- end }}

type {{ $opName }}{{ .StatusCode }}Response struct {
	server.{{ $responseType }}
}

func (response {{ $opName }}{{ .StatusCode }}Response) Visit{{ $opName }}Response(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/problem+json")
	w.WriteHeader({{ .StatusCode }})

	return json.NewEncoder(w).Encode(response.{{ $responseType }})
}
{{- end }}
{{- end }}

// Handler method

// {{ .GoName }} handles the {{ .Method }} {{ .Path }} endpoint.
func (c *{{ $.Domain }}Controller) {{ .GoName }}(ctx echo.Context) error {
	reqCtx := ctx.Request().Context()
	{{- if or .PathParams .QueryParams .HasRequestBody }}
	request := {{ .GoName }}Request{}
	{{- end }}
	{{- if .RequiresAuth }}

	// Extract session ID from context for authenticated operations
	var sessionID uuid.UUID
	if sid := ctx.Get("sessionID"); sid != nil {
		sessionID = sid.(uuid.UUID)
	} else {
		return echo.NewHTTPError(http.StatusUnauthorized, "session required")
	}
	{{- end }}

	{{- if .PathParams }}
	{{- range .PathParams }}

	// Path parameter "{{ .Name }}"
	var {{ .Name }} {{ .Type }}
	if err := runtime.BindStyledParameterWithOptions("simple", "{{ .Name }}", ctx.Param("{{ .Name }}"), &{{ .Name }}, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true}); err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter {{ .Name }}: %s", err))
	}
	request.{{ .Name | title }} = {{ .Name }}
	{{- end }}
	{{- end }}

	{{- if .QueryParams }}

	// Query parameters
	var params {{ .OperationID | title }}Params
	{{- range .QueryParams }}
	// {{ if .Required }}Required{{ else }}Optional{{ end }} query parameter "{{ .Name }}"
	{{- if eq .Name "filter" }}
	if err := runtime.BindQueryParameter("deepObject", true, {{ .Required }}, "{{ .Name }}", ctx.QueryParams(), &params.{{ .Name | title }}); err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter {{ .Name }}: %s", err))
	}
	{{- else }}
	if err := runtime.BindQueryParameter("form", true, {{ .Required }}, "{{ .Name }}", ctx.QueryParams(), &params.{{ .Name | title }}); err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter {{ .Name }}: %s", err))
	}
	{{- end }}
	{{- end }}
	request.Params = params
	{{- end }}

	{{- if .HasRequestBody }}

	// Request body
	request.Body = &{{ .GoName }}RequestBody{}
	if err := ctx.Bind(request.Body); err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, err.Error())
	}
	{{- end }}

	{{- if .HasBearerAuth }}

	// Set auth scopes
	ctx.Set(server.BearerAuthScopes, []string{})
	{{- end }}
	{{- if .HasCookieAuth }}
	ctx.Set(server.SessionCookieScopes, []string{})
	{{- end }}

	// Determine which handler to call based on operation
	{{- if ne .Method "GET" }}
	// Command handler

	// Map request to command parameters
	cmd := commands.New{{ pascalCase .GoName }}Command(
		{{- if .RequiresAuth }}
		sessionID, // SessionID for authenticated operations
		{{- end }}
		{{- range .PathParams }}
		request.{{ pascalCase .Name }}, // {{ .Name }}
		{{- end }}
		{{- if .HasRequestBody }}
		{{- if .RequestBodySchema }}
		{{- range $i, $field := .RequestBodySchema.Fields }}
		request.Body.{{ $field.FieldName }}, // {{ $field.Name }}
		{{- end }}
		{{- end }}
		{{- end }}
	)

	{{- if and (eq .Method "DELETE") (not .ResponseType) }}
	err := c.{{ camelCase .GoName }}Handler.Handle(reqCtx, cmd)
	if err != nil {
		return err
	}
	return ctx.NoContent(http.StatusNoContent)
	{{- else }}
	result, err := c.{{ camelCase .GoName }}Handler.Handle(reqCtx, cmd)
	if err != nil {
		return err
	}
	{{- if eq .Method "POST" }}
	return ctx.JSON(http.StatusCreated, map[string]interface{}{
		"data": result,
	})
	{{- else if eq .Method "DELETE" }}
	return ctx.JSON(http.StatusOK, map[string]interface{}{
		"data": result,
	})
	{{- else }}
	return ctx.JSON(http.StatusOK, map[string]interface{}{
		"data": result,
	})
	{{- end }}
	{{- end }}
	{{- else }}
	// Query handler
	query := queries.New{{ pascalCase .GoName }}Query(
		{{- if .RequiresAuth }}
		sessionID, // SessionID for authenticated operations
		{{- end }}
		{{- range .PathParams }}
		request.{{ pascalCase .Name }}, // {{ .Name }}
		{{- end }}
	)
	{{- if hasPrefix .GoName "List" }}
	// TODO: Apply filters, pagination, sorting from request.Params

	results, total, err := c.{{ camelCase .GoName }}Handler.Handle(reqCtx, query)
	if err != nil {
		return err
	}

	return ctx.JSON(http.StatusOK, map[string]interface{}{
		"data": results,
		"meta": map[string]interface{}{
			"total": total,
		},
	})
	{{- else }}

	result, err := c.{{ camelCase .GoName }}Handler.Handle(reqCtx, query)
	if err != nil {
		return err
	}

	return ctx.JSON(http.StatusOK, map[string]interface{}{
		"data": result,
	})
	{{- end }}
	{{- end }}
}
{{- end }}