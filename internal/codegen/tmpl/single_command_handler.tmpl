{{- /*
Template: single_command_handler.tmpl
Generates: A single command handler implementation
Expected data:
- Package: string (package name, e.g., "labels")
- CommandType: string (e.g., "Create", "Update", "Delete")
- EntityName: string (e.g., "Label")
- EntityNameLower: string (e.g., "label")
*/ -}}
// Code generated by archesai/codegen. DO NOT EDIT.

package {{ .Package }}

import (
	"context"
	"fmt"
	"time"

	"github.com/google/uuid"

	"github.com/archesai/archesai/internal/core/entities"
	"github.com/archesai/archesai/internal/core/events"
	"github.com/archesai/archesai/internal/core/repositories"
)

// {{ .CommandType }}{{ .EntityName }}Command represents the command to {{ lower .CommandType }} a {{ .EntityNameLower }}.
type {{ .CommandType }}{{ .EntityName }}Command struct {
{{- if eq .CommandType "Delete" }}
	ID uuid.UUID
{{- else if eq .CommandType "Update" }}
	ID uuid.UUID
	{{- if .RequestBody }}
	{{- range .RequestBody.Fields }}
	{{ .FieldName }} {{ .GoType }}
	{{- end }}
	{{- else }}
	Name        *string
	Description *string
	Metadata    map[string]interface{}
	{{- end }}
{{- else if eq .CommandType "Create" }}
	{{- if .RequestBody }}
	{{- range .RequestBody.Fields }}
	{{ .FieldName }} {{ .GoType }}
	{{- end }}
	{{- else }}
	OrganizationID uuid.UUID
	Name           string
	Description    string
	Metadata       map[string]interface{}
	{{- end }}
{{- end }}
}

// New{{ .CommandType }}{{ .EntityName }}Command creates a new {{ lower .CommandType }} {{ .EntityNameLower }} command.
func New{{ .CommandType }}{{ .EntityName }}Command(
{{- if eq .CommandType "Delete" }}
	id uuid.UUID,
{{- else if eq .CommandType "Update" }}
	id uuid.UUID,
	{{- if .RequestBody }}
	{{- range .RequestBody.Fields }}
	{{ .Name }} {{ .GoType }},
	{{- end }}
	{{- else }}
	name *string,
	description *string,
	metadata map[string]interface{},
	{{- end }}
{{- else if eq .CommandType "Create" }}
	{{- if .RequestBody }}
	{{- range .RequestBody.Fields }}
	{{ .Name }} {{ .GoType }},
	{{- end }}
	{{- else }}
	organizationID uuid.UUID,
	name string,
	description string,
	metadata map[string]interface{},
	{{- end }}
{{- end }}
) *{{ .CommandType }}{{ .EntityName }}Command {
	return &{{ .CommandType }}{{ .EntityName }}Command{
{{- if eq .CommandType "Delete" }}
		ID: id,
{{- else if eq .CommandType "Update" }}
		ID: id,
		{{- if .RequestBody }}
		{{- range .RequestBody.Fields }}
		{{ .FieldName }}: {{ .Name }},
		{{- end }}
		{{- else }}
		Name:        name,
		Description: description,
		Metadata:    metadata,
		{{- end }}
{{- else if eq .CommandType "Create" }}
		{{- if .RequestBody }}
		{{- range .RequestBody.Fields }}
		{{ .FieldName }}: {{ .Name }},
		{{- end }}
		{{- else }}
		OrganizationID: organizationID,
		Name:           name,
		Description:    description,
		Metadata:       metadata,
		{{- end }}
{{- end }}
	}
}

{{- if eq .CommandType "Create" }}

// {{ .CommandType }}{{ .EntityName }}CommandHandler handles the create {{ .EntityNameLower }} command.
type {{ .CommandType }}{{ .EntityName }}CommandHandler struct {
	repo      repositories.{{ .EntityName }}Repository
	publisher events.Publisher
}

// New{{ .CommandType }}{{ .EntityName }}CommandHandler creates a new create {{ .EntityNameLower }} command handler.
func New{{ .CommandType }}{{ .EntityName }}CommandHandler(
	repo repositories.{{ .EntityName }}Repository,
	publisher events.Publisher,
) *{{ .CommandType }}{{ .EntityName }}CommandHandler {
	return &{{ .CommandType }}{{ .EntityName }}CommandHandler{
		repo:      repo,
		publisher: publisher,
	}
}

// Handle executes the create {{ .EntityNameLower }} command.
func (h *{{ .CommandType }}{{ .EntityName }}CommandHandler) Handle(ctx context.Context, cmd *{{ .CommandType }}{{ .EntityName }}Command) (*entities.{{ .EntityName }}, error) {
	// Create the {{ .EntityNameLower }} entity
	entity := &entities.{{ .EntityName }}{
		ID:        uuid.New(),
		CreatedAt: time.Now().UTC(),
		UpdatedAt: time.Now().UTC(),
		// TODO: Map command fields to entity
	}

	// Save to repository
	created, err := h.repo.Create(ctx, entity)
	if err != nil {
		return nil, fmt.Errorf("failed to create {{ .EntityNameLower }}: %w", err)
	}

	// Publish domain event
	event := events.New{{ .EntityName }}CreatedEvent(created.ID)
	if err := h.publisher.Publish(ctx, event); err != nil {
		// Log error but don't fail the operation
	}

	return created, nil
}
{{- else if eq .CommandType "Update" }}

// {{ .CommandType }}{{ .EntityName }}CommandHandler handles the update {{ .EntityNameLower }} command.
type {{ .CommandType }}{{ .EntityName }}CommandHandler struct {
	repo      repositories.{{ .EntityName }}Repository
	publisher events.Publisher
}

// New{{ .CommandType }}{{ .EntityName }}CommandHandler creates a new update {{ .EntityNameLower }} command handler.
func New{{ .CommandType }}{{ .EntityName }}CommandHandler(
	repo repositories.{{ .EntityName }}Repository,
	publisher events.Publisher,
) *{{ .CommandType }}{{ .EntityName }}CommandHandler {
	return &{{ .CommandType }}{{ .EntityName }}CommandHandler{
		repo:      repo,
		publisher: publisher,
	}
}

// Handle executes the update {{ .EntityNameLower }} command.
func (h *{{ .CommandType }}{{ .EntityName }}CommandHandler) Handle(ctx context.Context, cmd *{{ .CommandType }}{{ .EntityName }}Command) (*entities.{{ .EntityName }}, error) {
	// Fetch existing {{ .EntityNameLower }}
	existing, err := h.repo.Get(ctx, cmd.ID)
	if err != nil {
		return nil, fmt.Errorf("failed to get {{ .EntityNameLower }}: %w", err)
	}

	// Update fields
	// TODO: Map command fields to entity
	existing.UpdatedAt = time.Now().UTC()

	// Save to repository
	updated, err := h.repo.Update(ctx, cmd.ID, existing)
	if err != nil {
		return nil, fmt.Errorf("failed to update {{ .EntityNameLower }}: %w", err)
	}

	// Publish domain event
	event := events.New{{ .EntityName }}UpdatedEvent(updated.ID)
	if err := h.publisher.Publish(ctx, event); err != nil {
		// Log error but don't fail the operation
	}

	return updated, nil
}
{{- else if eq .CommandType "Delete" }}

// {{ .CommandType }}{{ .EntityName }}CommandHandler handles the delete {{ .EntityNameLower }} command.
type {{ .CommandType }}{{ .EntityName }}CommandHandler struct {
	repo      repositories.{{ .EntityName }}Repository
	publisher events.Publisher
}

// New{{ .CommandType }}{{ .EntityName }}CommandHandler creates a new delete {{ .EntityNameLower }} command handler.
func New{{ .CommandType }}{{ .EntityName }}CommandHandler(
	repo repositories.{{ .EntityName }}Repository,
	publisher events.Publisher,
) *{{ .CommandType }}{{ .EntityName }}CommandHandler {
	return &{{ .CommandType }}{{ .EntityName }}CommandHandler{
		repo:      repo,
		publisher: publisher,
	}
}

// Handle executes the delete {{ .EntityNameLower }} command.
func (h *{{ .CommandType }}{{ .EntityName }}CommandHandler) Handle(ctx context.Context, cmd *{{ .CommandType }}{{ .EntityName }}Command) error {
	// Delete from repository
	if err := h.repo.Delete(ctx, cmd.ID); err != nil {
		return fmt.Errorf("failed to delete {{ .EntityNameLower }}: %w", err)
	}

	// Publish domain event
	event := events.New{{ .EntityName }}DeletedEvent(cmd.ID)
	if err := h.publisher.Publish(ctx, event); err != nil {
		// Log error but don't fail the operation
	}

	return nil
}
{{- end }}