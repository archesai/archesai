{{- /*
Template: single_command_handler.tmpl
Generates: A single command handler implementation
Expected data:
- Package: string (package name, e.g., "labels")
- CommandType: string (e.g., "Create", "Update", "Delete")
- EntityName: string (e.g., "Label")
- EntityNameLower: string (e.g., "label")
*/ -}}
// Code generated by archesai/codegen. DO NOT EDIT.

package {{ .Package }}

import (
	"context"
	"time"

	"github.com/archesai/archesai/internal/core/entities"
	"github.com/archesai/archesai/internal/core/errors"
	"github.com/archesai/archesai/internal/core/events"
	"github.com/archesai/archesai/internal/core/valueobjects"
	"github.com/archesai/archesai/internal/infrastructure/events"
)

// {{ .CommandType }}{{ .EntityName }}Command represents the command to {{ lower .CommandType }} a {{ .EntityNameLower }}.
type {{ .CommandType }}{{ .EntityName }}Command struct {
{{- if eq .CommandType "Delete" }}
	ID valueobjects.{{ .EntityName }}ID
{{- else if eq .CommandType "Update" }}
	ID          valueobjects.{{ .EntityName }}ID
	Name        *string
	Description *string
	Metadata    map[string]interface{}
{{- else if eq .CommandType "Create" }}
	OrganizationID valueobjects.OrganizationID
	Name           string
	Description    string
	Metadata       map[string]interface{}
{{- end }}
}

// New{{ .CommandType }}{{ .EntityName }}Command creates a new {{ lower .CommandType }} {{ .EntityNameLower }} command.
func New{{ .CommandType }}{{ .EntityName }}Command(
{{- if eq .CommandType "Delete" }}
	id valueobjects.{{ .EntityName }}ID,
{{- else if eq .CommandType "Update" }}
	id valueobjects.{{ .EntityName }}ID,
	name *string,
	description *string,
	metadata map[string]interface{},
{{- else if eq .CommandType "Create" }}
	organizationID valueobjects.OrganizationID,
	name string,
	description string,
	metadata map[string]interface{},
{{- end }}
) *{{ .CommandType }}{{ .EntityName }}Command {
	return &{{ .CommandType }}{{ .EntityName }}Command{
{{- if eq .CommandType "Delete" }}
		ID: id,
{{- else if eq .CommandType "Update" }}
		ID:          id,
		Name:        name,
		Description: description,
		Metadata:    metadata,
{{- else if eq .CommandType "Create" }}
		OrganizationID: organizationID,
		Name:           name,
		Description:    description,
		Metadata:       metadata,
{{- end }}
	}
}

{{- if eq .CommandType "Create" }}

// {{ .CommandType }}{{ .EntityName }}CommandHandler handles the create {{ .EntityNameLower }} command.
type {{ .CommandType }}{{ .EntityName }}CommandHandler struct {
	repo      repositories.{{ .EntityName }}Repository
	publisher events.Publisher
}

// New{{ .CommandType }}{{ .EntityName }}CommandHandler creates a new create {{ .EntityNameLower }} command handler.
func New{{ .CommandType }}{{ .EntityName }}CommandHandler(
	repo repositories.{{ .EntityName }}Repository,
	publisher events.Publisher,
) *{{ .CommandType }}{{ .EntityName }}CommandHandler {
	return &{{ .CommandType }}{{ .EntityName }}CommandHandler{
		repo:      repo,
		publisher: publisher,
	}
}

// Handle executes the create {{ .EntityNameLower }} command.
func (h *{{ .CommandType }}{{ .EntityName }}CommandHandler) Handle(ctx context.Context, cmd *{{ .CommandType }}{{ .EntityName }}Command) (*entities.{{ .EntityName }}, error) {
	// Create the {{ .EntityNameLower }} entity
	entity := &entities.{{ .EntityName }}{
		ID:        valueobjects.New{{ .EntityName }}ID(),
		CreatedAt: time.Now().UTC(),
		UpdatedAt: time.Now().UTC(),
		// TODO: Map command fields to entity
	}

	// Save to repository
	created, err := h.repo.Create(ctx, entity)
	if err != nil {
		return nil, errors.Wrap(err, "failed to create {{ .EntityNameLower }}")
	}

	// Publish domain event
	event := events.New{{ .EntityName }}CreatedEvent(
		created.ID,
		created.CreatedAt,
	)
	if err := h.publisher.Publish(ctx, event); err != nil {
		// Log error but don't fail the operation
	}

	return created, nil
}
{{- else if eq .CommandType "Update" }}
// Update{{ .EntityName }}Command represents a command to update an {{ .EntityNameLower }}.
type Update{{ .EntityName }}Command struct {
	ID          valueobjects.{{ .EntityName }}ID
	Name        *string
	Description *string
	Metadata    map[string]interface{}
}

// NewUpdate{{ .EntityName }}Command creates a new update {{ .EntityNameLower }} command.
func NewUpdate{{ .EntityName }}Command(
	id valueobjects.{{ .EntityName }}ID,
	name *string,
	description *string,
	metadata map[string]interface{},
) *Update{{ .EntityName }}Command {
	return &Update{{ .EntityName }}Command{
		ID:          id,
		Name:        name,
		Description: description,
		Metadata:    metadata,
	}
}

// {{ .CommandType }}{{ .EntityName }}CommandHandler handles the update {{ .EntityNameLower }} command.
type {{ .CommandType }}{{ .EntityName }}CommandHandler struct {
	repo      repositories.{{ .EntityName }}Repository
	publisher events.Publisher
}

// New{{ .CommandType }}{{ .EntityName }}CommandHandler creates a new update {{ .EntityNameLower }} command handler.
func New{{ .CommandType }}{{ .EntityName }}CommandHandler(
	repo repositories.{{ .EntityName }}Repository,
	publisher events.Publisher,
) *{{ .CommandType }}{{ .EntityName }}CommandHandler {
	return &{{ .CommandType }}{{ .EntityName }}CommandHandler{
		repo:      repo,
		publisher: publisher,
	}
}

// Handle executes the update {{ .EntityNameLower }} command.
func (h *{{ .CommandType }}{{ .EntityName }}CommandHandler) Handle(ctx context.Context, cmd *{{ .CommandType }}{{ .EntityName }}Command) (*entities.{{ .EntityName }}, error) {
	// Fetch existing {{ .EntityNameLower }}
	existing, err := h.repo.Get(ctx, cmd.ID)
	if err != nil {
		return nil, errors.Wrap(err, "failed to get {{ .EntityNameLower }}")
	}

	// Update fields
	// TODO: Map command fields to entity
	existing.UpdatedAt = time.Now().UTC()

	// Save to repository
	updated, err := h.repo.Update(ctx, cmd.ID, existing)
	if err != nil {
		return nil, errors.Wrap(err, "failed to update {{ .EntityNameLower }}")
	}

	// Publish domain event
	event := events.New{{ .EntityName }}UpdatedEvent(
		updated.ID,
		updated.UpdatedAt,
	)
	if err := h.publisher.Publish(ctx, event); err != nil {
		// Log error but don't fail the operation
	}

	return updated, nil
}
{{- else if eq .CommandType "Delete" }}
// Delete{{ .EntityName }}Command represents a command to delete an {{ .EntityNameLower }}.
type Delete{{ .EntityName }}Command struct {
	ID valueobjects.{{ .EntityName }}ID
}

// NewDelete{{ .EntityName }}Command creates a new delete {{ .EntityNameLower }} command.
func NewDelete{{ .EntityName }}Command(id valueobjects.{{ .EntityName }}ID) *Delete{{ .EntityName }}Command {
	return &Delete{{ .EntityName }}Command{
		ID: id,
	}
}

// {{ .CommandType }}{{ .EntityName }}CommandHandler handles the delete {{ .EntityNameLower }} command.
type {{ .CommandType }}{{ .EntityName }}CommandHandler struct {
	repo      repositories.{{ .EntityName }}Repository
	publisher events.Publisher
}

// New{{ .CommandType }}{{ .EntityName }}CommandHandler creates a new delete {{ .EntityNameLower }} command handler.
func New{{ .CommandType }}{{ .EntityName }}CommandHandler(
	repo repositories.{{ .EntityName }}Repository,
	publisher events.Publisher,
) *{{ .CommandType }}{{ .EntityName }}CommandHandler {
	return &{{ .CommandType }}{{ .EntityName }}CommandHandler{
		repo:      repo,
		publisher: publisher,
	}
}

// Handle executes the delete {{ .EntityNameLower }} command.
func (h *{{ .CommandType }}{{ .EntityName }}CommandHandler) Handle(ctx context.Context, cmd *{{ .CommandType }}{{ .EntityName }}Command) error {
	// Delete from repository
	if err := h.repo.Delete(ctx, cmd.ID); err != nil {
		return errors.Wrap(err, "failed to delete {{ .EntityNameLower }}")
	}

	// Publish domain event
	event := events.New{{ .EntityName }}DeletedEvent(
		cmd.ID,
		time.Now().UTC(),
	)
	if err := h.publisher.Publish(ctx, event); err != nil {
		// Log error but don't fail the operation
	}

	return nil
}
{{- end }}