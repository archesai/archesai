{{- /*
Template: single_command_handler.tmpl
Generates: A single command handler implementation
Expected data:
- Package: string (package name, e.g., "labels")
- CommandType: string (e.g., "Create", "Update", "Delete")
- EntityName: string (e.g., "Label")
- EntityNameLower: string (e.g., "label")
*/ -}}
// Code generated by archesai/codegen. DO NOT EDIT.

package {{ .Package }}

import (
	"context"
	"fmt"
	"time"

	"github.com/google/uuid"

	"github.com/archesai/archesai/internal/core/entities"
	"github.com/archesai/archesai/internal/core/events"
	"github.com/archesai/archesai/internal/core/repositories"
)

// {{ .CommandType }}{{ .CommandEntityName }}Command represents the command to {{ lower .CommandType }} a {{ .EntityNameLower }}.
type {{ .CommandType }}{{ .CommandEntityName }}Command struct {
{{- if .RequiresAuth }}
	SessionID uuid.UUID
{{- end }}
{{- if .PathParams }}
{{- range .PathParams }}
	{{ pascalCase .Name }} {{ .Type }}
{{- end }}
{{- end }}
{{- if .RequestBody }}
{{- range .RequestBody.Fields }}
	{{ .FieldName }} {{ .GoType }}
{{- end }}
{{- end }}
}

// New{{ .CommandType }}{{ .CommandEntityName }}Command creates a new {{ lower .CommandType }} {{ .EntityNameLower }} command.
func New{{ .CommandType }}{{ .CommandEntityName }}Command(
{{- if .RequiresAuth }}
	SessionID uuid.UUID,
{{- end }}
{{- range .PathParams }}
	{{ .Name }} {{ .Type }},
{{- end }}
{{- if .RequestBody }}
{{- range .RequestBody.Fields }}
	{{ .Name }} {{ .GoType }},
{{- end }}
{{- end }}
) *{{ .CommandType }}{{ .CommandEntityName }}Command {
	return &{{ .CommandType }}{{ .CommandEntityName }}Command{
{{- if .RequiresAuth }}
		SessionID: SessionID,
{{- end }}
{{- range .PathParams }}
		{{ pascalCase .Name }}: {{ .Name }},
{{- end }}
{{- if .RequestBody }}
{{- range .RequestBody.Fields }}
		{{ .FieldName }}: {{ .Name }},
{{- end }}
{{- end }}
	}
}
{{- if not .CustomHandler }}

{{- if eq .CommandType "Create" }}

// {{ .CommandType }}{{ .EntityName }}CommandHandler handles the create {{ .EntityNameLower }} command.
type {{ .CommandType }}{{ .EntityName }}CommandHandler struct {
	repo      repositories.{{ .EntityName }}Repository
	publisher events.Publisher
}

// New{{ .CommandType }}{{ .EntityName }}CommandHandler creates a new create {{ .EntityNameLower }} command handler.
func New{{ .CommandType }}{{ .EntityName }}CommandHandler(
	repo repositories.{{ .EntityName }}Repository,
	publisher events.Publisher,
) *{{ .CommandType }}{{ .EntityName }}CommandHandler {
	return &{{ .CommandType }}{{ .EntityName }}CommandHandler{
		repo:      repo,
		publisher: publisher,
	}
}

// Handle executes the create {{ .EntityNameLower }} command.
func (h *{{ .CommandType }}{{ .EntityName }}CommandHandler) Handle(ctx context.Context, cmd *{{ .CommandType }}{{ .EntityName }}Command) (*entities.{{ .EntityName }}, error) {
	// Create the {{ .EntityNameLower }} entity
	entity := &entities.{{ .EntityName }}{
		ID:        uuid.New(),
		CreatedAt: time.Now().UTC(),
		UpdatedAt: time.Now().UTC(),
		// TODO: Map command fields to entity
	}

	// Save to repository
	created, err := h.repo.Create(ctx, entity)
	if err != nil {
		return nil, fmt.Errorf("failed to create {{ .EntityNameLower }}: %w", err)
	}

	// Publish domain event
	event := events.New{{ .EntityName }}CreatedEvent(created.ID)
	if err := h.publisher.Publish(ctx, event); err != nil {
		// Log error but don't fail the operation
	}

	return created, nil
}
{{- else if eq .CommandType "Update" }}

// {{ .CommandType }}{{ .EntityName }}CommandHandler handles the update {{ .EntityNameLower }} command.
type {{ .CommandType }}{{ .EntityName }}CommandHandler struct {
	repo      repositories.{{ .EntityName }}Repository
	publisher events.Publisher
}

// New{{ .CommandType }}{{ .EntityName }}CommandHandler creates a new update {{ .EntityNameLower }} command handler.
func New{{ .CommandType }}{{ .EntityName }}CommandHandler(
	repo repositories.{{ .EntityName }}Repository,
	publisher events.Publisher,
) *{{ .CommandType }}{{ .EntityName }}CommandHandler {
	return &{{ .CommandType }}{{ .EntityName }}CommandHandler{
		repo:      repo,
		publisher: publisher,
	}
}

// Handle executes the update {{ .EntityNameLower }} command.
func (h *{{ .CommandType }}{{ .EntityName }}CommandHandler) Handle(ctx context.Context, cmd *{{ .CommandType }}{{ .EntityName }}Command) (*entities.{{ .EntityName }}, error) {
	// Fetch existing {{ .EntityNameLower }}
	existing, err := h.repo.Get(ctx, cmd.ID)
	if err != nil {
		return nil, fmt.Errorf("failed to get {{ .EntityNameLower }}: %w", err)
	}

	// Update fields
	// TODO: Map command fields to entity
	existing.UpdatedAt = time.Now().UTC()

	// Save to repository
	updated, err := h.repo.Update(ctx, cmd.ID, existing)
	if err != nil {
		return nil, fmt.Errorf("failed to update {{ .EntityNameLower }}: %w", err)
	}

	// Publish domain event
	event := events.New{{ .EntityName }}UpdatedEvent(updated.ID)
	if err := h.publisher.Publish(ctx, event); err != nil {
		// Log error but don't fail the operation
	}

	return updated, nil
}
{{- else if eq .CommandType "Delete" }}

// {{ .CommandType }}{{ .EntityName }}CommandHandler handles the delete {{ .EntityNameLower }} command.
type {{ .CommandType }}{{ .EntityName }}CommandHandler struct {
	repo      repositories.{{ .EntityName }}Repository
	publisher events.Publisher
}

// New{{ .CommandType }}{{ .EntityName }}CommandHandler creates a new delete {{ .EntityNameLower }} command handler.
func New{{ .CommandType }}{{ .EntityName }}CommandHandler(
	repo repositories.{{ .EntityName }}Repository,
	publisher events.Publisher,
) *{{ .CommandType }}{{ .EntityName }}CommandHandler {
	return &{{ .CommandType }}{{ .EntityName }}CommandHandler{
		repo:      repo,
		publisher: publisher,
	}
}

// Handle executes the delete {{ .EntityNameLower }} command.
func (h *{{ .CommandType }}{{ .EntityName }}CommandHandler) Handle(ctx context.Context, cmd *{{ .CommandType }}{{ .EntityName }}Command) error {
	// Delete from repository
	if err := h.repo.Delete(ctx, cmd.ID); err != nil {
		return fmt.Errorf("failed to delete {{ .EntityNameLower }}: %w", err)
	}

	// Publish domain event
	event := events.New{{ .EntityName }}DeletedEvent(cmd.ID)
	if err := h.publisher.Publish(ctx, event); err != nil {
		// Log error but don't fail the operation
	}

	return nil
}
{{- end }}
{{- end }}