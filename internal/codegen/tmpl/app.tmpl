{{- /*
Template: app.tmpl
Generates: Main application wiring and dependency injection
Expects:
- Domains: []DomainData
  - Name: string (e.g., "Account")
  - NamePlural: string (e.g., "Accounts")
  - NameLower: string (e.g., "account")
  - NamePluralLower: string (e.g., "accounts")
  - HasController: bool
  - HasRepository: bool
  - HasCommands: bool
  - HasQueries: bool
  - Commands: []string (e.g., ["Create", "Update", "Delete"])
  - Queries: []string (e.g., ["Get", "List"])
*/ -}}
// Code generated by archesai codegen. DO NOT EDIT.
package app

import (
	"context"
	"fmt"
	"log/slog"
	"net/http"
	"time"

	"golang.org/x/sync/errgroup"
	"github.com/labstack/echo/v4"

	"github.com/archesai/archesai/internal/adapters/http/controllers"
	"github.com/archesai/archesai/internal/adapters/http/server"
{{- range .Domains }}
{{- if .HasCommands }}
	{{ .NameLower }}Commands "github.com/archesai/archesai/internal/application/commands/{{ .NamePluralLower }}"
{{- end }}
{{- if .HasQueries }}
	{{ .NameLower }}Queries "github.com/archesai/archesai/internal/application/queries/{{ .NamePluralLower }}"
{{- end }}
{{- end }}
	configQueries "github.com/archesai/archesai/internal/application/queries/config"
	healthQueries "github.com/archesai/archesai/internal/application/queries/health"
	"github.com/archesai/archesai/internal/infrastructure/config"
	database "github.com/archesai/archesai/internal/infrastructure/persistence"
)

// App holds all application dependencies.
type App struct {
	// Core infrastructure
	infra *Infrastructure

	// Public infrastructure access
	Logger *slog.Logger
	Config *config.Config
	Server *server.Server

	// HTTP Controllers
{{- range .Domains }}
{{- if .HasController }}
	{{ .NamePlural }}Handler *controllers.{{ .NamePlural }}Controller
{{- end }}
{{- end }}
}

// NewApp creates and initializes all application dependencies.
func NewApp(cfg *config.Config) (*App, error) {
	// Initialize infrastructure
	infra, err := NewInfrastructure(cfg)
	if err != nil {
		return nil, fmt.Errorf("failed to initialize infrastructure: %w", err)
	}

	log := infra.Logger

	// Run migrations if enabled
	if cfg.Database.RunMigrations {
		log.Info("running database migrations")
		if err := database.RunMigrations(infra.Database.SQLDB(), infra.Database.TypeString(), log); err != nil {
			log.Error("failed to run migrations", "error", err)
			isProduction := cfg.API.Environment == "production"
			if isProduction {
				return nil, fmt.Errorf("failed to run migrations: %w", err)
			}
		}
		log.Info("database migrations completed")
	}

	// Create repositories
	log.Info("creating repositories")
	repos, err := NewRepositories(infra)
	if err != nil {
		return nil, fmt.Errorf("failed to create repositories: %w", err)
	}

	// Create app instance to populate
	app := &App{
		// Infrastructure
		infra:  infra,
		Logger: log,
		Config: cfg,
	}

	// Initialize all domain handlers in parallel where possible
	g, _ := errgroup.WithContext(context.Background())

	// Initialize config domain (infrastructure query - needs special handling)
	log.Info("initializing config domain")
	getConfigHandler := configQueries.NewGetConfigQueryHandler(cfg)
	app.ConfigHandler = controllers.NewConfigController(getConfigHandler)
	log.Info("config domain ready")

	// Initialize health domain (infrastructure query - needs special handling)
	log.Info("initializing health domain")
	getHealthHandler := healthQueries.NewGetHealthQueryHandler()
	app.HealthHandler = controllers.NewHealthController(getHealthHandler)
	log.Info("health domain ready")

{{- range .Domains }}
{{- if and .HasController (ne .Name "Config") (ne .Name "Health") }}

	// Initialize {{ .NamePluralLower }} domain
	g.Go(func() error {
		log.Info("initializing {{ .NamePluralLower }} domain")

		{{- if or .HasCommands .HasQueries }}
		// Create command and query handlers
		{{- end }}
		{{- $domain := . }}
		{{- range .Commands }}
		{{ . | lower }}{{ $domain.Name }}Handler := {{ $domain.NameLower }}Commands.New{{ . }}{{ $domain.Name }}CommandHandler(
			repos.{{ $domain.NamePlural }},
			infra.EventPublisher,
		)
		{{- end }}
		{{- range .Queries }}
		{{- if eq . "List" }}
		{{ . | lower }}{{ $domain.Name }}Handler := {{ $domain.NameLower }}Queries.New{{ . }}{{ $domain.NamePlural }}QueryHandler(
		{{- else }}
		{{ . | lower }}{{ $domain.Name }}Handler := {{ $domain.NameLower }}Queries.New{{ . }}{{ $domain.Name }}QueryHandler(
		{{- end }}
			repos.{{ $domain.NamePlural }},
		)
		{{- end }}

		// Create controller with handlers
		app.{{ .NamePlural }}Handler = controllers.New{{ .NamePlural }}Controller(
			{{- range .Commands }}
			{{ . | lower }}{{ $domain.Name }}Handler,
			{{- end }}
			{{- range .Queries }}
			{{ . | lower }}{{ $domain.Name }}Handler,
			{{- end }}
		)

		log.Info("{{ .NamePluralLower }} domain ready")
		return nil
	})
{{- end }}
{{- end }}

	// Wait for all parallel initializations to complete
	if err := g.Wait(); err != nil {
		return nil, fmt.Errorf("failed to initialize domains: %w", err)
	}

	// Create the HTTP server
	log.Info("creating HTTP server")
	app.Server = server.NewServer(cfg.API, log)

	// Register all application routes
	app.registerRoutes()

	log.Info("application initialized successfully")
	return app, nil
}

// Close cleans up all resources.
func (a *App) Close() error {
	a.Logger.Info("shutting down application")
	if a.infra != nil {
		return a.infra.Close()
	}
	return nil
}

// registerRoutes registers all application routes with the server.
func (a *App) registerRoutes() {
	// Get the echo instance from the server
	e := a.Server.Echo()

	// Register readiness check that can access the database
	a.Server.SetReadinessCheck(a.readinessCheck)

	// Setup API documentation if enabled
	if a.Config.API.Docs {
		a.Logger.Info("enabling API documentation")
		if err := a.Server.SetupDocs(); err != nil {
			a.Logger.Error("failed to setup API docs", "error", err)
		}
	}

	// Register all application routes
	a.RegisterRoutes(e)
	a.Logger.Info("routes registered")
}

// readinessCheck checks if the service is ready to handle requests.
func (a *App) readinessCheck(ctx echo.Context) error {
	// Check database connection
	if err := a.infra.Database.SQLDB().PingContext(ctx.Request().Context()); err != nil {
		a.Logger.Error("database health check failed", "error", err)
		return ctx.JSON(http.StatusServiceUnavailable, map[string]interface{}{
			"status": "unhealthy",
			"error":  "database connection failed",
		})
	}

	return ctx.JSON(http.StatusOK, map[string]interface{}{
		"status":    "ready",
		"timestamp": time.Now().Unix(),
	})
}

// RegisterRoutes registers all application routes with the Echo server.
func (a *App) RegisterRoutes(e *echo.Echo) {
	a.Logger.Info("registering API routes...")

	// API v1 group
	v1 := e.Group("/api/v1")

	// ========================================
	// API ROUTES
	// ========================================
{{- range .Domains }}
{{- if .HasController }}
	// {{ .NamePlural }} routes
	a.Logger.Info("registering {{ .NamePluralLower }} routes")
	controllers.Register{{ .NamePlural }}Routes(v1, a.{{ .NamePlural }}Handler)
{{- end }}
{{- end }}

	a.Logger.Info("all routes registered successfully")
}