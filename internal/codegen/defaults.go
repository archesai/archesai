package codegen

import (
	"bytes"
	"fmt"
	"go/format"
	"sort"
	"strings"
)

const developmentKey = "development"

// GenerateDefaultsCode generates Go code for configuration defaults.
func GenerateDefaultsCode(defaults map[string]interface{}) string {
	var buf bytes.Buffer

	// Header
	buf.WriteString(`// Code generated by codegen; DO NOT EDIT.
// This file contains default configuration values extracted from OpenAPI schemas.

package config

// GetDefaultConfig returns a complete default configuration with all values from OpenAPI schemas.
func GetDefaultConfig() *ArchesConfig {
	return &ArchesConfig{
`)

	// Generate each top-level config
	generateStruct(&buf, defaults, 2)

	buf.WriteString("\t}\n}\n")

	// Format the code
	code := buf.String()
	formatted, err := format.Source([]byte(code))
	if err != nil {
		// Return unformatted code if formatting fails
		return code
	}
	return string(formatted)
}

func generateStruct(buf *bytes.Buffer, data map[string]interface{}, indent int) {
	// Sort keys for consistent output
	keys := make([]string, 0, len(data))
	for k := range data {
		keys = append(keys, k)
	}
	sort.Strings(keys)

	for _, key := range keys {
		value := data[key]

		// Skip fields that don't exist in generated types
		if key == "oauth" {
			continue
		}

		// Skip development if it only has enabled field (incorrect parsing)
		if key == developmentKey {
			if m, ok := value.(map[string]interface{}); ok {
				if len(m) == 1 {
					if _, hasEnabled := m["enabled"]; hasEnabled {
						continue // Skip incorrect development config
					}
				}
			}
		}

		fieldName := toPascalCase(key)
		tabs := strings.Repeat("\t", indent)

		switch v := value.(type) {
		case map[string]interface{}:
			// Get the correct type name for the nested config
			typeName := getConfigTypeName(key)
			if len(v) == 0 {
				// Empty struct, skip or use empty initializer
				fmt.Fprintf(buf, "%s%s: %s{},\n", tabs, fieldName, typeName)
			} else {
				// Nested struct
				fmt.Fprintf(buf, "%s%s: %s{\n", tabs, fieldName, typeName)
				generateStruct(buf, v, indent+1)
				fmt.Fprintf(buf, "%s},\n", tabs)
			}
		case string:
			// Check if it's an enum value that needs a constant
			constValue := getEnumConstant(key, v)
			if constValue != "" {
				fmt.Fprintf(buf, "%s%s: %s,\n", tabs, fieldName, constValue)
			} else {
				fmt.Fprintf(buf, "%s%s: %q,\n", tabs, fieldName, v)
			}
		case bool:
			fmt.Fprintf(buf, "%s%s: %t,\n", tabs, fieldName, v)
		case float64:
			if v == float64(int(v)) {
				fmt.Fprintf(buf, "%s%s: %d,\n", tabs, fieldName, int(v))
			} else {
				fmt.Fprintf(buf, "%s%s: %f,\n", tabs, fieldName, v)
			}
		default:
			fmt.Fprintf(buf, "%s%s: %v,\n", tabs, fieldName, v)
		}
	}
}

func getConfigTypeName(key string) string {
	// Map field names to their config type names
	switch key {
	case "api":
		return "APIConfig"
	case "cors":
		return "CORSConfig"
	case "email":
		return "EmailConfig"
	case "image":
		return "ImageConfig"
	case "resources":
		return "ResourceConfig"
	case "auth":
		return "AuthConfig"
	case "local":
		return "LocalAuth"
	case "twitter":
		return "TwitterAuth"
	case "firebase":
		return "FirebaseAuth"
	case "database":
		return "DatabaseConfig"
	case "logging":
		return "LoggingConfig"
	case "redis":
		return "RedisConfig"
	case "storage":
		return "StorageConfig"
	case "infrastructure":
		return "InfrastructureConfig"
	case developmentKey:
		return "DevelopmentConfig"
	case "platform":
		return "PlatformConfig"
	case "ingress":
		return "IngressConfig"
	case "intelligence":
		return "IntelligenceConfig"
	case "llm":
		return "LLMConfig"
	case "embedding":
		return "EmbeddingConfig"
	case "monitoring":
		return "MonitoringConfig"
	case "grafana":
		return "GrafanaConfig"
	case "loki":
		return "LokiConfig"
	case "billing":
		return "BillingConfig"
	case "stripe":
		return "StripeConfig"
	default:
		// Fallback to PascalCase + Config
		return toPascalCase(key) + "Config"
	}
}

var pascalCaseMap = map[string]string{
	"api":            "Api",
	"cors":           "Cors",
	"auth":           "Auth",
	"database":       "Database",
	"infrastructure": "Infrastructure",
	"ingress":        "Ingress",
	"intelligence":   "Intelligence",
	"logging":        "Logging",
	"monitoring":     "Monitoring",
	"platform":       "Platform",
	"redis":          "Redis",
	"storage":        "Storage",
	"billing":        "Billing",
	"llm":            "Llm",
	"embedding":      "Embedding",
	"grafana":        "Grafana",
	"loki":           "Loki",
	"stripe":         "Stripe",
	"oauth":          "Oauth",
	"local":          "Local",
	"twitter":        "Twitter",
	"firebase":       "Firebase",
	developmentKey:   "Development",
	"url":            "Url",
	"maxConns":       "MaxConns",
	"minConns":       "MinConns",
	"runMigrations":  "RunMigrations",
	"pullPolicy":     "PullPolicy",
	"accesskey":      "Accesskey",
	"secretkey":      "Secretkey",
	"email":          "Email",
	"image":          "Image",
	"resources":      "Resources",
}

func toPascalCase(s string) string {
	// Handle special cases for field names
	if pascal, ok := pascalCaseMap[s]; ok {
		return pascal
	}

	// General case: capitalize first letter
	if len(s) == 0 {
		return s
	}
	return strings.ToUpper(s[:1]) + s[1:]
}

func getEnumConstant(key, value string) string {
	// Map known enum values to their Go constants
	switch key {
	case "environment":
		switch value {
		case developmentKey:
			return "Development"
		case "staging":
			return "Staging"
		case "production":
			return "Production"
		}
	case "type":
		switch value {
		case "postgresql":
			return "Postgresql"
		case "sqlite":
			return "Sqlite"
		case "ollama":
			// Return empty to use the quoted string
			return ""
		}
	case "level":
		switch value {
		case "debug":
			return "Debug"
		case "info":
			return "Info"
		case "warn":
			return "Warn"
		case "error":
			return "Error"
		}
	case "pullPolicy":
		switch value {
		case "Always":
			return "Always"
		case "IfNotPresent":
			return "IfNotPresent"
		case "Never":
			return "Never"
		}
	}
	return ""
}
