package codegen

import (
	"bytes"
	"fmt"
	"go/format"
	"sort"
	"strings"
)

const developmentKey = "development"

// GenerateDefaultsCode generates Go code for configuration defaults.
func GenerateDefaultsCode(defaults map[string]interface{}) string {
	var buf bytes.Buffer

	// Header
	buf.WriteString(`// Code generated by codegen; DO NOT EDIT.
// This file contains default configuration values extracted from OpenAPI schemas.

package config

// GetDefaultConfig returns a complete default configuration with all values from OpenAPI schemas.
func GetDefaultConfig() *ArchesConfig {
	return &ArchesConfig{
`)

	// Generate each top-level config
	generateStruct(&buf, defaults, 2)

	buf.WriteString("\t}\n}\n")

	// Format the code
	code := buf.String()
	formatted, err := format.Source([]byte(code))
	if err != nil {
		// Return unformatted code if formatting fails
		return code
	}
	return string(formatted)
}

func generateStruct(buf *bytes.Buffer, data map[string]interface{}, indent int) {
	// Sort keys for consistent output
	keys := make([]string, 0, len(data))
	for k := range data {
		keys = append(keys, k)
	}
	sort.Strings(keys)

	for _, key := range keys {
		value := data[key]

		// Skip fields that don't exist in generated types
		if key == "oauth" {
			continue
		}

		// Skip development if it only has enabled field (incorrect parsing)
		if key == developmentKey {
			if m, ok := value.(map[string]interface{}); ok {
				if len(m) == 1 {
					if _, hasEnabled := m["enabled"]; hasEnabled {
						continue // Skip incorrect development config
					}
				}
			}
		}

		fieldName := toPascalCase(key)
		tabs := strings.Repeat("\t", indent)

		switch v := value.(type) {
		case map[string]interface{}:
			// Get the correct type name for the nested config
			typeName := getConfigTypeName(key)
			if len(v) == 0 {
				// Empty struct, skip or use empty initializer
				fmt.Fprintf(buf, "%s%s: %s{},\n", tabs, fieldName, typeName)
			} else {
				// Nested struct
				fmt.Fprintf(buf, "%s%s: %s{\n", tabs, fieldName, typeName)
				generateStruct(buf, v, indent+1)
				fmt.Fprintf(buf, "%s},\n", tabs)
			}
		case string:
			// Check if it's an enum value that needs a constant
			constValue := getEnumConstant(key, v)
			if constValue != "" {
				fmt.Fprintf(buf, "%s%s: %s,\n", tabs, fieldName, constValue)
			} else {
				fmt.Fprintf(buf, "%s%s: %q,\n", tabs, fieldName, v)
			}
		case bool:
			fmt.Fprintf(buf, "%s%s: %t,\n", tabs, fieldName, v)
		case float64:
			if v == float64(int(v)) {
				fmt.Fprintf(buf, "%s%s: %d,\n", tabs, fieldName, int(v))
			} else {
				fmt.Fprintf(buf, "%s%s: %f,\n", tabs, fieldName, v)
			}
		default:
			fmt.Fprintf(buf, "%s%s: %v,\n", tabs, fieldName, v)
		}
	}
}

func getConfigTypeName(key string) string {
	// Map field names to their config type names
	switch key {
	case "api":
		return "APIConfig"
	case "cors":
		return "CORSConfig"
	case "email":
		return "EmailConfig"
	case "image":
		return "ImageConfig"
	case "resources":
		return "ResourceConfig"
	case "auth":
		return "AuthConfig"
	case "local":
		return "LocalAuth"
	case "twitter":
		return "TwitterAuth"
	case "firebase":
		return "FirebaseAuth"
	case "database":
		return "DatabaseConfig"
	case "logging":
		return "LoggingConfig"
	case "redis":
		return "RedisConfig"
	case "storage":
		return "StorageConfig"
	case "infrastructure":
		return "InfrastructureConfig"
	case developmentKey:
		return "DevelopmentConfig"
	case "platform":
		return "PlatformConfig"
	case "ingress":
		return "IngressConfig"
	case "intelligence":
		return "IntelligenceConfig"
	case "llm":
		return "LLMConfig"
	case "embedding":
		return "EmbeddingConfig"
	case "monitoring":
		return "MonitoringConfig"
	case "grafana":
		return "GrafanaConfig"
	case "loki":
		return "LokiConfig"
	case "billing":
		return "BillingConfig"
	case "stripe":
		return "StripeConfig"
	default:
		// Fallback to PascalCase + Config
		return toPascalCase(key) + "Config"
	}
}

var pascalCaseMap = map[string]string{
	"api":            "API",
	"cors":           "Cors",
	"auth":           "Auth",
	"database":       "Database",
	"infrastructure": "Infrastructure",
	"ingress":        "Ingress",
	"intelligence":   "Intelligence",
	"logging":        "Logging",
	"monitoring":     "Monitoring",
	"platform":       "Platform",
	"redis":          "Redis",
	"storage":        "Storage",
	"billing":        "Billing",
	"llm":            "Llm",
	"embedding":      "Embedding",
	"grafana":        "Grafana",
	"loki":           "Loki",
	"stripe":         "Stripe",
	"oauth":          "Oauth",
	"local":          "Local",
	"twitter":        "Twitter",
	"firebase":       "Firebase",
	developmentKey:   "Development",
	"url":            "Url",
	"maxConns":       "MaxConns",
	"minConns":       "MinConns",
	"runMigrations":  "RunMigrations",
	"pullPolicy":     "PullPolicy",
	"accesskey":      "Accesskey",
	"secretkey":      "Secretkey",
	"email":          "Email",
	"image":          "Image",
	"resources":      "Resources",
}

func toPascalCase(s string) string {
	// Handle special cases for field names
	if pascal, ok := pascalCaseMap[s]; ok {
		return pascal
	}

	// General case: capitalize first letter
	if len(s) == 0 {
		return s
	}
	return strings.ToUpper(s[:1]) + s[1:]
}

func getEnumConstant(key, value string) string {
	// Map known enum values to their Go constants
	switch key {
	case "environment":
		switch value {
		case developmentKey:
			return "Development"
		case "staging":
			return "Staging"
		case "production":
			return "Production"
		}
	case "type":
		switch value {
		case "postgresql":
			return "Postgresql"
		case "sqlite":
			return "Sqlite"
		case "ollama":
			// Return empty to use the quoted string
			return ""
		}
	case "level":
		switch value {
		case "debug":
			return "Debug"
		case "info":
			return "Info"
		case "warn":
			return "Warn"
		case "error":
			return "Error"
		}
	case "pullPolicy":
		switch value {
		case "Always":
			return "Always"
		case "IfNotPresent":
			return "IfNotPresent"
		case "Never":
			return "Never"
		}
	}
	return ""
}

// GetCompleteConfigDefaults safely extracts ALL configuration defaults from the ArchesConfig structure.
// This includes all nested config schemas (APIConfig, DatabaseConfig, etc.) and their sub-configs.
// Returns a complete hierarchical map of all defaults that can be used for code generation.
func (p *Parser) GetCompleteConfigDefaults() (map[string]interface{}, error) {
	if p.doc == nil || p.doc.Components == nil || p.doc.Components.Schemas == nil {
		return nil, fmt.Errorf("no OpenAPI document loaded - call ParseOpenAPISpec first")
	}

	// Build complete config structure matching ArchesConfig
	// Each top-level key corresponds to a field in ArchesConfig
	completeDefaults := make(map[string]interface{})

	// Helper function to safely get defaults for a schema
	safeGetDefaults := func(schemaName string) map[string]interface{} {
		defaults, err := p.GetDefaultValues(schemaName)
		if err != nil {
			// Schema might not exist or have no defaults
			return make(map[string]interface{})
		}
		return defaults
	}

	// Top-level configs in ArchesConfig
	configs := map[string]string{
		"api":            "APIConfig",
		"auth":           "AuthConfig",
		"billing":        "BillingConfig",
		"database":       "DatabaseConfig",
		"infrastructure": "InfrastructureConfig",
		"ingress":        "IngressConfig",
		"intelligence":   "IntelligenceConfig",
		"logging":        "LoggingConfig",
		"monitoring":     "MonitoringConfig",
		"platform":       "PlatformConfig",
		"redis":          "RedisConfig",
		"storage":        "StorageConfig",
	}

	// Get defaults for each top-level config
	for key, schemaName := range configs {
		completeDefaults[key] = safeGetDefaults(schemaName)
	}

	// Handle nested configs within each top-level config
	// APIConfig has nested: cors, email, image, resources
	if apiDefaults, ok := completeDefaults["api"].(map[string]interface{}); ok {
		apiDefaults["cors"] = safeGetDefaults("CORSConfig")
		apiDefaults["email"] = safeGetDefaults("EmailConfig")
		apiDefaults["image"] = safeGetDefaults("ImageConfig")
		apiDefaults["resources"] = safeGetDefaults("ResourceConfig")
	}

	// AuthConfig has nested: local, oauth
	if authDefaults, ok := completeDefaults["auth"].(map[string]interface{}); ok {
		authDefaults["local"] = safeGetDefaults("LocalAuthConfig")
		authDefaults["oauth"] = safeGetDefaults("OAuthConfig")
	}

	// IntelligenceConfig has nested: llm, embedding
	if intellDefaults, ok := completeDefaults["intelligence"].(map[string]interface{}); ok {
		intellDefaults["llm"] = safeGetDefaults("LLMConfig")
		intellDefaults["embedding"] = safeGetDefaults("EmbeddingConfig")
	}

	// MonitoringConfig has nested: grafana, loki
	if monDefaults, ok := completeDefaults["monitoring"].(map[string]interface{}); ok {
		monDefaults["grafana"] = safeGetDefaults("GrafanaConfig")
		monDefaults["loki"] = safeGetDefaults("LokiConfig")
	}

	// BillingConfig has nested: stripe
	if billDefaults, ok := completeDefaults["billing"].(map[string]interface{}); ok {
		billDefaults["stripe"] = safeGetDefaults("StripeConfig")
	}

	// InfrastructureConfig has nested: development
	if infraDefaults, ok := completeDefaults["infrastructure"].(map[string]interface{}); ok {
		infraDefaults["development"] = safeGetDefaults("DevServiceConfig")
	}

	return completeDefaults, nil
}

// FlattenConfigDefaults converts nested config defaults to a flat map with dot notation keys.
// For example: {"api": {"host": "0.0.0.0"}} becomes {"api.host": "0.0.0.0"}
// This is useful for environment variable generation or flat config files.
func (p *Parser) FlattenConfigDefaults(defaults map[string]interface{}) map[string]interface{} {
	result := make(map[string]interface{})
	p.flattenRecursive("", defaults, result)
	return result
}

// flattenRecursive is a helper to recursively flatten nested maps
func (p *Parser) flattenRecursive(prefix string, nested map[string]interface{}, result map[string]interface{}) {
	for key, value := range nested {
		fullKey := key
		if prefix != "" {
			fullKey = prefix + "." + key
		}

		switch v := value.(type) {
		case map[string]interface{}:
			// Recursively flatten nested maps
			p.flattenRecursive(fullKey, v, result)
		default:
			// Store the value with its full path
			result[fullKey] = value
		}
	}
}

// CountConfigDefaults counts the total number of default values in a nested config map.
// This includes all nested defaults at any depth.
func (p *Parser) CountConfigDefaults(defaults map[string]interface{}) int {
	count := 0
	for _, value := range defaults {
		switch v := value.(type) {
		case map[string]interface{}:
			// Recursively count nested defaults
			count += p.CountConfigDefaults(v)
		default:
			// This is a leaf value (actual default)
			count++
		}
	}
	return count
}
