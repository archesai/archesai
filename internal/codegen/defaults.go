package codegen

import (
	"bytes"
	"fmt"
	"go/format"
	"sort"
	"strings"
)

// GenerateDefaultsCode generates Go code for configuration defaults.
func GenerateDefaultsCode(defaults map[string]interface{}) string {
	var buf bytes.Buffer

	// Header
	buf.WriteString(`// Code generated by codegen; DO NOT EDIT.
// This file contains default configuration values extracted from OpenAPI schemas.

package config

// GetDefaultConfig returns a complete default configuration with all values from OpenAPI schemas.
func GetDefaultConfig() *ArchesConfig {
	return &ArchesConfig{
`)

	// Generate each top-level config
	generateStruct(&buf, defaults, 2)

	buf.WriteString("\t}\n}\n")

	// Format the code
	code := buf.String()
	formatted, err := format.Source([]byte(code))
	if err != nil {
		// Return unformatted code if formatting fails
		return code
	}
	return string(formatted)
}

func generateStruct(buf *bytes.Buffer, data map[string]interface{}, indent int) {
	// Sort keys for consistent output
	keys := make([]string, 0, len(data))
	for k := range data {
		keys = append(keys, k)
	}
	sort.Strings(keys)

	for _, key := range keys {
		value := data[key]

		// Skip fields that don't exist in generated types
		if key == "oauth" {
			continue
		}

		fieldName := toPascalCase(key)
		tabs := strings.Repeat("\t", indent)

		switch v := value.(type) {
		case map[string]interface{}:
			// Special handling for kubernetes field (anonymous struct)
			if key == "kubernetes" {
				if len(v) == 0 {
					fmt.Fprintf(buf, "%s%s: struct {\n", tabs, fieldName)
					fmt.Fprintf(buf, "%s\tInfrastructure InfrastructureConfig `json:\"infrastructure,omitempty,omitzero\" yaml:\"infrastructure,omitempty\" mapstructure:\"infrastructure,omitempty\"`\n", tabs)
					fmt.Fprintf(buf, "%s\tIngress        IngressConfig        `json:\"ingress,omitempty,omitzero\" yaml:\"ingress,omitempty\" mapstructure:\"ingress,omitempty\"`\n", tabs)
					fmt.Fprintf(buf, "%s\tMonitoring     MonitoringConfig     `json:\"monitoring,omitempty,omitzero\" yaml:\"monitoring,omitempty\" mapstructure:\"monitoring,omitempty\"`\n", tabs)
					fmt.Fprintf(buf, "%s}{},\n", tabs)
				} else {
					fmt.Fprintf(buf, "%s%s: struct {\n", tabs, fieldName)
					fmt.Fprintf(buf, "%s\tInfrastructure InfrastructureConfig `json:\"infrastructure,omitempty,omitzero\" yaml:\"infrastructure,omitempty\" mapstructure:\"infrastructure,omitempty\"`\n", tabs)
					fmt.Fprintf(buf, "%s\tIngress        IngressConfig        `json:\"ingress,omitempty,omitzero\" yaml:\"ingress,omitempty\" mapstructure:\"ingress,omitempty\"`\n", tabs)
					fmt.Fprintf(buf, "%s\tMonitoring     MonitoringConfig     `json:\"monitoring,omitempty,omitzero\" yaml:\"monitoring,omitempty\" mapstructure:\"monitoring,omitempty\"`\n", tabs)
					fmt.Fprintf(buf, "%s}{\n", tabs)
					generateStruct(buf, v, indent+1)
					fmt.Fprintf(buf, "%s},\n", tabs)
				}
			} else {
				// Get the correct type name for the nested config
				typeName := getConfigTypeName(key)
				if len(v) == 0 {
					// Empty struct, skip or use empty initializer
					fmt.Fprintf(buf, "%s%s: %s{},\n", tabs, fieldName, typeName)
				} else {
					// Nested struct
					fmt.Fprintf(buf, "%s%s: %s{\n", tabs, fieldName, typeName)
					generateStruct(buf, v, indent+1)
					fmt.Fprintf(buf, "%s},\n", tabs)
				}
			}
		case string:
			// Check if it's an enum value that needs a constant
			constValue := getEnumConstant(key, v)
			if constValue != "" {
				fmt.Fprintf(buf, "%s%s: %s,\n", tabs, fieldName, constValue)
			} else {
				fmt.Fprintf(buf, "%s%s: %q,\n", tabs, fieldName, v)
			}
		case bool:
			fmt.Fprintf(buf, "%s%s: %t,\n", tabs, fieldName, v)
		case float64:
			if v == float64(int(v)) {
				fmt.Fprintf(buf, "%s%s: %d,\n", tabs, fieldName, int(v))
			} else {
				fmt.Fprintf(buf, "%s%s: %f,\n", tabs, fieldName, v)
			}
		case []interface{}:
			// Handle empty slices with proper typing
			if len(v) == 0 {
				// For known slice types, provide proper initialization
				if key == "imagePullSecrets" {
					fmt.Fprintf(buf, "%s%s: []string{},\n", tabs, fieldName)
				} else {
					fmt.Fprintf(buf, "%s%s: []interface{}{},\n", tabs, fieldName)
				}
			} else {
				// Non-empty slices - for now just print as interface{}
				fmt.Fprintf(buf, "%s%s: %v,\n", tabs, fieldName, v)
			}
		default:
			fmt.Fprintf(buf, "%s%s: %v,\n", tabs, fieldName, v)
		}
	}
}

var configTypeMap = map[string]string{
	"api":            "APIConfig",
	"email":          "EmailConfig",
	"image":          "ImageConfig",
	"resources":      "ResourceConfig",
	"auth":           "AuthConfig",
	"local":          "LocalAuth",
	"twitter":        "TwitterAuth",
	"firebase":       "FirebaseAuth",
	"database":       "DatabaseConfig",
	"logging":        "LoggingConfig",
	"redis":          "RedisConfig",
	"storage":        "StorageConfig",
	"infrastructure": "InfrastructureConfig",
	"platform":       "PlatformConfig",
	"ingress":        "IngressConfig",
	"intelligence":   "IntelligenceConfig",
	"llm":            "LLMConfig",
	"embedding":      "EmbeddingConfig",
	"monitoring":     "MonitoringConfig",
	"grafana":        "GrafanaConfig",
	"loki":           "LokiConfig",
	"billing":        "BillingConfig",
	"stripe":         "StripeConfig",
	"kubernetes":     "struct { Infrastructure InfrastructureConfig; Ingress IngressConfig; Monitoring MonitoringConfig }",
	"images":         "ImagesConfig",
	"migrations":     "MigrationsConfig",
	"serviceAccount": "ServiceAccountConfig",
	"tls":            "TLSConfig",
	"limits":         "ResourceLimits",
	"requests":       "ResourceRequests",
	"runpod":         "RunPodConfig",
	"scraper":        "ScraperConfig",
	"speech":         "SpeechConfig",
	"unstructured":   "UnstructuredConfig",
}

func getConfigTypeName(key string) string {
	if typeName, exists := configTypeMap[key]; exists {
		return typeName
	}
	// Fallback to PascalCase + Config
	return toPascalCase(key) + "Config"
}

var pascalCaseMap = map[string]string{
	"api":            "API",
	"cors":           "Cors",
	"auth":           "Auth",
	"database":       "Database",
	"infrastructure": "Infrastructure",
	"ingress":        "Ingress",
	"intelligence":   "Intelligence",
	"logging":        "Logging",
	"monitoring":     "Monitoring",
	"platform":       "Platform",
	"redis":          "Redis",
	"storage":        "Storage",
	"billing":        "Billing",
	"llm":            "Llm",
	"embedding":      "Embedding",
	"grafana":        "Grafana",
	"loki":           "Loki",
	"stripe":         "Stripe",
	"oauth":          "Oauth",
	"local":          "Local",
	"twitter":        "Twitter",
	"firebase":       "Firebase",
	"url":            "URL",
	"maxConns":       "MaxConns",
	"minConns":       "MinConns",
	"runMigrations":  "RunMigrations",
	"pullPolicy":     "PullPolicy",
	"accesskey":      "Accesskey",
	"secretkey":      "Secretkey",
	"email":          "Email",
	"image":          "Image",
	"resources":      "Resources",
	"tls":            "TLS",
}

func toPascalCase(s string) string {
	// Handle special cases for field names
	if pascal, ok := pascalCaseMap[s]; ok {
		return pascal
	}

	// General case: capitalize first letter
	if len(s) == 0 {
		return s
	}
	return strings.ToUpper(s[:1]) + s[1:]
}

func getEnumConstant(key, value string) string {
	// Map known enum values to their Go constants
	switch key {
	case "environment":
		switch value {
		case "development":
			return "Development"
		case "staging":
			return "Staging"
		case "production":
			return "Production"
		}
	case "type":
		switch value {
		case "postgresql":
			return "Postgresql"
		case "sqlite":
			return "Sqlite"
		case "ollama":
			// Return empty to use the quoted string
			return ""
		}
	case "level":
		switch value {
		case "debug":
			return "Debug"
		case "info":
			return "Info"
		case "warn":
			return "Warn"
		case "error":
			return "Error"
		}
	case "pullPolicy":
		switch value {
		case "Always":
			return "Always"
		case "IfNotPresent":
			return "IfNotPresent"
		case "Never":
			return "Never"
		}
	}
	return ""
}

// GetCompleteConfigDefaults safely extracts ALL configuration defaults from the ArchesConfig structure.
// This includes all nested config schemas (APIConfig, DatabaseConfig, etc.) and their sub-configs.
// Returns a complete hierarchical map of all defaults that can be used for code generation.
func (p *Parser) GetCompleteConfigDefaults() (map[string]interface{}, error) {
	if p.doc == nil || p.doc.Components == nil || p.doc.Components.Schemas == nil {
		return nil, fmt.Errorf("no OpenAPI document loaded - call ParseOpenAPISpec first")
	}

	// Build complete config structure matching ArchesConfig
	// Each top-level key corresponds to a field in ArchesConfig
	completeDefaults := make(map[string]interface{})

	// Helper function to safely get defaults for a schema
	safeGetDefaults := func(schemaName string) map[string]interface{} {
		defaults, err := p.GetDefaultValues(schemaName)
		if err != nil {
			// Schema might not exist or have no defaults
			return make(map[string]interface{})
		}
		return defaults
	}

	// Top-level configs in ArchesConfig
	configs := map[string]string{
		"api":          "APIConfig",
		"auth":         "AuthConfig",
		"billing":      "BillingConfig",
		"database":     "DatabaseConfig",
		"intelligence": "IntelligenceConfig",
		"logging":      "LoggingConfig",
		"platform":     "PlatformConfig",
		"redis":        "RedisConfig",
		"storage":      "StorageConfig",
	}

	// Get defaults for each top-level config
	for key, schemaName := range configs {
		completeDefaults[key] = safeGetDefaults(schemaName)
	}

	// Handle nested configs within each top-level config
	// APIConfig has nested: cors, email, image, resources
	if apiDefaults, ok := completeDefaults["api"].(map[string]interface{}); ok {
		apiDefaults["email"] = safeGetDefaults("EmailConfig")
		apiDefaults["image"] = safeGetDefaults("ImageConfig")
		apiDefaults["resources"] = safeGetDefaults("ResourceConfig")
	}

	// AuthConfig has nested: local, oauth
	if authDefaults, ok := completeDefaults["auth"].(map[string]interface{}); ok {
		authDefaults["local"] = safeGetDefaults("LocalAuthConfig")
		authDefaults["oauth"] = safeGetDefaults("OAuthConfig")
	}

	// IntelligenceConfig has nested: llm, embedding
	if intellDefaults, ok := completeDefaults["intelligence"].(map[string]interface{}); ok {
		intellDefaults["llm"] = safeGetDefaults("LLMConfig")
		intellDefaults["embedding"] = safeGetDefaults("EmbeddingConfig")
	}

	// MonitoringConfig has nested: grafana, loki
	if monDefaults, ok := completeDefaults["monitoring"].(map[string]interface{}); ok {
		monDefaults["grafana"] = safeGetDefaults("GrafanaConfig")
		monDefaults["loki"] = safeGetDefaults("LokiConfig")
	}

	// BillingConfig has nested: stripe
	if billDefaults, ok := completeDefaults["billing"].(map[string]interface{}); ok {
		billDefaults["stripe"] = safeGetDefaults("StripeConfig")
	}

	// Add kubernetes nested structure
	kubernetes := map[string]interface{}{
		"infrastructure": safeGetDefaults("InfrastructureConfig"),
		"ingress":        safeGetDefaults("IngressConfig"),
		"monitoring":     safeGetDefaults("MonitoringConfig"),
	}

	// Handle nested configs within kubernetes structure
	if infraDefaults, ok := kubernetes["infrastructure"].(map[string]interface{}); ok {
		infraDefaults["images"] = safeGetDefaults("ImagesConfig")
		infraDefaults["migrations"] = safeGetDefaults("MigrationsConfig")
		infraDefaults["serviceAccount"] = safeGetDefaults("ServiceAccountConfig")
	}

	if ingressDefaults, ok := kubernetes["ingress"].(map[string]interface{}); ok {
		ingressDefaults["tls"] = safeGetDefaults("TLSConfig")
	}

	if monDefaults, ok := kubernetes["monitoring"].(map[string]interface{}); ok {
		monDefaults["grafana"] = safeGetDefaults("GrafanaConfig")
		monDefaults["loki"] = safeGetDefaults("LokiConfig")
	}

	completeDefaults["kubernetes"] = kubernetes

	return completeDefaults, nil
}

// FlattenConfigDefaults converts nested config defaults to a flat map with dot notation keys.
// For example: {"api": {"host": "0.0.0.0"}} becomes {"api.host": "0.0.0.0"}
// This is useful for environment variable generation or flat config files.
func (p *Parser) FlattenConfigDefaults(defaults map[string]interface{}) map[string]interface{} {
	result := make(map[string]interface{})
	p.flattenRecursive("", defaults, result)
	return result
}

// flattenRecursive is a helper to recursively flatten nested maps.
func (p *Parser) flattenRecursive(
	prefix string,
	nested map[string]interface{},
	result map[string]interface{},
) {
	for key, value := range nested {
		fullKey := key
		if prefix != "" {
			fullKey = prefix + "." + key
		}

		switch v := value.(type) {
		case map[string]interface{}:
			// Recursively flatten nested maps
			p.flattenRecursive(fullKey, v, result)
		default:
			// Store the value with its full path
			result[fullKey] = value
		}
	}
}

// CountConfigDefaults counts the total number of default values in a nested config map.
// This includes all nested defaults at any depth.
func (p *Parser) CountConfigDefaults(defaults map[string]interface{}) int {
	count := 0
	for _, value := range defaults {
		switch v := value.(type) {
		case map[string]interface{}:
			// Recursively count nested defaults
			count += p.CountConfigDefaults(v)
		default:
			// This is a leaf value (actual default)
			count++
		}
	}
	return count
}
