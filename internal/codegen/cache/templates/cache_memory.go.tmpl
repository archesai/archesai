// Code generated by codegen cache. DO NOT EDIT.
package {{.Package}}

import (
	"context"
	"fmt"
	"sync"
	"time"

	"github.com/google/uuid"
)

// cacheItem represents a cached item with expiration.
type cacheItem struct {
	data      interface{}
	expiresAt time.Time
}

// isExpired checks if the cache item has expired.
func (i *cacheItem) isExpired() bool {
	return time.Now().After(i.expiresAt)
}

// MemoryCache implements Cache using in-memory storage.
type MemoryCache struct {
	mu       sync.RWMutex
	items    map[string]*cacheItem
	maxItems int
	ttl      time.Duration
}

// NewMemoryCache creates a new in-memory cache.
func NewMemoryCache() Cache {
	maxItems := 1000
	{{if .Config.Cache.Memory.MaxItems}}maxItems = {{.Config.Cache.Memory.MaxItems}}{{end}}

	ttl := 5 * time.Minute
	{{if .Config.Cache.Memory.DefaultTTL}}ttl = {{.Config.Cache.Memory.DefaultTTL}} * time.Second{{end}}

	cache := &MemoryCache{
		items:    make(map[string]*cacheItem),
		maxItems: maxItems,
		ttl:      ttl,
	}

	// Start cleanup goroutine
	go cache.cleanupExpired()

	return cache
}

// NewMemoryCacheWithOptions creates a new in-memory cache with custom options.
func NewMemoryCacheWithOptions(maxItems int, ttl time.Duration) Cache {
	cache := &MemoryCache{
		items:    make(map[string]*cacheItem),
		maxItems: maxItems,
		ttl:      ttl,
	}

	// Start cleanup goroutine
	go cache.cleanupExpired()

	return cache
}

// cleanupExpired periodically removes expired items.
func (c *MemoryCache) cleanupExpired() {
	ticker := time.NewTicker(1 * time.Minute)
	defer ticker.Stop()

	for range ticker.C {
		c.mu.Lock()
		for key, item := range c.items {
			if item.isExpired() {
				delete(c.items, key)
			}
		}
		c.mu.Unlock()
	}
}

// evictOldest removes the oldest items when cache is full.
func (c *MemoryCache) evictOldest() {
	if len(c.items) < c.maxItems {
		return
	}

	// Simple eviction: remove 10% of oldest items
	toRemove := c.maxItems / 10
	if toRemove < 1 {
		toRemove = 1
	}

	var oldestKeys []string
	now := time.Now()

	for key, item := range c.items {
		if now.After(item.expiresAt) || len(oldestKeys) < toRemove {
			oldestKeys = append(oldestKeys, key)
		} else {
			// Replace if this item is older
			for i, oldKey := range oldestKeys {
				if c.items[oldKey].expiresAt.After(item.expiresAt) {
					oldestKeys[i] = key
					break
				}
			}
		}
	}

	for _, key := range oldestKeys {
		delete(c.items, key)
	}
}

{{range .Entities}}{{if .Cacheable}}
// {{.Name}} caching operations

func (c *MemoryCache) Get{{.Name}}(ctx context.Context, id uuid.UUID) (*{{.Type}}, error) {
	c.mu.RLock()
	defer c.mu.RUnlock()

	key := fmt.Sprintf("{{lower .Name}}:%s", id.String())
	item, exists := c.items[key]

	if !exists || item.isExpired() {
		return nil, ErrCacheMiss
	}

	entity, ok := item.data.(*{{.Type}})
	if !ok {
		return nil, fmt.Errorf("invalid cached type for {{lower .Name}}")
	}

	return entity, nil
}

func (c *MemoryCache) Set{{.Name}}(ctx context.Context, entity *{{.Type}}, ttl time.Duration) error {
	if entity == nil {
		return nil
	}

	c.mu.Lock()
	defer c.mu.Unlock()

	// Check if we need to evict items
	if len(c.items) >= c.maxItems {
		c.evictOldest()
	}

	key := fmt.Sprintf("{{lower .Name}}:%s", entity.{{.PrimaryKey}}.String())

	if ttl == 0 {
		ttl = c.ttl
	}

	c.items[key] = &cacheItem{
		data:      entity,
		expiresAt: time.Now().Add(ttl),
	}

	return nil
}

func (c *MemoryCache) Delete{{.Name}}(ctx context.Context, id uuid.UUID) error {
	c.mu.Lock()
	defer c.mu.Unlock()

	key := fmt.Sprintf("{{lower .Name}}:%s", id.String())
	delete(c.items, key)

	return nil
}

{{if eq .Name "User"}}// Additional User cache operations
func (c *MemoryCache) Get{{.Name}}ByEmail(ctx context.Context, email string) (*{{.Type}}, error) {
	c.mu.RLock()
	defer c.mu.RUnlock()

	key := fmt.Sprintf("{{lower .Name}}:email:%s", email)
	item, exists := c.items[key]

	if !exists || item.isExpired() {
		return nil, ErrCacheMiss
	}

	entity, ok := item.data.(*{{.Type}})
	if !ok {
		return nil, fmt.Errorf("invalid cached type for {{lower .Name}}")
	}

	return entity, nil
}

func (c *MemoryCache) Set{{.Name}}ByEmail(ctx context.Context, email string, entity *{{.Type}}, ttl time.Duration) error {
	if entity == nil {
		return nil
	}

	c.mu.Lock()
	defer c.mu.Unlock()

	// Check if we need to evict items
	if len(c.items) >= c.maxItems {
		c.evictOldest()
	}

	key := fmt.Sprintf("{{lower .Name}}:email:%s", email)

	if ttl == 0 {
		ttl = c.ttl
	}

	c.items[key] = &cacheItem{
		data:      entity,
		expiresAt: time.Now().Add(ttl),
	}

	// Also cache by ID
	idKey := fmt.Sprintf("{{lower .Name}}:%s", entity.{{.PrimaryKey}}.String())
	c.items[idKey] = &cacheItem{
		data:      entity,
		expiresAt: time.Now().Add(ttl),
	}

	return nil
}

func (c *MemoryCache) Delete{{.Name}}ByEmail(ctx context.Context, email string) error {
	c.mu.Lock()
	defer c.mu.Unlock()

	key := fmt.Sprintf("{{lower .Name}}:email:%s", email)
	delete(c.items, key)

	return nil
}{{end}}

{{if eq .Name "Session"}}// Additional Session cache operations
func (c *MemoryCache) Get{{.Name}}ByToken(ctx context.Context, token string) (*{{.Type}}, error) {
	c.mu.RLock()
	defer c.mu.RUnlock()

	key := fmt.Sprintf("{{lower .Name}}:token:%s", token)
	item, exists := c.items[key]

	if !exists || item.isExpired() {
		return nil, ErrCacheMiss
	}

	entity, ok := item.data.(*{{.Type}})
	if !ok {
		return nil, fmt.Errorf("invalid cached type for {{lower .Name}}")
	}

	return entity, nil
}

func (c *MemoryCache) Set{{.Name}}ByToken(ctx context.Context, token string, entity *{{.Type}}, ttl time.Duration) error {
	if entity == nil {
		return nil
	}

	c.mu.Lock()
	defer c.mu.Unlock()

	// Check if we need to evict items
	if len(c.items) >= c.maxItems {
		c.evictOldest()
	}

	key := fmt.Sprintf("{{lower .Name}}:token:%s", token)

	if ttl == 0 {
		ttl = c.ttl
	}

	c.items[key] = &cacheItem{
		data:      entity,
		expiresAt: time.Now().Add(ttl),
	}

	// Also cache by ID
	idKey := fmt.Sprintf("{{lower .Name}}:%s", entity.{{.PrimaryKey}}.String())
	c.items[idKey] = &cacheItem{
		data:      entity,
		expiresAt: time.Now().Add(ttl),
	}

	// Track by user ID for bulk deletion
	userKey := fmt.Sprintf("{{lower .Name}}:user:%s:%s", entity.UserId, entity.{{.PrimaryKey}}.String())
	c.items[userKey] = &cacheItem{
		data:      entity,
		expiresAt: time.Now().Add(ttl),
	}

	return nil
}

func (c *MemoryCache) Delete{{.Name}}ByToken(ctx context.Context, token string) error {
	c.mu.Lock()
	defer c.mu.Unlock()

	key := fmt.Sprintf("{{lower .Name}}:token:%s", token)
	delete(c.items, key)

	return nil
}

func (c *MemoryCache) DeleteUser{{.Name}}s(ctx context.Context, userID uuid.UUID) error {
	c.mu.Lock()
	defer c.mu.Unlock()

	prefix := fmt.Sprintf("{{lower .Name}}:user:%s:", userID.String())

	// Find and delete all matching keys
	for key := range c.items {
		if len(key) >= len(prefix) && key[:len(prefix)] == prefix {
			delete(c.items, key)
		}
	}

	return nil
}{{end}}
{{end}}{{end}}

// FlushAll removes all cached items.
func (c *MemoryCache) FlushAll(ctx context.Context) error {
	c.mu.Lock()
	defer c.mu.Unlock()

	c.items = make(map[string]*cacheItem)

	return nil
}
