package {{.Package}}

import (
	"context"
	"errors"
	"fmt"

	"github.com/archesai/archesai/internal/infrastructure/config"
)

// Repository defines the data access interface for this domain.
// Following the "interface defined by consumer" pattern.
type Repository interface {
	{{range .Tables}}
	// {{title .}} operations
	Get{{title .}}(ctx context.Context, id string) (*{{title .}}, error)
	List{{title .}}s(ctx context.Context, limit, offset int) ([]*{{title .}}, error)
	Create{{title .}}(ctx context.Context, {{lower .}} *{{title .}}) error
	Update{{title .}}(ctx context.Context, {{lower .}} *{{title .}}) error
	Delete{{title .}}(ctx context.Context, id string) error
	{{end}}
}

// Service contains the business logic for the {{.Package}} domain.
type Service struct {
	repo   Repository
	config *config.Config
}

// NewService creates a new {{.Package}} service.
func NewService(repo Repository, config *config.Config) *Service {
	return &Service{
		repo:   repo,
		config: config,
	}
}

{{range .Tables}}
// Get{{title .}} retrieves a {{.}} by ID.
func (s *Service) Get{{title .}}(ctx context.Context, id string) (*{{title .}}, error) {
	if id == "" {
		return nil, fmt.Errorf("%w: id is required", ErrInvalidInput)
	}

	{{lower .}}, err := s.repo.Get{{title .}}(ctx, id)
	if err != nil {
		if errors.Is(err, ErrNotFound) {
			return nil, err
		}
		return nil, fmt.Errorf("failed to get {{.}}: %w", err)
	}

	return {{lower .}}, nil
}

// Create{{title .}} creates a new {{.}}.
func (s *Service) Create{{title .}}(ctx context.Context, {{lower .}} *{{title .}}) error {
	// Add validation and business logic here
	
	if err := s.repo.Create{{title .}}(ctx, {{lower .}}); err != nil {
		return fmt.Errorf("failed to create {{.}}: %w", err)
	}

	return nil
}

// Update{{title .}} updates an existing {{.}}.
func (s *Service) Update{{title .}}(ctx context.Context, {{lower .}} *{{title .}}) error {
	// Add validation and business logic here
	
	if err := s.repo.Update{{title .}}(ctx, {{lower .}}); err != nil {
		return fmt.Errorf("failed to update {{.}}: %w", err)
	}

	return nil
}

// Delete{{title .}} deletes a {{.}} by ID.
func (s *Service) Delete{{title .}}(ctx context.Context, id string) error {
	if id == "" {
		return fmt.Errorf("%w: id is required", ErrInvalidInput)
	}

	if err := s.repo.Delete{{title .}}(ctx, id); err != nil {
		return fmt.Errorf("failed to delete {{.}}: %w", err)
	}

	return nil
}
{{end}}