// Code generated by codegen cache. DO NOT EDIT.
package {{.Package}}

import (
	"context"
	"time"

	genericcache "github.com/archesai/archesai/internal/cache"
	"github.com/google/uuid"
)

// ErrCacheMiss re-exported from generic cache package
var ErrCacheMiss = genericcache.ErrCacheMiss

// Cache provides caching operations for {{.Domain}} domain.
type Cache interface {
{{range .Schemas}}{{if .XCodegen.Cache}}
	// {{.Name}} caching
	Get{{.Name}}(ctx context.Context, id uuid.UUID) (*{{.Name}}, error)
	Set{{.Name}}(ctx context.Context, entity *{{.Name}}, ttl time.Duration) error
	Delete{{.Name}}(ctx context.Context, id uuid.UUID) error
	{{if eq .Name "User"}}Get{{.Name}}ByEmail(ctx context.Context, email string) (*{{.Name}}, error)
	Set{{.Name}}ByEmail(ctx context.Context, email string, entity *{{.Name}}, ttl time.Duration) error
	Delete{{.Name}}ByEmail(ctx context.Context, email string) error{{end}}
	{{if eq .Name "Session"}}Get{{.Name}}ByToken(ctx context.Context, token string) (*{{.Name}}, error)
	Set{{.Name}}ByToken(ctx context.Context, token string, entity *{{.Name}}, ttl time.Duration) error
	Delete{{.Name}}ByToken(ctx context.Context, token string) error
	DeleteUser{{.Name}}s(ctx context.Context, userID uuid.UUID) error{{end}}
{{end}}{{end}}

	// Batch operations
	FlushAll(ctx context.Context) error
}

// NewNoOpCache creates a no-op cache using the generic NoOpCache with the adapter
func NewNoOpCache() Cache {
	return NewCacheAdapter({{range $i, $s := .Schemas}}{{if $s.XCodegen.Cache}}{{if $i}}, {{end}}genericcache.NewNoOpCache[{{$s.Name}}](){{end}}{{end}})
}

// CacheAdapter adapts generic cache implementations to the domain Cache interface
type CacheAdapter struct {
{{range .Schemas}}{{if .XCodegen.Cache}}	{{.Name | lower}}Cache genericcache.Cache[{{.Name}}]
{{end}}{{end}}}

// NewCacheAdapter creates a new cache adapter using generic caches
func NewCacheAdapter({{range $i, $s := .Schemas}}{{if $s.XCodegen.Cache}}{{if $i}}, {{end}}{{$s.Name | lower}}Cache genericcache.Cache[{{$s.Name}}]{{end}}{{end}}) Cache {
	return &CacheAdapter{
{{range .Schemas}}{{if .XCodegen.Cache}}		{{.Name | lower}}Cache: {{.Name | lower}}Cache,
{{end}}{{end}}	}
}

{{range .Schemas}}{{if .XCodegen.Cache}}
// Get{{.Name}} retrieves {{.Name | lower}} from cache by ID
func (a *CacheAdapter) Get{{.Name}}(ctx context.Context, id uuid.UUID) (*{{.Name}}, error) {
	entity, err := a.{{.Name | lower}}Cache.Get(ctx, id.String())
	if err != nil {
		return nil, err
	}
	if entity == nil {
		return nil, ErrCacheMiss
	}
	return entity, nil
}

// Set{{.Name}} stores {{.Name | lower}} in cache with TTL
func (a *CacheAdapter) Set{{.Name}}(ctx context.Context, entity *{{.Name}}, ttl time.Duration) error {
	if entity == nil {
		return nil
	}
	return a.{{.Name | lower}}Cache.Set(ctx, entity.Id.String(), entity, ttl)
}

// Delete{{.Name}} removes {{.Name | lower}} from cache
func (a *CacheAdapter) Delete{{.Name}}(ctx context.Context, id uuid.UUID) error {
	return a.{{.Name | lower}}Cache.Delete(ctx, id.String())
}

{{if eq .Name "User"}}
// Get{{.Name}}ByEmail retrieves {{.Name | lower}} from cache by email
func (a *CacheAdapter) Get{{.Name}}ByEmail(ctx context.Context, email string) (*{{.Name}}, error) {
	key := "email:" + email
	entity, err := a.{{.Name | lower}}Cache.Get(ctx, key)
	if err != nil {
		return nil, err
	}
	if entity == nil {
		return nil, ErrCacheMiss
	}
	return entity, nil
}

// Set{{.Name}}ByEmail stores {{.Name | lower}} in cache indexed by email
func (a *CacheAdapter) Set{{.Name}}ByEmail(ctx context.Context, email string, entity *{{.Name}}, ttl time.Duration) error {
	if entity == nil {
		return nil
	}
	key := "email:" + email
	return a.{{.Name | lower}}Cache.Set(ctx, key, entity, ttl)
}

// Delete{{.Name}}ByEmail removes {{.Name | lower}} from cache by email
func (a *CacheAdapter) Delete{{.Name}}ByEmail(ctx context.Context, email string) error {
	key := "email:" + email
	return a.{{.Name | lower}}Cache.Delete(ctx, key)
}{{end}}

{{if eq .Name "Session"}}
// Get{{.Name}}ByToken retrieves {{.Name | lower}} from cache by token
func (a *CacheAdapter) Get{{.Name}}ByToken(ctx context.Context, token string) (*{{.Name}}, error) {
	key := "token:" + token
	entity, err := a.{{.Name | lower}}Cache.Get(ctx, key)
	if err != nil {
		return nil, err
	}
	if entity == nil {
		return nil, ErrCacheMiss
	}
	return entity, nil
}

// Set{{.Name}}ByToken stores {{.Name | lower}} in cache indexed by token
func (a *CacheAdapter) Set{{.Name}}ByToken(ctx context.Context, token string, entity *{{.Name}}, ttl time.Duration) error {
	if entity == nil {
		return nil
	}
	key := "token:" + token
	return a.{{.Name | lower}}Cache.Set(ctx, key, entity, ttl)
}

// Delete{{.Name}}ByToken removes {{.Name | lower}} from cache by token
func (a *CacheAdapter) Delete{{.Name}}ByToken(ctx context.Context, token string) error {
	key := "token:" + token
	return a.{{.Name | lower}}Cache.Delete(ctx, key)
}

// DeleteUser{{.Name}}s removes all sessions for a user from cache
func (a *CacheAdapter) DeleteUser{{.Name}}s(ctx context.Context, userID uuid.UUID) error {
	// This would require a more complex implementation with indexing
	// For now, returning nil as it's best-effort cleanup
	return nil
}{{end}}
{{end}}{{end}}

// FlushAll clears all cached data
func (a *CacheAdapter) FlushAll(ctx context.Context) error {
{{range .Schemas}}{{if .XCodegen.Cache}}	if err := a.{{.Name | lower}}Cache.Clear(ctx); err != nil {
		return err
	}
{{end}}{{end}}	return nil
}

// Ensure CacheAdapter implements Cache interface
var _ Cache = (*CacheAdapter)(nil)