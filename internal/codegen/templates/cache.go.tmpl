// Code generated by codegen cache. DO NOT EDIT.
package {{.Package}}

import (
	"context"
	"time"

	genericcache "github.com/archesai/archesai/internal/cache"
	"github.com/google/uuid"
)

// ErrCacheMiss re-exported from generic cache package
var ErrCacheMiss = genericcache.ErrCacheMiss

// Cache provides caching operations for {{.Domain}} domain.
type Cache interface {
{{range .Entities}}{{$entity := .}}{{if .XCodegen.Cache}}
	// {{.Name}} caching
	{{if contains .Operations "get"}}Get(ctx context.Context, id uuid.UUID) (*{{.Type}}, error){{end}}
	{{if contains .Operations "set"}}Set(ctx context.Context, entity *{{.Type}}, ttl time.Duration) error{{end}}
	{{if contains .Operations "delete"}}Delete(ctx context.Context, id uuid.UUID) error{{end}}
{{if .AdditionalMethods}}{{range .AdditionalMethods}}	{{.Name}}(ctx context.Context{{range $i, $param := .Params}}, {{$param}} {{paramType $param}}{{end}}) {{if eq .Returns "single"}}(*{{$entity.Type}}, error){{else if eq .Returns "multiple"}}([]*{{$entity.Type}}, error){{else}}error{{end}}
{{end}}{{end}}
{{end}}{{end}}

	// Batch operations
	FlushAll(ctx context.Context) error
}

// NewNoOpCache creates a no-op cache using the generic NoOpCache with the adapter
func NewNoOpCache() Cache {
	return NewCacheAdapter({{range $i, $e := .Entities}}{{if $e.XCodegen.Cache}}{{if $i}}, {{end}}genericcache.NewNoOpCache[{{$e.Type}}](){{end}}{{end}})
}

// CacheAdapter adapts generic cache implementations to the domain Cache interface
type CacheAdapter struct {
{{range .Entities}}{{if .XCodegen.Cache}}	{{.Name | lower}}Cache genericcache.Cache[{{.Type}}]
{{end}}{{end}}}

// NewCacheAdapter creates a new cache adapter using generic caches
func NewCacheAdapter({{range $i, $e := .Entities}}{{if $e.XCodegen.Cache}}{{if $i}}, {{end}}{{$e.Name | lower}}Cache genericcache.Cache[{{$e.Type}}]{{end}}{{end}}) Cache {
	return &CacheAdapter{
{{range .Entities}}{{if .XCodegen.Cache}}		{{.Name | lower}}Cache: {{.Name | lower}}Cache,
{{end}}{{end}}	}
}

{{range .Entities}}{{$entity := .}}{{if .XCodegen.Cache}}
// Get retrieves {{.Name | lower}} from cache by ID
func (a *CacheAdapter) Get(ctx context.Context, id uuid.UUID) (*{{.Type}}, error) {
	entity, err := a.{{.Name | lower}}Cache.Get(ctx, id.String())
	if err != nil {
		return nil, err
	}
	if entity == nil {
		return nil, ErrCacheMiss
	}
	return entity, nil
}

// Set stores {{.Name | lower}} in cache with TTL
func (a *CacheAdapter) Set(ctx context.Context, entity *{{.Type}}, ttl time.Duration) error {
	if entity == nil {
		return nil
	}
	return a.{{.Name | lower}}Cache.Set(ctx, entity.Id.String(), entity, ttl)
}

// Delete removes {{.Name | lower}} from cache
func (a *CacheAdapter) Delete(ctx context.Context, id uuid.UUID) error {
	return a.{{.Name | lower}}Cache.Delete(ctx, id.String())
}

{{if .AdditionalMethods}}{{range .AdditionalMethods}}
{{if eq .Returns "single"}}
// {{.Name}} retrieves {{$entity.Name | lower}} from cache by {{range .Params}}{{.}}{{end}}
func (a *CacheAdapter) {{.Name}}(ctx context.Context{{range $i, $param := .Params}}, {{$param}} {{paramType $param}}{{end}}) (*{{$entity.Type}}, error) {
	key := "{{index .Params 0}}:" + {{if isUUIDParam (index .Params 0)}}{{index .Params 0}}.String(){{else}}{{index .Params 0}}{{end}}
	entity, err := a.{{$entity.Name | lower}}Cache.Get(ctx, key)
	if err != nil {
		return nil, err
	}
	if entity == nil {
		return nil, ErrCacheMiss
	}
	return entity, nil
}
{{else if eq .Returns "multiple"}}
// {{.Name}} retrieves multiple {{$entity.Name | lower}}s from cache by {{range .Params}}{{.}}{{end}}
func (a *CacheAdapter) {{.Name}}(ctx context.Context{{range $i, $param := .Params}}, {{$param}} {{paramType $param}}{{end}}) ([]*{{$entity.Type}}, error) {
	// List operations typically aren't cached as they're dynamic
	// Return cache miss to fall back to database
	return nil, ErrCacheMiss
}
{{else if eq .Returns "void"}}
// {{.Name}} removes cache entries{{if .Params}} by {{range .Params}}{{.}}{{end}}{{end}}
func (a *CacheAdapter) {{.Name}}(ctx context.Context{{range $i, $param := .Params}}, {{$param}} {{paramType $param}}{{end}}) error {
	{{if .Params}}{{if len .Params | eq 1}}key := "{{index .Params 0}}:" + {{if isUUIDParam (index .Params 0)}}{{index .Params 0}}.String(){{else}}{{index .Params 0}}{{end}}
	return a.{{$entity.Name | lower}}Cache.Delete(ctx, key){{else}}// This would require a more complex implementation with multiple parameters
	// For now, returning nil as it's best-effort cleanup
	return nil{{end}}{{else}}// This would require a more complex implementation
	// For now, returning nil as it's best-effort cleanup
	return nil{{end}}
}
{{end}}{{end}}{{end}}
{{end}}{{end}}

// FlushAll clears all cached data
func (a *CacheAdapter) FlushAll(ctx context.Context) error {
{{range .Entities}}{{if .XCodegen.Cache}}	if err := a.{{.Name | lower}}Cache.Clear(ctx); err != nil {
		return err
	}
{{end}}{{end}}	return nil
}

// Ensure CacheAdapter implements Cache interface
var _ Cache = (*CacheAdapter)(nil)