// Code generated by codegen service implementation. DO NOT EDIT.
package {{.Package}}

import (
	"context"
	"database/sql"
	"errors"
	"log/slog"
{{range .Imports}}	"{{.}}"
{{end}}
)

{{range .Entities}}{{$entity := .}}
// ServiceImpl implements the Service interface for {{lower .Name}}
type ServiceImpl struct {
	repository Repository
{{if .Cache.Enabled}}	cache      Cache
{{end}}{{if .Events}}	events     EventPublisher
{{end}}	logger     *slog.Logger
}

// NewServiceImpl creates a new {{lower .Name}} service implementation
func NewServiceImpl(repository Repository{{if .Cache.Enabled}}, cache Cache{{end}}{{if .Events}}, events EventPublisher{{end}}, logger *slog.Logger) *ServiceImpl {
	return &ServiceImpl{
		repository: repository,
{{if .Cache.Enabled}}		cache:      cache,
{{end}}{{if .Events}}		events:     events,
{{end}}		logger:     logger,
	}
}

// Ensure ServiceImpl implements Service interface
var _ Service = (*ServiceImpl)(nil)

// List retrieves {{lower .Name}}s with pagination
func (s *ServiceImpl) List(ctx context.Context, limit, offset int) ([]*{{.Type}}, int64, error) {
	// Set defaults
	if limit <= 0 {
		limit = 50
	}

	// TODO: Add business logic validation here (e.g., organization access checks)

	params := List{{.Name}}sParams{
		Page: PageQuery{
			Number: offset/limit + 1,
			Size:   limit,
		},
	}

	entities, total, err := s.repository.List(ctx, params)
	if err != nil {
		s.logger.Error("failed to list {{lower .Name}}s", "error", err)
		return nil, 0, err
	}

	return entities, total, nil
}

// Get retrieves a {{lower .Name}} by ID
func (s *ServiceImpl) Get(ctx context.Context, id uuid.UUID) (*{{.Type}}, error) {
	// TODO: Add access validation here (e.g., user can access this {{lower .Name}})

	entity, err := s.repository.Get(ctx, id)
	if err != nil {
		if errors.Is(err, sql.ErrNoRows) {
			return nil, Err{{.Name}}NotFound
		}
		s.logger.Error("failed to get {{lower .Name}}", "error", err, "id", id)
		return nil, err
	}

	return entity, nil
}

// Create creates a new {{lower .Name}}
func (s *ServiceImpl) Create(ctx context.Context, req *Create{{.Name}}Request, creatorUserID string) (*{{.Type}}, error) {
	s.logger.Debug("creating {{lower .Name}}", "creator", creatorUserID)

	// TODO: Add validation here
	if err := s.validate{{.Name}}CreateRequest(req); err != nil {
		return nil, err
	}

	// TODO: Create entity from request - customize field mapping below
	entity := s.build{{.Name}}FromCreateRequest(req)

	createdEntity, err := s.repository.Create(ctx, entity)
	if err != nil {
		s.logger.Error("failed to create {{lower .Name}}", "error", err)
		return nil, err
	}

{{if .Events}}	// Publish creation event if events are configured
	if s.events != nil {
		_ = s.events.Publish{{.Name}}Created(ctx, createdEntity)
	}
{{end}}
	s.logger.Info("{{lower .Name}} created successfully", "id", createdEntity.ID)
	return createdEntity, nil
}

// Update updates a {{lower .Name}}
func (s *ServiceImpl) Update(ctx context.Context, id uuid.UUID, req *Update{{.Name}}Request) (*{{.Type}}, error) {
	// Get existing entity
	entity, err := s.repository.Get(ctx, id)
	if err != nil {
		if errors.Is(err, sql.ErrNoRows) {
			return nil, Err{{.Name}}NotFound
		}
		s.logger.Error("failed to get {{lower .Name}} for update", "error", err, "id", id)
		return nil, err
	}

	// TODO: Add access validation here

	// TODO: Update entity fields from request - customize field mapping below
	s.apply{{.Name}}UpdateRequest(entity, req)

	updatedEntity, err := s.repository.Update(ctx, id, entity)
	if err != nil {
		s.logger.Error("failed to update {{lower .Name}}", "error", err, "id", id)
		return nil, err
	}

{{if .Events}}	// Publish update event if events are configured
	if s.events != nil {
		_ = s.events.Publish{{.Name}}Updated(ctx, updatedEntity)
	}
{{end}}
	return updatedEntity, nil
}

// Delete deletes a {{lower .Name}}
func (s *ServiceImpl) Delete(ctx context.Context, id uuid.UUID) error {
	// Check if entity exists
	entity, err := s.repository.Get(ctx, id)
	if err != nil {
		if errors.Is(err, sql.ErrNoRows) {
			return Err{{.Name}}NotFound
		}
		s.logger.Error("failed to get {{lower .Name}} for deletion", "error", err, "id", id)
		return err
	}

	// TODO: Add business logic validation here (e.g., check for dependencies)

	// Delete entity
	err = s.repository.Delete(ctx, id)
	if err != nil {
		s.logger.Error("failed to delete {{lower .Name}}", "error", err, "id", id)
		return err
	}

{{if .Events}}	// Publish deletion event if events are configured
	if s.events != nil {
		_ = s.events.Publish{{.Name}}Deleted(ctx, entity)
	}
{{end}}
	return nil
}

// Helper methods - TODO: Implement these according to your business logic

// validate{{.Name}}CreateRequest validates the create request
func (s *ServiceImpl) validate{{.Name}}CreateRequest(req *Create{{.Name}}Request) error {
	// TODO: Add validation logic here
	// Example validations:
	// - Required fields check
	// - Format validation (email, etc.)
	// - Business rule validation
	return nil
}

// build{{.Name}}FromCreateRequest builds an entity from create request
func (s *ServiceImpl) build{{.Name}}FromCreateRequest(req *Create{{.Name}}Request) *{{.Type}} {
	// TODO: Map request fields to entity
	// Add default values, computed fields, etc.
	return &{{.Type}}{
		// Map fields from req to entity
		// Set default values
		// Generate computed fields (slugs, timestamps, etc.)
	}
}

// apply{{.Name}}UpdateRequest applies update request to existing entity
func (s *ServiceImpl) apply{{.Name}}UpdateRequest(entity *{{.Type}}, req *Update{{.Name}}Request) {
	// TODO: Update entity fields from request
	// Only update fields that are provided
	// Update timestamps, etc.
}
{{end}}