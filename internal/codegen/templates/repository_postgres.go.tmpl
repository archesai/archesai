// Code generated by codegen repository. DO NOT EDIT.
package {{.Package}}

import (
	"context"
	"database/sql"
	"fmt"
	
	"github.com/archesai/archesai/internal/database/postgresql"
	"github.com/google/uuid"
)

// PostgresRepository implements Repository using PostgreSQL.
type PostgresRepository struct {
	db      *sql.DB
	queries *postgresql.Queries
}

// NewPostgresRepository creates a new PostgreSQL repository.
func NewPostgresRepository(db *sql.DB) Repository {
	return &PostgresRepository{
		db:      db,
		queries: postgresql.New(db),
	}
}

{{range .Entities}}
// {{.Name}} operations

{{if contains .Operations "create"}}
func (r *PostgresRepository) Create{{.Name}}(ctx context.Context, entity *{{.Type}}) (*{{.Type}}, error) {
	{{if eq .Name "User"}}params := postgresql.CreateUserParams{
		Id:            entity.Id.String(),
		Email:         string(entity.Email),
		Name:          entity.Name,
		EmailVerified: entity.EmailVerified,
		Image:         entity.Image,
	}
	
	result, err := r.queries.CreateUser(ctx, params){{else if eq .Name "Session"}}params := postgresql.CreateSessionParams{
		Id:                     entity.Id.String(),
		UserId:                 entity.UserId,
		ExpiresAt:              entity.ExpiresAt,
		ActiveOrganizationId:   entity.ActiveOrganizationId,
	}
	
	result, err := r.queries.CreateSession(ctx, params){{else if eq .Name "Account"}}params := postgresql.CreateAccountParams{
		Id:           entity.Id.String(),
		UserId:       entity.UserId.String(),
		ProviderId:   string(entity.ProviderId),
		AccountId:    entity.AccountId,
		AccessToken:  entity.AccessToken,
		RefreshToken: entity.RefreshToken,
		IdToken:      entity.IdToken,
		Password:     entity.Password,
	}
	
	result, err := r.queries.CreateAccount(ctx, params){{end}}
	if err != nil {
		return nil, NewRepositoryError("create {{lower .Name}}", err)
	}
	
	return {{.Name}}DBToAPI(&result), nil
}
{{end}}

{{if contains .Operations "read"}}
func (r *PostgresRepository) Get{{.Name}}ByID(ctx context.Context, id uuid.UUID) (*{{.Type}}, error) {
	{{if eq .Name "User"}}result, err := r.queries.GetUserById(ctx, id.String()){{else if eq .Name "Session"}}result, err := r.queries.GetSessionById(ctx, id.String()){{else if eq .Name "Account"}}result, err := r.queries.GetAccountById(ctx, id.String()){{end}}
	if err != nil {
		if err == sql.ErrNoRows {
			return nil, NewRepositoryError("{{lower .Name}} not found", err)
		}
		return nil, NewRepositoryError("get {{lower .Name}}", err)
	}
	
	return {{.Name}}DBToAPI(&result), nil
}
{{end}}

{{if contains .Operations "update"}}
func (r *PostgresRepository) Update{{.Name}}(ctx context.Context, id uuid.UUID, entity *{{.Type}}) (*{{.Type}}, error) {
	{{if eq .Name "User"}}params := postgresql.UpdateUserParams{
		Id:            id.String(),
		Email:         string(entity.Email),
		Name:          entity.Name,
		EmailVerified: entity.EmailVerified,
		Image:         entity.Image,
	}
	
	result, err := r.queries.UpdateUser(ctx, params){{else if eq .Name "Session"}}params := postgresql.UpdateSessionParams{
		Id:                     id.String(),
		ActiveOrganizationId:   entity.ActiveOrganizationId,
	}
	
	result, err := r.queries.UpdateSession(ctx, params){{else if eq .Name "Account"}}params := postgresql.UpdateAccountParams{
		Id:           id.String(),
		AccessToken:  entity.AccessToken,
		RefreshToken: entity.RefreshToken,
		IdToken:      entity.IdToken,
		Password:     entity.Password,
	}
	
	result, err := r.queries.UpdateAccount(ctx, params){{end}}
	if err != nil {
		return nil, NewRepositoryError("update {{lower .Name}}", err)
	}
	
	return {{.Name}}DBToAPI(&result), nil
}
{{end}}

{{if contains .Operations "delete"}}
func (r *PostgresRepository) Delete{{.Name}}(ctx context.Context, id uuid.UUID) error {
	{{if eq .Name "User"}}err := r.queries.DeleteUser(ctx, id.String()){{else if eq .Name "Session"}}err := r.queries.DeleteSession(ctx, id.String()){{else if eq .Name "Account"}}err := r.queries.DeleteAccount(ctx, id.String()){{end}}
	if err != nil {
		return NewRepositoryError("delete {{lower .Name}}", err)
	}
	return nil
}
{{end}}

{{if contains .Operations "list"}}
func (r *PostgresRepository) List{{.Name}}s(ctx context.Context, params List{{.Name}}sParams) ([]*{{.Type}}, int64, error) {
	{{if eq .Name "User"}}listParams := postgresql.ListUsersParams{
		Limit:  int32(params.Limit),
		Offset: int32(params.Offset),
	}
	
	results, err := r.queries.ListUsers(ctx, listParams){{else if eq .Name "Session"}}listParams := postgresql.ListSessionsParams{
		Limit:  int32(params.Limit),
		Offset: int32(params.Offset),
	}
	
	results, err := r.queries.ListSessions(ctx, listParams){{else if eq .Name "Account"}}listParams := postgresql.ListAccountsParams{
		Limit:  int32(params.Limit),
		Offset: int32(params.Offset),
	}
	
	results, err := r.queries.ListAccounts(ctx, listParams){{end}}
	if err != nil {
		return nil, 0, NewRepositoryError("list {{lower .Name}}s", err)
	}
	
	entities := make([]*{{.Type}}, len(results))
	for i, result := range results {
		entities[i] = {{.Name}}DBToAPI(&result)
	}
	
	// For simplicity, return length as total count
	// In production, you'd want a separate count query
	return entities, int64(len(entities)), nil
}
{{end}}

{{if eq .Name "User"}}
// Additional User operations
func (r *PostgresRepository) GetUserByEmail(ctx context.Context, email string) (*{{.Type}}, error) {
	result, err := r.queries.GetUserByEmail(ctx, email)
	if err != nil {
		if err == sql.ErrNoRows {
			return nil, NewRepositoryError("user not found", err)
		}
		return nil, NewRepositoryError("get user by email", err)
	}
	
	return {{.Name}}DBToAPI(&result), nil
}
{{end}}

{{if eq .Name "Session"}}
// Additional Session operations
func (r *PostgresRepository) GetSessionByToken(ctx context.Context, token string) (*{{.Type}}, error) {
	result, err := r.queries.GetSessionByToken(ctx, token)
	if err != nil {
		if err == sql.ErrNoRows {
			return nil, NewRepositoryError("session not found", err)
		}
		return nil, NewRepositoryError("get session by token", err)
	}
	
	return {{.Name}}DBToAPI(&result), nil
}

func (r *PostgresRepository) DeleteSessionByToken(ctx context.Context, token string) error {
	err := r.queries.DeleteSessionByToken(ctx, token)
	if err != nil {
		return NewRepositoryError("delete session by token", err)
	}
	return nil
}

func (r *PostgresRepository) DeleteUserSessions(ctx context.Context, userID uuid.UUID) error {
	err := r.queries.DeleteUserSessions(ctx, userID.String())
	if err != nil {
		return NewRepositoryError("delete user sessions", err)
	}
	return nil
}
{{end}}

{{if eq .Name "Account"}}
// Additional Account operations
func (r *PostgresRepository) GetAccountByProviderID(ctx context.Context, provider, providerID string) (*{{.Type}}, error) {
	params := postgresql.GetAccountByProviderParams{
		ProviderId: provider,
		AccountId:  providerID,
	}
	
	result, err := r.queries.GetAccountByProvider(ctx, params)
	if err != nil {
		if err == sql.ErrNoRows {
			return nil, NewRepositoryError("account not found", err)
		}
		return nil, NewRepositoryError("get account by provider", err)
	}
	
	return {{.Name}}DBToAPI(&result), nil
}

func (r *PostgresRepository) ListUserAccounts(ctx context.Context, userID uuid.UUID) ([]*{{.Type}}, error) {
	results, err := r.queries.ListUserAccounts(ctx, userID.String())
	if err != nil {
		return nil, NewRepositoryError("list user accounts", err)
	}
	
	entities := make([]*{{.Type}}, len(results))
	for i, result := range results {
		entities[i] = {{.Name}}DBToAPI(&result)
	}
	
	return entities, nil
}
{{end}}
{{end}}