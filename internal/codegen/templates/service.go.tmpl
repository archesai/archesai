{{- $package := .Package -}}
{{- $entityName := .Name -}}
{{- $entityNameLower := .NameLower -}}
{{- $entityNamePlural := .NamePlural -}}
{{- $entityNamePluralLower := .NamePluralLower -}}
// Code generated by archesai/codegen. DO NOT EDIT.

package {{ $package }}

import (
	"context"
	"errors"
{{- $hasCreate := false -}}
{{- $hasUpdate := false -}}
{{- $needsFmt := false -}}
{{- $needsUUID := false -}}
{{- range .XCodegen.Repository.Operations -}}
{{- if eq . "create" -}}
{{- $hasCreate = true -}}
{{- $needsUUID = true -}}
{{- if or (eq $package "accounts") (eq $package "sessions") -}}
{{- $needsFmt = true -}}
{{- end -}}
{{- end -}}
{{- if eq . "update" -}}
{{- $hasUpdate = true -}}
{{- end -}}
{{- end }}
{{- if $needsFmt }}
	"fmt"
{{- end }}
	"log/slog"
{{- if or $hasCreate $hasUpdate }}
	"time"
{{- end }}

	"github.com/archesai/archesai/internal/database/postgresql"
{{- if $needsUUID }}
	"github.com/google/uuid"
{{- end }}
)

// ServiceInterface defines the business logic operations
type ServiceInterface interface {
{{- range .XCodegen.Repository.Operations }}
{{- if eq . "list" }}
	List(ctx context.Context, request List{{ $entityNamePlural }}RequestObject) (List{{ $entityNamePlural }}ResponseObject, error)
{{- end }}
{{- if eq . "create" }}
	Create(ctx context.Context, request Create{{ $entityName }}RequestObject) (Create{{ $entityName }}ResponseObject, error)
{{- end }}
{{- if or (eq . "get") (eq . "read") }}
	Get(ctx context.Context, request Get{{ $entityName }}RequestObject) (Get{{ $entityName }}ResponseObject, error)
{{- end }}
{{- if eq . "update" }}
	Update(ctx context.Context, request Update{{ $entityName }}RequestObject) (Update{{ $entityName }}ResponseObject, error)
{{- end }}
{{- if eq . "delete" }}
	Delete(ctx context.Context, request Delete{{ $entityName }}RequestObject) (Delete{{ $entityName }}ResponseObject, error)
{{- end }}
{{- end }}
}

// Service implements the business logic
type Service struct {
	repo   Repository
	db     *postgresql.Queries
	logger *slog.Logger
}

// NewService creates a new service implementation
func NewService(repo Repository, db *postgresql.Queries, logger *slog.Logger) *Service {
	return &Service{
		repo:   repo,
		db:     db,
		logger: logger,
	}
}

{{- range .XCodegen.Repository.Operations }}
{{- if eq . "list" }}

// List lists all {{ $entityNamePluralLower }}
func (s *Service) List(ctx context.Context, request List{{ $entityNamePlural }}RequestObject) (List{{ $entityNamePlural }}ResponseObject, error) {
	// Call repository to fetch entities using the request parameters
	entities, total, err := s.repo.List(ctx, request.Params)
	if err != nil {
		s.logger.Error("Failed to list {{ $entityNamePluralLower }}", "error", err)
		return List{{ $entityNamePlural }}400ApplicationProblemPlusJSONResponse{
			BadRequestApplicationProblemPlusJSONResponse: BadRequestApplicationProblemPlusJSONResponse{
				Detail: "Failed to list {{ $entityNamePluralLower }}",
				Status: 500,
				Title:  "Internal Server Error",
				Type:   "about:blank",
			},
		}, nil
	}

	// Convert entities to response format
	var responseData []{{ $entityName }}
	for _, entity := range entities {
		if entity != nil {
			responseData = append(responseData, *entity)
		}
	}

	return List{{ $entityNamePlural }}200JSONResponse{
		Data: responseData,
		Meta: struct {
			Total float32 `json:"total"`
		}{
			Total: float32(total),
		},
	}, nil
}
{{- end }}

{{- if eq . "create" }}

// Create creates a new {{ $entityNameLower }}
func (s *Service) Create(ctx context.Context, request Create{{ $entityName }}RequestObject) (Create{{ $entityName }}ResponseObject, error) {
	if request.Body == nil {
		return Create{{ $entityName }}400ApplicationProblemPlusJSONResponse{
			BadRequestApplicationProblemPlusJSONResponse: BadRequestApplicationProblemPlusJSONResponse{
				Detail: "Request body is required",
				Status: 400,
				Title:  "Bad Request",
				Type:   "about:blank",
			},
		}, nil
	}

	// Create entity from request
	entity := &{{ $entityName }}{
		ID:        uuid.New(),
		CreatedAt: time.Now(),
		UpdatedAt: time.Now(),
	}

	// Call repository to persist
	created, err := s.repo.Create(ctx, entity)
	if err != nil {
		s.logger.Error("Failed to create {{ $entityNameLower }}", "error", err)
		return Create{{ $entityName }}400ApplicationProblemPlusJSONResponse{
			BadRequestApplicationProblemPlusJSONResponse: BadRequestApplicationProblemPlusJSONResponse{
				Detail: "Failed to create {{ $entityNameLower }}",
				Status: 400,
				Title:  "Bad Request",
				Type:   "about:blank",
			},
		}, nil
	}

	{{- if or (eq $package "accounts") (eq $package "sessions") }}
	// Return token response for accounts and sessions
	tokenResponse := TokenResponse{
		AccessToken:  fmt.Sprintf("token_%s", created.ID.String()),
		ExpiresIn:    3600,
		RefreshToken: fmt.Sprintf("refresh_%s", created.ID.String()),
		TokenType:    "Bearer",
	}
	return Create{{ $entityName }}201JSONResponse(tokenResponse), nil
	{{- else }}
	// Check if response type has Data field (wrapped response)
	return Create{{ $entityName }}201JSONResponse{
		Data: *created,
	}, nil
	{{- end }}
}
{{- end }}

{{- if or (eq . "get") (eq . "read") }}

// Get gets a {{ $entityNameLower }} by ID
func (s *Service) Get(ctx context.Context, request Get{{ $entityName }}RequestObject) (Get{{ $entityName }}ResponseObject, error) {
	// Call repository to fetch entity
	entity, err := s.repo.Get(ctx, request.ID)
	if err != nil {
		if errors.Is(err, Err{{ $entityName }}NotFound) {
			return Get{{ $entityName }}404ApplicationProblemPlusJSONResponse{
				NotFoundApplicationProblemPlusJSONResponse: NotFoundApplicationProblemPlusJSONResponse{
					Detail: "{{ $entityName }} not found",
					Status: 404,
					Title:  "Not Found",
					Type:   "about:blank",
				},
			}, nil
		}

		s.logger.Error("Failed to get {{ $entityNameLower }}", "error", err, "id", request.ID)
		return Get{{ $entityName }}404ApplicationProblemPlusJSONResponse{
			NotFoundApplicationProblemPlusJSONResponse: NotFoundApplicationProblemPlusJSONResponse{
				Detail: "Failed to retrieve {{ $entityNameLower }}",
				Status: 404,
				Title:  "Not Found",
				Type:   "about:blank",
			},
		}, nil
	}

	return Get{{ $entityName }}200JSONResponse{
		Data: *entity,
	}, nil
}
{{- end }}

{{- if eq . "update" }}

// Update updates a {{ $entityNameLower }}
func (s *Service) Update(ctx context.Context, request Update{{ $entityName }}RequestObject) (Update{{ $entityName }}ResponseObject, error) {
	if request.Body == nil {
		return Update{{ $entityName }}404ApplicationProblemPlusJSONResponse{
			NotFoundApplicationProblemPlusJSONResponse: NotFoundApplicationProblemPlusJSONResponse{
				Detail: "Request body is required",
				Status: 400,
				Title:  "Bad Request",
				Type:   "about:blank",
			},
		}, nil
	}

	// Get existing entity to verify it exists
	existing, err := s.repo.Get(ctx, request.ID)
	if err != nil {
		if errors.Is(err, Err{{ $entityName }}NotFound) {
			return Update{{ $entityName }}404ApplicationProblemPlusJSONResponse{
				NotFoundApplicationProblemPlusJSONResponse: NotFoundApplicationProblemPlusJSONResponse{
					Detail: "{{ $entityName }} not found",
					Status: 404,
					Title:  "Not Found",
					Type:   "about:blank",
				},
			}, nil
		}
		s.logger.Error("Failed to get {{ $entityNameLower }} for update", "error", err, "id", request.ID)
		return Update{{ $entityName }}404ApplicationProblemPlusJSONResponse{
			NotFoundApplicationProblemPlusJSONResponse: NotFoundApplicationProblemPlusJSONResponse{
				Detail: "Internal server error",
				Status: 500,
				Title:  "Internal Server Error",
				Type:   "about:blank",
			},
		}, nil
	}

	// Update the entity with current timestamp
	existing.UpdatedAt = time.Now()

	// Call repository to persist changes
	updated, err := s.repo.Update(ctx, request.ID, existing)
	if err != nil {
		s.logger.Error("Failed to update {{ $entityNameLower }}", "error", err, "id", request.ID)
		return Update{{ $entityName }}404ApplicationProblemPlusJSONResponse{
			NotFoundApplicationProblemPlusJSONResponse: NotFoundApplicationProblemPlusJSONResponse{
				Detail: "Failed to update {{ $entityNameLower }}",
				Status: 500,
				Title:  "Internal Server Error",
				Type:   "about:blank",
			},
		}, nil
	}

	return Update{{ $entityName }}200JSONResponse{
		Data: *updated,
	}, nil
}
{{- end }}

{{- if eq . "delete" }}

// Delete deletes a {{ $entityNameLower }}
func (s *Service) Delete(ctx context.Context, request Delete{{ $entityName }}RequestObject) (Delete{{ $entityName }}ResponseObject, error) {
	// Check if entity exists first
	_, err := s.repo.Get(ctx, request.ID)
	if err != nil {
		if errors.Is(err, Err{{ $entityName }}NotFound) {
			return Delete{{ $entityName }}404ApplicationProblemPlusJSONResponse{
				NotFoundApplicationProblemPlusJSONResponse: NotFoundApplicationProblemPlusJSONResponse{
					Detail: "{{ $entityName }} not found",
					Status: 404,
					Title:  "Not Found",
					Type:   "about:blank",
				},
			}, nil
		}
		s.logger.Error("Failed to get {{ $entityNameLower }} for deletion", "error", err, "id", request.ID)
		return Delete{{ $entityName }}404ApplicationProblemPlusJSONResponse{
			NotFoundApplicationProblemPlusJSONResponse: NotFoundApplicationProblemPlusJSONResponse{
				Detail: "Internal server error",
				Status: 500,
				Title:  "Internal Server Error",
				Type:   "about:blank",
			},
		}, nil
	}

	// Delete the entity
	err = s.repo.Delete(ctx, request.ID)
	if err != nil {
		s.logger.Error("Failed to delete {{ $entityNameLower }}", "error", err, "id", request.ID)
		return Delete{{ $entityName }}404ApplicationProblemPlusJSONResponse{
			NotFoundApplicationProblemPlusJSONResponse: NotFoundApplicationProblemPlusJSONResponse{
				Detail: "Failed to delete {{ $entityNameLower }}",
				Status: 500,
				Title:  "Internal Server Error",
				Type:   "about:blank",
			},
		}, nil
	}

	return Delete{{ $entityName }}200JSONResponse{}, nil
}
{{- end }}
{{- end }}
