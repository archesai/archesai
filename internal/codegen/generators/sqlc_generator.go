package generators

import (
	"bytes"
	"fmt"
	"os"
	"path/filepath"
	"strings"

	sqlc "github.com/sqlc-dev/sqlc/pkg/cli"

	"github.com/archesai/archesai/pkg/storage"
)

// SQLCGenerator generates type-safe Go code from SQL queries using sqlc.
type SQLCGenerator struct{}

// Name returns the generator name.
func (g *SQLCGenerator) Name() string { return "sqlc" }

// Priority returns the generator priority.
func (g *SQLCGenerator) Priority() int { return PriorityFinal }

// Generate runs sqlc to generate Go code from SQL queries.
func (g *SQLCGenerator) Generate(ctx *GeneratorContext) error {
	// Generate sqlc.gen.yaml for postgres
	data := map[string]string{"OutputDir": ctx.Storage.BaseDir()}
	var buf bytes.Buffer
	if err := ctx.Renderer.Render(&buf, "sqlc_postgres.yaml.tmpl", data); err != nil {
		return fmt.Errorf("failed to render sqlc.yaml: %w", err)
	}
	sqlcPath := filepath.Join("infrastructure", "postgres", "sqlc.gen.yaml")
	if err := ctx.Storage.WriteFile(sqlcPath, buf.Bytes(), 0644); err != nil {
		return fmt.Errorf("failed to write sqlc.yaml: %w", err)
	}

	// Generate migrations.gen.go for embedding
	for _, dbName := range []string{"postgres", "sqlite"} {
		content := fmt.Sprintf(`// Code generated by archesai; DO NOT EDIT.

package %s

import "embed"

//go:embed migrations/*.sql
var Migrations embed.FS
`, dbName)
		path := filepath.Join("infrastructure", dbName, "migrations.gen.go")
		if err := ctx.Storage.WriteFile(path, []byte(content), 0644); err != nil {
			return fmt.Errorf("failed to write migrations.gen.go: %w", err)
		}
	}

	// Skip sqlc execution for memory storage
	if _, isMemory := ctx.Storage.(*storage.MemoryStorage); isMemory {
		return nil
	}

	// Run sqlc if queries exist
	queriesPath := filepath.Join(ctx.Storage.BaseDir(), "infrastructure", "postgres", "queries")
	entries, err := os.ReadDir(queriesPath)
	if err != nil {
		return nil
	}

	hasQueries := false
	for _, entry := range entries {
		if !entry.IsDir() && strings.HasSuffix(entry.Name(), ".gen.sql") {
			hasQueries = true
			break
		}
	}

	if hasQueries {
		fullConfigPath := filepath.Join(ctx.Storage.BaseDir(), sqlcPath)
		if code := sqlc.Run([]string{"generate", "--file", fullConfigPath}); code != 0 {
			return fmt.Errorf("sqlc generation failed with code %d", code)
		}

		// Rename .gen.sql.go files to .sql.gen.go
		repoPath := filepath.Join(
			ctx.Storage.BaseDir(), "infrastructure", "postgres", "repositories",
		)
		repoEntries, err := os.ReadDir(repoPath)
		if err != nil {
			return fmt.Errorf("failed to read repositories directory: %w", err)
		}
		for _, entry := range repoEntries {
			if strings.HasSuffix(entry.Name(), ".gen.sql.go") {
				oldPath := filepath.Join(repoPath, entry.Name())
				newName := strings.TrimSuffix(entry.Name(), ".gen.sql.go") + ".sql.gen.go"
				newPath := filepath.Join(repoPath, newName)
				if err := os.Rename(oldPath, newPath); err != nil {
					return fmt.Errorf("failed to rename %s: %w", entry.Name(), err)
				}
			}
		}
	}

	return nil
}
