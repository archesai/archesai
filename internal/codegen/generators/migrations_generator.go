package generators

import (
	"context"
	"fmt"
	"log/slog"
	"os"
	"path/filepath"
	"regexp"
	"sort"
	"strconv"

	"ariga.io/atlas/sql/migrate"
	"ariga.io/atlas/sql/postgres"
	"ariga.io/atlas/sql/schema"
	"ariga.io/atlas/sql/sqlite"

	_ "github.com/jackc/pgx/v5/stdlib" // pgx driver for database/sql
	testpostgres "github.com/testcontainers/testcontainers-go/modules/postgres"

	_ "modernc.org/sqlite" // SQLite driver for database/sql

	"github.com/archesai/archesai/pkg/database"
)

const (
	postgresSchemaName = "public"
	sqliteSchemaName   = "main"
)

// MigrationGenerator handles database migration generation using Atlas.
type MigrationGenerator struct {
	container *testpostgres.PostgresContainer
	database  *database.Database
	outputDir string
}

// Start spins up a database for migration generation.
func (m *MigrationGenerator) Start(ctx context.Context, dbType database.Type) error {
	switch dbType {
	case database.TypePostgreSQL:
		db, container, err := database.StartPostgreSQL(ctx)
		if err != nil {
			return fmt.Errorf("failed to start PostgreSQL container: %w", err)
		}
		m.database = db
		m.container = container
	case database.TypeSQLite:
		db, err := database.StartSQLite()
		if err != nil {
			return fmt.Errorf("failed to start SQLite database: %w", err)
		}
		m.database = db
	default:
		return fmt.Errorf("unsupported database type: %s", dbType)
	}
	return nil
}

// Stop terminates the database container.
func (m *MigrationGenerator) Stop(ctx context.Context) error {
	if m.database != nil && m.database.SQLDB() != nil {
		if err := m.database.SQLDB().Close(); err != nil {
			slog.Warn("Failed to close database connection", slog.String("error", err.Error()))
		}
	}
	if m.container != nil {
		slog.Debug("Stopping PostgreSQL testcontainer")
		return m.container.Terminate(ctx)
	}
	return nil
}

// GenerateMigration generates a migration by comparing the current database state
// with the desired state defined in the HCL schema.
func (m *MigrationGenerator) GenerateMigration(ctx context.Context) error {
	if m.database == nil {
		return fmt.Errorf("database not initialized, call Start() first")
	}

	var migrationDir, schemaName string
	switch m.database.Type() {
	case database.TypePostgreSQL:
		migrationDir = filepath.Join(m.outputDir, "infrastructure", "postgres", "migrations")
		schemaName = postgresSchemaName
	case database.TypeSQLite:
		migrationDir = filepath.Join(m.outputDir, "infrastructure", "sqlite", "migrations")
		schemaName = sqliteSchemaName
	default:
		return fmt.Errorf("unsupported database type: %s", m.database.Type())
	}

	if err := os.MkdirAll(migrationDir, 0755); err != nil {
		return fmt.Errorf("failed to create migration directory: %w", err)
	}

	parentDir := filepath.Dir(migrationDir)
	migrationsFS := os.DirFS(parentDir)

	runner := database.NewMigrationRunner(m.database, migrationsFS)
	if err := runner.Up(); err != nil {
		slog.Debug(
			"No existing migrations to apply or error applying them",
			slog.String("error", err.Error()),
		)
	} else {
		slog.Debug("Existing migrations applied successfully to dev database")
	}

	var driver migrate.Driver
	var err error
	switch m.database.Type() {
	case database.TypePostgreSQL:
		driver, err = postgres.Open(m.database.SQLDB())
	case database.TypeSQLite:
		driver, err = sqlite.Open(m.database.SQLDB())
	default:
		return fmt.Errorf("unsupported database type: %s", m.database.Type())
	}
	if err != nil {
		return fmt.Errorf("failed to create atlas driver: %w", err)
	}

	currentSchema, err := driver.InspectSchema(ctx, schemaName, &schema.InspectOptions{})
	if err != nil {
		return fmt.Errorf("failed to inspect current schema: %w", err)
	}

	desiredSchema, err := m.loadHCLSchema()
	if err != nil {
		return fmt.Errorf("failed to load HCL schema: %w", err)
	}

	changes, err := driver.SchemaDiff(currentSchema, desiredSchema)
	if err != nil {
		return fmt.Errorf("failed to compute schema diff: %w", err)
	}

	packageName := filepath.Base(filepath.Dir(migrationDir))
	migrationsGoPath := filepath.Join(filepath.Dir(migrationDir), "migrations.gen.go")

	migrationsGoContent := fmt.Sprintf(`// Code generated by archesai; DO NOT EDIT.

package %s

import "embed"

//go:embed migrations/*.sql
var Migrations embed.FS
`, packageName)

	if err := os.WriteFile(migrationsGoPath, []byte(migrationsGoContent), 0644); err != nil {
		return fmt.Errorf("failed to write migrations.gen.go: %w", err)
	}

	slog.Debug("Migrations embed file created", slog.String("path", migrationsGoPath))

	if len(changes) == 0 {
		slog.Debug("No schema changes detected")
		return nil
	}

	plan, err := driver.PlanChanges(ctx, "", changes)
	if err != nil {
		return fmt.Errorf("failed to plan changes: %w", err)
	}

	migrationSQL := m.formatMigrationSQL(plan)

	nextVersion := m.getNextMigrationVersion(migrationDir)
	migrationFile := fmt.Sprintf("%04d.gen.sql", nextVersion)
	migrationPath := filepath.Join(migrationDir, migrationFile)

	migrationContent := migrationSQL

	if err := os.WriteFile(migrationPath, []byte(migrationContent), 0644); err != nil {
		return fmt.Errorf("failed to write migration file: %w", err)
	}

	slog.Info("Migration file created", slog.String("path", migrationPath))
	return nil
}

func (m *MigrationGenerator) loadHCLSchema() (*schema.Schema, error) {
	var hclSchemaFile string
	switch m.database.Type() {
	case database.TypePostgreSQL:
		hclSchemaFile = filepath.Join(m.outputDir, "infrastructure", "postgres", "schema.gen.hcl")
	case database.TypeSQLite:
		hclSchemaFile = filepath.Join(m.outputDir, "infrastructure", "sqlite", "schema.gen.hcl")
	default:
		return nil, fmt.Errorf("unsupported database type for HCL schema: %s", m.database.Type())
	}

	hclData, err := os.ReadFile(hclSchemaFile)
	if err != nil {
		return nil, fmt.Errorf("failed to read HCL file: %w", err)
	}

	var s schema.Schema
	var defaultSchemaName string

	switch m.database.Type() {
	case database.TypePostgreSQL:
		defaultSchemaName = postgresSchemaName
		if err := postgres.EvalHCLBytes(hclData, &s, nil); err != nil {
			return nil, fmt.Errorf("failed to parse HCL schema: %w", err)
		}
	case database.TypeSQLite:
		defaultSchemaName = sqliteSchemaName
		if err := sqlite.EvalHCLBytes(hclData, &s, nil); err != nil {
			return nil, fmt.Errorf("failed to parse HCL schema: %w", err)
		}
	default:
		return nil, fmt.Errorf("unsupported database type: %s", m.database.Type())
	}

	s.Name = defaultSchemaName
	return &s, nil
}

// getNextMigrationVersion scans the migration directory and returns the next version number.
func (m *MigrationGenerator) getNextMigrationVersion(migrationDir string) int {
	entries, err := os.ReadDir(migrationDir)
	if err != nil {
		return 1
	}

	// Match files like "0000001.gen.sql" or "0000001.sql"
	versionRegex := regexp.MustCompile(`^(\d+)\.(?:gen\.)?sql$`)

	var versions []int
	for _, entry := range entries {
		if entry.IsDir() {
			continue
		}
		matches := versionRegex.FindStringSubmatch(entry.Name())
		if len(matches) == 2 {
			if v, err := strconv.Atoi(matches[1]); err == nil {
				versions = append(versions, v)
			}
		}
	}

	if len(versions) == 0 {
		return 0
	}

	sort.Ints(versions)
	return versions[len(versions)-1] + 1
}

func (m *MigrationGenerator) formatMigrationSQL(plan *migrate.Plan) string {
	if len(plan.Changes) == 0 {
		return ""
	}

	var sql string
	for _, change := range plan.Changes {
		if change.Comment != "" {
			sql += "-- " + change.Comment + "\n"
		}
		sql += change.Cmd
		if change.Cmd != "" && change.Cmd[len(change.Cmd)-1] != ';' {
			sql += ";"
		}
		sql += "\n"
	}
	return sql
}
