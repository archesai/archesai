package codegen

// GenerateSQLC generates SQLC queries from SQL files

import (
	"bytes"
	"fmt"
	"os"
	"path/filepath"

	sqlc "github.com/sqlc-dev/sqlc/pkg/cli"

	"github.com/archesai/archesai/pkg/storage"
)

// GenerateSQLC generates SQLC queries from SQL files
func (g *Generator) GenerateSQLC() error {

	// Ensure required directories exist for sqlc
	// This is idempotent - only creates .gitkeep if directory is empty
	requiredDirs := []struct {
		path string
		desc string
	}{
		{
			filepath.Join("generated", "infrastructure", "persistence", "postgres", "migrations"),
			"PostgreSQL migrations",
		},
		{
			filepath.Join("generated", "infrastructure", "persistence", "postgres", "queries"),
			"PostgreSQL queries",
		},
		{
			filepath.Join("generated", "infrastructure", "persistence", "sqlite", "migrations"),
			"SQLite migrations",
		},
		{
			filepath.Join("generated", "infrastructure", "persistence", "sqlite", "queries"),
			"SQLite queries",
		},
	}

	// For disk storage, ensure directories exist
	if diskStorage, ok := g.storage.(*storage.DiskStorage); ok {
		for _, dir := range requiredDirs {
			fullPath := filepath.Join(diskStorage.BaseDir(), dir.path)
			// Create directory if it doesn't exist
			if err := os.MkdirAll(fullPath, 0755); err != nil {
				return fmt.Errorf("failed to create %s directory: %w", dir.desc, err)
			}

			// Only create .gitkeep if directory is empty (idempotent)
			entries, err := os.ReadDir(fullPath)
			if err != nil {
				return fmt.Errorf("failed to read %s directory: %w", dir.desc, err)
			}

			// If directory is empty, add .gitkeep to preserve it in git
			if len(entries) == 0 {
				gitkeepPath := filepath.Join(dir.path, ".gitkeep")
				if err := g.storage.WriteFile(gitkeepPath, []byte(""), 0644); err != nil {
					return fmt.Errorf("failed to create .gitkeep in %s: %w", dir.desc, err)
				}
			}
		}
	}

	// Generate the sqlc.yaml file with the correct output paths
	sqlcConfigPath := filepath.Join(
		"generated",
		"infrastructure",
		"persistence",
		"sqlc.gen.yaml",
	)

	// Generate sqlc.yaml
	data := map[string]string{
		"OutputDir": g.storage.BaseDir(),
	}

	var buf bytes.Buffer
	if err := g.renderer.Render(&buf, "sqlc.yaml.tmpl", data); err != nil {
		return fmt.Errorf("failed to render sqlc.yaml: %w", err)
	}

	if err := g.storage.WriteFile(sqlcConfigPath, buf.Bytes(), 0644); err != nil {
		return fmt.Errorf("failed to write sqlc.yaml: %w", err)
	}

	// FIXME: Skip sqlc execution if using memory storage (e.g., dry-run mode)
	// Memory storage doesn't create actual files that sqlc can read
	if _, isMemory := g.storage.(*storage.MemoryStorage); isMemory {
		// In dry-run mode, just indicate what would be generated
		// The sqlc.gen.yaml file itself is already in memory storage
		return nil
	}

	// Check if there are any actual SQL query files before running sqlc
	hasQueries := false
	if diskStorage, ok := g.storage.(*storage.DiskStorage); ok {
		for _, dir := range []string{"postgres/queries", "sqlite/queries"} {
			fullPath := filepath.Join(
				diskStorage.BaseDir(),
				"generated",
				"infrastructure",
				"persistence",
				dir,
			)
			entries, err := os.ReadDir(fullPath)
			if err != nil {
				continue // Directory might not exist
			}
			// Check if there are any .sql files (not just .gitkeep)
			for _, entry := range entries {
				if !entry.IsDir() && filepath.Ext(entry.Name()) == ".sql" {
					hasQueries = true
					break
				}
			}
			if hasQueries {
				break
			}
		}
	}

	// Skip sqlc if no queries exist
	if !hasQueries {
		// Still create the migrations.gen.go files for embedding
		for _, dbType := range []string{"postgres", "sqlite"} {
			packageName := dbType
			migrationsGoPath := filepath.Join(
				"generated",
				"infrastructure",
				"persistence",
				dbType,
				"migrations.gen.go",
			)

			migrationsGoContent := fmt.Sprintf(`// Code generated by archesai; DO NOT EDIT.

package %s

import "embed"

//go:embed migrations/*.sql
var Migrations embed.FS
`, packageName)

			if err := g.storage.WriteFile(migrationsGoPath, []byte(migrationsGoContent), 0644); err != nil {
				return fmt.Errorf("failed to write migrations.gen.go: %w", err)
			}
		}
		return nil
	}

	// Now run sqlc with the generated config file
	// Need to construct the full path for the sqlc command
	fullConfigPath := filepath.Join(g.storage.BaseDir(), sqlcConfigPath)
	code := sqlc.Run(
		[]string{"generate", "--file", fullConfigPath},
	)
	if code != 0 {
		return fmt.Errorf("sqlc generation failed with code %d", code)
	}

	return nil
}
