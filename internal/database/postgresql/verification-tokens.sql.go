// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.30.0
// source: verification-tokens.sql

package postgresql

import (
	"context"
	"time"

	"github.com/google/uuid"
)

const createVerificationToken = `-- name: CreateVerificationToken :one
INSERT INTO
  verification_token (id, identifier, value, expires_at)
VALUES
  ($1, $2, $3, $4)
RETURNING
  id, created_at, updated_at, expires_at, identifier, value
`

type CreateVerificationTokenParams struct {
	Id         uuid.UUID
	Identifier string
	Value      string
	ExpiresAt  time.Time
}

func (q *Queries) CreateVerificationToken(ctx context.Context, arg CreateVerificationTokenParams) (VerificationToken, error) {
	row := q.db.QueryRow(ctx, createVerificationToken,
		arg.Id,
		arg.Identifier,
		arg.Value,
		arg.ExpiresAt,
	)
	var i VerificationToken
	err := row.Scan(
		&i.Id,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.ExpiresAt,
		&i.Identifier,
		&i.Value,
	)
	return i, err
}

const deleteVerificationToken = `-- name: DeleteVerificationToken :exec
DELETE FROM verification_token
WHERE
  id = $1
`

func (q *Queries) DeleteVerificationToken(ctx context.Context, id uuid.UUID) error {
	_, err := q.db.Exec(ctx, deleteVerificationToken, id)
	return err
}

const deleteVerificationTokensByIdentifier = `-- name: DeleteVerificationTokensByIdentifier :exec
DELETE FROM verification_token
WHERE
  identifier = $1
`

func (q *Queries) DeleteVerificationTokensByIdentifier(ctx context.Context, identifier string) error {
	_, err := q.db.Exec(ctx, deleteVerificationTokensByIdentifier, identifier)
	return err
}

const getVerificationToken = `-- name: GetVerificationToken :one
SELECT
  id, created_at, updated_at, expires_at, identifier, value
FROM
  verification_token
WHERE
  id = $1
LIMIT
  1
`

func (q *Queries) GetVerificationToken(ctx context.Context, id uuid.UUID) (VerificationToken, error) {
	row := q.db.QueryRow(ctx, getVerificationToken, id)
	var i VerificationToken
	err := row.Scan(
		&i.Id,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.ExpiresAt,
		&i.Identifier,
		&i.Value,
	)
	return i, err
}

const getVerificationTokenByValue = `-- name: GetVerificationTokenByValue :one
SELECT
  id, created_at, updated_at, expires_at, identifier, value
FROM
  verification_token
WHERE
  identifier = $1
  AND value = $2
LIMIT
  1
`

type GetVerificationTokenByValueParams struct {
	Identifier string
	Value      string
}

func (q *Queries) GetVerificationTokenByValue(ctx context.Context, arg GetVerificationTokenByValueParams) (VerificationToken, error) {
	row := q.db.QueryRow(ctx, getVerificationTokenByValue, arg.Identifier, arg.Value)
	var i VerificationToken
	err := row.Scan(
		&i.Id,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.ExpiresAt,
		&i.Identifier,
		&i.Value,
	)
	return i, err
}

const listVerificationTokens = `-- name: ListVerificationTokens :many
SELECT
  id, created_at, updated_at, expires_at, identifier, value
FROM
  verification_token
ORDER BY
  created_at DESC
LIMIT
  $1
OFFSET
  $2
`

type ListVerificationTokensParams struct {
	Limit  int32
	Offset int32
}

func (q *Queries) ListVerificationTokens(ctx context.Context, arg ListVerificationTokensParams) ([]VerificationToken, error) {
	rows, err := q.db.Query(ctx, listVerificationTokens, arg.Limit, arg.Offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []VerificationToken
	for rows.Next() {
		var i VerificationToken
		if err := rows.Scan(
			&i.Id,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.ExpiresAt,
			&i.Identifier,
			&i.Value,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listVerificationTokensByIdentifier = `-- name: ListVerificationTokensByIdentifier :many
SELECT
  id, created_at, updated_at, expires_at, identifier, value
FROM
  verification_token
WHERE
  identifier = $1
ORDER BY
  created_at DESC
LIMIT
  $2
OFFSET
  $3
`

type ListVerificationTokensByIdentifierParams struct {
	Identifier string
	Limit      int32
	Offset     int32
}

func (q *Queries) ListVerificationTokensByIdentifier(ctx context.Context, arg ListVerificationTokensByIdentifierParams) ([]VerificationToken, error) {
	rows, err := q.db.Query(ctx, listVerificationTokensByIdentifier, arg.Identifier, arg.Limit, arg.Offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []VerificationToken
	for rows.Next() {
		var i VerificationToken
		if err := rows.Scan(
			&i.Id,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.ExpiresAt,
			&i.Identifier,
			&i.Value,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const updateVerificationToken = `-- name: UpdateVerificationToken :one
UPDATE verification_token
SET
  value = COALESCE($2, value),
  expires_at = COALESCE($3, expires_at),
  updated_at = NOW()
WHERE
  id = $1
RETURNING
  id, created_at, updated_at, expires_at, identifier, value
`

type UpdateVerificationTokenParams struct {
	Id        uuid.UUID
	Value     *string
	ExpiresAt *time.Time
}

func (q *Queries) UpdateVerificationToken(ctx context.Context, arg UpdateVerificationTokenParams) (VerificationToken, error) {
	row := q.db.QueryRow(ctx, updateVerificationToken, arg.Id, arg.Value, arg.ExpiresAt)
	var i VerificationToken
	err := row.Scan(
		&i.Id,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.ExpiresAt,
		&i.Identifier,
		&i.Value,
	)
	return i, err
}
