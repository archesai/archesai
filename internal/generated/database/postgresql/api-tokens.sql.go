// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.29.0
// source: api-tokens.sql

package postgresql

import (
	"context"

	"github.com/jackc/pgx/v5/pgtype"
)

const createApiToken = `-- name: CreateApiToken :one
INSERT INTO api_token (
    user_id,
    name,
    key,
    prefix,
    enabled,
    expires_at,
    permissions,
    rate_limit_enabled,
    rate_limit_max,
    rate_limit_time_window,
    refill_amount,
    refill_interval,
    remaining,
    metadata
) VALUES (
    $1, $2, $3, $4, $5, $6, $7, $8, $9, $10, $11, $12, $13, $14
)
RETURNING id, created_at, updated_at, enabled, expires_at, key, last_refill, last_request, metadata, name, permissions, prefix, rate_limit_enabled, rate_limit_max, rate_limit_time_window, refill_amount, refill_interval, remaining, request_count, start, user_id
`

type CreateApiTokenParams struct {
	UserID              string             `json:"user_id"`
	Name                *string            `json:"name"`
	Key                 string             `json:"key"`
	Prefix              *string            `json:"prefix"`
	Enabled             bool               `json:"enabled"`
	ExpiresAt           pgtype.Timestamptz `json:"expires_at"`
	Permissions         *string            `json:"permissions"`
	RateLimitEnabled    bool               `json:"rate_limit_enabled"`
	RateLimitMax        pgtype.Int4        `json:"rate_limit_max"`
	RateLimitTimeWindow pgtype.Int4        `json:"rate_limit_time_window"`
	RefillAmount        pgtype.Int4        `json:"refill_amount"`
	RefillInterval      pgtype.Int4        `json:"refill_interval"`
	Remaining           pgtype.Int4        `json:"remaining"`
	Metadata            []byte             `json:"metadata"`
}

func (q *Queries) CreateApiToken(ctx context.Context, arg CreateApiTokenParams) (ApiToken, error) {
	row := q.db.QueryRow(ctx, createApiToken,
		arg.UserID,
		arg.Name,
		arg.Key,
		arg.Prefix,
		arg.Enabled,
		arg.ExpiresAt,
		arg.Permissions,
		arg.RateLimitEnabled,
		arg.RateLimitMax,
		arg.RateLimitTimeWindow,
		arg.RefillAmount,
		arg.RefillInterval,
		arg.Remaining,
		arg.Metadata,
	)
	var i ApiToken
	err := row.Scan(
		&i.ID,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.Enabled,
		&i.ExpiresAt,
		&i.Key,
		&i.LastRefill,
		&i.LastRequest,
		&i.Metadata,
		&i.Name,
		&i.Permissions,
		&i.Prefix,
		&i.RateLimitEnabled,
		&i.RateLimitMax,
		&i.RateLimitTimeWindow,
		&i.RefillAmount,
		&i.RefillInterval,
		&i.Remaining,
		&i.RequestCount,
		&i.Start,
		&i.UserID,
	)
	return i, err
}

const deleteApiToken = `-- name: DeleteApiToken :exec
DELETE FROM api_token
WHERE id = $1
`

func (q *Queries) DeleteApiToken(ctx context.Context, id string) error {
	_, err := q.db.Exec(ctx, deleteApiToken, id)
	return err
}

const deleteApiTokensByUser = `-- name: DeleteApiTokensByUser :exec
DELETE FROM api_token
WHERE user_id = $1
`

func (q *Queries) DeleteApiTokensByUser(ctx context.Context, userID string) error {
	_, err := q.db.Exec(ctx, deleteApiTokensByUser, userID)
	return err
}

const getApiToken = `-- name: GetApiToken :one
SELECT id, created_at, updated_at, enabled, expires_at, key, last_refill, last_request, metadata, name, permissions, prefix, rate_limit_enabled, rate_limit_max, rate_limit_time_window, refill_amount, refill_interval, remaining, request_count, start, user_id FROM api_token
WHERE id = $1 LIMIT 1
`

func (q *Queries) GetApiToken(ctx context.Context, id string) (ApiToken, error) {
	row := q.db.QueryRow(ctx, getApiToken, id)
	var i ApiToken
	err := row.Scan(
		&i.ID,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.Enabled,
		&i.ExpiresAt,
		&i.Key,
		&i.LastRefill,
		&i.LastRequest,
		&i.Metadata,
		&i.Name,
		&i.Permissions,
		&i.Prefix,
		&i.RateLimitEnabled,
		&i.RateLimitMax,
		&i.RateLimitTimeWindow,
		&i.RefillAmount,
		&i.RefillInterval,
		&i.Remaining,
		&i.RequestCount,
		&i.Start,
		&i.UserID,
	)
	return i, err
}

const getApiTokenByKey = `-- name: GetApiTokenByKey :one
SELECT id, created_at, updated_at, enabled, expires_at, key, last_refill, last_request, metadata, name, permissions, prefix, rate_limit_enabled, rate_limit_max, rate_limit_time_window, refill_amount, refill_interval, remaining, request_count, start, user_id FROM api_token
WHERE key = $1 LIMIT 1
`

func (q *Queries) GetApiTokenByKey(ctx context.Context, key string) (ApiToken, error) {
	row := q.db.QueryRow(ctx, getApiTokenByKey, key)
	var i ApiToken
	err := row.Scan(
		&i.ID,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.Enabled,
		&i.ExpiresAt,
		&i.Key,
		&i.LastRefill,
		&i.LastRequest,
		&i.Metadata,
		&i.Name,
		&i.Permissions,
		&i.Prefix,
		&i.RateLimitEnabled,
		&i.RateLimitMax,
		&i.RateLimitTimeWindow,
		&i.RefillAmount,
		&i.RefillInterval,
		&i.Remaining,
		&i.RequestCount,
		&i.Start,
		&i.UserID,
	)
	return i, err
}

const listApiTokens = `-- name: ListApiTokens :many
SELECT id, created_at, updated_at, enabled, expires_at, key, last_refill, last_request, metadata, name, permissions, prefix, rate_limit_enabled, rate_limit_max, rate_limit_time_window, refill_amount, refill_interval, remaining, request_count, start, user_id FROM api_token
ORDER BY created_at DESC
LIMIT $1 OFFSET $2
`

type ListApiTokensParams struct {
	Limit  int32 `json:"limit"`
	Offset int32 `json:"offset"`
}

func (q *Queries) ListApiTokens(ctx context.Context, arg ListApiTokensParams) ([]ApiToken, error) {
	rows, err := q.db.Query(ctx, listApiTokens, arg.Limit, arg.Offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []ApiToken
	for rows.Next() {
		var i ApiToken
		if err := rows.Scan(
			&i.ID,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.Enabled,
			&i.ExpiresAt,
			&i.Key,
			&i.LastRefill,
			&i.LastRequest,
			&i.Metadata,
			&i.Name,
			&i.Permissions,
			&i.Prefix,
			&i.RateLimitEnabled,
			&i.RateLimitMax,
			&i.RateLimitTimeWindow,
			&i.RefillAmount,
			&i.RefillInterval,
			&i.Remaining,
			&i.RequestCount,
			&i.Start,
			&i.UserID,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listApiTokensByUser = `-- name: ListApiTokensByUser :many
SELECT id, created_at, updated_at, enabled, expires_at, key, last_refill, last_request, metadata, name, permissions, prefix, rate_limit_enabled, rate_limit_max, rate_limit_time_window, refill_amount, refill_interval, remaining, request_count, start, user_id FROM api_token
WHERE user_id = $1
ORDER BY created_at DESC
LIMIT $2 OFFSET $3
`

type ListApiTokensByUserParams struct {
	UserID string `json:"user_id"`
	Limit  int32  `json:"limit"`
	Offset int32  `json:"offset"`
}

func (q *Queries) ListApiTokensByUser(ctx context.Context, arg ListApiTokensByUserParams) ([]ApiToken, error) {
	rows, err := q.db.Query(ctx, listApiTokensByUser, arg.UserID, arg.Limit, arg.Offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []ApiToken
	for rows.Next() {
		var i ApiToken
		if err := rows.Scan(
			&i.ID,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.Enabled,
			&i.ExpiresAt,
			&i.Key,
			&i.LastRefill,
			&i.LastRequest,
			&i.Metadata,
			&i.Name,
			&i.Permissions,
			&i.Prefix,
			&i.RateLimitEnabled,
			&i.RateLimitMax,
			&i.RateLimitTimeWindow,
			&i.RefillAmount,
			&i.RefillInterval,
			&i.Remaining,
			&i.RequestCount,
			&i.Start,
			&i.UserID,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const updateApiToken = `-- name: UpdateApiToken :one
UPDATE api_token
SET 
    name = COALESCE($2, name),
    enabled = COALESCE($3, enabled),
    expires_at = COALESCE($4, expires_at),
    permissions = COALESCE($5, permissions),
    rate_limit_enabled = COALESCE($6, rate_limit_enabled),
    rate_limit_max = COALESCE($7, rate_limit_max),
    rate_limit_time_window = COALESCE($8, rate_limit_time_window),
    metadata = COALESCE($9, metadata)
WHERE id = $1
RETURNING id, created_at, updated_at, enabled, expires_at, key, last_refill, last_request, metadata, name, permissions, prefix, rate_limit_enabled, rate_limit_max, rate_limit_time_window, refill_amount, refill_interval, remaining, request_count, start, user_id
`

type UpdateApiTokenParams struct {
	ID                  string             `json:"id"`
	Name                *string            `json:"name"`
	Enabled             pgtype.Bool        `json:"enabled"`
	ExpiresAt           pgtype.Timestamptz `json:"expires_at"`
	Permissions         *string            `json:"permissions"`
	RateLimitEnabled    pgtype.Bool        `json:"rate_limit_enabled"`
	RateLimitMax        pgtype.Int4        `json:"rate_limit_max"`
	RateLimitTimeWindow pgtype.Int4        `json:"rate_limit_time_window"`
	Metadata            []byte             `json:"metadata"`
}

func (q *Queries) UpdateApiToken(ctx context.Context, arg UpdateApiTokenParams) (ApiToken, error) {
	row := q.db.QueryRow(ctx, updateApiToken,
		arg.ID,
		arg.Name,
		arg.Enabled,
		arg.ExpiresAt,
		arg.Permissions,
		arg.RateLimitEnabled,
		arg.RateLimitMax,
		arg.RateLimitTimeWindow,
		arg.Metadata,
	)
	var i ApiToken
	err := row.Scan(
		&i.ID,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.Enabled,
		&i.ExpiresAt,
		&i.Key,
		&i.LastRefill,
		&i.LastRequest,
		&i.Metadata,
		&i.Name,
		&i.Permissions,
		&i.Prefix,
		&i.RateLimitEnabled,
		&i.RateLimitMax,
		&i.RateLimitTimeWindow,
		&i.RefillAmount,
		&i.RefillInterval,
		&i.Remaining,
		&i.RequestCount,
		&i.Start,
		&i.UserID,
	)
	return i, err
}
