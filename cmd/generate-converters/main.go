// Package main provides a code generator for creating type converters between database and API models.
package main

import (
	"bytes"
	"fmt"
	"go/ast"
	"go/format"
	"go/parser"
	"go/token"
	"log"
	"os"
	"path/filepath"
	"sort"
	"strings"
	"text/template"

	"gopkg.in/yaml.v3"
)

const converterTemplate = `// Code generated by generate-converters. DO NOT EDIT.
package converters

import (
	"encoding/json"
	"time"
	
	"github.com/archesai/archesai/internal/generated/api"
	"github.com/archesai/archesai/internal/generated/database/postgresql"
	"github.com/google/uuid"
	"github.com/jackc/pgx/v5/pgtype"
	openapi_types "github.com/oapi-codegen/runtime/types"
)

// Helper functions
func handleNullableString(s *string) string {
	if s == nil {
		return ""
	}
	return *s
}

func handleNullableTime(t *time.Time) string {
	if t == nil {
		return ""
	}
	return t.Format(time.RFC3339)
}

func handleNullableTimestamp(ts pgtype.Timestamptz) time.Time {
	if !ts.Valid {
		return time.Time{}
	}
	return ts.Time
}

func handleNullableJSON(j *string) *json.RawMessage {
	if j == nil {
		return nil
	}
	raw := json.RawMessage(*j)
	return &raw
}

{{ range .Converters }}
// {{ .Name }} converts {{ .From }} to {{ .To }}
func {{ .Name }}(from {{ .FromType }}) {{ .ToType }} {
	return {{ .ToPrefix }}{{ .ToVar }}{
		{{- range .Fields }}
		{{ .ToField }}: {{ .Conversion }},
		{{- end }}
	}
}
{{ end }}
`

type ConverterSpec struct {
	Name     string
	From     string
	FromType string
	To       string
	ToType   string
	ToPrefix string
	ToVar    string
	Fields   []FieldMapping
}

type FieldMapping struct {
	FromField  string
	ToField    string
	Conversion string
}

type Config struct {
	Converters []ConverterConfig `yaml:"converters"`
}

type ConverterConfig struct {
	Name      string                 `yaml:"name"`
	From      string                 `yaml:"from"`
	To        string                 `yaml:"to"`
	Automap   bool                   `yaml:"automap"`
	Mappings  map[string]string      `yaml:"mappings"`
	Overrides map[string]interface{} `yaml:"overrides"`
	Exclude   []string               `yaml:"exclude"`
}

func main() {
	// Read converter configuration
	configPath := "internal/domains/converters.yaml"
	configData, err := os.ReadFile(configPath)
	if err != nil {
		// Create default configuration if it doesn't exist
		if os.IsNotExist(err) {
			if err := createDefaultConfig(configPath); err != nil {
				log.Fatalf("Failed to create default config: %v", err)
			}
			log.Printf("Created default converter configuration at %s", configPath)
			return
		}
		log.Fatalf("Failed to read config: %v", err)
	}

	var config Config
	if err := yaml.Unmarshal(configData, &config); err != nil {
		log.Fatalf("Failed to parse config: %v", err)
	}

	// Generate converters for each domain
	domains := []string{"auth", "organizations", "workflows", "content"}
	for _, domain := range domains {
		if err := generateDomainConverters(domain, config); err != nil {
			log.Printf("Failed to generate converters for %s: %v", domain, err)
		}
	}

	log.Println("âœ… Converter generation completed successfully")
}

func generateDomainConverters(domain string, config Config) error {
	// Filter converters for this domain
	var domainConverters []ConverterSpec
	for _, conv := range config.Converters {
		// Check if converter name starts with domain or matches domain-specific patterns
		nameLower := strings.ToLower(conv.Name)
		domainMatch := strings.HasPrefix(nameLower, domain) ||
			(domain == "organizations" && (strings.HasPrefix(nameLower, "organization") ||
				strings.HasPrefix(nameLower, "member") ||
				strings.HasPrefix(nameLower, "invitation"))) ||
			(domain == "workflows" && (strings.HasPrefix(nameLower, "pipeline") ||
				strings.HasPrefix(nameLower, "run") ||
				strings.HasPrefix(nameLower, "tool"))) ||
			(domain == "content" && (strings.HasPrefix(nameLower, "artifact") ||
				strings.HasPrefix(nameLower, "label")))

		if domainMatch {
			spec := buildConverterSpec(conv)
			domainConverters = append(domainConverters, spec)
		}
	}

	if len(domainConverters) == 0 {
		return nil
	}

	// Generate code
	tmpl, err := template.New("converters").Parse(converterTemplate)
	if err != nil {
		return fmt.Errorf("failed to parse template: %w", err)
	}

	var buf bytes.Buffer
	if err := tmpl.Execute(&buf, map[string]interface{}{
		"Converters": domainConverters,
	}); err != nil {
		return fmt.Errorf("failed to execute template: %w", err)
	}

	// Format the generated code
	formatted, err := format.Source(buf.Bytes())
	if err != nil {
		return fmt.Errorf("failed to format code: %w", err)
	}

	// Write to file
	outputPath := fmt.Sprintf("internal/domains/%s/converters/converters.gen.go", domain)
	if err := os.MkdirAll(filepath.Dir(outputPath), 0755); err != nil {
		return fmt.Errorf("failed to create directory: %w", err)
	}

	if err := os.WriteFile(outputPath, formatted, 0644); err != nil {
		return fmt.Errorf("failed to write file: %w", err)
	}

	log.Printf("Generated converters for %s domain", domain)
	return nil
}

// StructField represents a field in a struct
type StructField struct {
	Name string
	Type string
	Tag  string
}

// getStructFields extracts fields from a struct in the generated code
func getStructFields(packagePath, typeName string) ([]StructField, error) {
	// Map package names to file paths
	var filePath string
	switch {
	case strings.HasPrefix(packagePath, "postgresql."):
		filePath = "internal/generated/database/postgresql/models.go"
	case strings.HasPrefix(packagePath, "api."):
		filePath = "internal/generated/api/types.gen.go"
	default:
		return nil, fmt.Errorf("unknown package: %s", packagePath)
	}

	// Parse the file
	fset := token.NewFileSet()
	file, err := parser.ParseFile(fset, filePath, nil, parser.ParseComments)
	if err != nil {
		return nil, fmt.Errorf("failed to parse %s: %w", filePath, err)
	}

	// Extract just the type name without package prefix
	parts := strings.Split(typeName, ".")
	structName := parts[len(parts)-1]

	// Find the struct
	var fields []StructField
	ast.Inspect(file, func(n ast.Node) bool {
		typeSpec, ok := n.(*ast.TypeSpec)
		if !ok || typeSpec.Name.Name != structName {
			return true
		}

		structType, ok := typeSpec.Type.(*ast.StructType)
		if !ok {
			return true
		}

		// Extract fields
		for _, field := range structType.Fields.List {
			if len(field.Names) == 0 {
				continue // Skip embedded fields for now
			}

			fieldName := field.Names[0].Name

			// Extract field type more accurately
			var fieldType string
			switch t := field.Type.(type) {
			case *ast.StarExpr:
				// Pointer type
				fieldType = fmt.Sprintf("*%v", t.X)
			case *ast.Ident:
				// Simple type
				fieldType = t.Name
			case *ast.SelectorExpr:
				// Package.Type
				fieldType = fmt.Sprintf("%v.%v", t.X, t.Sel)
			default:
				fieldType = fmt.Sprintf("%v", field.Type)
			}

			var tag string
			if field.Tag != nil {
				tag = field.Tag.Value
			}

			fields = append(fields, StructField{
				Name: fieldName,
				Type: fieldType,
				Tag:  tag,
			})
		}
		return false
	})

	return fields, nil
}

func buildConverterSpec(config ConverterConfig) ConverterSpec {
	spec := ConverterSpec{
		Name:     config.Name,
		From:     config.From,
		FromType: resolveType(config.From),
		To:       config.To,
		ToType:   resolveType(config.To),
		ToPrefix: getTypePrefix(config.To),
		ToVar:    getTypeName(config.To),
		Fields:   []FieldMapping{},
	}

	// Handle automap mode
	if config.Automap {
		// Get fields from both structs
		fromFields, err := getStructFields(config.From, config.From)
		if err != nil {
			log.Printf("Warning: Failed to get fields for %s: %v", config.From, err)
		}

		toFields, err := getStructFields(config.To, config.To)
		if err != nil {
			log.Printf("Warning: Failed to get fields for %s: %v", config.To, err)
		}

		// Create a map of target fields for quick lookup
		toFieldMap := make(map[string]bool)
		for _, field := range toFields {
			toFieldMap[field.Name] = true
		}

		// Create a set of excluded fields
		excludeMap := make(map[string]bool)
		for _, field := range config.Exclude {
			excludeMap[field] = true
		}

		// Create map to look up field types
		fromFieldTypes := make(map[string]string)
		for _, field := range fromFields {
			fromFieldTypes[field.Name] = field.Type
		}

		// Auto-map fields with matching names
		for _, fromField := range fromFields {
			// Skip if excluded
			if excludeMap[fromField.Name] {
				continue
			}

			// Skip if manually mapped
			if _, hasManualMapping := config.Mappings[fromField.Name]; hasManualMapping {
				continue
			}

			// Check if field exists in target struct
			if toFieldMap[fromField.Name] {
				mapping := FieldMapping{
					FromField: fromField.Name,
					ToField:   fromField.Name,
				}
				conversion := determineConversionWithType(fromField.Name, fromField.Name, config.From, config.To, fromField.Type)
				mapping.Conversion = conversion
				spec.Fields = append(spec.Fields, mapping)
			}
		}
	}

	// Add manual mappings
	for fromField, toField := range config.Mappings {
		mapping := FieldMapping{
			FromField: fromField,
			ToField:   toField,
		}

		// Determine conversion logic based on field names and types
		conversion := determineConversion(fromField, toField, config.From, config.To)
		mapping.Conversion = conversion

		spec.Fields = append(spec.Fields, mapping)
	}

	// Add overrides (these replace auto-mapped or manual mappings)
	for field, value := range config.Overrides {
		// Remove any existing mapping for this field
		newFields := []FieldMapping{}
		for _, fm := range spec.Fields {
			if fm.ToField != field {
				newFields = append(newFields, fm)
			}
		}
		spec.Fields = newFields

		// Add the override
		spec.Fields = append(spec.Fields, FieldMapping{
			ToField:    field,
			Conversion: fmt.Sprintf("%v", value),
		})
	}

	// Sort fields alphabetically by ToField for consistent output
	sort.Slice(spec.Fields, func(i, j int) bool {
		return spec.Fields[i].ToField < spec.Fields[j].ToField
	})

	return spec
}

func resolveType(typeName string) string {
	// All postgresql types are pointers when passed to converters
	if strings.HasPrefix(typeName, "postgresql.") {
		return "*" + typeName
	}
	// All API entity types are value types
	if strings.HasPrefix(typeName, "api.") && strings.HasSuffix(typeName, "Entity") {
		return typeName
	}
	return typeName
}

const (
	billingEmailField = "BillingEmail"
)

func getTypeName(fullType string) string {
	parts := strings.Split(fullType, ".")
	return parts[len(parts)-1]
}

func getTypePrefix(fullType string) string {
	if strings.Contains(fullType, "api.") {
		return "api."
	} else if strings.Contains(fullType, "postgresql.") {
		return "postgresql."
	}
	return ""
}

func determineConversionWithType(fromField, toField, fromType, toType string, fieldType string) string {
	// Check if it's a database to API conversion
	isDBToAPI := strings.Contains(fromType, "postgresql") && strings.Contains(toType, "api")

	// Special handling based on field type from AST
	if isDBToAPI {
		// Handle special cases first before general rules
		switch fromField {
		case billingEmailField:
			if strings.HasPrefix(fieldType, "*string") {
				return "openapi_types.Email(handleNullableString(from.BillingEmail))"
			}
			return fmt.Sprintf("openapi_types.Email(from.%s)", fromField)
		case "Email":
			return fmt.Sprintf("openapi_types.Email(from.%s)", fromField)
		case "Credits":
			if fieldType == "int32" {
				return fmt.Sprintf("float64(from.%s)", fromField)
			}
		case "Progress":
			if fieldType == "float64" {
				return fmt.Sprintf("float32(from.%s)", fromField)
			}
		}

		// Handle nullable string fields (pointer types)
		if strings.HasPrefix(fieldType, "*string") {
			// Skip Id fields with pointers - they need special handling
			if !strings.Contains(fromField, "Id") {
				return fmt.Sprintf("handleNullableString(from.%s)", fromField)
			}
		}

		// Handle UUID conversions for Id fields
		if strings.Contains(fromField, "Id") && (fieldType == "string" || strings.HasPrefix(fieldType, "*string")) {
			// Special case: Some OrganizationId fields are string, not UUID
			if fromField == "OrganizationId" {
				// For now, check the target type - if ArtifactEntity, LabelEntity, etc., it's string
				if strings.Contains(toType, "ArtifactEntity") ||
					strings.Contains(toType, "LabelEntity") ||
					strings.Contains(toType, "RunEntity") ||
					strings.Contains(toType, "ToolEntity") {
					return fmt.Sprintf("from.%s", fromField)
				}
			}

			// Check if it's a pointer
			if strings.HasPrefix(fieldType, "*string") {
				return fmt.Sprintf("openapi_types.UUID(uuid.MustParse(*from.%s))", fromField)
			}
			return fmt.Sprintf("openapi_types.UUID(uuid.MustParse(from.%s))", fromField)
		}
	}

	// Fall back to original logic for other cases
	return determineConversion(fromField, toField, fromType, toType)
}

func isNullableStringField(field string) bool {
	nullableFields := map[string]bool{
		"Image": true, "Logo": true, "StripeCustomerId": true,
		"AccessToken": true, "RefreshToken": true, "IdToken": true,
		"Scope": true, "ActiveOrganizationId": true, "IpAddress": true,
		"UserAgent": true, "Description": true, "Color": true,
		"StorageProvider": true, "StorageKey": true, "ContentType": true,
		"Checksum": true, "Error": true, "UpdatedBy": true,
		"Name": true, billingEmailField: true,
	}
	return nullableFields[field]
}

// nolint:gocyclo // This function handles many field conversion cases
func determineConversionForSpecialFields(fromField, toField string, isDBToAPI bool, toType string) (string, bool) {
	switch fromField {
	case "Id":
		if isDBToAPI {
			return fmt.Sprintf("openapi_types.UUID(uuid.MustParse(from.%s))", fromField), true
		}
	case "UserId":
		if isDBToAPI && strings.Contains(toType, "AccountEntity") {
			return fmt.Sprintf("openapi_types.UUID(uuid.MustParse(from.%s))", fromField), true
		}
	case "Email":
		if isDBToAPI {
			return fmt.Sprintf("openapi_types.Email(from.%s)", fromField), true
		}
	case billingEmailField:
		if isDBToAPI {
			return "openapi_types.Email(handleNullableString(from.BillingEmail))", true
		}
	case "ProviderId":
		if toField == "ProviderId" && isDBToAPI {
			return fmt.Sprintf("api.AccountEntityProviderId(from.%s)", fromField), true
		}
	case "Plan":
		if isDBToAPI {
			return fmt.Sprintf("api.OrganizationEntityPlan(from.%s)", fromField), true
		}
	case "Credits":
		if isDBToAPI {
			return fmt.Sprintf("float64(from.%s)", fromField), true
		}
	case "ExpiresAt":
		if isDBToAPI {
			return fmt.Sprintf("from.%s.Format(time.RFC3339)", fromField), true
		}
	case "Metadata", "Config":
		if isDBToAPI {
			return fmt.Sprintf("handleNullableJSON(from.%s)", fromField), true
		}
	case "StartedAt", "CompletedAt":
		if isDBToAPI {
			return fmt.Sprintf("handleNullableTimestamp(from.%s)", fromField), true
		}
	case "Status":
		if toField == "Status" && isDBToAPI && strings.Contains(toType, "RunEntity") {
			return fmt.Sprintf("api.RunEntityStatus(from.%s)", fromField), true
		}
	case "Role":
		if toField == "Role" && isDBToAPI {
			return fmt.Sprintf("api.Role(from.%s)", fromField), true
		}
	case "Type", "Size":
		if isDBToAPI {
			return fmt.Sprintf("from.%s", fromField), true
		}
	}

	// Handle timestamp fields with prefixes
	if strings.HasSuffix(fromField, "ExpiresAt") && isDBToAPI {
		if strings.HasPrefix(fromField, "AccessToken") || strings.HasPrefix(fromField, "RefreshToken") {
			return fmt.Sprintf("handleNullableTimestamp(from.%s)", fromField), true
		}
	}

	return "", false
}

func determineConversion(fromField, toField, fromType, toType string) string {
	isDBToAPI := strings.Contains(fromType, "postgresql") && strings.Contains(toType, "api")

	// Try special field conversions first
	if conversion, handled := determineConversionForSpecialFields(fromField, toField, isDBToAPI, toType); handled {
		return conversion
	}

	// Check if it's a nullable string field
	if isNullableStringField(fromField) && isDBToAPI {
		return fmt.Sprintf("handleNullableString(from.%s)", fromField)
	}

	// Default: direct mapping
	return fmt.Sprintf("from.%s", fromField)
}

func createDefaultConfig(path string) error {
	defaultConfig := `# Converter configuration for generating type mappings between layers
converters:
  # Auth domain converters
  - name: AuthUserDBToAPI
    from: postgresql.User
    to: api.UserEntity
    mappings:
      ID: Id
      Email: Email
      Name: Name
      EmailVerified: EmailVerified
      Image: Image
      CreatedAt: CreatedAt
      UpdatedAt: UpdatedAt

  - name: AuthSessionDBToAPI
    from: postgresql.Session
    to: api.SessionEntity
    mappings:
      ID: Id
      UserID: UserId
      Token: Token
      ExpiresAt: ExpiresAt
      ActiveOrganizationID: ActiveOrganizationId
      IpAddress: IpAddress
      UserAgent: UserAgent
      CreatedAt: CreatedAt
      UpdatedAt: UpdatedAt

  - name: AuthAccountDBToAPI
    from: postgresql.Account
    to: api.AccountEntity
    mappings:
      ID: Id
      UserID: UserId
      ProviderID: ProviderId
      AccountID: AccountId
      AccessToken: AccessToken
      RefreshToken: RefreshToken
      AccessTokenExpiresAt: AccessTokenExpiresAt
      RefreshTokenExpiresAt: RefreshTokenExpiresAt
      Scope: Scope
      IdToken: IdToken
      CreatedAt: CreatedAt
      UpdatedAt: UpdatedAt

  # Admin domain converters
  - name: AdminOrganizationDBToAPI
    from: postgresql.Organization
    to: api.OrganizationEntity
    mappings:
      ID: Id
      Name: Name
      Logo: Logo
      Plan: Plan
      Credits: Credits
      BillingEmail: BillingEmail
      StripeCustomerID: StripeCustomerId
      Metadata: Metadata
      CreatedAt: CreatedAt
      UpdatedAt: UpdatedAt

  # Intelligence domain converters
  # Add converters for pipelines, artifacts, labels, etc.
`

	// Ensure directory exists
	if err := os.MkdirAll(filepath.Dir(path), 0755); err != nil {
		return err
	}

	return os.WriteFile(path, []byte(defaultConfig), 0644)
}
