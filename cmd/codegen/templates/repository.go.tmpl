package {{.Package}}

import (
	"context"
	"errors"

	"github.com/archesai/archesai/gen/db/postgresql"
	"github.com/jackc/pgx/v5"
	"github.com/jackc/pgx/v5/pgxpool"
)

var (
	Err{{.Entity}}NotFound = errors.New("{{.LowerEntity}} not found")
	Err{{.Entity}}Exists   = errors.New("{{.LowerEntity}} already exists")
)

// Repository handles {{.LowerEntity}} data persistence
type Repository struct {
	queries *postgresql.Queries
	db      *pgxpool.Pool
}

// NewRepository creates a new {{.LowerEntity}} repository
func NewRepository(db *pgxpool.Pool) *Repository {
	return &Repository{
		queries: postgresql.New(db),
		db:      db,
	}
}

// Create creates a new {{.LowerEntity}}
func (r *Repository) Create(ctx context.Context, params Create{{.Entity}}Params) (*{{.Entity}}, error) {
	db{{.Entity}}, err := r.queries.Create{{.Entity}}(ctx, &postgresql.Create{{.Entity}}Params{
		{{range .CreateFields}}{{.Name}}: params.{{.Name}},
		{{end}}
	})
	if err != nil {
		return nil, err
	}

	return r.dbToEntity(db{{.Entity}}), nil
}

// GetByID retrieves a {{.LowerEntity}} by ID
func (r *Repository) GetByID(ctx context.Context, id string) (*{{.Entity}}, error) {
	db{{.Entity}}, err := r.queries.Get{{.Entity}}(ctx, id)
	if err != nil {
		if errors.Is(err, pgx.ErrNoRows) {
			return nil, Err{{.Entity}}NotFound
		}
		return nil, err
	}

	return r.dbToEntity(db{{.Entity}}), nil
}

// Update updates a {{.LowerEntity}}
func (r *Repository) Update(ctx context.Context, id string, params Update{{.Entity}}Params) (*{{.Entity}}, error) {
	dbParams := &postgresql.Update{{.Entity}}Params{
		Id: id,
	}

	{{range .UpdateFields}}
	if params.{{.Name}} != nil {
		dbParams.{{.Name}} = params.{{.Name}}
	}
	{{end}}

	db{{.Entity}}, err := r.queries.Update{{.Entity}}(ctx, dbParams)
	if err != nil {
		if errors.Is(err, pgx.ErrNoRows) {
			return nil, Err{{.Entity}}NotFound
		}
		return nil, err
	}

	return r.dbToEntity(db{{.Entity}}), nil
}

// Delete deletes a {{.LowerEntity}}
func (r *Repository) Delete(ctx context.Context, id string) error {
	err := r.queries.Delete{{.Entity}}(ctx, id)
	if err != nil {
		if errors.Is(err, pgx.ErrNoRows) {
			return Err{{.Entity}}NotFound
		}
		return err
	}
	return nil
}

// List lists {{.LowerEntity}}s with pagination
func (r *Repository) List(ctx context.Context, params List{{.Entity}}sParams) ([]*{{.Entity}}, error) {
	if params.Limit == 0 {
		params.Limit = 50
	}

	db{{.Entity}}s, err := r.queries.List{{.Entity}}s(ctx, &postgresql.List{{.Entity}}sParams{
		Limit:  params.Limit,
		Offset: params.Offset,
	})
	if err != nil {
		return nil, err
	}

	{{.LowerEntity}}s := make([]*{{.Entity}}, len(db{{.Entity}}s))
	for i, db{{.Entity}} := range db{{.Entity}}s {
		{{.LowerEntity}}s[i] = r.dbToEntity(db{{.Entity}})
	}

	return {{.LowerEntity}}s, nil
}

// Count returns the total number of {{.LowerEntity}}s
func (r *Repository) Count(ctx context.Context) (int64, error) {
	count, err := r.queries.Count{{.Entity}}s(ctx)
	if err != nil {
		return 0, err
	}
	return count, nil
}

// dbToEntity converts a database {{.LowerEntity}} to a domain entity
func (r *Repository) dbToEntity(db{{.Entity}} *postgresql.{{.Entity}}) *{{.Entity}} {
	return &{{.Entity}}{
		{{range .EntityFields}}{{.Name}}: db{{$.Entity}}.{{.Name}},
		{{end}}
	}
}