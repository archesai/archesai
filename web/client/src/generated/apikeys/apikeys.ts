/**
 * Generated by orval v7.11.2 üç∫
 * Do not edit manually.
 * Arches AI API
 * The Arches AI API
 * OpenAPI spec version: v0.0.0
 */
import {
  useMutation,
  useQuery,
  useSuspenseQuery
} from '@tanstack/react-query';
import type {
  DataTag,
  DefinedInitialDataOptions,
  DefinedUseQueryResult,
  MutationFunction,
  QueryClient,
  QueryFunction,
  QueryKey,
  UndefinedInitialDataOptions,
  UseMutationOptions,
  UseMutationResult,
  UseQueryOptions,
  UseQueryResult,
  UseSuspenseQueryOptions,
  UseSuspenseQueryResult
} from '@tanstack/react-query';

import type {
  ApiKey,
  ApiKeyResponse,
  ApikeysCreateBody,
  ApikeysFindMany200,
  ApikeysFindManyParams,
  ApikeysUpdateBody,
  BadRequestResponse,
  NotFoundResponse,
  UnauthorizedResponse
} from '../orval.schemas';

import { customFetch } from '../../fetcher';


type SecondParameter<T extends (...args: never) => unknown> = Parameters<T>[1];



/**
 * List user's API keys (without showing the actual key values)
 * @summary List API keys
 */
export const getApikeysFindManyUrl = (params?: ApikeysFindManyParams,) => {
  const normalizedParams = new URLSearchParams();

  Object.entries(params || {}).forEach(([key, value]) => {
    
    if (value !== undefined) {
      normalizedParams.append(key, value === null ? 'null' : value.toString())
    }
  });

  const stringifiedParams = normalizedParams.toString();

  return stringifiedParams.length > 0 ? `/apikeys?${stringifiedParams}` : `/apikeys`
}

export const apikeysFindMany = async (params?: ApikeysFindManyParams, options?: RequestInit): Promise<ApikeysFindMany200> => {
  
  return customFetch<ApikeysFindMany200>(getApikeysFindManyUrl(params),
  {      
    ...options,
    method: 'GET'
    
    
  }
);}



export const getApikeysFindManyQueryKey = (params?: ApikeysFindManyParams,) => {
    return [`/apikeys`, ...(params ? [params]: [])] as const;
    }

    
export const getApikeysFindManyQueryOptions = <TData = Awaited<ReturnType<typeof apikeysFindMany>>, TError = UnauthorizedResponse>(params?: ApikeysFindManyParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof apikeysFindMany>>, TError, TData>>, request?: SecondParameter<typeof customFetch>}
) => {

const {query: queryOptions, request: requestOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getApikeysFindManyQueryKey(params);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof apikeysFindMany>>> = ({ signal }) => apikeysFindMany(params, { signal, ...requestOptions });

      

      

   return  { queryKey, queryFn, ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof apikeysFindMany>>, TError, TData> & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type ApikeysFindManyQueryResult = NonNullable<Awaited<ReturnType<typeof apikeysFindMany>>>
export type ApikeysFindManyQueryError = UnauthorizedResponse


export function useApikeysFindMany<TData = Awaited<ReturnType<typeof apikeysFindMany>>, TError = UnauthorizedResponse>(
 params: undefined |  ApikeysFindManyParams, options: { query:Partial<UseQueryOptions<Awaited<ReturnType<typeof apikeysFindMany>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof apikeysFindMany>>,
          TError,
          Awaited<ReturnType<typeof apikeysFindMany>>
        > , 'initialData'
      >, request?: SecondParameter<typeof customFetch>}
 , queryClient?: QueryClient
  ):  DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useApikeysFindMany<TData = Awaited<ReturnType<typeof apikeysFindMany>>, TError = UnauthorizedResponse>(
 params?: ApikeysFindManyParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof apikeysFindMany>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof apikeysFindMany>>,
          TError,
          Awaited<ReturnType<typeof apikeysFindMany>>
        > , 'initialData'
      >, request?: SecondParameter<typeof customFetch>}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useApikeysFindMany<TData = Awaited<ReturnType<typeof apikeysFindMany>>, TError = UnauthorizedResponse>(
 params?: ApikeysFindManyParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof apikeysFindMany>>, TError, TData>>, request?: SecondParameter<typeof customFetch>}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
/**
 * @summary List API keys
 */

export function useApikeysFindMany<TData = Awaited<ReturnType<typeof apikeysFindMany>>, TError = UnauthorizedResponse>(
 params?: ApikeysFindManyParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof apikeysFindMany>>, TError, TData>>, request?: SecondParameter<typeof customFetch>}
 , queryClient?: QueryClient 
 ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {

  const queryOptions = getApikeysFindManyQueryOptions(params,options)

  const query = useQuery(queryOptions , queryClient) as  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}



export const getApikeysFindManySuspenseQueryOptions = <TData = Awaited<ReturnType<typeof apikeysFindMany>>, TError = UnauthorizedResponse>(params?: ApikeysFindManyParams, options?: { query?:Partial<UseSuspenseQueryOptions<Awaited<ReturnType<typeof apikeysFindMany>>, TError, TData>>, request?: SecondParameter<typeof customFetch>}
) => {

const {query: queryOptions, request: requestOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getApikeysFindManyQueryKey(params);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof apikeysFindMany>>> = ({ signal }) => apikeysFindMany(params, { signal, ...requestOptions });

      

      

   return  { queryKey, queryFn, ...queryOptions} as UseSuspenseQueryOptions<Awaited<ReturnType<typeof apikeysFindMany>>, TError, TData> & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type ApikeysFindManySuspenseQueryResult = NonNullable<Awaited<ReturnType<typeof apikeysFindMany>>>
export type ApikeysFindManySuspenseQueryError = UnauthorizedResponse


export function useApikeysFindManySuspense<TData = Awaited<ReturnType<typeof apikeysFindMany>>, TError = UnauthorizedResponse>(
 params: undefined |  ApikeysFindManyParams, options: { query:Partial<UseSuspenseQueryOptions<Awaited<ReturnType<typeof apikeysFindMany>>, TError, TData>>, request?: SecondParameter<typeof customFetch>}
 , queryClient?: QueryClient
  ):  UseSuspenseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useApikeysFindManySuspense<TData = Awaited<ReturnType<typeof apikeysFindMany>>, TError = UnauthorizedResponse>(
 params?: ApikeysFindManyParams, options?: { query?:Partial<UseSuspenseQueryOptions<Awaited<ReturnType<typeof apikeysFindMany>>, TError, TData>>, request?: SecondParameter<typeof customFetch>}
 , queryClient?: QueryClient
  ):  UseSuspenseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useApikeysFindManySuspense<TData = Awaited<ReturnType<typeof apikeysFindMany>>, TError = UnauthorizedResponse>(
 params?: ApikeysFindManyParams, options?: { query?:Partial<UseSuspenseQueryOptions<Awaited<ReturnType<typeof apikeysFindMany>>, TError, TData>>, request?: SecondParameter<typeof customFetch>}
 , queryClient?: QueryClient
  ):  UseSuspenseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
/**
 * @summary List API keys
 */

export function useApikeysFindManySuspense<TData = Awaited<ReturnType<typeof apikeysFindMany>>, TError = UnauthorizedResponse>(
 params?: ApikeysFindManyParams, options?: { query?:Partial<UseSuspenseQueryOptions<Awaited<ReturnType<typeof apikeysFindMany>>, TError, TData>>, request?: SecondParameter<typeof customFetch>}
 , queryClient?: QueryClient 
 ):  UseSuspenseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {

  const queryOptions = getApikeysFindManySuspenseQueryOptions(params,options)

  const query = useSuspenseQuery(queryOptions , queryClient) as  UseSuspenseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}



/**
 * Create a new API key for authentication
 * @summary Create API key
 */
export const getApikeysCreateUrl = () => {


  

  return `/apikeys`
}

export const apikeysCreate = async (apikeysCreateBody: ApikeysCreateBody, options?: RequestInit): Promise<ApiKeyResponse> => {
  
  return customFetch<ApiKeyResponse>(getApikeysCreateUrl(),
  {      
    ...options,
    method: 'POST',
    headers: { 'Content-Type': 'application/json', ...options?.headers },
    body: JSON.stringify(
      apikeysCreateBody,)
  }
);}




export const getApikeysCreateMutationOptions = <TError = BadRequestResponse | UnauthorizedResponse,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof apikeysCreate>>, TError,{data: ApikeysCreateBody}, TContext>, request?: SecondParameter<typeof customFetch>}
): UseMutationOptions<Awaited<ReturnType<typeof apikeysCreate>>, TError,{data: ApikeysCreateBody}, TContext> => {

const mutationKey = ['apikeysCreate'];
const {mutation: mutationOptions, request: requestOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, request: undefined};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof apikeysCreate>>, {data: ApikeysCreateBody}> = (props) => {
          const {data} = props ?? {};

          return  apikeysCreate(data,requestOptions)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type ApikeysCreateMutationResult = NonNullable<Awaited<ReturnType<typeof apikeysCreate>>>
    export type ApikeysCreateMutationBody = ApikeysCreateBody
    export type ApikeysCreateMutationError = BadRequestResponse | UnauthorizedResponse

    /**
 * @summary Create API key
 */
export const useApikeysCreate = <TError = BadRequestResponse | UnauthorizedResponse,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof apikeysCreate>>, TError,{data: ApikeysCreateBody}, TContext>, request?: SecondParameter<typeof customFetch>}
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof apikeysCreate>>,
        TError,
        {data: ApikeysCreateBody},
        TContext
      > => {

      const mutationOptions = getApikeysCreateMutationOptions(options);

      return useMutation(mutationOptions , queryClient);
    }
    /**
 * Get details of a specific API key (without the actual key value)
 * @summary Get API key details
 */
export const getApikeysFindByIdUrl = (id: string | undefined | null,) => {


  

  return `/apikeys/${id}`
}

export const apikeysFindById = async (id: string | undefined | null, options?: RequestInit): Promise<ApiKey> => {
  
  return customFetch<ApiKey>(getApikeysFindByIdUrl(id),
  {      
    ...options,
    method: 'GET'
    
    
  }
);}



export const getApikeysFindByIdQueryKey = (id?: string | undefined | null,) => {
    return [`/apikeys/${id}`] as const;
    }

    
export const getApikeysFindByIdQueryOptions = <TData = Awaited<ReturnType<typeof apikeysFindById>>, TError = BadRequestResponse | UnauthorizedResponse | NotFoundResponse>(id: string | undefined | null, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof apikeysFindById>>, TError, TData>>, request?: SecondParameter<typeof customFetch>}
) => {

const {query: queryOptions, request: requestOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getApikeysFindByIdQueryKey(id);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof apikeysFindById>>> = ({ signal }) => apikeysFindById(id, { signal, ...requestOptions });

      

      

   return  { queryKey, queryFn, enabled: !!(id), ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof apikeysFindById>>, TError, TData> & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type ApikeysFindByIdQueryResult = NonNullable<Awaited<ReturnType<typeof apikeysFindById>>>
export type ApikeysFindByIdQueryError = BadRequestResponse | UnauthorizedResponse | NotFoundResponse


export function useApikeysFindById<TData = Awaited<ReturnType<typeof apikeysFindById>>, TError = BadRequestResponse | UnauthorizedResponse | NotFoundResponse>(
 id: string | undefined | null, options: { query:Partial<UseQueryOptions<Awaited<ReturnType<typeof apikeysFindById>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof apikeysFindById>>,
          TError,
          Awaited<ReturnType<typeof apikeysFindById>>
        > , 'initialData'
      >, request?: SecondParameter<typeof customFetch>}
 , queryClient?: QueryClient
  ):  DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useApikeysFindById<TData = Awaited<ReturnType<typeof apikeysFindById>>, TError = BadRequestResponse | UnauthorizedResponse | NotFoundResponse>(
 id: string | undefined | null, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof apikeysFindById>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof apikeysFindById>>,
          TError,
          Awaited<ReturnType<typeof apikeysFindById>>
        > , 'initialData'
      >, request?: SecondParameter<typeof customFetch>}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useApikeysFindById<TData = Awaited<ReturnType<typeof apikeysFindById>>, TError = BadRequestResponse | UnauthorizedResponse | NotFoundResponse>(
 id: string | undefined | null, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof apikeysFindById>>, TError, TData>>, request?: SecondParameter<typeof customFetch>}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
/**
 * @summary Get API key details
 */

export function useApikeysFindById<TData = Awaited<ReturnType<typeof apikeysFindById>>, TError = BadRequestResponse | UnauthorizedResponse | NotFoundResponse>(
 id: string | undefined | null, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof apikeysFindById>>, TError, TData>>, request?: SecondParameter<typeof customFetch>}
 , queryClient?: QueryClient 
 ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {

  const queryOptions = getApikeysFindByIdQueryOptions(id,options)

  const query = useQuery(queryOptions , queryClient) as  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}



export const getApikeysFindByIdSuspenseQueryOptions = <TData = Awaited<ReturnType<typeof apikeysFindById>>, TError = BadRequestResponse | UnauthorizedResponse | NotFoundResponse>(id: string | undefined | null, options?: { query?:Partial<UseSuspenseQueryOptions<Awaited<ReturnType<typeof apikeysFindById>>, TError, TData>>, request?: SecondParameter<typeof customFetch>}
) => {

const {query: queryOptions, request: requestOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getApikeysFindByIdQueryKey(id);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof apikeysFindById>>> = ({ signal }) => apikeysFindById(id, { signal, ...requestOptions });

      

      

   return  { queryKey, queryFn, ...queryOptions} as UseSuspenseQueryOptions<Awaited<ReturnType<typeof apikeysFindById>>, TError, TData> & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type ApikeysFindByIdSuspenseQueryResult = NonNullable<Awaited<ReturnType<typeof apikeysFindById>>>
export type ApikeysFindByIdSuspenseQueryError = BadRequestResponse | UnauthorizedResponse | NotFoundResponse


export function useApikeysFindByIdSuspense<TData = Awaited<ReturnType<typeof apikeysFindById>>, TError = BadRequestResponse | UnauthorizedResponse | NotFoundResponse>(
 id: string | undefined | null, options: { query:Partial<UseSuspenseQueryOptions<Awaited<ReturnType<typeof apikeysFindById>>, TError, TData>>, request?: SecondParameter<typeof customFetch>}
 , queryClient?: QueryClient
  ):  UseSuspenseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useApikeysFindByIdSuspense<TData = Awaited<ReturnType<typeof apikeysFindById>>, TError = BadRequestResponse | UnauthorizedResponse | NotFoundResponse>(
 id: string | undefined | null, options?: { query?:Partial<UseSuspenseQueryOptions<Awaited<ReturnType<typeof apikeysFindById>>, TError, TData>>, request?: SecondParameter<typeof customFetch>}
 , queryClient?: QueryClient
  ):  UseSuspenseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useApikeysFindByIdSuspense<TData = Awaited<ReturnType<typeof apikeysFindById>>, TError = BadRequestResponse | UnauthorizedResponse | NotFoundResponse>(
 id: string | undefined | null, options?: { query?:Partial<UseSuspenseQueryOptions<Awaited<ReturnType<typeof apikeysFindById>>, TError, TData>>, request?: SecondParameter<typeof customFetch>}
 , queryClient?: QueryClient
  ):  UseSuspenseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
/**
 * @summary Get API key details
 */

export function useApikeysFindByIdSuspense<TData = Awaited<ReturnType<typeof apikeysFindById>>, TError = BadRequestResponse | UnauthorizedResponse | NotFoundResponse>(
 id: string | undefined | null, options?: { query?:Partial<UseSuspenseQueryOptions<Awaited<ReturnType<typeof apikeysFindById>>, TError, TData>>, request?: SecondParameter<typeof customFetch>}
 , queryClient?: QueryClient 
 ):  UseSuspenseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {

  const queryOptions = getApikeysFindByIdSuspenseQueryOptions(id,options)

  const query = useSuspenseQuery(queryOptions , queryClient) as  UseSuspenseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}



/**
 * Update an API key's name, scopes, or rate limit
 * @summary Update API key
 */
export const getApikeysUpdateUrl = (id: string | undefined | null,) => {


  

  return `/apikeys/${id}`
}

export const apikeysUpdate = async (id: string | undefined | null,
    apikeysUpdateBody: ApikeysUpdateBody, options?: RequestInit): Promise<ApiKey> => {
  
  return customFetch<ApiKey>(getApikeysUpdateUrl(id),
  {      
    ...options,
    method: 'PATCH',
    headers: { 'Content-Type': 'application/json', ...options?.headers },
    body: JSON.stringify(
      apikeysUpdateBody,)
  }
);}




export const getApikeysUpdateMutationOptions = <TError = BadRequestResponse | UnauthorizedResponse | NotFoundResponse,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof apikeysUpdate>>, TError,{id: string | undefined | null;data: ApikeysUpdateBody}, TContext>, request?: SecondParameter<typeof customFetch>}
): UseMutationOptions<Awaited<ReturnType<typeof apikeysUpdate>>, TError,{id: string | undefined | null;data: ApikeysUpdateBody}, TContext> => {

const mutationKey = ['apikeysUpdate'];
const {mutation: mutationOptions, request: requestOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, request: undefined};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof apikeysUpdate>>, {id: string | undefined | null;data: ApikeysUpdateBody}> = (props) => {
          const {id,data} = props ?? {};

          return  apikeysUpdate(id,data,requestOptions)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type ApikeysUpdateMutationResult = NonNullable<Awaited<ReturnType<typeof apikeysUpdate>>>
    export type ApikeysUpdateMutationBody = ApikeysUpdateBody
    export type ApikeysUpdateMutationError = BadRequestResponse | UnauthorizedResponse | NotFoundResponse

    /**
 * @summary Update API key
 */
export const useApikeysUpdate = <TError = BadRequestResponse | UnauthorizedResponse | NotFoundResponse,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof apikeysUpdate>>, TError,{id: string | undefined | null;data: ApikeysUpdateBody}, TContext>, request?: SecondParameter<typeof customFetch>}
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof apikeysUpdate>>,
        TError,
        {id: string | undefined | null;data: ApikeysUpdateBody},
        TContext
      > => {

      const mutationOptions = getApikeysUpdateMutationOptions(options);

      return useMutation(mutationOptions , queryClient);
    }
    /**
 * Delete an API key permanently. This action cannot be undone.
 * @summary Delete API key
 */
export const getApikeysDeleteUrl = (id: string | undefined | null,) => {


  

  return `/apikeys/${id}`
}

export const apikeysDelete = async (id: string | undefined | null, options?: RequestInit): Promise<null> => {
  
  return customFetch<null>(getApikeysDeleteUrl(id),
  {      
    ...options,
    method: 'DELETE'
    
    
  }
);}




export const getApikeysDeleteMutationOptions = <TError = BadRequestResponse | UnauthorizedResponse | NotFoundResponse,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof apikeysDelete>>, TError,{id: string | undefined | null}, TContext>, request?: SecondParameter<typeof customFetch>}
): UseMutationOptions<Awaited<ReturnType<typeof apikeysDelete>>, TError,{id: string | undefined | null}, TContext> => {

const mutationKey = ['apikeysDelete'];
const {mutation: mutationOptions, request: requestOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, request: undefined};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof apikeysDelete>>, {id: string | undefined | null}> = (props) => {
          const {id} = props ?? {};

          return  apikeysDelete(id,requestOptions)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type ApikeysDeleteMutationResult = NonNullable<Awaited<ReturnType<typeof apikeysDelete>>>
    
    export type ApikeysDeleteMutationError = BadRequestResponse | UnauthorizedResponse | NotFoundResponse

    /**
 * @summary Delete API key
 */
export const useApikeysDelete = <TError = BadRequestResponse | UnauthorizedResponse | NotFoundResponse,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof apikeysDelete>>, TError,{id: string | undefined | null}, TContext>, request?: SecondParameter<typeof customFetch>}
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof apikeysDelete>>,
        TError,
        {id: string | undefined | null},
        TContext
      > => {

      const mutationOptions = getApikeysDeleteMutationOptions(options);

      return useMutation(mutationOptions , queryClient);
    }
    