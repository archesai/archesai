/**
 * Generated by orval v7.13.1 üç∫
 * Do not edit manually.
 * Arches AI API
 * The Arches AI API
 * OpenAPI spec version: v0.0.0
 */
import zod from 'zod';

/**
 * Authenticate user and create a session
 * @summary Login
 */
export const loginBodyEmailRegExp = new RegExp('^(?!\\.)(?!.*\\.\\.)([A-Za-z0-9_\'+\\-\\.]*)[A-Za-z0-9_+-]@([A-Za-z0-9][A-Za-z0-9\\-]*\\.)+[A-Za-z]{2,}$');
export const loginBodyRememberMeDefault = false;

export const loginBody = zod.object({
  "email": zod.email().min(1).regex(loginBodyEmailRegExp).describe('The email address associated with the account'),
  "password": zod.string().min(1).describe('The password for the account'),
  "rememberMe": zod.boolean().optional().describe('Whether to create a long-lived session')
})


/**
 * Logout from current session
 * @summary Logout
 */
export const logoutResponse = zod.object({
  "message": zod.string().min(1)
})


/**
 * Logout from all sessions across all devices
 * @summary Logout all sessions
 */
export const logoutAllResponseCountMin = 0;

export const logoutAllResponse = zod.object({
  "message": zod.string().min(1),
  "count": zod.number().min(logoutAllResponseCountMin).describe('Number of sessions that were terminated')
})


/**
 * Register a new user account with email and password
 * @summary Register
 */
export const registerBodyEmailRegExp = new RegExp('^(?!\\.)(?!.*\\.\\.)([A-Za-z0-9_\'+\\-\\.]*)[A-Za-z0-9_+-]@([A-Za-z0-9][A-Za-z0-9\\-]*\\.)+[A-Za-z]{2,}$');
export const registerBodyPasswordMin = 8;

export const registerBody = zod.object({
  "email": zod.email().min(1).regex(registerBodyEmailRegExp).describe('The email address for the new account'),
  "name": zod.string().min(1).describe('The name of the user'),
  "password": zod.string().min(registerBodyPasswordMin).describe('The password for the account')
})


/**
 * Request a magic link to be sent via email or generate an OTP code
 * @summary Request a magic link
 */
export const requestMagicLinkBodyDeliveryMethodDefault = "email";

export const requestMagicLinkBody = zod.object({
  "identifier": zod.string().min(1).describe('Email address or username'),
  "deliveryMethod": zod.enum(['email', 'console', 'otp', 'webhook']).default(requestMagicLinkBodyDeliveryMethodDefault).describe('How to deliver the magic link'),
  "redirectUrl": zod.url().optional().describe('URL to redirect to after successful authentication')
})

export const requestMagicLinkResponseOtpCodeMin = 6;
export const requestMagicLinkResponseOtpCodeMax = 6;export const requestMagicLinkResponseTokenIdMin = 36;export const requestMagicLinkResponseTokenUserIDMin = 36;export const requestMagicLinkResponseTokenTokenMin = 32;export const requestMagicLinkResponseTokenTokenHashMin = 64;
export const requestMagicLinkResponseTokenTokenHashMax = 64;export const requestMagicLinkResponseTokenCodeMin = 6;
export const requestMagicLinkResponseTokenCodeMax = 6;
export const requestMagicLinkResponseTokenCodeRegExp = new RegExp('^[0-9]{6}$');


export const requestMagicLinkResponse = zod.object({
  "message": zod.string().optional(),
  "otpCode": zod.string().min(requestMagicLinkResponseOtpCodeMin).max(requestMagicLinkResponseOtpCodeMax).optional().describe('OTP code (only returned if deliveryMethod is \'otp\')'),
  "expiresIn": zod.number().optional().describe('Token expiry in seconds'),
  "token": zod.object({
  "id": zod.uuid().min(requestMagicLinkResponseTokenIdMin).describe('Unique identifier for the magic link token'),
  "userID": zod.uuid().min(requestMagicLinkResponseTokenUserIDMin).optional().describe('User ID if token is for existing user'),
  "token": zod.string().min(requestMagicLinkResponseTokenTokenMin).optional().describe('The raw magic link token'),
  "tokenHash": zod.string().min(requestMagicLinkResponseTokenTokenHashMin).max(requestMagicLinkResponseTokenTokenHashMax).describe('SHA256 hash of the magic link token'),
  "code": zod.string().min(requestMagicLinkResponseTokenCodeMin).max(requestMagicLinkResponseTokenCodeMax).regex(requestMagicLinkResponseTokenCodeRegExp).optional().describe('Optional 6-digit OTP code'),
  "identifier": zod.string().min(1).describe('Email or username for authentication'),
  "deliveryMethod": zod.enum(['email', 'console', 'webhook', 'otp', 'file']).optional().describe('How the magic link was delivered'),
  "expiresAt": zod.iso.datetime({}).describe('When the token expires'),
  "usedAt": zod.union([zod.iso.datetime({}),zod.null()]).optional().describe('When the token was used (null if unused)'),
  "ipAddress": zod.string().optional().describe('IP address of the request'),
  "userAgent": zod.string().optional().describe('User agent of the request'),
  "createdAt": zod.iso.datetime({}).describe('When the token was created')
}).optional().describe('Schema for MagicLinkToken entity')
})


/**
 * Verify a magic link token or OTP code and create a session
 * @summary Verify a magic link token
 */
export const verifyMagicLinkBodyTokenMin = 32;export const verifyMagicLinkBodyCodeMin = 6;
export const verifyMagicLinkBodyCodeMax = 6;
export const verifyMagicLinkBodyCodeRegExp = new RegExp('^[0-9]{6}$');


export const verifyMagicLinkBody = zod.object({
  "token": zod.string().min(verifyMagicLinkBodyTokenMin).optional().describe('Magic link token from URL'),
  "code": zod.string().min(verifyMagicLinkBodyCodeMin).max(verifyMagicLinkBodyCodeMax).regex(verifyMagicLinkBodyCodeRegExp).optional().describe('OTP code (alternative to token)'),
  "identifier": zod.string().optional().describe('Required when using OTP code')
})


/**
 * Link an additional authentication provider to the current user account
 * @summary Link authentication provider
 */
export const linkAccountBody = zod.object({
  "provider": zod.enum(['google', 'github', 'microsoft', 'apple']).describe('The authentication provider to link'),
  "redirectUrl": zod.url().optional().describe('URL to redirect to after successful linking')
})

export const linkAccountResponse = zod.object({
  "authorizationUrl": zod.url().describe('URL to redirect the user to for provider authorization')
})


/**
 * List all active sessions for the current user
 * @summary List sessions
 */
export const listSessionsQueryPageLimitDefault = 10;
export const listSessionsQueryPageLimitMax = 100;export const listSessionsQueryPageOffsetDefault = 0;
export const listSessionsQueryPageOffsetMin = 0;
export const listSessionsQueryPageOffsetMax = 9007199254740991;

export const listSessionsQueryParams = zod.object({
  "page": zod.object({
  "limit": zod.number().min(1).max(listSessionsQueryPageLimitMax).default(listSessionsQueryPageLimitDefault).describe('Maximum number of items to return'),
  "offset": zod.number().min(listSessionsQueryPageOffsetMin).max(listSessionsQueryPageOffsetMax).optional().describe('Number of items to skip before starting to collect the result set')
}).optional().describe('The page parameter'),
  "sort": zod.array(zod.object({
  "field": zod.enum(['createdAt', 'id', 'updatedAt', 'organizationID', 'expiresAt', 'ipAddress', 'token', 'userAgent', 'userID']),
  "order": zod.enum(['asc', 'desc'])
})).optional().describe('The sort parameter')
})

export const listSessionsResponseDataItemIdMin = 36;export const listSessionsResponseDataItemOrganizationIDMin = 36;export const listSessionsResponseDataItemUserIDMin = 36;export const listSessionsResponseMetaTotalMin = 0;

export const listSessionsResponse = zod.object({
  "data": zod.array(zod.object({
  "id": zod.uuid().min(listSessionsResponseDataItemIdMin).describe('Unique identifier for the resource'),
  "createdAt": zod.iso.datetime({}).min(1).describe('The date and time when the resource was created'),
  "updatedAt": zod.iso.datetime({}).min(1).describe('The date and time when the resource was last updated')
}).describe('Base schema for all entities with common fields').and(zod.object({
  "organizationID": zod.uuid().min(listSessionsResponseDataItemOrganizationIDMin).optional().describe('The organization ID for this session (nullable for users without org)'),
  "authMethod": zod.string().optional().describe('The authentication method used (magic_link, oauth_google, oauth_github, etc.)'),
  "authProvider": zod.string().optional().describe('The authentication provider (google, github, microsoft, local)'),
  "expiresAt": zod.iso.datetime({}).min(1).describe('The expiration date of the session'),
  "ipAddress": zod.string().min(1).optional().describe('The IP address of the session'),
  "token": zod.string().min(1).describe('The session token'),
  "userAgent": zod.string().min(1).optional().describe('The user agent of the session'),
  "userID": zod.uuid().min(listSessionsResponseDataItemUserIDMin).describe('The user who owns this session')
})).describe('Schema for Session entity')),
  "meta": zod.object({
  "total": zod.number().min(listSessionsResponseMetaTotalMin).describe('Total number of sessions')
})
})


/**
 * Delete a specific session (logout from that session)
 * @summary Delete session (Logout)
 */
export const deleteSessionPathIdMin = 36;

export const deleteSessionParams = zod.object({
  "id": zod.uuid().min(deleteSessionPathIdMin).describe('The unique identifier of the session.')
})

export const deleteSessionResponseDataIdMin = 36;export const deleteSessionResponseDataOrganizationIDMin = 36;export const deleteSessionResponseDataUserIDMin = 36;

export const deleteSessionResponse = zod.object({
  "data": zod.object({
  "id": zod.uuid().min(deleteSessionResponseDataIdMin).describe('Unique identifier for the resource'),
  "createdAt": zod.iso.datetime({}).min(1).describe('The date and time when the resource was created'),
  "updatedAt": zod.iso.datetime({}).min(1).describe('The date and time when the resource was last updated')
}).describe('Base schema for all entities with common fields').and(zod.object({
  "organizationID": zod.uuid().min(deleteSessionResponseDataOrganizationIDMin).optional().describe('The organization ID for this session (nullable for users without org)'),
  "authMethod": zod.string().optional().describe('The authentication method used (magic_link, oauth_google, oauth_github, etc.)'),
  "authProvider": zod.string().optional().describe('The authentication provider (google, github, microsoft, local)'),
  "expiresAt": zod.iso.datetime({}).min(1).describe('The expiration date of the session'),
  "ipAddress": zod.string().min(1).optional().describe('The IP address of the session'),
  "token": zod.string().min(1).describe('The session token'),
  "userAgent": zod.string().min(1).optional().describe('The user agent of the session'),
  "userID": zod.uuid().min(deleteSessionResponseDataUserIDMin).describe('The user who owns this session')
})).describe('Schema for Session entity')
})


/**
 * Find a session
 * @summary Find a session
 */
export const getSessionPathIdMin = 36;

export const getSessionParams = zod.object({
  "id": zod.uuid().min(getSessionPathIdMin).describe('The unique identifier of the resource.')
})

export const getSessionResponseDataIdMin = 36;export const getSessionResponseDataOrganizationIDMin = 36;export const getSessionResponseDataUserIDMin = 36;

export const getSessionResponse = zod.object({
  "data": zod.object({
  "id": zod.uuid().min(getSessionResponseDataIdMin).describe('Unique identifier for the resource'),
  "createdAt": zod.iso.datetime({}).min(1).describe('The date and time when the resource was created'),
  "updatedAt": zod.iso.datetime({}).min(1).describe('The date and time when the resource was last updated')
}).describe('Base schema for all entities with common fields').and(zod.object({
  "organizationID": zod.uuid().min(getSessionResponseDataOrganizationIDMin).optional().describe('The organization ID for this session (nullable for users without org)'),
  "authMethod": zod.string().optional().describe('The authentication method used (magic_link, oauth_google, oauth_github, etc.)'),
  "authProvider": zod.string().optional().describe('The authentication provider (google, github, microsoft, local)'),
  "expiresAt": zod.iso.datetime({}).min(1).describe('The expiration date of the session'),
  "ipAddress": zod.string().min(1).optional().describe('The IP address of the session'),
  "token": zod.string().min(1).describe('The session token'),
  "userAgent": zod.string().min(1).optional().describe('The user agent of the session'),
  "userID": zod.uuid().min(getSessionResponseDataUserIDMin).describe('The user who owns this session')
})).describe('Schema for Session entity')
})


/**
 * This endpoint will update the active organization for the current session
 * @summary Update Session
 */
export const updateSessionPathIdMin = 36;

export const updateSessionParams = zod.object({
  "id": zod.uuid().min(updateSessionPathIdMin).describe('The unique identifier of the resource.')
})

export const updateSessionBodyOrganizationIDMin = 36;

export const updateSessionBody = zod.object({
  "organizationID": zod.uuid().min(updateSessionBodyOrganizationIDMin).describe('The organization ID to set as active for this session')
})

export const updateSessionResponseDataIdMin = 36;export const updateSessionResponseDataOrganizationIDMin = 36;export const updateSessionResponseDataUserIDMin = 36;

export const updateSessionResponse = zod.object({
  "data": zod.object({
  "id": zod.uuid().min(updateSessionResponseDataIdMin).describe('Unique identifier for the resource'),
  "createdAt": zod.iso.datetime({}).min(1).describe('The date and time when the resource was created'),
  "updatedAt": zod.iso.datetime({}).min(1).describe('The date and time when the resource was last updated')
}).describe('Base schema for all entities with common fields').and(zod.object({
  "organizationID": zod.uuid().min(updateSessionResponseDataOrganizationIDMin).optional().describe('The organization ID for this session (nullable for users without org)'),
  "authMethod": zod.string().optional().describe('The authentication method used (magic_link, oauth_google, oauth_github, etc.)'),
  "authProvider": zod.string().optional().describe('The authentication provider (google, github, microsoft, local)'),
  "expiresAt": zod.iso.datetime({}).min(1).describe('The expiration date of the session'),
  "ipAddress": zod.string().min(1).optional().describe('The IP address of the session'),
  "token": zod.string().min(1).describe('The session token'),
  "userAgent": zod.string().min(1).optional().describe('The user agent of the session'),
  "userID": zod.uuid().min(updateSessionResponseDataUserIDMin).describe('The user who owns this session')
})).describe('Schema for Session entity')
})


/**
 * List all linked authentication providers for the current user
 * @summary List linked accounts
 */
export const listAccountsResponseDataItemIdMin = 36;export const listAccountsResponseDataItemUserIDMin = 36;export const listAccountsResponseMetaTotalMin = 0;

export const listAccountsResponse = zod.object({
  "data": zod.array(zod.object({
  "id": zod.uuid().min(listAccountsResponseDataItemIdMin).describe('Unique identifier for the resource'),
  "createdAt": zod.iso.datetime({}).min(1).describe('The date and time when the resource was created'),
  "updatedAt": zod.iso.datetime({}).min(1).describe('The date and time when the resource was last updated')
}).describe('Base schema for all entities with common fields').and(zod.object({
  "accountIdentifier": zod.string().min(1).describe('The unique identifier for the account from the provider'),
  "userID": zod.uuid().min(listAccountsResponseDataItemUserIDMin).describe('The user ID this account belongs to'),
  "provider": zod.enum(['local', 'google', 'github', 'microsoft', 'apple']).describe('The authentication provider identifier'),
  "accessToken": zod.string().optional().describe('The OAuth access token'),
  "accessTokenExpiresAt": zod.iso.datetime({}).optional().describe('The access token expiration timestamp'),
  "refreshToken": zod.string().optional().describe('The OAuth refresh token'),
  "refreshTokenExpiresAt": zod.iso.datetime({}).optional().describe('The refresh token expiration timestamp'),
  "idToken": zod.string().optional().describe('The OpenID Connect ID token'),
  "scope": zod.string().optional().describe('The OAuth scope granted')
})).describe('Schema for Account entity (authentication provider account)')),
  "meta": zod.object({
  "total": zod.number().min(listAccountsResponseMetaTotalMin)
})
})


/**
 * Get an account
 * @summary Find an account
 */
export const getAccountPathIdMin = 36;

export const getAccountParams = zod.object({
  "id": zod.uuid().min(getAccountPathIdMin).describe('The unique identifier of the resource')
})

export const getAccountResponseDataIdMin = 36;export const getAccountResponseDataUserIDMin = 36;

export const getAccountResponse = zod.object({
  "data": zod.object({
  "id": zod.uuid().min(getAccountResponseDataIdMin).describe('Unique identifier for the resource'),
  "createdAt": zod.iso.datetime({}).min(1).describe('The date and time when the resource was created'),
  "updatedAt": zod.iso.datetime({}).min(1).describe('The date and time when the resource was last updated')
}).describe('Base schema for all entities with common fields').and(zod.object({
  "accountIdentifier": zod.string().min(1).describe('The unique identifier for the account from the provider'),
  "userID": zod.uuid().min(getAccountResponseDataUserIDMin).describe('The user ID this account belongs to'),
  "provider": zod.enum(['local', 'google', 'github', 'microsoft', 'apple']).describe('The authentication provider identifier'),
  "accessToken": zod.string().optional().describe('The OAuth access token'),
  "accessTokenExpiresAt": zod.iso.datetime({}).optional().describe('The access token expiration timestamp'),
  "refreshToken": zod.string().optional().describe('The OAuth refresh token'),
  "refreshTokenExpiresAt": zod.iso.datetime({}).optional().describe('The refresh token expiration timestamp'),
  "idToken": zod.string().optional().describe('The OpenID Connect ID token'),
  "scope": zod.string().optional().describe('The OAuth scope granted')
})).describe('Schema for Account entity (authentication provider account)')
})


/**
 * Update an account
 * @summary Update an account
 */
export const updateAccountPathIdMin = 36;

export const updateAccountParams = zod.object({
  "id": zod.uuid().min(updateAccountPathIdMin).describe('The unique identifier of the resource')
})

export const updateAccountBody = zod.object({
  "provider": zod.string().optional().describe('The account provider'),
  "providerAccountIdentifier": zod.string().optional().describe('The provider account ID'),
  "type": zod.string().optional().describe('The account type')
})

export const updateAccountResponseDataIdMin = 36;export const updateAccountResponseDataUserIDMin = 36;

export const updateAccountResponse = zod.object({
  "data": zod.object({
  "id": zod.uuid().min(updateAccountResponseDataIdMin).describe('Unique identifier for the resource'),
  "createdAt": zod.iso.datetime({}).min(1).describe('The date and time when the resource was created'),
  "updatedAt": zod.iso.datetime({}).min(1).describe('The date and time when the resource was last updated')
}).describe('Base schema for all entities with common fields').and(zod.object({
  "accountIdentifier": zod.string().min(1).describe('The unique identifier for the account from the provider'),
  "userID": zod.uuid().min(updateAccountResponseDataUserIDMin).describe('The user ID this account belongs to'),
  "provider": zod.enum(['local', 'google', 'github', 'microsoft', 'apple']).describe('The authentication provider identifier'),
  "accessToken": zod.string().optional().describe('The OAuth access token'),
  "accessTokenExpiresAt": zod.iso.datetime({}).optional().describe('The access token expiration timestamp'),
  "refreshToken": zod.string().optional().describe('The OAuth refresh token'),
  "refreshTokenExpiresAt": zod.iso.datetime({}).optional().describe('The refresh token expiration timestamp'),
  "idToken": zod.string().optional().describe('The OpenID Connect ID token'),
  "scope": zod.string().optional().describe('The OAuth scope granted')
})).describe('Schema for Account entity (authentication provider account)')
})


/**
 * Delete an account
 * @summary Delete an account
 */
export const deleteAccountPathIdMin = 36;

export const deleteAccountParams = zod.object({
  "id": zod.uuid().min(deleteAccountPathIdMin).describe('The unique identifier of the resource')
})

export const deleteAccountResponseDataIdMin = 36;export const deleteAccountResponseDataUserIDMin = 36;

export const deleteAccountResponse = zod.object({
  "data": zod.object({
  "id": zod.uuid().min(deleteAccountResponseDataIdMin).describe('Unique identifier for the resource'),
  "createdAt": zod.iso.datetime({}).min(1).describe('The date and time when the resource was created'),
  "updatedAt": zod.iso.datetime({}).min(1).describe('The date and time when the resource was last updated')
}).describe('Base schema for all entities with common fields').and(zod.object({
  "accountIdentifier": zod.string().min(1).describe('The unique identifier for the account from the provider'),
  "userID": zod.uuid().min(deleteAccountResponseDataUserIDMin).describe('The user ID this account belongs to'),
  "provider": zod.enum(['local', 'google', 'github', 'microsoft', 'apple']).describe('The authentication provider identifier'),
  "accessToken": zod.string().optional().describe('The OAuth access token'),
  "accessTokenExpiresAt": zod.iso.datetime({}).optional().describe('The access token expiration timestamp'),
  "refreshToken": zod.string().optional().describe('The OAuth refresh token'),
  "refreshTokenExpiresAt": zod.iso.datetime({}).optional().describe('The refresh token expiration timestamp'),
  "idToken": zod.string().optional().describe('The OpenID Connect ID token'),
  "scope": zod.string().optional().describe('The OAuth scope granted')
})).describe('Schema for Account entity (authentication provider account)')
})


/**
 * This endpoint will confirm your e-mail with a token
 * @summary Confirm e-mail verification
 */
export const confirmEmailVerificationBody = zod.object({
  "token": zod.string().min(1).describe('The password reset token')
})

export const confirmEmailVerificationResponseSessionIdMin = 36;export const confirmEmailVerificationResponseSessionOrganizationIDMin = 36;export const confirmEmailVerificationResponseSessionUserIDMin = 36;export const confirmEmailVerificationResponseUserIdMin = 36;export const confirmEmailVerificationResponseUserEmailMin = 5;
export const confirmEmailVerificationResponseUserEmailMax = 255;export const confirmEmailVerificationResponseUserEmailVerifiedDefault = false;export const confirmEmailVerificationResponseUserImageMin = 5;
export const confirmEmailVerificationResponseUserImageMax = 2048;export const confirmEmailVerificationResponseUserNameMax = 255;

export const confirmEmailVerificationResponse = zod.object({
  "session": zod.object({
  "id": zod.uuid().min(confirmEmailVerificationResponseSessionIdMin).describe('Unique identifier for the resource'),
  "createdAt": zod.iso.datetime({}).min(1).describe('The date and time when the resource was created'),
  "updatedAt": zod.iso.datetime({}).min(1).describe('The date and time when the resource was last updated')
}).describe('Base schema for all entities with common fields').and(zod.object({
  "organizationID": zod.uuid().min(confirmEmailVerificationResponseSessionOrganizationIDMin).optional().describe('The organization ID for this session (nullable for users without org)'),
  "authMethod": zod.string().optional().describe('The authentication method used (magic_link, oauth_google, oauth_github, etc.)'),
  "authProvider": zod.string().optional().describe('The authentication provider (google, github, microsoft, local)'),
  "expiresAt": zod.iso.datetime({}).min(1).describe('The expiration date of the session'),
  "ipAddress": zod.string().min(1).optional().describe('The IP address of the session'),
  "token": zod.string().min(1).describe('The session token'),
  "userAgent": zod.string().min(1).optional().describe('The user agent of the session'),
  "userID": zod.uuid().min(confirmEmailVerificationResponseSessionUserIDMin).describe('The user who owns this session')
})).describe('Schema for Session entity'),
  "user": zod.object({
  "id": zod.uuid().min(confirmEmailVerificationResponseUserIdMin).describe('Unique identifier for the resource'),
  "createdAt": zod.iso.datetime({}).min(1).describe('The date and time when the resource was created'),
  "updatedAt": zod.iso.datetime({}).min(1).describe('The date and time when the resource was last updated')
}).describe('Base schema for all entities with common fields').and(zod.object({
  "email": zod.email().min(confirmEmailVerificationResponseUserEmailMin).max(confirmEmailVerificationResponseUserEmailMax).describe('The user\'s email address'),
  "emailVerified": zod.boolean().describe('Whether the user\'s email has been verified'),
  "image": zod.url().min(confirmEmailVerificationResponseUserImageMin).max(confirmEmailVerificationResponseUserImageMax).optional().describe('The user\'s avatar image URL'),
  "name": zod.string().min(1).max(confirmEmailVerificationResponseUserNameMax).describe('The user\'s display name')
})).describe('Schema for User entity')
})


/**
 * This endpoint will request a password reset link
 * @summary Request password reset
 */
export const requestPasswordResetBody = zod.object({
  "email": zod.string().min(1).describe('The e-mail to send the password reset token to')
})


/**
 * This endpoint will verify your password change with a token
 * @summary Verify password reset
 */
export const confirmPasswordResetBody = zod.object({
  "newPassword": zod.string().min(1).describe('The new password'),
  "token": zod.string().min(1).describe('The password reset token')
})


/**
 * This endpoint will request your e-mail change with a token
 * @summary Request e-mail change
 */
export const requestEmailChangeBodyNewEmailRegExp = new RegExp('^(?!\\.)(?!.*\\.\\.)([A-Za-z0-9_\'+\\-\\.]*)[A-Za-z0-9_+-]@([A-Za-z0-9][A-Za-z0-9\\-]*\\.)+[A-Za-z]{2,}$');
export const requestEmailChangeBodyUserIDMin = 36;

export const requestEmailChangeBody = zod.object({
  "newEmail": zod.email().min(1).regex(requestEmailChangeBodyNewEmailRegExp).describe('The e-mail to send the confirmation token to'),
  "userID": zod.uuid().min(requestEmailChangeBodyUserIDMin).describe('The user ID of the user requesting the email change')
})


/**
 * This endpoint will verify your e-mail change with a token
 * @summary Verify e-mail change
 */
export const confirmEmailChangeBodyNewEmailRegExp = new RegExp('^(?!\\.)(?!.*\\.\\.)([A-Za-z0-9_\'+\\-\\.]*)[A-Za-z0-9_+-]@([A-Za-z0-9][A-Za-z0-9\\-]*\\.)+[A-Za-z]{2,}$');
export const confirmEmailChangeBodyUserIDMin = 36;

export const confirmEmailChangeBody = zod.object({
  "newEmail": zod.email().min(1).regex(confirmEmailChangeBodyNewEmailRegExp).describe('The e-mail to send the confirmation token to'),
  "token": zod.string().min(1).describe('The password reset token'),
  "userID": zod.uuid().min(confirmEmailChangeBodyUserIDMin).describe('The user ID of the user requesting the email change')
})


/**
 * List users
 * @summary List users
 */
export const listUsersQueryPageLimitDefault = 10;
export const listUsersQueryPageLimitMax = 100;export const listUsersQueryPageOffsetDefault = 0;
export const listUsersQueryPageOffsetMin = 0;
export const listUsersQueryPageOffsetMax = 9007199254740991;

export const listUsersQueryParams = zod.object({
  "filter": zod.object({
  "type": zod.enum(['and', 'or', 'eq', 'ne', 'gt', 'gte', 'lt', 'lte', 'contains', 'starts_with', 'ends_with']).describe('The type of filter operation'),
  "field": zod.string().min(1).optional().describe('The field to filter on (for leaf conditions)'),
  "value": zod.any().optional().describe('The value to compare against (for leaf conditions)'),
  "children": zod.array(zod.object({
  "type": zod.enum(['and', 'or', 'eq', 'ne', 'gt', 'gte', 'lt', 'lte', 'contains', 'starts_with', 'ends_with']).describe('The type of filter operation'),
  "field": zod.string().min(1).optional().describe('The field to filter on (for leaf conditions)'),
  "value": zod.any().optional().describe('The value to compare against (for leaf conditions)'),
  "children": zod.array(zod.any()).optional().describe('Child filter nodes (for logical operators)')
}).describe('A recursive filter node that can be a condition or group')).optional().describe('Child filter nodes (for logical operators)')
}).optional().describe('Filter users by field values. Supported fields:\n- createdAt, id, updatedAt, email, emailVerified, image, name\n'),
  "page": zod.object({
  "limit": zod.number().min(1).max(listUsersQueryPageLimitMax).default(listUsersQueryPageLimitDefault).describe('Maximum number of items to return'),
  "offset": zod.number().min(listUsersQueryPageOffsetMin).max(listUsersQueryPageOffsetMax).optional().describe('Number of items to skip before starting to collect the result set')
}).optional().describe('The page parameter'),
  "sort": zod.array(zod.object({
  "field": zod.enum(['createdAt', 'id', 'updatedAt', 'email', 'emailVerified', 'image', 'name']),
  "order": zod.enum(['asc', 'desc'])
})).optional().describe('The sort parameter')
})

export const listUsersResponseDataItemIdMin = 36;export const listUsersResponseDataItemEmailMin = 5;
export const listUsersResponseDataItemEmailMax = 255;export const listUsersResponseDataItemEmailVerifiedDefault = false;export const listUsersResponseDataItemImageMin = 5;
export const listUsersResponseDataItemImageMax = 2048;export const listUsersResponseDataItemNameMax = 255;

export const listUsersResponse = zod.object({
  "data": zod.array(zod.object({
  "id": zod.uuid().min(listUsersResponseDataItemIdMin).describe('Unique identifier for the resource'),
  "createdAt": zod.iso.datetime({}).min(1).describe('The date and time when the resource was created'),
  "updatedAt": zod.iso.datetime({}).min(1).describe('The date and time when the resource was last updated')
}).describe('Base schema for all entities with common fields').and(zod.object({
  "email": zod.email().min(listUsersResponseDataItemEmailMin).max(listUsersResponseDataItemEmailMax).describe('The user\'s email address'),
  "emailVerified": zod.boolean().describe('Whether the user\'s email has been verified'),
  "image": zod.url().min(listUsersResponseDataItemImageMin).max(listUsersResponseDataItemImageMax).optional().describe('The user\'s avatar image URL'),
  "name": zod.string().min(1).max(listUsersResponseDataItemNameMax).describe('The user\'s display name')
})).describe('Schema for User entity')),
  "meta": zod.object({
  "total": zod.number().describe('Total number of items in the collection')
})
})


/**
 * Get the currently authenticated user's profile
 * @summary Get current user
 */
export const getCurrentUserResponseDataIdMin = 36;export const getCurrentUserResponseDataEmailMin = 5;
export const getCurrentUserResponseDataEmailMax = 255;export const getCurrentUserResponseDataEmailVerifiedDefault = false;export const getCurrentUserResponseDataImageMin = 5;
export const getCurrentUserResponseDataImageMax = 2048;export const getCurrentUserResponseDataNameMax = 255;

export const getCurrentUserResponse = zod.object({
  "data": zod.object({
  "id": zod.uuid().min(getCurrentUserResponseDataIdMin).describe('Unique identifier for the resource'),
  "createdAt": zod.iso.datetime({}).min(1).describe('The date and time when the resource was created'),
  "updatedAt": zod.iso.datetime({}).min(1).describe('The date and time when the resource was last updated')
}).describe('Base schema for all entities with common fields').and(zod.object({
  "email": zod.email().min(getCurrentUserResponseDataEmailMin).max(getCurrentUserResponseDataEmailMax).describe('The user\'s email address'),
  "emailVerified": zod.boolean().describe('Whether the user\'s email has been verified'),
  "image": zod.url().min(getCurrentUserResponseDataImageMin).max(getCurrentUserResponseDataImageMax).optional().describe('The user\'s avatar image URL'),
  "name": zod.string().min(1).max(getCurrentUserResponseDataNameMax).describe('The user\'s display name')
})).describe('Schema for User entity')
})


/**
 * Update the currently authenticated user's profile
 * @summary Update current user
 */
export const updateCurrentUserBodyNameMax = 255;export const updateCurrentUserBodyImageMin = 5;
export const updateCurrentUserBodyImageMax = 2048;

export const updateCurrentUserBody = zod.object({
  "name": zod.string().min(1).max(updateCurrentUserBodyNameMax).optional().describe('The user\'s display name'),
  "image": zod.url().min(updateCurrentUserBodyImageMin).max(updateCurrentUserBodyImageMax).optional().describe('The user\'s avatar image URL')
})

export const updateCurrentUserResponseDataIdMin = 36;export const updateCurrentUserResponseDataEmailMin = 5;
export const updateCurrentUserResponseDataEmailMax = 255;export const updateCurrentUserResponseDataEmailVerifiedDefault = false;export const updateCurrentUserResponseDataImageMin = 5;
export const updateCurrentUserResponseDataImageMax = 2048;export const updateCurrentUserResponseDataNameMax = 255;

export const updateCurrentUserResponse = zod.object({
  "data": zod.object({
  "id": zod.uuid().min(updateCurrentUserResponseDataIdMin).describe('Unique identifier for the resource'),
  "createdAt": zod.iso.datetime({}).min(1).describe('The date and time when the resource was created'),
  "updatedAt": zod.iso.datetime({}).min(1).describe('The date and time when the resource was last updated')
}).describe('Base schema for all entities with common fields').and(zod.object({
  "email": zod.email().min(updateCurrentUserResponseDataEmailMin).max(updateCurrentUserResponseDataEmailMax).describe('The user\'s email address'),
  "emailVerified": zod.boolean().describe('Whether the user\'s email has been verified'),
  "image": zod.url().min(updateCurrentUserResponseDataImageMin).max(updateCurrentUserResponseDataImageMax).optional().describe('The user\'s avatar image URL'),
  "name": zod.string().min(1).max(updateCurrentUserResponseDataNameMax).describe('The user\'s display name')
})).describe('Schema for User entity')
})


/**
 * Delete the currently authenticated user's account (cascades to all sessions and accounts)
 * @summary Delete current user
 */
export const deleteCurrentUserBody = zod.object({
  "confirmation": zod.enum(['DELETE_MY_ACCOUNT']).describe('Confirmation string to prevent accidental deletion')
})

export const deleteCurrentUserResponse = zod.object({
  "message": zod.string()
})


/**
 * Delete a user
 * @summary Delete a user
 */
export const deleteUserPathIdMin = 36;

export const deleteUserParams = zod.object({
  "id": zod.uuid().min(deleteUserPathIdMin).describe('The unique identifier of the resource.')
})

export const deleteUserResponseDataIdMin = 36;export const deleteUserResponseDataEmailMin = 5;
export const deleteUserResponseDataEmailMax = 255;export const deleteUserResponseDataEmailVerifiedDefault = false;export const deleteUserResponseDataImageMin = 5;
export const deleteUserResponseDataImageMax = 2048;export const deleteUserResponseDataNameMax = 255;

export const deleteUserResponse = zod.object({
  "data": zod.object({
  "id": zod.uuid().min(deleteUserResponseDataIdMin).describe('Unique identifier for the resource'),
  "createdAt": zod.iso.datetime({}).min(1).describe('The date and time when the resource was created'),
  "updatedAt": zod.iso.datetime({}).min(1).describe('The date and time when the resource was last updated')
}).describe('Base schema for all entities with common fields').and(zod.object({
  "email": zod.email().min(deleteUserResponseDataEmailMin).max(deleteUserResponseDataEmailMax).describe('The user\'s email address'),
  "emailVerified": zod.boolean().describe('Whether the user\'s email has been verified'),
  "image": zod.url().min(deleteUserResponseDataImageMin).max(deleteUserResponseDataImageMax).optional().describe('The user\'s avatar image URL'),
  "name": zod.string().min(1).max(deleteUserResponseDataNameMax).describe('The user\'s display name')
})).describe('Schema for User entity')
})


/**
 * Get a user
 * @summary Get a user
 */
export const getUserPathIdMin = 36;

export const getUserParams = zod.object({
  "id": zod.uuid().min(getUserPathIdMin).describe('The unique identifier of the resource.')
})

export const getUserResponseDataIdMin = 36;export const getUserResponseDataEmailMin = 5;
export const getUserResponseDataEmailMax = 255;export const getUserResponseDataEmailVerifiedDefault = false;export const getUserResponseDataImageMin = 5;
export const getUserResponseDataImageMax = 2048;export const getUserResponseDataNameMax = 255;

export const getUserResponse = zod.object({
  "data": zod.object({
  "id": zod.uuid().min(getUserResponseDataIdMin).describe('Unique identifier for the resource'),
  "createdAt": zod.iso.datetime({}).min(1).describe('The date and time when the resource was created'),
  "updatedAt": zod.iso.datetime({}).min(1).describe('The date and time when the resource was last updated')
}).describe('Base schema for all entities with common fields').and(zod.object({
  "email": zod.email().min(getUserResponseDataEmailMin).max(getUserResponseDataEmailMax).describe('The user\'s email address'),
  "emailVerified": zod.boolean().describe('Whether the user\'s email has been verified'),
  "image": zod.url().min(getUserResponseDataImageMin).max(getUserResponseDataImageMax).optional().describe('The user\'s avatar image URL'),
  "name": zod.string().min(1).max(getUserResponseDataNameMax).describe('The user\'s display name')
})).describe('Schema for User entity')
})


/**
 * Update an user
 * @summary Update an user
 */
export const updateUserPathIdMin = 36;

export const updateUserParams = zod.object({
  "id": zod.uuid().min(updateUserPathIdMin).describe('The unique identifier of the resource.')
})

export const updateUserBody = zod.object({
  "email": zod.string().min(1).optional().describe('The user\'s e-mail'),
  "image": zod.string().optional().describe('The user\'s avatar image URL')
})

export const updateUserResponseDataIdMin = 36;export const updateUserResponseDataEmailMin = 5;
export const updateUserResponseDataEmailMax = 255;export const updateUserResponseDataEmailVerifiedDefault = false;export const updateUserResponseDataImageMin = 5;
export const updateUserResponseDataImageMax = 2048;export const updateUserResponseDataNameMax = 255;

export const updateUserResponse = zod.object({
  "data": zod.object({
  "id": zod.uuid().min(updateUserResponseDataIdMin).describe('Unique identifier for the resource'),
  "createdAt": zod.iso.datetime({}).min(1).describe('The date and time when the resource was created'),
  "updatedAt": zod.iso.datetime({}).min(1).describe('The date and time when the resource was last updated')
}).describe('Base schema for all entities with common fields').and(zod.object({
  "email": zod.email().min(updateUserResponseDataEmailMin).max(updateUserResponseDataEmailMax).describe('The user\'s email address'),
  "emailVerified": zod.boolean().describe('Whether the user\'s email has been verified'),
  "image": zod.url().min(updateUserResponseDataImageMin).max(updateUserResponseDataImageMax).optional().describe('The user\'s avatar image URL'),
  "name": zod.string().min(1).max(updateUserResponseDataNameMax).describe('The user\'s display name')
})).describe('Schema for User entity')
})


/**
 * Redirect user to OAuth provider authorization page
 * @summary Start OAuth authorization flow
 */
export const oauthAuthorizeParams = zod.object({
  "provider": zod.enum(['google', 'github', 'microsoft']).describe('The OAuth provider to use for authorization')
})

export const oauthAuthorizeQueryParams = zod.object({
  "redirect_uri": zod.string().optional().describe('Where to redirect after authorization (optional, uses default if not provided)'),
  "scope": zod.string().optional().describe('OAuth scopes to request (optional, uses default if not provided)'),
  "state": zod.string().optional().describe('State parameter for CSRF protection')
})

export const oauthAuthorizeResponse = zod.object({
  "authorization_url": zod.string().min(1).describe('URL to redirect user for OAuth authorization')
})


/**
 * Handle the callback from OAuth provider and complete authentication
 * @summary Handle OAuth callback
 */
export const oauthCallbackParams = zod.object({
  "provider": zod.enum(['google', 'github', 'microsoft']).describe('The OAuth provider handling the callback')
})

export const oauthCallbackQueryParams = zod.object({
  "code": zod.string().optional().describe('Authorization code from OAuth provider'),
  "state": zod.string().optional().describe('State parameter for CSRF protection'),
  "error": zod.string().optional().describe('Error code if authorization failed'),
  "error_description": zod.string().optional().describe('Human-readable error description')
})

export const oauthCallbackResponseIdMin = 36;export const oauthCallbackResponseOrganizationIDMin = 36;export const oauthCallbackResponseUserIDMin = 36;

export const oauthCallbackResponse = zod.object({
  "id": zod.uuid().min(oauthCallbackResponseIdMin).describe('Unique identifier for the resource'),
  "createdAt": zod.iso.datetime({}).min(1).describe('The date and time when the resource was created'),
  "updatedAt": zod.iso.datetime({}).min(1).describe('The date and time when the resource was last updated')
}).describe('Base schema for all entities with common fields').and(zod.object({
  "organizationID": zod.uuid().min(oauthCallbackResponseOrganizationIDMin).optional().describe('The organization ID for this session (nullable for users without org)'),
  "authMethod": zod.string().optional().describe('The authentication method used (magic_link, oauth_google, oauth_github, etc.)'),
  "authProvider": zod.string().optional().describe('The authentication provider (google, github, microsoft, local)'),
  "expiresAt": zod.iso.datetime({}).min(1).describe('The expiration date of the session'),
  "ipAddress": zod.string().min(1).optional().describe('The IP address of the session'),
  "token": zod.string().min(1).describe('The session token'),
  "userAgent": zod.string().min(1).optional().describe('The user agent of the session'),
  "userID": zod.uuid().min(oauthCallbackResponseUserIDMin).describe('The user who owns this session')
})).describe('Schema for Session entity')


/**
 * List user's tokens (without showing the actual key values)
 * @summary List tokens
 */
export const listAPIKeysQueryPageLimitDefault = 10;
export const listAPIKeysQueryPageLimitMax = 100;export const listAPIKeysQueryPageOffsetDefault = 0;
export const listAPIKeysQueryPageOffsetMin = 0;
export const listAPIKeysQueryPageOffsetMax = 9007199254740991;

export const listAPIKeysQueryParams = zod.object({
  "filter": zod.object({
  "type": zod.enum(['and', 'or', 'eq', 'ne', 'gt', 'gte', 'lt', 'lte', 'contains', 'starts_with', 'ends_with']).describe('The type of filter operation'),
  "field": zod.string().min(1).optional().describe('The field to filter on (for leaf conditions)'),
  "value": zod.any().optional().describe('The value to compare against (for leaf conditions)'),
  "children": zod.array(zod.object({
  "type": zod.enum(['and', 'or', 'eq', 'ne', 'gt', 'gte', 'lt', 'lte', 'contains', 'starts_with', 'ends_with']).describe('The type of filter operation'),
  "field": zod.string().min(1).optional().describe('The field to filter on (for leaf conditions)'),
  "value": zod.any().optional().describe('The value to compare against (for leaf conditions)'),
  "children": zod.array(zod.any()).optional().describe('Child filter nodes (for logical operators)')
}).describe('A recursive filter node that can be a condition or group')).optional().describe('Child filter nodes (for logical operators)')
}).optional().describe('Filter API keys by field values. Supported fields:\n- createdAt, id, updatedAt, userID, organizationID\n- keyHash, name, prefix, rateLimit, lastUsedAt, expiresAt\n'),
  "page": zod.object({
  "limit": zod.number().min(1).max(listAPIKeysQueryPageLimitMax).default(listAPIKeysQueryPageLimitDefault).describe('Maximum number of items to return'),
  "offset": zod.number().min(listAPIKeysQueryPageOffsetMin).max(listAPIKeysQueryPageOffsetMax).optional().describe('Number of items to skip before starting to collect the result set')
}).optional().describe('The page parameter'),
  "sort": zod.array(zod.object({
  "field": zod.enum(['createdAt', 'id', 'updatedAt', 'userID', 'organizationID', 'keyHash', 'name', 'prefix', 'rateLimit', 'lastUsedAt', 'expiresAt']),
  "order": zod.enum(['asc', 'desc'])
})).optional().describe('The sort parameter')
})

export const listAPIKeysResponseDataItemIdMin = 36;export const listAPIKeysResponseDataItemUserIDMin = 36;export const listAPIKeysResponseDataItemOrganizationIDMin = 36;

export const listAPIKeysResponse = zod.object({
  "data": zod.array(zod.object({
  "id": zod.uuid().min(listAPIKeysResponseDataItemIdMin).describe('Unique identifier for the resource'),
  "createdAt": zod.iso.datetime({}).min(1).describe('The date and time when the resource was created'),
  "updatedAt": zod.iso.datetime({}).min(1).describe('The date and time when the resource was last updated')
}).describe('Base schema for all entities with common fields').and(zod.object({
  "userID": zod.uuid().min(listAPIKeysResponseDataItemUserIDMin).describe('The user who owns this API key'),
  "organizationID": zod.uuid().min(listAPIKeysResponseDataItemOrganizationIDMin).describe('The organization this API key belongs to'),
  "keyHash": zod.string().min(1).describe('Hashed version of the API key for secure storage'),
  "name": zod.string().min(1).optional(),
  "prefix": zod.string().min(1).optional(),
  "scopes": zod.array(zod.string()),
  "rateLimit": zod.number().describe('Requests per minute allowed for this API key'),
  "lastUsedAt": zod.iso.datetime({}).min(1).optional().describe('When this API key was last used'),
  "expiresAt": zod.iso.datetime({}).min(1).optional().describe('When this API key expires')
})).describe('Schema for API Key entity')),
  "meta": zod.object({
  "total": zod.number()
})
})


/**
 * Create a token
 * @summary Create a token
 */
export const createAPIKeyBodyNameMax = 255;export const createAPIKeyBodyRateLimitDefault = 60;
export const createAPIKeyBodyRateLimitMax = 10000;

export const createAPIKeyBody = zod.object({
  "name": zod.string().min(1).max(createAPIKeyBodyNameMax).describe('Human-readable name for the API key'),
  "scopes": zod.array(zod.string()).describe('List of scopes/permissions for this API key'),
  "rateLimit": zod.number().min(1).max(createAPIKeyBodyRateLimitMax).default(createAPIKeyBodyRateLimitDefault).describe('Requests per minute limit (default 60)'),
  "expiresAt": zod.iso.datetime({}).optional().describe('When the API key expires (optional, no expiry if omitted)')
})


/**
 * Get details of a specific API key (without the actual key value)
 * @summary Get API key details
 */
export const getAPIKeyPathIdMin = 36;

export const getAPIKeyParams = zod.object({
  "id": zod.uuid().min(getAPIKeyPathIdMin).describe('The unique identifier of the API key')
})

export const getAPIKeyResponseIdMin = 36;export const getAPIKeyResponseUserIDMin = 36;export const getAPIKeyResponseOrganizationIDMin = 36;

export const getAPIKeyResponse = zod.object({
  "id": zod.uuid().min(getAPIKeyResponseIdMin).describe('Unique identifier for the resource'),
  "createdAt": zod.iso.datetime({}).min(1).describe('The date and time when the resource was created'),
  "updatedAt": zod.iso.datetime({}).min(1).describe('The date and time when the resource was last updated')
}).describe('Base schema for all entities with common fields').and(zod.object({
  "userID": zod.uuid().min(getAPIKeyResponseUserIDMin).describe('The user who owns this API key'),
  "organizationID": zod.uuid().min(getAPIKeyResponseOrganizationIDMin).describe('The organization this API key belongs to'),
  "keyHash": zod.string().min(1).describe('Hashed version of the API key for secure storage'),
  "name": zod.string().min(1).optional(),
  "prefix": zod.string().min(1).optional(),
  "scopes": zod.array(zod.string()),
  "rateLimit": zod.number().describe('Requests per minute allowed for this API key'),
  "lastUsedAt": zod.iso.datetime({}).min(1).optional().describe('When this API key was last used'),
  "expiresAt": zod.iso.datetime({}).min(1).optional().describe('When this API key expires')
})).describe('Schema for API Key entity')


/**
 * Update an API key's name, scopes, or rate limit
 * @summary Update API key
 */
export const updateAPIKeyPathIdMin = 36;

export const updateAPIKeyParams = zod.object({
  "id": zod.uuid().min(updateAPIKeyPathIdMin).describe('The unique identifier of the API key')
})

export const updateAPIKeyBodyRateLimitMax = 10000;

export const updateAPIKeyBody = zod.object({
  "name": zod.string().min(1).optional().describe('Human-readable name for the API key'),
  "scopes": zod.array(zod.string()).optional().describe('Array of permission scopes'),
  "rateLimit": zod.number().min(1).max(updateAPIKeyBodyRateLimitMax).optional().describe('Requests per minute allowed for this API key')
})

export const updateAPIKeyResponseIdMin = 36;export const updateAPIKeyResponseUserIDMin = 36;export const updateAPIKeyResponseOrganizationIDMin = 36;

export const updateAPIKeyResponse = zod.object({
  "id": zod.uuid().min(updateAPIKeyResponseIdMin).describe('Unique identifier for the resource'),
  "createdAt": zod.iso.datetime({}).min(1).describe('The date and time when the resource was created'),
  "updatedAt": zod.iso.datetime({}).min(1).describe('The date and time when the resource was last updated')
}).describe('Base schema for all entities with common fields').and(zod.object({
  "userID": zod.uuid().min(updateAPIKeyResponseUserIDMin).describe('The user who owns this API key'),
  "organizationID": zod.uuid().min(updateAPIKeyResponseOrganizationIDMin).describe('The organization this API key belongs to'),
  "keyHash": zod.string().min(1).describe('Hashed version of the API key for secure storage'),
  "name": zod.string().min(1).optional(),
  "prefix": zod.string().min(1).optional(),
  "scopes": zod.array(zod.string()),
  "rateLimit": zod.number().describe('Requests per minute allowed for this API key'),
  "lastUsedAt": zod.iso.datetime({}).min(1).optional().describe('When this API key was last used'),
  "expiresAt": zod.iso.datetime({}).min(1).optional().describe('When this API key expires')
})).describe('Schema for API Key entity')


/**
 * Delete an API key permanently. This action cannot be undone.
 * @summary Delete API key
 */
export const deleteAPIKeyPathIdMin = 36;

export const deleteAPIKeyParams = zod.object({
  "id": zod.uuid().min(deleteAPIKeyPathIdMin).describe('The unique identifier of the API key')
})


/**
 * Create an organization
 * @summary Create an organization
 */
export const createOrganizationBodyOrganizationIDMin = 36;

export const createOrganizationBody = zod.object({
  "billingEmail": zod.email().min(1).describe('The billing email to use for the organization'),
  "organizationID": zod.uuid().min(createOrganizationBodyOrganizationIDMin).describe('UUID identifier')
})


/**
 * List organizations
 * @summary List organizations
 */
export const listOrganizationsQueryPageLimitDefault = 10;
export const listOrganizationsQueryPageLimitMax = 100;export const listOrganizationsQueryPageOffsetDefault = 0;
export const listOrganizationsQueryPageOffsetMin = 0;
export const listOrganizationsQueryPageOffsetMax = 9007199254740991;

export const listOrganizationsQueryParams = zod.object({
  "filter": zod.object({
  "type": zod.enum(['and', 'or', 'eq', 'ne', 'gt', 'gte', 'lt', 'lte', 'contains', 'starts_with', 'ends_with']).describe('The type of filter operation'),
  "field": zod.string().min(1).optional().describe('The field to filter on (for leaf conditions)'),
  "value": zod.any().optional().describe('The value to compare against (for leaf conditions)'),
  "children": zod.array(zod.object({
  "type": zod.enum(['and', 'or', 'eq', 'ne', 'gt', 'gte', 'lt', 'lte', 'contains', 'starts_with', 'ends_with']).describe('The type of filter operation'),
  "field": zod.string().min(1).optional().describe('The field to filter on (for leaf conditions)'),
  "value": zod.any().optional().describe('The value to compare against (for leaf conditions)'),
  "children": zod.array(zod.any()).optional().describe('Child filter nodes (for logical operators)')
}).describe('A recursive filter node that can be a condition or group')).optional().describe('Child filter nodes (for logical operators)')
}).optional().describe('Filter organizations by field values. Supported fields:\n- createdAt, id, updatedAt, billingEmail, credits, logo\n- metadata, name, plan, slug, stripeCustomerIdentifier\n'),
  "page": zod.object({
  "limit": zod.number().min(1).max(listOrganizationsQueryPageLimitMax).default(listOrganizationsQueryPageLimitDefault).describe('Maximum number of items to return'),
  "offset": zod.number().min(listOrganizationsQueryPageOffsetMin).max(listOrganizationsQueryPageOffsetMax).optional().describe('Number of items to skip before starting to collect the result set')
}).optional().describe('The page parameter'),
  "sort": zod.array(zod.object({
  "field": zod.enum(['createdAt', 'id', 'updatedAt', 'billingEmail', 'credits', 'logo', 'metadata', 'name', 'plan', 'slug', 'stripeCustomerIdentifier']),
  "order": zod.enum(['asc', 'desc'])
})).optional().describe('The sort parameter')
})

export const listOrganizationsResponseDataItemIdMin = 36;export const listOrganizationsResponseDataItemNameMax = 255;export const listOrganizationsResponseDataItemSlugMin = 3;
export const listOrganizationsResponseDataItemSlugMax = 50;
export const listOrganizationsResponseDataItemSlugRegExp = new RegExp('^[a-z0-9]+(?:-[a-z0-9]+)*$');
export const listOrganizationsResponseDataItemPlanDefault = "FREE";export const listOrganizationsResponseDataItemCreditsDefault = 0;
export const listOrganizationsResponseDataItemCreditsMin = 0;

export const listOrganizationsResponse = zod.object({
  "data": zod.array(zod.object({
  "id": zod.uuid().min(listOrganizationsResponseDataItemIdMin).describe('Unique identifier for the resource'),
  "createdAt": zod.iso.datetime({}).min(1).describe('The date and time when the resource was created'),
  "updatedAt": zod.iso.datetime({}).min(1).describe('The date and time when the resource was last updated')
}).describe('Base schema for all entities with common fields').and(zod.object({
  "name": zod.string().min(1).max(listOrganizationsResponseDataItemNameMax).describe('The organization\'s display name'),
  "slug": zod.string().min(listOrganizationsResponseDataItemSlugMin).max(listOrganizationsResponseDataItemSlugMax).regex(listOrganizationsResponseDataItemSlugRegExp).describe('URL-friendly unique identifier for the organization'),
  "logo": zod.string().optional().describe('The organization\'s logo URL'),
  "billingEmail": zod.email().optional().describe('Email address for billing communications'),
  "plan": zod.enum(['FREE', 'BASIC', 'STANDARD', 'PREMIUM', 'UNLIMITED']).describe('The current subscription plan'),
  "credits": zod.number().min(listOrganizationsResponseDataItemCreditsMin).describe('Available credits for this organization'),
  "stripeCustomerIdentifier": zod.string().describe('Stripe customer identifier')
})).describe('Schema for Organization entity')),
  "meta": zod.object({
  "total": zod.number().describe('Total number of items in the collection')
})
})


/**
 * Delete an organization
 * @summary Delete an organization
 */
export const deleteOrganizationPathIdMin = 36;

export const deleteOrganizationParams = zod.object({
  "id": zod.uuid().min(deleteOrganizationPathIdMin).describe('The unique identifier of the resource.')
})

export const deleteOrganizationResponseDataIdMin = 36;export const deleteOrganizationResponseDataNameMax = 255;export const deleteOrganizationResponseDataSlugMin = 3;
export const deleteOrganizationResponseDataSlugMax = 50;
export const deleteOrganizationResponseDataSlugRegExp = new RegExp('^[a-z0-9]+(?:-[a-z0-9]+)*$');
export const deleteOrganizationResponseDataPlanDefault = "FREE";export const deleteOrganizationResponseDataCreditsDefault = 0;
export const deleteOrganizationResponseDataCreditsMin = 0;

export const deleteOrganizationResponse = zod.object({
  "data": zod.object({
  "id": zod.uuid().min(deleteOrganizationResponseDataIdMin).describe('Unique identifier for the resource'),
  "createdAt": zod.iso.datetime({}).min(1).describe('The date and time when the resource was created'),
  "updatedAt": zod.iso.datetime({}).min(1).describe('The date and time when the resource was last updated')
}).describe('Base schema for all entities with common fields').and(zod.object({
  "name": zod.string().min(1).max(deleteOrganizationResponseDataNameMax).describe('The organization\'s display name'),
  "slug": zod.string().min(deleteOrganizationResponseDataSlugMin).max(deleteOrganizationResponseDataSlugMax).regex(deleteOrganizationResponseDataSlugRegExp).describe('URL-friendly unique identifier for the organization'),
  "logo": zod.string().optional().describe('The organization\'s logo URL'),
  "billingEmail": zod.email().optional().describe('Email address for billing communications'),
  "plan": zod.enum(['FREE', 'BASIC', 'STANDARD', 'PREMIUM', 'UNLIMITED']).describe('The current subscription plan'),
  "credits": zod.number().min(deleteOrganizationResponseDataCreditsMin).describe('Available credits for this organization'),
  "stripeCustomerIdentifier": zod.string().describe('Stripe customer identifier')
})).describe('Schema for Organization entity')
})


/**
 * Get an organization
 * @summary Get an organization
 */
export const getOrganizationPathIdMin = 36;

export const getOrganizationParams = zod.object({
  "id": zod.uuid().min(getOrganizationPathIdMin).describe('The unique identifier of the resource.')
})

export const getOrganizationResponseDataIdMin = 36;export const getOrganizationResponseDataNameMax = 255;export const getOrganizationResponseDataSlugMin = 3;
export const getOrganizationResponseDataSlugMax = 50;
export const getOrganizationResponseDataSlugRegExp = new RegExp('^[a-z0-9]+(?:-[a-z0-9]+)*$');
export const getOrganizationResponseDataPlanDefault = "FREE";export const getOrganizationResponseDataCreditsDefault = 0;
export const getOrganizationResponseDataCreditsMin = 0;

export const getOrganizationResponse = zod.object({
  "data": zod.object({
  "id": zod.uuid().min(getOrganizationResponseDataIdMin).describe('Unique identifier for the resource'),
  "createdAt": zod.iso.datetime({}).min(1).describe('The date and time when the resource was created'),
  "updatedAt": zod.iso.datetime({}).min(1).describe('The date and time when the resource was last updated')
}).describe('Base schema for all entities with common fields').and(zod.object({
  "name": zod.string().min(1).max(getOrganizationResponseDataNameMax).describe('The organization\'s display name'),
  "slug": zod.string().min(getOrganizationResponseDataSlugMin).max(getOrganizationResponseDataSlugMax).regex(getOrganizationResponseDataSlugRegExp).describe('URL-friendly unique identifier for the organization'),
  "logo": zod.string().optional().describe('The organization\'s logo URL'),
  "billingEmail": zod.email().optional().describe('Email address for billing communications'),
  "plan": zod.enum(['FREE', 'BASIC', 'STANDARD', 'PREMIUM', 'UNLIMITED']).describe('The current subscription plan'),
  "credits": zod.number().min(getOrganizationResponseDataCreditsMin).describe('Available credits for this organization'),
  "stripeCustomerIdentifier": zod.string().describe('Stripe customer identifier')
})).describe('Schema for Organization entity')
})


/**
 * Update an organization
 * @summary Update an organization
 */
export const updateOrganizationPathIdMin = 36;

export const updateOrganizationParams = zod.object({
  "id": zod.uuid().min(updateOrganizationPathIdMin).describe('The unique identifier of the resource.')
})

export const updateOrganizationBodyOrganizationIDMin = 36;

export const updateOrganizationBody = zod.object({
  "billingEmail": zod.email().optional().describe('The billing email to use for the organization'),
  "organizationID": zod.uuid().min(updateOrganizationBodyOrganizationIDMin).optional().describe('UUID identifier')
})

export const updateOrganizationResponseDataIdMin = 36;export const updateOrganizationResponseDataNameMax = 255;export const updateOrganizationResponseDataSlugMin = 3;
export const updateOrganizationResponseDataSlugMax = 50;
export const updateOrganizationResponseDataSlugRegExp = new RegExp('^[a-z0-9]+(?:-[a-z0-9]+)*$');
export const updateOrganizationResponseDataPlanDefault = "FREE";export const updateOrganizationResponseDataCreditsDefault = 0;
export const updateOrganizationResponseDataCreditsMin = 0;

export const updateOrganizationResponse = zod.object({
  "data": zod.object({
  "id": zod.uuid().min(updateOrganizationResponseDataIdMin).describe('Unique identifier for the resource'),
  "createdAt": zod.iso.datetime({}).min(1).describe('The date and time when the resource was created'),
  "updatedAt": zod.iso.datetime({}).min(1).describe('The date and time when the resource was last updated')
}).describe('Base schema for all entities with common fields').and(zod.object({
  "name": zod.string().min(1).max(updateOrganizationResponseDataNameMax).describe('The organization\'s display name'),
  "slug": zod.string().min(updateOrganizationResponseDataSlugMin).max(updateOrganizationResponseDataSlugMax).regex(updateOrganizationResponseDataSlugRegExp).describe('URL-friendly unique identifier for the organization'),
  "logo": zod.string().optional().describe('The organization\'s logo URL'),
  "billingEmail": zod.email().optional().describe('Email address for billing communications'),
  "plan": zod.enum(['FREE', 'BASIC', 'STANDARD', 'PREMIUM', 'UNLIMITED']).describe('The current subscription plan'),
  "credits": zod.number().min(updateOrganizationResponseDataCreditsMin).describe('Available credits for this organization'),
  "stripeCustomerIdentifier": zod.string().describe('Stripe customer identifier')
})).describe('Schema for Organization entity')
})


/**
 * Create a member
 * @summary Create a member
 */
export const createMemberParams = zod.object({
  "organizationID": zod.uuid().describe('Organization ID')
})

export const createMemberBody = zod.object({
  "role": zod.enum(['admin', 'owner', 'member']).describe('The role of the member')
})


/**
 * List members
 * @summary List members
 */
export const listMembersParams = zod.object({
  "organizationID": zod.uuid().describe('Organization ID')
})

export const listMembersQueryPageLimitDefault = 10;
export const listMembersQueryPageLimitMax = 100;export const listMembersQueryPageOffsetDefault = 0;
export const listMembersQueryPageOffsetMin = 0;
export const listMembersQueryPageOffsetMax = 9007199254740991;

export const listMembersQueryParams = zod.object({
  "filter": zod.object({
  "type": zod.enum(['and', 'or', 'eq', 'ne', 'gt', 'gte', 'lt', 'lte', 'contains', 'starts_with', 'ends_with']).describe('The type of filter operation'),
  "field": zod.string().min(1).optional().describe('The field to filter on (for leaf conditions)'),
  "value": zod.any().optional().describe('The value to compare against (for leaf conditions)'),
  "children": zod.array(zod.object({
  "type": zod.enum(['and', 'or', 'eq', 'ne', 'gt', 'gte', 'lt', 'lte', 'contains', 'starts_with', 'ends_with']).describe('The type of filter operation'),
  "field": zod.string().min(1).optional().describe('The field to filter on (for leaf conditions)'),
  "value": zod.any().optional().describe('The value to compare against (for leaf conditions)'),
  "children": zod.array(zod.any()).optional().describe('Child filter nodes (for logical operators)')
}).describe('A recursive filter node that can be a condition or group')).optional().describe('Child filter nodes (for logical operators)')
}).optional().describe('Filter members by field values. Supported fields:\n- createdAt, id, updatedAt, organizationID, role, userID\n'),
  "page": zod.object({
  "limit": zod.number().min(1).max(listMembersQueryPageLimitMax).default(listMembersQueryPageLimitDefault).describe('Maximum number of items to return'),
  "offset": zod.number().min(listMembersQueryPageOffsetMin).max(listMembersQueryPageOffsetMax).optional().describe('Number of items to skip before starting to collect the result set')
}).optional().describe('The page parameter'),
  "sort": zod.array(zod.object({
  "field": zod.enum(['createdAt', 'id', 'updatedAt', 'organizationID', 'role', 'userID']),
  "order": zod.enum(['asc', 'desc'])
})).optional().describe('The sort parameter')
})

export const listMembersResponseDataItemIdMin = 36;export const listMembersResponseDataItemOrganizationIDMin = 36;export const listMembersResponseDataItemUserIDMin = 36;

export const listMembersResponse = zod.object({
  "data": zod.array(zod.object({
  "id": zod.uuid().min(listMembersResponseDataItemIdMin).describe('Unique identifier for the resource'),
  "createdAt": zod.iso.datetime({}).min(1).describe('The date and time when the resource was created'),
  "updatedAt": zod.iso.datetime({}).min(1).describe('The date and time when the resource was last updated')
}).describe('Base schema for all entities with common fields').and(zod.object({
  "organizationID": zod.uuid().min(listMembersResponseDataItemOrganizationIDMin).describe('The organization this member belongs to'),
  "role": zod.enum(['admin', 'owner', 'basic']).describe('The role of the member'),
  "userID": zod.uuid().min(listMembersResponseDataItemUserIDMin).describe('The user who is a member of the organization')
})).describe('Schema for Member entity')),
  "meta": zod.object({
  "total": zod.number().describe('Total number of items in the collection')
})
})


/**
 * Delete a member
 * @summary Delete a member
 */
export const deleteMemberPathOrganizationIDMin = 36;export const deleteMemberPathIdMin = 36;

export const deleteMemberParams = zod.object({
  "organizationID": zod.uuid().min(deleteMemberPathOrganizationIDMin).describe('The unique identifier of the organization.'),
  "id": zod.uuid().min(deleteMemberPathIdMin).describe('The unique identifier of the member.')
})

export const deleteMemberResponseDataIdMin = 36;export const deleteMemberResponseDataOrganizationIDMin = 36;export const deleteMemberResponseDataUserIDMin = 36;

export const deleteMemberResponse = zod.object({
  "data": zod.object({
  "id": zod.uuid().min(deleteMemberResponseDataIdMin).describe('Unique identifier for the resource'),
  "createdAt": zod.iso.datetime({}).min(1).describe('The date and time when the resource was created'),
  "updatedAt": zod.iso.datetime({}).min(1).describe('The date and time when the resource was last updated')
}).describe('Base schema for all entities with common fields').and(zod.object({
  "organizationID": zod.uuid().min(deleteMemberResponseDataOrganizationIDMin).describe('The organization this member belongs to'),
  "role": zod.enum(['admin', 'owner', 'basic']).describe('The role of the member'),
  "userID": zod.uuid().min(deleteMemberResponseDataUserIDMin).describe('The user who is a member of the organization')
})).describe('Schema for Member entity')
})


/**
 * Get a member
 * @summary Get a member
 */
export const getMemberPathOrganizationIDMin = 36;export const getMemberPathIdMin = 36;

export const getMemberParams = zod.object({
  "organizationID": zod.uuid().min(getMemberPathOrganizationIDMin).describe('The unique identifier of the organization.'),
  "id": zod.uuid().min(getMemberPathIdMin).describe('The unique identifier of the member.')
})

export const getMemberResponseDataIdMin = 36;export const getMemberResponseDataOrganizationIDMin = 36;export const getMemberResponseDataUserIDMin = 36;

export const getMemberResponse = zod.object({
  "data": zod.object({
  "id": zod.uuid().min(getMemberResponseDataIdMin).describe('Unique identifier for the resource'),
  "createdAt": zod.iso.datetime({}).min(1).describe('The date and time when the resource was created'),
  "updatedAt": zod.iso.datetime({}).min(1).describe('The date and time when the resource was last updated')
}).describe('Base schema for all entities with common fields').and(zod.object({
  "organizationID": zod.uuid().min(getMemberResponseDataOrganizationIDMin).describe('The organization this member belongs to'),
  "role": zod.enum(['admin', 'owner', 'basic']).describe('The role of the member'),
  "userID": zod.uuid().min(getMemberResponseDataUserIDMin).describe('The user who is a member of the organization')
})).describe('Schema for Member entity')
})


/**
 * Update a member
 * @summary Update a member
 */
export const updateMemberPathOrganizationIDMin = 36;export const updateMemberPathIdMin = 36;

export const updateMemberParams = zod.object({
  "organizationID": zod.uuid().min(updateMemberPathOrganizationIDMin).describe('The unique identifier of the organization.'),
  "id": zod.uuid().min(updateMemberPathIdMin).describe('The unique identifier of the member.')
})

export const updateMemberBody = zod.object({
  "role": zod.enum(['admin', 'owner', 'member']).optional().describe('The role of the member')
})

export const updateMemberResponseDataIdMin = 36;export const updateMemberResponseDataOrganizationIDMin = 36;export const updateMemberResponseDataUserIDMin = 36;

export const updateMemberResponse = zod.object({
  "data": zod.object({
  "id": zod.uuid().min(updateMemberResponseDataIdMin).describe('Unique identifier for the resource'),
  "createdAt": zod.iso.datetime({}).min(1).describe('The date and time when the resource was created'),
  "updatedAt": zod.iso.datetime({}).min(1).describe('The date and time when the resource was last updated')
}).describe('Base schema for all entities with common fields').and(zod.object({
  "organizationID": zod.uuid().min(updateMemberResponseDataOrganizationIDMin).describe('The organization this member belongs to'),
  "role": zod.enum(['admin', 'owner', 'basic']).describe('The role of the member'),
  "userID": zod.uuid().min(updateMemberResponseDataUserIDMin).describe('The user who is a member of the organization')
})).describe('Schema for Member entity')
})


/**
 * Create an invitation
 * @summary Create an invitation
 */
export const createInvitationPathOrganizationIDMin = 36;

export const createInvitationParams = zod.object({
  "organizationID": zod.uuid().min(createInvitationPathOrganizationIDMin).describe('The unique identifier of the organization.')
})

export const createInvitationBody = zod.object({
  "email": zod.string().min(1).describe('The email of the invitated user'),
  "role": zod.enum(['admin', 'owner', 'member']).describe('The role of the invitation')
})


/**
 * List invitations
 * @summary List invitations
 */
export const listInvitationsPathOrganizationIDMin = 36;

export const listInvitationsParams = zod.object({
  "organizationID": zod.uuid().min(listInvitationsPathOrganizationIDMin).describe('The unique identifier of the organization.')
})

export const listInvitationsQueryPageLimitDefault = 10;
export const listInvitationsQueryPageLimitMax = 100;export const listInvitationsQueryPageOffsetDefault = 0;
export const listInvitationsQueryPageOffsetMin = 0;
export const listInvitationsQueryPageOffsetMax = 9007199254740991;

export const listInvitationsQueryParams = zod.object({
  "filter": zod.object({
  "type": zod.enum(['and', 'or', 'eq', 'ne', 'gt', 'gte', 'lt', 'lte', 'contains', 'starts_with', 'ends_with']).describe('The type of filter operation'),
  "field": zod.string().min(1).optional().describe('The field to filter on (for leaf conditions)'),
  "value": zod.any().optional().describe('The value to compare against (for leaf conditions)'),
  "children": zod.array(zod.object({
  "type": zod.enum(['and', 'or', 'eq', 'ne', 'gt', 'gte', 'lt', 'lte', 'contains', 'starts_with', 'ends_with']).describe('The type of filter operation'),
  "field": zod.string().min(1).optional().describe('The field to filter on (for leaf conditions)'),
  "value": zod.any().optional().describe('The value to compare against (for leaf conditions)'),
  "children": zod.array(zod.any()).optional().describe('Child filter nodes (for logical operators)')
}).describe('A recursive filter node that can be a condition or group')).optional().describe('Child filter nodes (for logical operators)')
}).optional().describe('Filter invitations by field values. Supported fields:\n- createdAt, id, updatedAt, email, expiresAt\n- inviterID, organizationID, role, status\n'),
  "page": zod.object({
  "limit": zod.number().min(1).max(listInvitationsQueryPageLimitMax).default(listInvitationsQueryPageLimitDefault).describe('Maximum number of items to return'),
  "offset": zod.number().min(listInvitationsQueryPageOffsetMin).max(listInvitationsQueryPageOffsetMax).optional().describe('Number of items to skip before starting to collect the result set')
}).optional().describe('The page parameter'),
  "sort": zod.array(zod.object({
  "field": zod.enum(['createdAt', 'id', 'updatedAt', 'email', 'expiresAt', 'inviterID', 'organizationID', 'role', 'status']),
  "order": zod.enum(['asc', 'desc'])
})).optional().describe('The sort parameter')
})

export const listInvitationsResponseDataItemIdMin = 36;export const listInvitationsResponseDataItemInviterIDMin = 36;export const listInvitationsResponseDataItemOrganizationIDMin = 36;

export const listInvitationsResponse = zod.object({
  "data": zod.array(zod.object({
  "id": zod.uuid().min(listInvitationsResponseDataItemIdMin).describe('Unique identifier for the resource'),
  "createdAt": zod.iso.datetime({}).min(1).describe('The date and time when the resource was created'),
  "updatedAt": zod.iso.datetime({}).min(1).describe('The date and time when the resource was last updated')
}).describe('Base schema for all entities with common fields').and(zod.object({
  "email": zod.string().min(1).describe('The email of the invitated user'),
  "expiresAt": zod.iso.datetime({}).min(1).describe('The date and time when the invitation expires'),
  "inviterID": zod.uuid().min(listInvitationsResponseDataItemInviterIDMin).describe('The ID of the user who sent this invitation'),
  "organizationID": zod.uuid().min(listInvitationsResponseDataItemOrganizationIDMin).describe('The organization the user is being invited to join'),
  "role": zod.enum(['admin', 'owner', 'basic']).describe('The role of the invitation'),
  "status": zod.string().min(1).describe('The status of the invitation, e.g., pending, accepted, declined')
})).describe('Schema for Invitation entity')),
  "meta": zod.object({
  "total": zod.number().describe('Total number of items in the collection')
})
})


/**
 * Delete an invitation
 * @summary Delete an invitation
 */
export const deleteInvitationPathOrganizationIDMin = 36;export const deleteInvitationPathIdMin = 36;

export const deleteInvitationParams = zod.object({
  "organizationID": zod.uuid().min(deleteInvitationPathOrganizationIDMin).describe('The unique identifier of the organization.'),
  "id": zod.uuid().min(deleteInvitationPathIdMin).describe('The unique identifier of the invitation.')
})

export const deleteInvitationResponseDataIdMin = 36;export const deleteInvitationResponseDataInviterIDMin = 36;export const deleteInvitationResponseDataOrganizationIDMin = 36;

export const deleteInvitationResponse = zod.object({
  "data": zod.object({
  "id": zod.uuid().min(deleteInvitationResponseDataIdMin).describe('Unique identifier for the resource'),
  "createdAt": zod.iso.datetime({}).min(1).describe('The date and time when the resource was created'),
  "updatedAt": zod.iso.datetime({}).min(1).describe('The date and time when the resource was last updated')
}).describe('Base schema for all entities with common fields').and(zod.object({
  "email": zod.string().min(1).describe('The email of the invitated user'),
  "expiresAt": zod.iso.datetime({}).min(1).describe('The date and time when the invitation expires'),
  "inviterID": zod.uuid().min(deleteInvitationResponseDataInviterIDMin).describe('The ID of the user who sent this invitation'),
  "organizationID": zod.uuid().min(deleteInvitationResponseDataOrganizationIDMin).describe('The organization the user is being invited to join'),
  "role": zod.enum(['admin', 'owner', 'basic']).describe('The role of the invitation'),
  "status": zod.string().min(1).describe('The status of the invitation, e.g., pending, accepted, declined')
})).describe('Schema for Invitation entity')
})


/**
 * Get an invitation
 * @summary Get an invitation
 */
export const getInvitationPathOrganizationIDMin = 36;export const getInvitationPathIdMin = 36;

export const getInvitationParams = zod.object({
  "organizationID": zod.uuid().min(getInvitationPathOrganizationIDMin).describe('The unique identifier of the organization.'),
  "id": zod.uuid().min(getInvitationPathIdMin).describe('The unique identifier of the invitation.')
})

export const getInvitationResponseDataIdMin = 36;export const getInvitationResponseDataInviterIDMin = 36;export const getInvitationResponseDataOrganizationIDMin = 36;

export const getInvitationResponse = zod.object({
  "data": zod.object({
  "id": zod.uuid().min(getInvitationResponseDataIdMin).describe('Unique identifier for the resource'),
  "createdAt": zod.iso.datetime({}).min(1).describe('The date and time when the resource was created'),
  "updatedAt": zod.iso.datetime({}).min(1).describe('The date and time when the resource was last updated')
}).describe('Base schema for all entities with common fields').and(zod.object({
  "email": zod.string().min(1).describe('The email of the invitated user'),
  "expiresAt": zod.iso.datetime({}).min(1).describe('The date and time when the invitation expires'),
  "inviterID": zod.uuid().min(getInvitationResponseDataInviterIDMin).describe('The ID of the user who sent this invitation'),
  "organizationID": zod.uuid().min(getInvitationResponseDataOrganizationIDMin).describe('The organization the user is being invited to join'),
  "role": zod.enum(['admin', 'owner', 'basic']).describe('The role of the invitation'),
  "status": zod.string().min(1).describe('The status of the invitation, e.g., pending, accepted, declined')
})).describe('Schema for Invitation entity')
})


/**
 * Update an invitation
 * @summary Update an invitation
 */
export const updateInvitationPathOrganizationIDMin = 36;export const updateInvitationPathIdMin = 36;

export const updateInvitationParams = zod.object({
  "organizationID": zod.uuid().min(updateInvitationPathOrganizationIDMin).describe('The unique identifier of the organization.'),
  "id": zod.uuid().min(updateInvitationPathIdMin).describe('The unique identifier of the invitation.')
})

export const updateInvitationBody = zod.object({
  "email": zod.string().optional().describe('The email of the invitated user'),
  "role": zod.enum(['admin', 'owner', 'member']).optional().describe('The role of the invitation')
})

export const updateInvitationResponseDataIdMin = 36;export const updateInvitationResponseDataInviterIDMin = 36;export const updateInvitationResponseDataOrganizationIDMin = 36;

export const updateInvitationResponse = zod.object({
  "data": zod.object({
  "id": zod.uuid().min(updateInvitationResponseDataIdMin).describe('Unique identifier for the resource'),
  "createdAt": zod.iso.datetime({}).min(1).describe('The date and time when the resource was created'),
  "updatedAt": zod.iso.datetime({}).min(1).describe('The date and time when the resource was last updated')
}).describe('Base schema for all entities with common fields').and(zod.object({
  "email": zod.string().min(1).describe('The email of the invitated user'),
  "expiresAt": zod.iso.datetime({}).min(1).describe('The date and time when the invitation expires'),
  "inviterID": zod.uuid().min(updateInvitationResponseDataInviterIDMin).describe('The ID of the user who sent this invitation'),
  "organizationID": zod.uuid().min(updateInvitationResponseDataOrganizationIDMin).describe('The organization the user is being invited to join'),
  "role": zod.enum(['admin', 'owner', 'basic']).describe('The role of the invitation'),
  "status": zod.string().min(1).describe('The status of the invitation, e.g., pending, accepted, declined')
})).describe('Schema for Invitation entity')
})


/**
 * Create a pipeline
 * @summary Create a pipeline
 */
export const createPipelineBody = zod.object({
  "description": zod.string().min(1).optional().describe('The pipeline description'),
  "name": zod.string().min(1).optional().describe('The pipeline name')
})


/**
 * List pipelines
 * @summary List pipelines
 */
export const listPipelinesQueryPageLimitDefault = 10;
export const listPipelinesQueryPageLimitMax = 100;export const listPipelinesQueryPageOffsetDefault = 0;
export const listPipelinesQueryPageOffsetMin = 0;
export const listPipelinesQueryPageOffsetMax = 9007199254740991;

export const listPipelinesQueryParams = zod.object({
  "filter": zod.object({
  "type": zod.enum(['and', 'or', 'eq', 'ne', 'gt', 'gte', 'lt', 'lte', 'contains', 'starts_with', 'ends_with']).describe('The type of filter operation'),
  "field": zod.string().min(1).optional().describe('The field to filter on (for leaf conditions)'),
  "value": zod.any().optional().describe('The value to compare against (for leaf conditions)'),
  "children": zod.array(zod.object({
  "type": zod.enum(['and', 'or', 'eq', 'ne', 'gt', 'gte', 'lt', 'lte', 'contains', 'starts_with', 'ends_with']).describe('The type of filter operation'),
  "field": zod.string().min(1).optional().describe('The field to filter on (for leaf conditions)'),
  "value": zod.any().optional().describe('The value to compare against (for leaf conditions)'),
  "children": zod.array(zod.any()).optional().describe('Child filter nodes (for logical operators)')
}).describe('A recursive filter node that can be a condition or group')).optional().describe('Child filter nodes (for logical operators)')
}).optional().describe('Filter pipelines by field values. Supported fields:\n- createdAt, id, updatedAt, description, name, organizationID\n'),
  "page": zod.object({
  "limit": zod.number().min(1).max(listPipelinesQueryPageLimitMax).default(listPipelinesQueryPageLimitDefault).describe('Maximum number of items to return'),
  "offset": zod.number().min(listPipelinesQueryPageOffsetMin).max(listPipelinesQueryPageOffsetMax).optional().describe('Number of items to skip before starting to collect the result set')
}).optional().describe('The page parameter'),
  "sort": zod.array(zod.object({
  "field": zod.enum(['createdAt', 'id', 'updatedAt', 'description', 'name', 'organizationID']),
  "order": zod.enum(['asc', 'desc'])
})).optional().describe('The sort parameter')
})

export const listPipelinesResponseDataItemIdMin = 36;export const listPipelinesResponseDataItemOrganizationIDMin = 36;export const listPipelinesResponseDataItemNameMax = 255;export const listPipelinesResponseDataItemDescriptionMax = 1000;

export const listPipelinesResponse = zod.object({
  "data": zod.array(zod.object({
  "id": zod.uuid().min(listPipelinesResponseDataItemIdMin).describe('Unique identifier for the resource'),
  "createdAt": zod.iso.datetime({}).min(1).describe('The date and time when the resource was created'),
  "updatedAt": zod.iso.datetime({}).min(1).describe('The date and time when the resource was last updated')
}).describe('Base schema for all entities with common fields').and(zod.object({
  "organizationID": zod.uuid().min(listPipelinesResponseDataItemOrganizationIDMin).describe('The organization identifier'),
  "name": zod.string().min(1).max(listPipelinesResponseDataItemNameMax).optional().describe('The pipeline\'s display name'),
  "description": zod.string().max(listPipelinesResponseDataItemDescriptionMax).optional().describe('Detailed description of the pipeline\'s purpose')
})).describe('Schema for Pipeline entity')),
  "meta": zod.object({
  "total": zod.number().describe('Total number of items in the collection')
})
})


/**
 * Delete a pipeline
 * @summary Delete a pipeline
 */
export const deletePipelinePathIdMin = 36;

export const deletePipelineParams = zod.object({
  "id": zod.uuid().min(deletePipelinePathIdMin).describe('The unique identifier of the resource.')
})

export const deletePipelineResponseDataIdMin = 36;export const deletePipelineResponseDataOrganizationIDMin = 36;export const deletePipelineResponseDataNameMax = 255;export const deletePipelineResponseDataDescriptionMax = 1000;

export const deletePipelineResponse = zod.object({
  "data": zod.object({
  "id": zod.uuid().min(deletePipelineResponseDataIdMin).describe('Unique identifier for the resource'),
  "createdAt": zod.iso.datetime({}).min(1).describe('The date and time when the resource was created'),
  "updatedAt": zod.iso.datetime({}).min(1).describe('The date and time when the resource was last updated')
}).describe('Base schema for all entities with common fields').and(zod.object({
  "organizationID": zod.uuid().min(deletePipelineResponseDataOrganizationIDMin).describe('The organization identifier'),
  "name": zod.string().min(1).max(deletePipelineResponseDataNameMax).optional().describe('The pipeline\'s display name'),
  "description": zod.string().max(deletePipelineResponseDataDescriptionMax).optional().describe('Detailed description of the pipeline\'s purpose')
})).describe('Schema for Pipeline entity')
})


/**
 * Find a pipeline
 * @summary Find a pipeline
 */
export const getPipelinePathIdMin = 36;

export const getPipelineParams = zod.object({
  "id": zod.uuid().min(getPipelinePathIdMin).describe('The unique identifier of the resource.')
})

export const getPipelineResponseDataIdMin = 36;export const getPipelineResponseDataOrganizationIDMin = 36;export const getPipelineResponseDataNameMax = 255;export const getPipelineResponseDataDescriptionMax = 1000;

export const getPipelineResponse = zod.object({
  "data": zod.object({
  "id": zod.uuid().min(getPipelineResponseDataIdMin).describe('Unique identifier for the resource'),
  "createdAt": zod.iso.datetime({}).min(1).describe('The date and time when the resource was created'),
  "updatedAt": zod.iso.datetime({}).min(1).describe('The date and time when the resource was last updated')
}).describe('Base schema for all entities with common fields').and(zod.object({
  "organizationID": zod.uuid().min(getPipelineResponseDataOrganizationIDMin).describe('The organization identifier'),
  "name": zod.string().min(1).max(getPipelineResponseDataNameMax).optional().describe('The pipeline\'s display name'),
  "description": zod.string().max(getPipelineResponseDataDescriptionMax).optional().describe('Detailed description of the pipeline\'s purpose')
})).describe('Schema for Pipeline entity')
})


/**
 * Update a pipeline
 * @summary Update a pipeline
 */
export const updatePipelinePathIdMin = 36;

export const updatePipelineParams = zod.object({
  "id": zod.uuid().min(updatePipelinePathIdMin).describe('The unique identifier of the resource.')
})

export const updatePipelineBody = zod.object({
  "description": zod.string().optional().describe('The pipeline description'),
  "name": zod.string().optional().describe('The pipeline name')
})

export const updatePipelineResponseDataIdMin = 36;export const updatePipelineResponseDataOrganizationIDMin = 36;export const updatePipelineResponseDataNameMax = 255;export const updatePipelineResponseDataDescriptionMax = 1000;

export const updatePipelineResponse = zod.object({
  "data": zod.object({
  "id": zod.uuid().min(updatePipelineResponseDataIdMin).describe('Unique identifier for the resource'),
  "createdAt": zod.iso.datetime({}).min(1).describe('The date and time when the resource was created'),
  "updatedAt": zod.iso.datetime({}).min(1).describe('The date and time when the resource was last updated')
}).describe('Base schema for all entities with common fields').and(zod.object({
  "organizationID": zod.uuid().min(updatePipelineResponseDataOrganizationIDMin).describe('The organization identifier'),
  "name": zod.string().min(1).max(updatePipelineResponseDataNameMax).optional().describe('The pipeline\'s display name'),
  "description": zod.string().max(updatePipelineResponseDataDescriptionMax).optional().describe('Detailed description of the pipeline\'s purpose')
})).describe('Schema for Pipeline entity')
})


/**
 * Retrieve all steps and their dependencies for a pipeline
 * @summary Get all steps for a pipeline
 */
export const getPipelineStepsPathIdMin = 36;

export const getPipelineStepsParams = zod.object({
  "id": zod.uuid().min(getPipelineStepsPathIdMin).describe('Pipeline ID')
})

export const getPipelineStepsResponseDataItemIdMin = 36;export const getPipelineStepsResponseDataItemPipelineIDMin = 36;export const getPipelineStepsResponseDataItemToolIDMin = 36;

export const getPipelineStepsResponse = zod.object({
  "data": zod.array(zod.object({
  "id": zod.uuid().min(getPipelineStepsResponseDataItemIdMin).describe('Unique identifier for the resource'),
  "createdAt": zod.iso.datetime({}).min(1).describe('The date and time when the resource was created'),
  "updatedAt": zod.iso.datetime({}).min(1).describe('The date and time when the resource was last updated')
}).describe('Base schema for all entities with common fields').and(zod.object({
  "pipelineID": zod.uuid().min(getPipelineStepsResponseDataItemPipelineIDMin).describe('The pipeline this step belongs to'),
  "toolID": zod.uuid().min(getPipelineStepsResponseDataItemToolIDMin).describe('The tool used in this step')
})).describe('Schema for PipelineStep entity'))
})


/**
 * Create a step in the pipeline
 * @summary Add a step to a pipeline
 */
export const createPipelineStepPathIdMin = 36;

export const createPipelineStepParams = zod.object({
  "id": zod.uuid().min(createPipelineStepPathIdMin).describe('Pipeline ID')
})

export const createPipelineStepBodyToolIDMin = 36;export const createPipelineStepBodyNameMax = 255;export const createPipelineStepBodyDescriptionMax = 1000;export const createPipelineStepBodyPositionMin = 0;export const createPipelineStepBodyDependenciesItemMin = 36;

export const createPipelineStepBody = zod.object({
  "toolID": zod.uuid().min(createPipelineStepBodyToolIDMin).describe('UUID identifier'),
  "name": zod.string().min(1).max(createPipelineStepBodyNameMax).describe('Name of the step'),
  "description": zod.string().max(createPipelineStepBodyDescriptionMax).optional().describe('Description of what this step does'),
  "config": zod.record(zod.string(), zod.any()).optional().describe('Configuration for the tool'),
  "position": zod.number().min(createPipelineStepBodyPositionMin).optional().describe('Position in the pipeline (for ordering)'),
  "dependencies": zod.array(zod.uuid().min(createPipelineStepBodyDependenciesItemMin).describe('UUID identifier')).optional().describe('IDs of steps this step depends on')
})


/**
 * Get the DAG execution plan showing which steps can run in parallel
 * @summary Get execution plan for a pipeline
 */
export const getPipelineExecutionPlanPathIdMin = 36;

export const getPipelineExecutionPlanParams = zod.object({
  "id": zod.uuid().min(getPipelineExecutionPlanPathIdMin).describe('Pipeline ID')
})

export const getPipelineExecutionPlanResponseDataPipelineIDMin = 36;export const getPipelineExecutionPlanResponseDataLevelsItemStepsItemMin = 36;

export const getPipelineExecutionPlanResponse = zod.object({
  "data": zod.object({
  "pipelineID": zod.uuid().min(getPipelineExecutionPlanResponseDataPipelineIDMin).describe('UUID identifier'),
  "levels": zod.array(zod.object({
  "level": zod.number().describe('Execution level (0-based)'),
  "steps": zod.array(zod.uuid().min(getPipelineExecutionPlanResponseDataLevelsItemStepsItemMin).describe('Step IDs that can run in parallel at this level'))
})),
  "totalSteps": zod.number().describe('Total number of steps in the pipeline'),
  "isValid": zod.boolean().describe('Whether the pipeline DAG is valid (no cycles)'),
  "estimatedDuration": zod.number().optional().describe('Estimated execution time in seconds')
})
})


/**
 * Validate that a pipeline can be executed without issues
 * @summary Validate a pipeline configuration
 */
export const validatePipelineExecutionPlanPathIdMin = 36;

export const validatePipelineExecutionPlanParams = zod.object({
  "id": zod.uuid().min(validatePipelineExecutionPlanPathIdMin).describe('Pipeline ID')
})

export const validatePipelineExecutionPlanResponse = zod.object({
  "data": zod.object({
  "valid": zod.boolean(),
  "issues": zod.array(zod.string()).optional().describe('List of any warnings or non-critical issues')
})
})


/**
 * Create a run
 * @summary Create a run
 */
export const createRunBodyPipelineIDMin = 36;

export const createRunBody = zod.object({
  "pipelineID": zod.uuid().min(createRunBodyPipelineIDMin).describe('UUID identifier')
})


/**
 * List runs
 * @summary List runs
 */
export const listRunsQueryPageLimitDefault = 10;
export const listRunsQueryPageLimitMax = 100;export const listRunsQueryPageOffsetDefault = 0;
export const listRunsQueryPageOffsetMin = 0;
export const listRunsQueryPageOffsetMax = 9007199254740991;

export const listRunsQueryParams = zod.object({
  "filter": zod.object({
  "type": zod.enum(['and', 'or', 'eq', 'ne', 'gt', 'gte', 'lt', 'lte', 'contains', 'starts_with', 'ends_with']).describe('The type of filter operation'),
  "field": zod.string().min(1).optional().describe('The field to filter on (for leaf conditions)'),
  "value": zod.any().optional().describe('The value to compare against (for leaf conditions)'),
  "children": zod.array(zod.object({
  "type": zod.enum(['and', 'or', 'eq', 'ne', 'gt', 'gte', 'lt', 'lte', 'contains', 'starts_with', 'ends_with']).describe('The type of filter operation'),
  "field": zod.string().min(1).optional().describe('The field to filter on (for leaf conditions)'),
  "value": zod.any().optional().describe('The value to compare against (for leaf conditions)'),
  "children": zod.array(zod.any()).optional().describe('Child filter nodes (for logical operators)')
}).describe('A recursive filter node that can be a condition or group')).optional().describe('Child filter nodes (for logical operators)')
}).optional().describe('Filter runs by field values. Supported fields:\n- createdAt, id, updatedAt, completedAt, error, organizationID\n- pipelineID, progress, startedAt, status, toolID\n'),
  "page": zod.object({
  "limit": zod.number().min(1).max(listRunsQueryPageLimitMax).default(listRunsQueryPageLimitDefault).describe('Maximum number of items to return'),
  "offset": zod.number().min(listRunsQueryPageOffsetMin).max(listRunsQueryPageOffsetMax).optional().describe('Number of items to skip before starting to collect the result set')
}).optional().describe('The page parameter'),
  "sort": zod.array(zod.object({
  "field": zod.enum(['createdAt', 'id', 'updatedAt', 'completedAt', 'error', 'organizationID', 'pipelineID', 'progress', 'startedAt', 'status', 'toolID']),
  "order": zod.enum(['asc', 'desc'])
})).optional().describe('The sort parameter')
})

export const listRunsResponseDataItemIdMin = 36;export const listRunsResponseDataItemOrganizationIDMin = 36;export const listRunsResponseDataItemPipelineIDMin = 36;export const listRunsResponseDataItemToolIDMin = 36;

export const listRunsResponse = zod.object({
  "data": zod.array(zod.object({
  "id": zod.uuid().min(listRunsResponseDataItemIdMin).describe('Unique identifier for the resource'),
  "createdAt": zod.iso.datetime({}).min(1).describe('The date and time when the resource was created'),
  "updatedAt": zod.iso.datetime({}).min(1).describe('The date and time when the resource was last updated')
}).describe('Base schema for all entities with common fields').and(zod.object({
  "completedAt": zod.iso.datetime({}).min(1).optional().describe('The timestamp when the run completed'),
  "error": zod.string().min(1).optional().describe('The error message'),
  "organizationID": zod.uuid().min(listRunsResponseDataItemOrganizationIDMin).describe('The organization this run belongs to'),
  "pipelineID": zod.uuid().min(listRunsResponseDataItemPipelineIDMin).describe('The pipeline this run is executing'),
  "progress": zod.number().describe('The percent progress of the run'),
  "startedAt": zod.iso.datetime({}).min(1).optional().describe('The timestamp when the run started'),
  "status": zod.enum(['COMPLETED', 'FAILED', 'PROCESSING', 'QUEUED']),
  "toolID": zod.uuid().min(listRunsResponseDataItemToolIDMin).describe('The tool being used in this run')
})).describe('Schema for Run entity')),
  "meta": zod.object({
  "total": zod.number().describe('Total number of items in the collection')
})
})


/**
 * Delete a run
 * @summary Delete a run
 */
export const deleteRunPathIdMin = 36;

export const deleteRunParams = zod.object({
  "id": zod.uuid().min(deleteRunPathIdMin).describe('The unique identifier of the resource.')
})

export const deleteRunResponseDataIdMin = 36;export const deleteRunResponseDataOrganizationIDMin = 36;export const deleteRunResponseDataPipelineIDMin = 36;export const deleteRunResponseDataToolIDMin = 36;

export const deleteRunResponse = zod.object({
  "data": zod.object({
  "id": zod.uuid().min(deleteRunResponseDataIdMin).describe('Unique identifier for the resource'),
  "createdAt": zod.iso.datetime({}).min(1).describe('The date and time when the resource was created'),
  "updatedAt": zod.iso.datetime({}).min(1).describe('The date and time when the resource was last updated')
}).describe('Base schema for all entities with common fields').and(zod.object({
  "completedAt": zod.iso.datetime({}).min(1).optional().describe('The timestamp when the run completed'),
  "error": zod.string().min(1).optional().describe('The error message'),
  "organizationID": zod.uuid().min(deleteRunResponseDataOrganizationIDMin).describe('The organization this run belongs to'),
  "pipelineID": zod.uuid().min(deleteRunResponseDataPipelineIDMin).describe('The pipeline this run is executing'),
  "progress": zod.number().describe('The percent progress of the run'),
  "startedAt": zod.iso.datetime({}).min(1).optional().describe('The timestamp when the run started'),
  "status": zod.enum(['COMPLETED', 'FAILED', 'PROCESSING', 'QUEUED']),
  "toolID": zod.uuid().min(deleteRunResponseDataToolIDMin).describe('The tool being used in this run')
})).describe('Schema for Run entity')
})


/**
 * Find a run
 * @summary Find a run
 */
export const getRunPathIdMin = 36;

export const getRunParams = zod.object({
  "id": zod.uuid().min(getRunPathIdMin).describe('The unique identifier of the resource.')
})

export const getRunResponseDataIdMin = 36;export const getRunResponseDataOrganizationIDMin = 36;export const getRunResponseDataPipelineIDMin = 36;export const getRunResponseDataToolIDMin = 36;

export const getRunResponse = zod.object({
  "data": zod.object({
  "id": zod.uuid().min(getRunResponseDataIdMin).describe('Unique identifier for the resource'),
  "createdAt": zod.iso.datetime({}).min(1).describe('The date and time when the resource was created'),
  "updatedAt": zod.iso.datetime({}).min(1).describe('The date and time when the resource was last updated')
}).describe('Base schema for all entities with common fields').and(zod.object({
  "completedAt": zod.iso.datetime({}).min(1).optional().describe('The timestamp when the run completed'),
  "error": zod.string().min(1).optional().describe('The error message'),
  "organizationID": zod.uuid().min(getRunResponseDataOrganizationIDMin).describe('The organization this run belongs to'),
  "pipelineID": zod.uuid().min(getRunResponseDataPipelineIDMin).describe('The pipeline this run is executing'),
  "progress": zod.number().describe('The percent progress of the run'),
  "startedAt": zod.iso.datetime({}).min(1).optional().describe('The timestamp when the run started'),
  "status": zod.enum(['COMPLETED', 'FAILED', 'PROCESSING', 'QUEUED']),
  "toolID": zod.uuid().min(getRunResponseDataToolIDMin).describe('The tool being used in this run')
})).describe('Schema for Run entity')
})


/**
 * Update a run
 * @summary Update a run
 */
export const updateRunPathIdMin = 36;

export const updateRunParams = zod.object({
  "id": zod.uuid().min(updateRunPathIdMin).describe('The unique identifier of the resource.')
})

export const updateRunBodyPipelineIDMin = 36;

export const updateRunBody = zod.object({
  "pipelineID": zod.uuid().min(updateRunBodyPipelineIDMin).optional().describe('UUID identifier')
})

export const updateRunResponseDataIdMin = 36;export const updateRunResponseDataOrganizationIDMin = 36;export const updateRunResponseDataPipelineIDMin = 36;export const updateRunResponseDataToolIDMin = 36;

export const updateRunResponse = zod.object({
  "data": zod.object({
  "id": zod.uuid().min(updateRunResponseDataIdMin).describe('Unique identifier for the resource'),
  "createdAt": zod.iso.datetime({}).min(1).describe('The date and time when the resource was created'),
  "updatedAt": zod.iso.datetime({}).min(1).describe('The date and time when the resource was last updated')
}).describe('Base schema for all entities with common fields').and(zod.object({
  "completedAt": zod.iso.datetime({}).min(1).optional().describe('The timestamp when the run completed'),
  "error": zod.string().min(1).optional().describe('The error message'),
  "organizationID": zod.uuid().min(updateRunResponseDataOrganizationIDMin).describe('The organization this run belongs to'),
  "pipelineID": zod.uuid().min(updateRunResponseDataPipelineIDMin).describe('The pipeline this run is executing'),
  "progress": zod.number().describe('The percent progress of the run'),
  "startedAt": zod.iso.datetime({}).min(1).optional().describe('The timestamp when the run started'),
  "status": zod.enum(['COMPLETED', 'FAILED', 'PROCESSING', 'QUEUED']),
  "toolID": zod.uuid().min(updateRunResponseDataToolIDMin).describe('The tool being used in this run')
})).describe('Schema for Run entity')
})


/**
 * Create a tool
 * @summary Create a tool
 */
export const createToolBody = zod.object({
  "description": zod.string().min(1).describe('The tool description'),
  "name": zod.string().min(1).describe('The name of the tool')
})


/**
 * List tools
 * @summary List tools
 */
export const listToolsQueryPageLimitDefault = 10;
export const listToolsQueryPageLimitMax = 100;export const listToolsQueryPageOffsetDefault = 0;
export const listToolsQueryPageOffsetMin = 0;
export const listToolsQueryPageOffsetMax = 9007199254740991;

export const listToolsQueryParams = zod.object({
  "filter": zod.object({
  "type": zod.enum(['and', 'or', 'eq', 'ne', 'gt', 'gte', 'lt', 'lte', 'contains', 'starts_with', 'ends_with']).describe('The type of filter operation'),
  "field": zod.string().min(1).optional().describe('The field to filter on (for leaf conditions)'),
  "value": zod.any().optional().describe('The value to compare against (for leaf conditions)'),
  "children": zod.array(zod.object({
  "type": zod.enum(['and', 'or', 'eq', 'ne', 'gt', 'gte', 'lt', 'lte', 'contains', 'starts_with', 'ends_with']).describe('The type of filter operation'),
  "field": zod.string().min(1).optional().describe('The field to filter on (for leaf conditions)'),
  "value": zod.any().optional().describe('The value to compare against (for leaf conditions)'),
  "children": zod.array(zod.any()).optional().describe('Child filter nodes (for logical operators)')
}).describe('A recursive filter node that can be a condition or group')).optional().describe('Child filter nodes (for logical operators)')
}).optional().describe('Filter tools by field values. Supported fields:\n- createdAt, id, updatedAt, description, inputMimeType\n- name, organizationID, outputMimeType\n'),
  "page": zod.object({
  "limit": zod.number().min(1).max(listToolsQueryPageLimitMax).default(listToolsQueryPageLimitDefault).describe('Maximum number of items to return'),
  "offset": zod.number().min(listToolsQueryPageOffsetMin).max(listToolsQueryPageOffsetMax).optional().describe('Number of items to skip before starting to collect the result set')
}).optional().describe('The page parameter'),
  "sort": zod.array(zod.object({
  "field": zod.enum(['createdAt', 'id', 'updatedAt', 'description', 'inputMimeType', 'name', 'organizationID', 'outputMimeType']),
  "order": zod.enum(['asc', 'desc'])
})).optional().describe('The sort parameter')
})

export const listToolsResponseDataItemIdMin = 36;export const listToolsResponseDataItemOrganizationIDMin = 36;

export const listToolsResponse = zod.object({
  "data": zod.array(zod.object({
  "id": zod.uuid().min(listToolsResponseDataItemIdMin).describe('Unique identifier for the resource'),
  "createdAt": zod.iso.datetime({}).min(1).describe('The date and time when the resource was created'),
  "updatedAt": zod.iso.datetime({}).min(1).describe('The date and time when the resource was last updated')
}).describe('Base schema for all entities with common fields').and(zod.object({
  "description": zod.string().min(1).describe('The tool description'),
  "inputMimeType": zod.string().min(1).describe('The MIME type of the input for the tool, e.g. text/plain'),
  "name": zod.string().min(1).describe('The name of the tool'),
  "organizationID": zod.uuid().min(listToolsResponseDataItemOrganizationIDMin).describe('The organization that owns this tool'),
  "outputMimeType": zod.string().min(1).describe('The MIME type of the output for the tool, e.g. text/plain')
})).describe('Schema for Tool entity')),
  "meta": zod.object({
  "total": zod.number().describe('Total number of items in the collection')
})
})


/**
 * Delete a tool
 * @summary Delete a tool
 */
export const deleteToolPathIdMin = 36;

export const deleteToolParams = zod.object({
  "id": zod.uuid().min(deleteToolPathIdMin).describe('The unique identifier of the resource.')
})

export const deleteToolResponseDataIdMin = 36;export const deleteToolResponseDataOrganizationIDMin = 36;

export const deleteToolResponse = zod.object({
  "data": zod.object({
  "id": zod.uuid().min(deleteToolResponseDataIdMin).describe('Unique identifier for the resource'),
  "createdAt": zod.iso.datetime({}).min(1).describe('The date and time when the resource was created'),
  "updatedAt": zod.iso.datetime({}).min(1).describe('The date and time when the resource was last updated')
}).describe('Base schema for all entities with common fields').and(zod.object({
  "description": zod.string().min(1).describe('The tool description'),
  "inputMimeType": zod.string().min(1).describe('The MIME type of the input for the tool, e.g. text/plain'),
  "name": zod.string().min(1).describe('The name of the tool'),
  "organizationID": zod.uuid().min(deleteToolResponseDataOrganizationIDMin).describe('The organization that owns this tool'),
  "outputMimeType": zod.string().min(1).describe('The MIME type of the output for the tool, e.g. text/plain')
})).describe('Schema for Tool entity')
})


/**
 * Find a tool
 * @summary Find a tool
 */
export const getToolPathIdMin = 36;

export const getToolParams = zod.object({
  "id": zod.uuid().min(getToolPathIdMin).describe('The unique identifier of the resource.')
})

export const getToolResponseDataIdMin = 36;export const getToolResponseDataOrganizationIDMin = 36;

export const getToolResponse = zod.object({
  "data": zod.object({
  "id": zod.uuid().min(getToolResponseDataIdMin).describe('Unique identifier for the resource'),
  "createdAt": zod.iso.datetime({}).min(1).describe('The date and time when the resource was created'),
  "updatedAt": zod.iso.datetime({}).min(1).describe('The date and time when the resource was last updated')
}).describe('Base schema for all entities with common fields').and(zod.object({
  "description": zod.string().min(1).describe('The tool description'),
  "inputMimeType": zod.string().min(1).describe('The MIME type of the input for the tool, e.g. text/plain'),
  "name": zod.string().min(1).describe('The name of the tool'),
  "organizationID": zod.uuid().min(getToolResponseDataOrganizationIDMin).describe('The organization that owns this tool'),
  "outputMimeType": zod.string().min(1).describe('The MIME type of the output for the tool, e.g. text/plain')
})).describe('Schema for Tool entity')
})


/**
 * Update a tool
 * @summary Update a tool
 */
export const updateToolPathIdMin = 36;

export const updateToolParams = zod.object({
  "id": zod.uuid().min(updateToolPathIdMin).describe('The unique identifier of the resource.')
})

export const updateToolBody = zod.object({
  "description": zod.string().min(1).optional().describe('The tool description'),
  "name": zod.string().min(1).optional().describe('The name of the tool')
})

export const updateToolResponseDataIdMin = 36;export const updateToolResponseDataOrganizationIDMin = 36;

export const updateToolResponse = zod.object({
  "data": zod.object({
  "id": zod.uuid().min(updateToolResponseDataIdMin).describe('Unique identifier for the resource'),
  "createdAt": zod.iso.datetime({}).min(1).describe('The date and time when the resource was created'),
  "updatedAt": zod.iso.datetime({}).min(1).describe('The date and time when the resource was last updated')
}).describe('Base schema for all entities with common fields').and(zod.object({
  "description": zod.string().min(1).describe('The tool description'),
  "inputMimeType": zod.string().min(1).describe('The MIME type of the input for the tool, e.g. text/plain'),
  "name": zod.string().min(1).describe('The name of the tool'),
  "organizationID": zod.uuid().min(updateToolResponseDataOrganizationIDMin).describe('The organization that owns this tool'),
  "outputMimeType": zod.string().min(1).describe('The MIME type of the output for the tool, e.g. text/plain')
})).describe('Schema for Tool entity')
})


/**
 * Create a artifact
 * @summary Create a artifact
 */
export const createArtifactBody = zod.object({
  "name": zod.string().min(1).optional().describe('The name of the artifact'),
  "text": zod.string().min(1).describe('The artifact text')
})


/**
 * List artifacts
 * @summary List artifacts
 */
export const listArtifactsQueryPageLimitDefault = 10;
export const listArtifactsQueryPageLimitMax = 100;export const listArtifactsQueryPageOffsetDefault = 0;
export const listArtifactsQueryPageOffsetMin = 0;
export const listArtifactsQueryPageOffsetMax = 9007199254740991;

export const listArtifactsQueryParams = zod.object({
  "filter": zod.object({
  "type": zod.enum(['and', 'or', 'eq', 'ne', 'gt', 'gte', 'lt', 'lte', 'contains', 'starts_with', 'ends_with']).describe('The type of filter operation'),
  "field": zod.string().min(1).optional().describe('The field to filter on (for leaf conditions)'),
  "value": zod.any().optional().describe('The value to compare against (for leaf conditions)'),
  "children": zod.array(zod.object({
  "type": zod.enum(['and', 'or', 'eq', 'ne', 'gt', 'gte', 'lt', 'lte', 'contains', 'starts_with', 'ends_with']).describe('The type of filter operation'),
  "field": zod.string().min(1).optional().describe('The field to filter on (for leaf conditions)'),
  "value": zod.any().optional().describe('The value to compare against (for leaf conditions)'),
  "children": zod.array(zod.any()).optional().describe('Child filter nodes (for logical operators)')
}).describe('A recursive filter node that can be a condition or group')).optional().describe('Child filter nodes (for logical operators)')
}).optional().describe('Filter artifacts by field values. Supported fields:\n- createdAt, id, updatedAt, credits, description, mimeType\n- name, organizationID, previewImage, producerID, text, url\n'),
  "page": zod.object({
  "limit": zod.number().min(1).max(listArtifactsQueryPageLimitMax).default(listArtifactsQueryPageLimitDefault).describe('Maximum number of items to return'),
  "offset": zod.number().min(listArtifactsQueryPageOffsetMin).max(listArtifactsQueryPageOffsetMax).optional().describe('Number of items to skip before starting to collect the result set')
}).optional().describe('The page parameter'),
  "sort": zod.array(zod.object({
  "field": zod.enum(['createdAt', 'id', 'updatedAt', 'credits', 'description', 'mimeType', 'name', 'organizationID', 'previewImage', 'producerID', 'text', 'url']),
  "order": zod.enum(['asc', 'desc'])
})).optional().describe('The sort parameter')
})

export const listArtifactsResponseDataItemIdMin = 36;export const listArtifactsResponseDataItemOrganizationIDMin = 36;export const listArtifactsResponseDataItemProducerIDMin = 36;

export const listArtifactsResponse = zod.object({
  "data": zod.array(zod.object({
  "id": zod.uuid().min(listArtifactsResponseDataItemIdMin).describe('Unique identifier for the resource'),
  "createdAt": zod.iso.datetime({}).min(1).describe('The date and time when the resource was created'),
  "updatedAt": zod.iso.datetime({}).min(1).describe('The date and time when the resource was last updated')
}).describe('Base schema for all entities with common fields').and(zod.object({
  "credits": zod.number().describe('The number of credits required to access this artifact. This is used for metering and billing purposes.'),
  "description": zod.string().min(1).optional().describe('The artifact\'s description'),
  "mimeType": zod.string().min(1).describe('The MIME type of the artifact, e.g. image/png'),
  "name": zod.string().min(1).optional().describe('The name of the artifact, used for display purposes'),
  "organizationID": zod.uuid().min(listArtifactsResponseDataItemOrganizationIDMin).describe('The organization that owns this artifact'),
  "previewImage": zod.string().min(1).optional().describe('The URL of the preview image for this artifact. This is used for displaying a thumbnail in the UI.'),
  "producerID": zod.uuid().min(listArtifactsResponseDataItemProducerIDMin).optional().describe('The ID of the entity that produced this artifact'),
  "text": zod.string().min(1).optional().describe('The artifact text')
})).describe('Schema for Artifact entity')),
  "meta": zod.object({
  "total": zod.number().describe('Total number of items in the collection')
})
})


/**
 * Delete an artifact
 * @summary Delete an artifact
 */
export const deleteArtifactPathIdMin = 36;

export const deleteArtifactParams = zod.object({
  "id": zod.uuid().min(deleteArtifactPathIdMin).describe('The unique identifier of the resource.')
})

export const deleteArtifactResponseDataIdMin = 36;export const deleteArtifactResponseDataOrganizationIDMin = 36;export const deleteArtifactResponseDataProducerIDMin = 36;

export const deleteArtifactResponse = zod.object({
  "data": zod.object({
  "id": zod.uuid().min(deleteArtifactResponseDataIdMin).describe('Unique identifier for the resource'),
  "createdAt": zod.iso.datetime({}).min(1).describe('The date and time when the resource was created'),
  "updatedAt": zod.iso.datetime({}).min(1).describe('The date and time when the resource was last updated')
}).describe('Base schema for all entities with common fields').and(zod.object({
  "credits": zod.number().describe('The number of credits required to access this artifact. This is used for metering and billing purposes.'),
  "description": zod.string().min(1).optional().describe('The artifact\'s description'),
  "mimeType": zod.string().min(1).describe('The MIME type of the artifact, e.g. image/png'),
  "name": zod.string().min(1).optional().describe('The name of the artifact, used for display purposes'),
  "organizationID": zod.uuid().min(deleteArtifactResponseDataOrganizationIDMin).describe('The organization that owns this artifact'),
  "previewImage": zod.string().min(1).optional().describe('The URL of the preview image for this artifact. This is used for displaying a thumbnail in the UI.'),
  "producerID": zod.uuid().min(deleteArtifactResponseDataProducerIDMin).optional().describe('The ID of the entity that produced this artifact'),
  "text": zod.string().min(1).optional().describe('The artifact text')
})).describe('Schema for Artifact entity')
})


/**
 * Find an artifact
 * @summary Find an artifact
 */
export const getArtifactPathIdMin = 36;

export const getArtifactParams = zod.object({
  "id": zod.uuid().min(getArtifactPathIdMin).describe('The unique identifier of the resource.')
})

export const getArtifactResponseDataIdMin = 36;export const getArtifactResponseDataOrganizationIDMin = 36;export const getArtifactResponseDataProducerIDMin = 36;

export const getArtifactResponse = zod.object({
  "data": zod.object({
  "id": zod.uuid().min(getArtifactResponseDataIdMin).describe('Unique identifier for the resource'),
  "createdAt": zod.iso.datetime({}).min(1).describe('The date and time when the resource was created'),
  "updatedAt": zod.iso.datetime({}).min(1).describe('The date and time when the resource was last updated')
}).describe('Base schema for all entities with common fields').and(zod.object({
  "credits": zod.number().describe('The number of credits required to access this artifact. This is used for metering and billing purposes.'),
  "description": zod.string().min(1).optional().describe('The artifact\'s description'),
  "mimeType": zod.string().min(1).describe('The MIME type of the artifact, e.g. image/png'),
  "name": zod.string().min(1).optional().describe('The name of the artifact, used for display purposes'),
  "organizationID": zod.uuid().min(getArtifactResponseDataOrganizationIDMin).describe('The organization that owns this artifact'),
  "previewImage": zod.string().min(1).optional().describe('The URL of the preview image for this artifact. This is used for displaying a thumbnail in the UI.'),
  "producerID": zod.uuid().min(getArtifactResponseDataProducerIDMin).optional().describe('The ID of the entity that produced this artifact'),
  "text": zod.string().min(1).optional().describe('The artifact text')
})).describe('Schema for Artifact entity')
})


/**
 * Update an artifact
 * @summary Update an artifact
 */
export const updateArtifactPathIdMin = 36;

export const updateArtifactParams = zod.object({
  "id": zod.uuid().min(updateArtifactPathIdMin).describe('The unique identifier of the resource.')
})

export const updateArtifactBody = zod.object({
  "name": zod.string().min(1).optional().describe('The name of the artifact'),
  "text": zod.string().optional().describe('The artifact text'),
  "url": zod.string().optional().describe('The artifact URL')
})

export const updateArtifactResponseDataIdMin = 36;export const updateArtifactResponseDataOrganizationIDMin = 36;export const updateArtifactResponseDataProducerIDMin = 36;

export const updateArtifactResponse = zod.object({
  "data": zod.object({
  "id": zod.uuid().min(updateArtifactResponseDataIdMin).describe('Unique identifier for the resource'),
  "createdAt": zod.iso.datetime({}).min(1).describe('The date and time when the resource was created'),
  "updatedAt": zod.iso.datetime({}).min(1).describe('The date and time when the resource was last updated')
}).describe('Base schema for all entities with common fields').and(zod.object({
  "credits": zod.number().describe('The number of credits required to access this artifact. This is used for metering and billing purposes.'),
  "description": zod.string().min(1).optional().describe('The artifact\'s description'),
  "mimeType": zod.string().min(1).describe('The MIME type of the artifact, e.g. image/png'),
  "name": zod.string().min(1).optional().describe('The name of the artifact, used for display purposes'),
  "organizationID": zod.uuid().min(updateArtifactResponseDataOrganizationIDMin).describe('The organization that owns this artifact'),
  "previewImage": zod.string().min(1).optional().describe('The URL of the preview image for this artifact. This is used for displaying a thumbnail in the UI.'),
  "producerID": zod.uuid().min(updateArtifactResponseDataProducerIDMin).optional().describe('The ID of the entity that produced this artifact'),
  "text": zod.string().min(1).optional().describe('The artifact text')
})).describe('Schema for Artifact entity')
})


/**
 * Create a label
 * @summary Create a label
 */
export const createLabelBody = zod.object({
  "name": zod.string().min(1).describe('The name of the label')
})


/**
 * List labels
 * @summary List labels
 */
export const listLabelsQueryPageLimitDefault = 10;
export const listLabelsQueryPageLimitMax = 100;export const listLabelsQueryPageOffsetDefault = 0;
export const listLabelsQueryPageOffsetMin = 0;
export const listLabelsQueryPageOffsetMax = 9007199254740991;

export const listLabelsQueryParams = zod.object({
  "filter": zod.object({
  "type": zod.enum(['and', 'or', 'eq', 'ne', 'gt', 'gte', 'lt', 'lte', 'contains', 'starts_with', 'ends_with']).describe('The type of filter operation'),
  "field": zod.string().min(1).optional().describe('The field to filter on (for leaf conditions)'),
  "value": zod.any().optional().describe('The value to compare against (for leaf conditions)'),
  "children": zod.array(zod.object({
  "type": zod.enum(['and', 'or', 'eq', 'ne', 'gt', 'gte', 'lt', 'lte', 'contains', 'starts_with', 'ends_with']).describe('The type of filter operation'),
  "field": zod.string().min(1).optional().describe('The field to filter on (for leaf conditions)'),
  "value": zod.any().optional().describe('The value to compare against (for leaf conditions)'),
  "children": zod.array(zod.any()).optional().describe('Child filter nodes (for logical operators)')
}).describe('A recursive filter node that can be a condition or group')).optional().describe('Child filter nodes (for logical operators)')
}).optional().describe('Filter labels by field values. Supported fields:\n- createdAt, id, updatedAt, name, organizationID\n'),
  "page": zod.object({
  "limit": zod.number().min(1).max(listLabelsQueryPageLimitMax).default(listLabelsQueryPageLimitDefault).describe('Maximum number of items to return'),
  "offset": zod.number().min(listLabelsQueryPageOffsetMin).max(listLabelsQueryPageOffsetMax).optional().describe('Number of items to skip before starting to collect the result set')
}).optional().describe('The page parameter'),
  "sort": zod.array(zod.object({
  "field": zod.enum(['createdAt', 'id', 'updatedAt', 'name', 'organizationID']),
  "order": zod.enum(['asc', 'desc'])
})).optional().describe('The sort parameter')
})

export const listLabelsResponseDataItemIdMin = 36;export const listLabelsResponseDataItemOrganizationIDMin = 36;

export const listLabelsResponse = zod.object({
  "data": zod.array(zod.object({
  "id": zod.uuid().min(listLabelsResponseDataItemIdMin).describe('Unique identifier for the resource'),
  "createdAt": zod.iso.datetime({}).min(1).describe('The date and time when the resource was created'),
  "updatedAt": zod.iso.datetime({}).min(1).describe('The date and time when the resource was last updated')
}).describe('Base schema for all entities with common fields').and(zod.object({
  "name": zod.string().min(1).describe('The name of the label'),
  "organizationID": zod.uuid().min(listLabelsResponseDataItemOrganizationIDMin).describe('The organization this label belongs to')
})).describe('Schema for Label entity')),
  "meta": zod.object({
  "total": zod.number().describe('Total number of items in the collection')
})
})


/**
 * Delete a label
 * @summary Delete a label
 */
export const deleteLabelPathIdMin = 36;

export const deleteLabelParams = zod.object({
  "id": zod.uuid().min(deleteLabelPathIdMin).describe('The unique identifier of the resource.')
})

export const deleteLabelResponseDataIdMin = 36;export const deleteLabelResponseDataOrganizationIDMin = 36;

export const deleteLabelResponse = zod.object({
  "data": zod.object({
  "id": zod.uuid().min(deleteLabelResponseDataIdMin).describe('Unique identifier for the resource'),
  "createdAt": zod.iso.datetime({}).min(1).describe('The date and time when the resource was created'),
  "updatedAt": zod.iso.datetime({}).min(1).describe('The date and time when the resource was last updated')
}).describe('Base schema for all entities with common fields').and(zod.object({
  "name": zod.string().min(1).describe('The name of the label'),
  "organizationID": zod.uuid().min(deleteLabelResponseDataOrganizationIDMin).describe('The organization this label belongs to')
})).describe('Schema for Label entity')
})


/**
 * Find a label
 * @summary Find a label
 */
export const getLabelPathIdMin = 36;

export const getLabelParams = zod.object({
  "id": zod.uuid().min(getLabelPathIdMin).describe('The unique identifier of the resource.')
})

export const getLabelResponseDataIdMin = 36;export const getLabelResponseDataOrganizationIDMin = 36;

export const getLabelResponse = zod.object({
  "data": zod.object({
  "id": zod.uuid().min(getLabelResponseDataIdMin).describe('Unique identifier for the resource'),
  "createdAt": zod.iso.datetime({}).min(1).describe('The date and time when the resource was created'),
  "updatedAt": zod.iso.datetime({}).min(1).describe('The date and time when the resource was last updated')
}).describe('Base schema for all entities with common fields').and(zod.object({
  "name": zod.string().min(1).describe('The name of the label'),
  "organizationID": zod.uuid().min(getLabelResponseDataOrganizationIDMin).describe('The organization this label belongs to')
})).describe('Schema for Label entity')
})


/**
 * Update a label
 * @summary Update a label
 */
export const updateLabelPathIdMin = 36;

export const updateLabelParams = zod.object({
  "id": zod.uuid().min(updateLabelPathIdMin).describe('The unique identifier of the resource.')
})

export const updateLabelBody = zod.object({
  "name": zod.string().min(1).optional().describe('The name of the label')
})

export const updateLabelResponseDataIdMin = 36;export const updateLabelResponseDataOrganizationIDMin = 36;

export const updateLabelResponse = zod.object({
  "data": zod.object({
  "id": zod.uuid().min(updateLabelResponseDataIdMin).describe('Unique identifier for the resource'),
  "createdAt": zod.iso.datetime({}).min(1).describe('The date and time when the resource was created'),
  "updatedAt": zod.iso.datetime({}).min(1).describe('The date and time when the resource was last updated')
}).describe('Base schema for all entities with common fields').and(zod.object({
  "name": zod.string().min(1).describe('The name of the label'),
  "organizationID": zod.uuid().min(updateLabelResponseDataOrganizationIDMin).describe('The organization this label belongs to')
})).describe('Schema for Label entity')
})


/**
 * Get the configuration of the application
 * @summary Get the configuration
 */
export const getConfigResponseApiCorsDefault = "localhost";export const getConfigResponseApiUrlDefault = "http://localhost:3001";export const getConfigResponseApiDocsDefault = true;export const getConfigResponseApiEmailEnabledDefault = false;export const getConfigResponseApiEnvironmentDefault = "development";export const getConfigResponseApiHostDefault = "0.0.0.0";export const getConfigResponseApiPortDefault = 3001;export const getConfigResponseApiValidateDefault = true;export const getConfigResponseApiImagePullPolicyDefault = "IfNotPresent";export const getConfigResponseApiImageTagDefault = "latest";export const getConfigResponseApiResourcesLimitsCpuDefault = "1000m";export const getConfigResponseApiResourcesLimitsMemoryDefault = "1Gi";export const getConfigResponseApiResourcesRequestsCpuDefault = "100m";export const getConfigResponseApiResourcesRequestsMemoryDefault = "128Mi";export const getConfigResponseAuthEnabledDefault = true;export const getConfigResponseAuthFirebaseEnabledDefault = false;export const getConfigResponseAuthLocalEnabledDefault = true;export const getConfigResponseAuthLocalJwtSecretDefault = "change-me-in-production";
export const getConfigResponseAuthLocalJwtSecretMin = 32;export const getConfigResponseAuthLocalAccessTokenTtlDefault = "15m";
export const getConfigResponseAuthLocalAccessTokenTtlMin = 2;
export const getConfigResponseAuthLocalAccessTokenTtlRegExp = new RegExp('^(\\d+[smhd])+$');
export const getConfigResponseAuthLocalRefreshTokenTtlDefault = "168h";
export const getConfigResponseAuthLocalRefreshTokenTtlMin = 2;
export const getConfigResponseAuthLocalRefreshTokenTtlRegExp = new RegExp('^(\\d+[smhd])+$');
export const getConfigResponseAuthMagicLinkEnabledDefault = false;export const getConfigResponseAuthMagicLinkTokenExpiryDefault = 15;
export const getConfigResponseAuthMagicLinkTokenExpiryMax = 60;export const getConfigResponseAuthMagicLinkOtpLengthDefault = 6;
export const getConfigResponseAuthMagicLinkOtpLengthMin = 4;
export const getConfigResponseAuthMagicLinkOtpLengthMax = 8;export const getConfigResponseAuthMagicLinkDeliveryMethodsEmailEnabledDefault = true;export const getConfigResponseAuthMagicLinkDeliveryMethodsConsoleEnabledDefault = false;export const getConfigResponseAuthMagicLinkDeliveryMethodsOtpEnabledDefault = true;export const getConfigResponseAuthMagicLinkDeliveryMethodsWebhookEnabledDefault = false;export const getConfigResponseAuthMagicLinkRateLimitMaxAttemptsDefault = 5;export const getConfigResponseAuthMagicLinkRateLimitWindowMinutesDefault = 15;export const getConfigResponseAuthTwitterEnabledDefault = false;export const getConfigResponseAuthGoogleEnabledDefault = false;export const getConfigResponseAuthGoogleScopesDefault = ["openid", "profile", "email"];export const getConfigResponseAuthGithubEnabledDefault = false;export const getConfigResponseAuthGithubScopesDefault = ["user:email"];export const getConfigResponseAuthMicrosoftEnabledDefault = false;export const getConfigResponseAuthMicrosoftTenantDefault = "common";export const getConfigResponseAuthMicrosoftScopesDefault = ["openid", "profile", "email", "User.Read"];export const getConfigResponseBillingEnabledDefault = false;export const getConfigResponseDatabaseEnabledDefault = true;export const getConfigResponseDatabaseUrlDefault = "postgresql://admin:password@127.0.0.1:5432/archesai";export const getConfigResponseDatabaseTypeDefault = "postgresql";export const getConfigResponseDatabaseMaxConnsDefault = 25;export const getConfigResponseDatabaseMinConnsDefault = 5;
export const getConfigResponseDatabaseMinConnsMin = 0;export const getConfigResponseDatabaseConnMaxLifetimeRegExp = new RegExp('^(\\d+[smh])+$');
export const getConfigResponseDatabaseConnMaxIdleTimeRegExp = new RegExp('^(\\d+[smh])+$');
export const getConfigResponseDatabaseHealthCheckPeriodRegExp = new RegExp('^(\\d+[smh])+$');
export const getConfigResponseDatabaseRunMigrationsDefault = false;export const getConfigResponseDatabaseManagedDefault = false;export const getConfigResponseDatabaseImagePullPolicyDefault = "IfNotPresent";export const getConfigResponseDatabaseImageTagDefault = "latest";export const getConfigResponseDatabasePersistenceEnabledDefault = true;export const getConfigResponseDatabasePersistenceSizeDefault = "10Gi";export const getConfigResponseDatabaseResourcesLimitsCpuDefault = "1000m";export const getConfigResponseDatabaseResourcesLimitsMemoryDefault = "1Gi";export const getConfigResponseDatabaseResourcesRequestsCpuDefault = "100m";export const getConfigResponseDatabaseResourcesRequestsMemoryDefault = "128Mi";export const getConfigResponseIntelligenceEmbeddingTypeDefault = "ollama";export const getConfigResponseIntelligenceLlmTypeDefault = "ollama";export const getConfigResponseIntelligenceRunpodEnabledDefault = false;export const getConfigResponseIntelligenceScraperEnabledDefault = false;export const getConfigResponseIntelligenceScraperManagedDefault = false;export const getConfigResponseIntelligenceScraperImagePullPolicyDefault = "IfNotPresent";export const getConfigResponseIntelligenceScraperImageTagDefault = "latest";export const getConfigResponseIntelligenceScraperResourcesLimitsCpuDefault = "1000m";export const getConfigResponseIntelligenceScraperResourcesLimitsMemoryDefault = "1Gi";export const getConfigResponseIntelligenceScraperResourcesRequestsCpuDefault = "100m";export const getConfigResponseIntelligenceScraperResourcesRequestsMemoryDefault = "128Mi";export const getConfigResponseIntelligenceSpeechEnabledDefault = false;export const getConfigResponseIntelligenceUnstructuredEnabledDefault = false;export const getConfigResponseIntelligenceUnstructuredManagedDefault = false;export const getConfigResponseIntelligenceUnstructuredImagePullPolicyDefault = "IfNotPresent";export const getConfigResponseIntelligenceUnstructuredImageTagDefault = "latest";export const getConfigResponseIntelligenceUnstructuredResourcesLimitsCpuDefault = "1000m";export const getConfigResponseIntelligenceUnstructuredResourcesLimitsMemoryDefault = "1Gi";export const getConfigResponseIntelligenceUnstructuredResourcesRequestsCpuDefault = "100m";export const getConfigResponseIntelligenceUnstructuredResourcesRequestsMemoryDefault = "128Mi";export const getConfigResponseLoggingLevelDefault = "info";export const getConfigResponseLoggingPrettyDefault = false;export const getConfigResponsePlatformEnabledDefault = false;export const getConfigResponsePlatformManagedDefault = false;export const getConfigResponsePlatformUrlDefault = "http://localhost:3000";export const getConfigResponsePlatformImagePullPolicyDefault = "IfNotPresent";export const getConfigResponsePlatformImageTagDefault = "latest";export const getConfigResponsePlatformResourcesLimitsCpuDefault = "1000m";export const getConfigResponsePlatformResourcesLimitsMemoryDefault = "1Gi";export const getConfigResponsePlatformResourcesRequestsCpuDefault = "100m";export const getConfigResponsePlatformResourcesRequestsMemoryDefault = "128Mi";export const getConfigResponseRedisEnabledDefault = false;export const getConfigResponseRedisManagedDefault = false;export const getConfigResponseRedisAuthDefault = "password";export const getConfigResponseRedisHostDefault = "localhost";export const getConfigResponseRedisPortDefault = 6379;export const getConfigResponseRedisImagePullPolicyDefault = "IfNotPresent";export const getConfigResponseRedisImageTagDefault = "latest";export const getConfigResponseRedisPersistenceEnabledDefault = true;export const getConfigResponseRedisPersistenceSizeDefault = "10Gi";export const getConfigResponseRedisResourcesLimitsCpuDefault = "1000m";export const getConfigResponseRedisResourcesLimitsMemoryDefault = "1Gi";export const getConfigResponseRedisResourcesRequestsCpuDefault = "100m";export const getConfigResponseRedisResourcesRequestsMemoryDefault = "128Mi";export const getConfigResponseStorageEnabledDefault = false;export const getConfigResponseStorageManagedDefault = false;export const getConfigResponseStorageAccesskeyDefault = "minioadmin";export const getConfigResponseStorageBucketDefault = "archesai";export const getConfigResponseStorageEndpointDefault = "http://localhost:9000";export const getConfigResponseStorageSecretkeyDefault = "minioadmin";export const getConfigResponseStorageImagePullPolicyDefault = "IfNotPresent";export const getConfigResponseStorageImageTagDefault = "latest";export const getConfigResponseStoragePersistenceEnabledDefault = true;export const getConfigResponseStoragePersistenceSizeDefault = "10Gi";export const getConfigResponseStorageResourcesLimitsCpuDefault = "1000m";export const getConfigResponseStorageResourcesLimitsMemoryDefault = "1Gi";export const getConfigResponseStorageResourcesRequestsCpuDefault = "100m";export const getConfigResponseStorageResourcesRequestsMemoryDefault = "128Mi";export const getConfigResponseKubernetesInfrastructureImagesImagePullSecretsDefault = [];export const getConfigResponseKubernetesInfrastructureImagesImageRegistryDefault = "";export const getConfigResponseKubernetesInfrastructureMigrationsEnabledDefault = false;export const getConfigResponseKubernetesInfrastructureNamespaceDefault = "arches-system";export const getConfigResponseKubernetesInfrastructureServiceAccountCreateDefault = true;export const getConfigResponseKubernetesInfrastructureServiceAccountNameDefault = "";export const getConfigResponseKubernetesIngressEnabledDefault = false;export const getConfigResponseKubernetesIngressDomainDefault = "archesai.dev";export const getConfigResponseKubernetesIngressTlsEnabledDefault = true;export const getConfigResponseKubernetesIngressTlsIssuerDefault = "letsencrypt-staging";export const getConfigResponseKubernetesIngressTlsSecretNameDefault = "archesai-tls";export const getConfigResponseKubernetesMonitoringGrafanaEnabledDefault = false;export const getConfigResponseKubernetesMonitoringGrafanaManagedDefault = false;export const getConfigResponseKubernetesMonitoringGrafanaImagePullPolicyDefault = "IfNotPresent";export const getConfigResponseKubernetesMonitoringGrafanaImageTagDefault = "latest";export const getConfigResponseKubernetesMonitoringGrafanaResourcesLimitsCpuDefault = "1000m";export const getConfigResponseKubernetesMonitoringGrafanaResourcesLimitsMemoryDefault = "1Gi";export const getConfigResponseKubernetesMonitoringGrafanaResourcesRequestsCpuDefault = "100m";export const getConfigResponseKubernetesMonitoringGrafanaResourcesRequestsMemoryDefault = "128Mi";export const getConfigResponseKubernetesMonitoringLokiEnabledDefault = false;export const getConfigResponseKubernetesMonitoringLokiManagedDefault = false;export const getConfigResponseKubernetesMonitoringLokiHostDefault = "http://localhost:3100";export const getConfigResponseKubernetesMonitoringLokiImagePullPolicyDefault = "IfNotPresent";export const getConfigResponseKubernetesMonitoringLokiImageTagDefault = "latest";export const getConfigResponseKubernetesMonitoringLokiResourcesLimitsCpuDefault = "1000m";export const getConfigResponseKubernetesMonitoringLokiResourcesLimitsMemoryDefault = "1Gi";export const getConfigResponseKubernetesMonitoringLokiResourcesRequestsCpuDefault = "100m";export const getConfigResponseKubernetesMonitoringLokiResourcesRequestsMemoryDefault = "128Mi";

export const getConfigResponse = zod.object({
  "api": zod.object({
  "cors": zod.string().min(1).describe('A comma-separated list of allowed origins for CORS requests'),
  "url": zod.url().default(getConfigResponseApiUrlDefault).describe('The public URL for the API'),
  "docs": zod.boolean().describe('Enable or disable API documentation'),
  "email": zod.object({
  "enabled": zod.boolean().describe('Enable email functionality'),
  "service": zod.string().optional().describe('Email service provider (e.g., \"gmail\", \"sendgrid\", etc.)'),
  "user": zod.string().optional().describe('Username for the email service'),
  "password": zod.string().optional().describe('Password for the email service')
}).optional().describe('Email configuration for sending emails'),
  "environment": zod.string().describe('Deployment environment (development, staging, production)'),
  "host": zod.string().min(1).describe('The host address on which the API server will listen'),
  "port": zod.number().describe('The port on which the API server will listen'),
  "validate": zod.boolean().describe('Enable or disable request validation'),
  "image": zod.object({
  "pullPolicy": zod.enum(['Always', 'IfNotPresent', 'Never']).describe('Kubernetes image pull policy'),
  "repository": zod.string().min(1).optional().describe('Container image repository'),
  "tag": zod.string().min(1).describe('Container image tag')
}).optional().describe('Container image configuration'),
  "resources": zod.object({
  "limits": zod.object({
  "cpu": zod.string().min(1).describe('Maximum CPU allocation'),
  "memory": zod.string().min(1).describe('Maximum memory allocation')
}).describe('Resource limits'),
  "requests": zod.object({
  "cpu": zod.string().min(1).describe('Requested CPU allocation'),
  "memory": zod.string().min(1).describe('Requested memory allocation')
}).describe('Resource requests')
}).optional().describe('Kubernetes resource configuration')
}).optional().describe('Configuration schema for the API server'),
  "auth": zod.object({
  "enabled": zod.boolean().describe('Enable authentication'),
  "firebase": zod.object({
  "enabled": zod.boolean().describe('Enable Firebase authentication'),
  "clientEmail": zod.string().optional().describe('Firebase service account client email address'),
  "privateKey": zod.string().min(1).optional().describe('Firebase service account private key (PEM format)'),
  "projectID": zod.string().min(1).optional().describe('Firebase project ID for authentication')
}).optional().describe('Firebase authentication configuration'),
  "local": zod.object({
  "enabled": zod.boolean().describe('Enable local authentication'),
  "jwtSecret": zod.string().min(getConfigResponseAuthLocalJwtSecretMin).describe('Secret key for JWT token signing'),
  "accessTokenTtl": zod.string().min(getConfigResponseAuthLocalAccessTokenTtlMin).regex(getConfigResponseAuthLocalAccessTokenTtlRegExp).describe('Access token time-to-live duration (e.g., \"15m\", \"1h\")'),
  "refreshTokenTtl": zod.string().min(getConfigResponseAuthLocalRefreshTokenTtlMin).regex(getConfigResponseAuthLocalRefreshTokenTtlRegExp).describe('Refresh token time-to-live duration (e.g., \"7d\", \"168h\")')
}).optional().describe('Local username/password authentication'),
  "magicLink": zod.object({
  "enabled": zod.boolean().describe('Enable magic link authentication'),
  "tokenExpiry": zod.number().min(1).max(getConfigResponseAuthMagicLinkTokenExpiryMax).default(getConfigResponseAuthMagicLinkTokenExpiryDefault).describe('Token expiry duration in minutes'),
  "otpLength": zod.number().min(getConfigResponseAuthMagicLinkOtpLengthMin).max(getConfigResponseAuthMagicLinkOtpLengthMax).default(getConfigResponseAuthMagicLinkOtpLengthDefault).describe('Length of OTP code'),
  "deliveryMethods": zod.object({
  "email": zod.object({
  "enabled": zod.boolean().default(getConfigResponseAuthMagicLinkDeliveryMethodsEmailEnabledDefault),
  "from": zod.email().optional()
}).optional(),
  "console": zod.object({
  "enabled": zod.boolean().optional().describe('Enable console output (development only)')
}).optional(),
  "otp": zod.object({
  "enabled": zod.boolean().default(getConfigResponseAuthMagicLinkDeliveryMethodsOtpEnabledDefault)
}).optional(),
  "webhook": zod.object({
  "enabled": zod.boolean().optional(),
  "url": zod.url().optional()
}).optional()
}).optional().describe('Available delivery methods'),
  "rateLimit": zod.object({
  "maxAttempts": zod.number().min(1).default(getConfigResponseAuthMagicLinkRateLimitMaxAttemptsDefault).describe('Maximum number of attempts within window'),
  "windowMinutes": zod.number().min(1).default(getConfigResponseAuthMagicLinkRateLimitWindowMinutesDefault).describe('Time window in minutes')
}).optional().describe('Rate limiting configuration')
}).optional().describe('Magic link authentication configuration'),
  "twitter": zod.object({
  "enabled": zod.boolean().describe('Enable Twitter OAuth'),
  "callbackURL": zod.string().min(1).optional().describe('OAuth callback URL'),
  "consumerKey": zod.string().min(1).optional().describe('Twitter API consumer key'),
  "consumerSecret": zod.string().min(1).optional().describe('Twitter API consumer secret')
}).optional().describe('Twitter OAuth configuration'),
  "google": zod.object({
  "enabled": zod.boolean().describe('Enable Google OAuth'),
  "clientId": zod.string().optional().describe('Google OAuth client ID'),
  "clientSecret": zod.string().optional().describe('Google OAuth client secret'),
  "redirectUrl": zod.string().optional().describe('OAuth callback URL'),
  "scopes": zod.array(zod.string()).default(getConfigResponseAuthGoogleScopesDefault).describe('OAuth scopes to request')
}).optional().describe('Google OAuth configuration'),
  "github": zod.object({
  "enabled": zod.boolean().describe('Enable GitHub OAuth'),
  "clientId": zod.string().optional().describe('GitHub OAuth App client ID'),
  "clientSecret": zod.string().optional().describe('GitHub OAuth App client secret'),
  "redirectUrl": zod.string().optional().describe('OAuth callback URL'),
  "scopes": zod.array(zod.string()).default(getConfigResponseAuthGithubScopesDefault).describe('OAuth scopes to request')
}).optional().describe('GitHub OAuth configuration'),
  "microsoft": zod.object({
  "enabled": zod.boolean().describe('Enable Microsoft OAuth'),
  "clientId": zod.string().optional().describe('Azure AD Application (client) ID'),
  "clientSecret": zod.string().optional().describe('Azure AD client secret'),
  "redirectUrl": zod.string().optional().describe('OAuth callback URL'),
  "tenant": zod.string().default(getConfigResponseAuthMicrosoftTenantDefault).describe('Azure AD tenant ID (use \'common\' for multi-tenant)'),
  "scopes": zod.array(zod.string()).default(getConfigResponseAuthMicrosoftScopesDefault).describe('OAuth scopes to request')
}).optional().describe('Microsoft/Azure AD OAuth configuration')
}).optional().describe('Authentication configuration for the API server'),
  "billing": zod.object({
  "enabled": zod.boolean().describe('Enable billing functionality'),
  "stripe": zod.object({
  "token": zod.string().min(1).describe('Stripe secret API key'),
  "whsec": zod.string().min(1).describe('Stripe webhook endpoint secret')
}).optional().describe('Stripe payment configuration')
}).optional().describe('Billing configuration for Stripe'),
  "database": zod.object({
  "enabled": zod.boolean().describe('Enable database'),
  "url": zod.string().min(1).describe('Database connection url/string'),
  "type": zod.enum(['postgresql', 'sqlite']).describe('Database type (postgresql or sqlite)'),
  "maxConns": zod.number().min(1).describe('Maximum number of connections in pool (PostgreSQL)'),
  "minConns": zod.number().min(getConfigResponseDatabaseMinConnsMin).describe('Minimum number of connections in pool (PostgreSQL)'),
  "connMaxLifetime": zod.string().regex(getConfigResponseDatabaseConnMaxLifetimeRegExp).optional().describe('Maximum connection lifetime (e.g., \"30m\")'),
  "connMaxIdleTime": zod.string().regex(getConfigResponseDatabaseConnMaxIdleTimeRegExp).optional().describe('Maximum connection idle time (e.g., \"5m\")'),
  "healthCheckPeriod": zod.string().regex(getConfigResponseDatabaseHealthCheckPeriodRegExp).optional().describe('Health check period for connections (PostgreSQL)'),
  "runMigrations": zod.boolean().describe('Automatically run database migrations on startup'),
  "managed": zod.boolean().describe('Use managed database deployment'),
  "image": zod.object({
  "pullPolicy": zod.enum(['Always', 'IfNotPresent', 'Never']).describe('Kubernetes image pull policy'),
  "repository": zod.string().min(1).optional().describe('Container image repository'),
  "tag": zod.string().min(1).describe('Container image tag')
}).optional().describe('Container image configuration'),
  "persistence": zod.object({
  "enabled": zod.boolean().describe('Enable persistent storage'),
  "size": zod.string().min(1).describe('Size of persistent volume')
}).optional().describe('Persistent storage configuration'),
  "resources": zod.object({
  "limits": zod.object({
  "cpu": zod.string().min(1).describe('Maximum CPU allocation'),
  "memory": zod.string().min(1).describe('Maximum memory allocation')
}).describe('Resource limits'),
  "requests": zod.object({
  "cpu": zod.string().min(1).describe('Requested CPU allocation'),
  "memory": zod.string().min(1).describe('Requested memory allocation')
}).describe('Resource requests')
}).optional().describe('Kubernetes resource configuration')
}).optional().describe('Database configuration for PostgreSQL'),
  "intelligence": zod.object({
  "embedding": zod.object({
  "type": zod.enum(['ollama', 'openai']).describe('LLM provider type'),
  "endpoint": zod.string().min(1).optional().describe('LLM service endpoint URL'),
  "token": zod.string().min(1).optional().describe('Authentication token for LLM service')
}).optional().describe('Large Language Model configuration'),
  "llm": zod.object({
  "type": zod.enum(['ollama', 'openai']).describe('LLM provider type'),
  "endpoint": zod.string().min(1).optional().describe('LLM service endpoint URL'),
  "token": zod.string().min(1).optional().describe('Authentication token for LLM service')
}).optional().describe('Large Language Model configuration'),
  "runpod": zod.object({
  "enabled": zod.boolean().describe('Enable RunPod integration'),
  "token": zod.string().min(1).optional().describe('RunPod API token')
}).optional().describe('RunPod serverless GPU configuration'),
  "scraper": zod.object({
  "enabled": zod.boolean().describe('Enable scraper service'),
  "managed": zod.boolean().optional().describe('Use managed scraper deployment'),
  "endpoint": zod.string().min(1).optional().describe('Web scraper service endpoint URL'),
  "image": zod.object({
  "pullPolicy": zod.enum(['Always', 'IfNotPresent', 'Never']).describe('Kubernetes image pull policy'),
  "repository": zod.string().min(1).optional().describe('Container image repository'),
  "tag": zod.string().min(1).describe('Container image tag')
}).optional().describe('Container image configuration'),
  "resources": zod.object({
  "limits": zod.object({
  "cpu": zod.string().min(1).describe('Maximum CPU allocation'),
  "memory": zod.string().min(1).describe('Maximum memory allocation')
}).describe('Resource limits'),
  "requests": zod.object({
  "cpu": zod.string().min(1).describe('Requested CPU allocation'),
  "memory": zod.string().min(1).describe('Requested memory allocation')
}).describe('Resource requests')
}).optional().describe('Kubernetes resource configuration')
}).optional().describe('Web scraping service configuration'),
  "speech": zod.object({
  "enabled": zod.boolean().describe('Enable speech services'),
  "token": zod.string().min(1).optional().describe('Speech-to-text service API token')
}).optional().describe('Speech recognition and TTS services'),
  "unstructured": zod.object({
  "enabled": zod.boolean().describe('Enable unstructured document parsing'),
  "managed": zod.boolean().optional().describe('Use managed unstructured deployment'),
  "image": zod.object({
  "pullPolicy": zod.enum(['Always', 'IfNotPresent', 'Never']).describe('Kubernetes image pull policy'),
  "repository": zod.string().min(1).optional().describe('Container image repository'),
  "tag": zod.string().min(1).describe('Container image tag')
}).optional().describe('Container image configuration'),
  "resources": zod.object({
  "limits": zod.object({
  "cpu": zod.string().min(1).describe('Maximum CPU allocation'),
  "memory": zod.string().min(1).describe('Maximum memory allocation')
}).describe('Resource limits'),
  "requests": zod.object({
  "cpu": zod.string().min(1).describe('Requested CPU allocation'),
  "memory": zod.string().min(1).describe('Requested memory allocation')
}).describe('Resource requests')
}).optional().describe('Kubernetes resource configuration')
}).optional().describe('Unstructured.io service for document parsing')
}).optional().describe('Intelligence configuration (LLMs, embeddings, scraper, speech, etc.)'),
  "logging": zod.object({
  "level": zod.enum(['fatal', 'error', 'warn', 'info', 'debug', 'trace', 'silent']).describe('Minimum log level to output'),
  "pretty": zod.boolean().describe('Enable pretty-printed logs for development')
}).optional().describe('Logging configuration'),
  "platform": zod.object({
  "enabled": zod.boolean().describe('Enable platform service'),
  "managed": zod.boolean().optional().describe('Use managed platform deployment'),
  "url": zod.url().default(getConfigResponsePlatformUrlDefault).describe('Platform URL'),
  "image": zod.object({
  "pullPolicy": zod.enum(['Always', 'IfNotPresent', 'Never']).describe('Kubernetes image pull policy'),
  "repository": zod.string().min(1).optional().describe('Container image repository'),
  "tag": zod.string().min(1).describe('Container image tag')
}).optional().describe('Container image configuration'),
  "resources": zod.object({
  "limits": zod.object({
  "cpu": zod.string().min(1).describe('Maximum CPU allocation'),
  "memory": zod.string().min(1).describe('Maximum memory allocation')
}).describe('Resource limits'),
  "requests": zod.object({
  "cpu": zod.string().min(1).describe('Requested CPU allocation'),
  "memory": zod.string().min(1).describe('Requested memory allocation')
}).describe('Resource requests')
}).optional().describe('Kubernetes resource configuration')
}).optional().describe('Platform configuration (host, image, resources)'),
  "redis": zod.object({
  "enabled": zod.boolean().describe('Enable Redis'),
  "managed": zod.boolean().optional().describe('Use managed Redis deployment'),
  "auth": zod.string().min(1).describe('Redis authentication password'),
  "ca": zod.string().min(1).optional().describe('Certificate Authority for TLS (optional)'),
  "host": zod.string().min(1).describe('Redis hostname or IP'),
  "port": zod.number().describe('Redis port number'),
  "image": zod.object({
  "pullPolicy": zod.enum(['Always', 'IfNotPresent', 'Never']).describe('Kubernetes image pull policy'),
  "repository": zod.string().min(1).optional().describe('Container image repository'),
  "tag": zod.string().min(1).describe('Container image tag')
}).optional().describe('Container image configuration'),
  "persistence": zod.object({
  "enabled": zod.boolean().describe('Enable persistent storage'),
  "size": zod.string().min(1).describe('Size of persistent volume')
}).optional().describe('Persistent storage configuration'),
  "resources": zod.object({
  "limits": zod.object({
  "cpu": zod.string().min(1).describe('Maximum CPU allocation'),
  "memory": zod.string().min(1).describe('Maximum memory allocation')
}).describe('Resource limits'),
  "requests": zod.object({
  "cpu": zod.string().min(1).describe('Requested CPU allocation'),
  "memory": zod.string().min(1).describe('Requested memory allocation')
}).describe('Resource requests')
}).optional().describe('Kubernetes resource configuration')
}).optional().describe('Redis configuration'),
  "storage": zod.object({
  "enabled": zod.boolean().describe('Enable object storage'),
  "managed": zod.boolean().optional().describe('Use managed storage deployment'),
  "accesskey": zod.string().min(1).describe('MinIO/S3 access key ID'),
  "bucket": zod.string().min(1).describe('S3 bucket name'),
  "endpoint": zod.string().min(1).describe('MinIO server endpoint URL'),
  "secretkey": zod.string().min(1).describe('MinIO/S3 secret access key'),
  "image": zod.object({
  "pullPolicy": zod.enum(['Always', 'IfNotPresent', 'Never']).describe('Kubernetes image pull policy'),
  "repository": zod.string().min(1).optional().describe('Container image repository'),
  "tag": zod.string().min(1).describe('Container image tag')
}).optional().describe('Container image configuration'),
  "persistence": zod.object({
  "enabled": zod.boolean().describe('Enable persistent storage'),
  "size": zod.string().min(1).describe('Size of persistent volume')
}).optional().describe('Persistent storage configuration'),
  "resources": zod.object({
  "limits": zod.object({
  "cpu": zod.string().min(1).describe('Maximum CPU allocation'),
  "memory": zod.string().min(1).describe('Maximum memory allocation')
}).describe('Resource limits'),
  "requests": zod.object({
  "cpu": zod.string().min(1).describe('Requested CPU allocation'),
  "memory": zod.string().min(1).describe('Requested memory allocation')
}).describe('Resource requests')
}).optional().describe('Kubernetes resource configuration')
}).optional().describe('Object storage configuration for MinIO or S3-compatible services'),
  "kubernetes": zod.object({
  "infrastructure": zod.object({
  "images": zod.object({
  "imagePullSecrets": zod.array(zod.string().min(1)).describe('List of Kubernetes secrets for pulling private images'),
  "imageRegistry": zod.string().min(1).describe('Custom container registry URL (leave empty for Docker Hub)')
}).describe('Container image configuration'),
  "migrations": zod.object({
  "enabled": zod.boolean().describe('Enable automatic DB migrations')
}).describe('Database migration configuration'),
  "namespace": zod.string().min(1).describe('Kubernetes namespace where all resources will be deployed'),
  "serviceAccount": zod.object({
  "create": zod.boolean().describe('Create dedicated service account'),
  "name": zod.string().min(1).describe('Custom service account name')
}).describe('Kubernetes service account configuration')
}).optional().describe('Infrastructure configuration for Kubernetes deployments'),
  "ingress": zod.object({
  "enabled": zod.boolean().describe('Enable ingress'),
  "domain": zod.string().min(1).default(getConfigResponseKubernetesIngressDomainDefault).describe('Primary domain name for ingress routing'),
  "tls": zod.object({
  "enabled": zod.boolean().describe('Enable TLS/SSL'),
  "issuer": zod.string().min(1).default(getConfigResponseKubernetesIngressTlsIssuerDefault).describe('Cert-manager ClusterIssuer'),
  "secretName": zod.string().min(1).default(getConfigResponseKubernetesIngressTlsSecretNameDefault).describe('Kubernetes secret name for TLS certificates')
}).optional().describe('TLS configuration')
}).optional().describe('Ingress configuration'),
  "monitoring": zod.object({
  "grafana": zod.object({
  "enabled": zod.boolean().describe('Enable Grafana'),
  "managed": zod.boolean().optional().describe('Use managed Grafana deployment'),
  "image": zod.object({
  "pullPolicy": zod.enum(['Always', 'IfNotPresent', 'Never']).describe('Kubernetes image pull policy'),
  "repository": zod.string().min(1).optional().describe('Container image repository'),
  "tag": zod.string().min(1).describe('Container image tag')
}).optional().describe('Container image configuration'),
  "resources": zod.object({
  "limits": zod.object({
  "cpu": zod.string().min(1).describe('Maximum CPU allocation'),
  "memory": zod.string().min(1).describe('Maximum memory allocation')
}).describe('Resource limits'),
  "requests": zod.object({
  "cpu": zod.string().min(1).describe('Requested CPU allocation'),
  "memory": zod.string().min(1).describe('Requested memory allocation')
}).describe('Resource requests')
}).optional().describe('Kubernetes resource configuration')
}).describe('Grafana monitoring dashboard configuration'),
  "loki": zod.object({
  "enabled": zod.boolean().describe('Enable Loki'),
  "managed": zod.boolean().optional().describe('Use managed Loki deployment'),
  "host": zod.string().min(1).default(getConfigResponseKubernetesMonitoringLokiHostDefault).describe('Loki host URL'),
  "image": zod.object({
  "pullPolicy": zod.enum(['Always', 'IfNotPresent', 'Never']).describe('Kubernetes image pull policy'),
  "repository": zod.string().min(1).optional().describe('Container image repository'),
  "tag": zod.string().min(1).describe('Container image tag')
}).optional().describe('Container image configuration'),
  "resources": zod.object({
  "limits": zod.object({
  "cpu": zod.string().min(1).describe('Maximum CPU allocation'),
  "memory": zod.string().min(1).describe('Maximum memory allocation')
}).describe('Resource limits'),
  "requests": zod.object({
  "cpu": zod.string().min(1).describe('Requested CPU allocation'),
  "memory": zod.string().min(1).describe('Requested memory allocation')
}).describe('Resource requests')
}).optional().describe('Kubernetes resource configuration')
}).describe('Loki log aggregation service configuration')
}).optional().describe('Monitoring configuration for Grafana and Loki')
}).optional().describe('Kubernetes-specific deployment configuration')
}).describe('Arches AI configuration schema')


/**
 * Check the health status of the application
 * @summary Get health status
 */
export const getHealthResponse = zod.object({
  "services": zod.object({
  "database": zod.string().min(1),
  "email": zod.string().min(1),
  "redis": zod.string().min(1)
}),
  "timestamp": zod.string().min(1),
  "uptime": zod.number()
}).describe('Health check response')
