/**
 * Generated by orval v7.11.2 üç∫
 * Do not edit manually.
 * Arches AI API
 * The Arches AI API
 * OpenAPI spec version: v0.0.0
 */
import type {
  MutationFunction,
  QueryClient,
  UseMutationOptions,
  UseMutationResult,
} from "@tanstack/react-query";

import { useMutation } from "@tanstack/react-query";

import type {
  BadRequestResponse,
  ConfirmEmailChangeBody,
  ConfirmEmailVerification200,
  ConfirmEmailVerificationBody,
  ConfirmPasswordResetBody,
  Login200,
  LoginBody,
  NoContentResponse,
  NotFoundResponse,
  Register201,
  RegisterBody,
  RequestEmailChangeBody,
  RequestPasswordResetBody,
  UnauthorizedResponse,
} from "../orval.schemas";

import { customFetch } from "../../fetcher";

type SecondParameter<T extends (...args: never) => unknown> = Parameters<T>[1];

/**
 * This endpoint will register you with your e-mail and password
 * @summary Register
 */
export const getRegisterUrl = () => {
  return `/auth/sign-up`;
};

export const register = async (
  registerBody: RegisterBody,
  options?: RequestInit,
): Promise<Register201> => {
  return customFetch<Register201>(getRegisterUrl(), {
    ...options,
    method: "POST",
    headers: { "Content-Type": "application/json", ...options?.headers },
    body: JSON.stringify(registerBody),
  });
};

export const getRegisterMutationOptions = <
  TError = UnauthorizedResponse,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof register>>,
    TError,
    { data: RegisterBody },
    TContext
  >;
  request?: SecondParameter<typeof customFetch>;
}): UseMutationOptions<
  Awaited<ReturnType<typeof register>>,
  TError,
  { data: RegisterBody },
  TContext
> => {
  const mutationKey = ["register"];
  const { mutation: mutationOptions, request: requestOptions } = options
    ? options.mutation &&
      "mutationKey" in options.mutation &&
      options.mutation.mutationKey
      ? options
      : { ...options, mutation: { ...options.mutation, mutationKey } }
    : { mutation: { mutationKey }, request: undefined };

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof register>>,
    { data: RegisterBody }
  > = (props) => {
    const { data } = props ?? {};

    return register(data, requestOptions);
  };

  return { mutationFn, ...mutationOptions };
};

export type RegisterMutationResult = NonNullable<
  Awaited<ReturnType<typeof register>>
>;
export type RegisterMutationBody = RegisterBody;
export type RegisterMutationError = UnauthorizedResponse;

/**
 * @summary Register
 */
export const useRegister = <TError = UnauthorizedResponse, TContext = unknown>(
  options?: {
    mutation?: UseMutationOptions<
      Awaited<ReturnType<typeof register>>,
      TError,
      { data: RegisterBody },
      TContext
    >;
    request?: SecondParameter<typeof customFetch>;
  },
  queryClient?: QueryClient,
): UseMutationResult<
  Awaited<ReturnType<typeof register>>,
  TError,
  { data: RegisterBody },
  TContext
> => {
  const mutationOptions = getRegisterMutationOptions(options);

  return useMutation(mutationOptions, queryClient);
};
/**
 * This endpoint will log you in with your e-mail and password
 * @summary Login
 */
export const getLoginUrl = () => {
  return `/auth/sign-in`;
};

export const login = async (
  loginBody: LoginBody,
  options?: RequestInit,
): Promise<Login200> => {
  return customFetch<Login200>(getLoginUrl(), {
    ...options,
    method: "POST",
    headers: { "Content-Type": "application/json", ...options?.headers },
    body: JSON.stringify(loginBody),
  });
};

export const getLoginMutationOptions = <
  TError = UnauthorizedResponse,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof login>>,
    TError,
    { data: LoginBody },
    TContext
  >;
  request?: SecondParameter<typeof customFetch>;
}): UseMutationOptions<
  Awaited<ReturnType<typeof login>>,
  TError,
  { data: LoginBody },
  TContext
> => {
  const mutationKey = ["login"];
  const { mutation: mutationOptions, request: requestOptions } = options
    ? options.mutation &&
      "mutationKey" in options.mutation &&
      options.mutation.mutationKey
      ? options
      : { ...options, mutation: { ...options.mutation, mutationKey } }
    : { mutation: { mutationKey }, request: undefined };

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof login>>,
    { data: LoginBody }
  > = (props) => {
    const { data } = props ?? {};

    return login(data, requestOptions);
  };

  return { mutationFn, ...mutationOptions };
};

export type LoginMutationResult = NonNullable<
  Awaited<ReturnType<typeof login>>
>;
export type LoginMutationBody = LoginBody;
export type LoginMutationError = UnauthorizedResponse;

/**
 * @summary Login
 */
export const useLogin = <TError = UnauthorizedResponse, TContext = unknown>(
  options?: {
    mutation?: UseMutationOptions<
      Awaited<ReturnType<typeof login>>,
      TError,
      { data: LoginBody },
      TContext
    >;
    request?: SecondParameter<typeof customFetch>;
  },
  queryClient?: QueryClient,
): UseMutationResult<
  Awaited<ReturnType<typeof login>>,
  TError,
  { data: LoginBody },
  TContext
> => {
  const mutationOptions = getLoginMutationOptions(options);

  return useMutation(mutationOptions, queryClient);
};
/**
 * This endpoint will log you out of the current session
 * @summary Logout
 */
export const getLogoutUrl = () => {
  return `/auth/sign-out`;
};

export const logout = async (
  options?: RequestInit,
): Promise<NotFoundResponse> => {
  return customFetch<NotFoundResponse>(getLogoutUrl(), {
    ...options,
    method: "POST",
  });
};

export const getLogoutMutationOptions = <
  TError = UnauthorizedResponse,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof logout>>,
    TError,
    void,
    TContext
  >;
  request?: SecondParameter<typeof customFetch>;
}): UseMutationOptions<
  Awaited<ReturnType<typeof logout>>,
  TError,
  void,
  TContext
> => {
  const mutationKey = ["logout"];
  const { mutation: mutationOptions, request: requestOptions } = options
    ? options.mutation &&
      "mutationKey" in options.mutation &&
      options.mutation.mutationKey
      ? options
      : { ...options, mutation: { ...options.mutation, mutationKey } }
    : { mutation: { mutationKey }, request: undefined };

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof logout>>,
    void
  > = () => {
    return logout(requestOptions);
  };

  return { mutationFn, ...mutationOptions };
};

export type LogoutMutationResult = NonNullable<
  Awaited<ReturnType<typeof logout>>
>;

export type LogoutMutationError = UnauthorizedResponse;

/**
 * @summary Logout
 */
export const useLogout = <TError = UnauthorizedResponse, TContext = unknown>(
  options?: {
    mutation?: UseMutationOptions<
      Awaited<ReturnType<typeof logout>>,
      TError,
      void,
      TContext
    >;
    request?: SecondParameter<typeof customFetch>;
  },
  queryClient?: QueryClient,
): UseMutationResult<
  Awaited<ReturnType<typeof logout>>,
  TError,
  void,
  TContext
> => {
  const mutationOptions = getLogoutMutationOptions(options);

  return useMutation(mutationOptions, queryClient);
};
/**
 * This endpoint will confirm your e-mail with a token
 * @summary Confirm e-mail verification
 */
export const getConfirmEmailVerificationUrl = () => {
  return `/auth/email-verification/verify`;
};

export const confirmEmailVerification = async (
  confirmEmailVerificationBody: ConfirmEmailVerificationBody,
  options?: RequestInit,
): Promise<ConfirmEmailVerification200> => {
  return customFetch<ConfirmEmailVerification200>(
    getConfirmEmailVerificationUrl(),
    {
      ...options,
      method: "POST",
      headers: { "Content-Type": "application/json", ...options?.headers },
      body: JSON.stringify(confirmEmailVerificationBody),
    },
  );
};

export const getConfirmEmailVerificationMutationOptions = <
  TError = UnauthorizedResponse | NotFoundResponse,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof confirmEmailVerification>>,
    TError,
    { data: ConfirmEmailVerificationBody },
    TContext
  >;
  request?: SecondParameter<typeof customFetch>;
}): UseMutationOptions<
  Awaited<ReturnType<typeof confirmEmailVerification>>,
  TError,
  { data: ConfirmEmailVerificationBody },
  TContext
> => {
  const mutationKey = ["confirmEmailVerification"];
  const { mutation: mutationOptions, request: requestOptions } = options
    ? options.mutation &&
      "mutationKey" in options.mutation &&
      options.mutation.mutationKey
      ? options
      : { ...options, mutation: { ...options.mutation, mutationKey } }
    : { mutation: { mutationKey }, request: undefined };

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof confirmEmailVerification>>,
    { data: ConfirmEmailVerificationBody }
  > = (props) => {
    const { data } = props ?? {};

    return confirmEmailVerification(data, requestOptions);
  };

  return { mutationFn, ...mutationOptions };
};

export type ConfirmEmailVerificationMutationResult = NonNullable<
  Awaited<ReturnType<typeof confirmEmailVerification>>
>;
export type ConfirmEmailVerificationMutationBody = ConfirmEmailVerificationBody;
export type ConfirmEmailVerificationMutationError =
  | UnauthorizedResponse
  | NotFoundResponse;

/**
 * @summary Confirm e-mail verification
 */
export const useConfirmEmailVerification = <
  TError = UnauthorizedResponse | NotFoundResponse,
  TContext = unknown,
>(
  options?: {
    mutation?: UseMutationOptions<
      Awaited<ReturnType<typeof confirmEmailVerification>>,
      TError,
      { data: ConfirmEmailVerificationBody },
      TContext
    >;
    request?: SecondParameter<typeof customFetch>;
  },
  queryClient?: QueryClient,
): UseMutationResult<
  Awaited<ReturnType<typeof confirmEmailVerification>>,
  TError,
  { data: ConfirmEmailVerificationBody },
  TContext
> => {
  const mutationOptions = getConfirmEmailVerificationMutationOptions(options);

  return useMutation(mutationOptions, queryClient);
};
/**
 * This endpoint will send an e-mail verification link to you. ADMIN ONLY.
 * @summary Request e-mail verification
 */
export const getRequestEmailVerificationUrl = () => {
  return `/auth/email-verification/request`;
};

export const requestEmailVerification = async (
  options?: RequestInit,
): Promise<NoContentResponse> => {
  return customFetch<NoContentResponse>(getRequestEmailVerificationUrl(), {
    ...options,
    method: "POST",
  });
};

export const getRequestEmailVerificationMutationOptions = <
  TError = BadRequestResponse | UnauthorizedResponse,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof requestEmailVerification>>,
    TError,
    void,
    TContext
  >;
  request?: SecondParameter<typeof customFetch>;
}): UseMutationOptions<
  Awaited<ReturnType<typeof requestEmailVerification>>,
  TError,
  void,
  TContext
> => {
  const mutationKey = ["requestEmailVerification"];
  const { mutation: mutationOptions, request: requestOptions } = options
    ? options.mutation &&
      "mutationKey" in options.mutation &&
      options.mutation.mutationKey
      ? options
      : { ...options, mutation: { ...options.mutation, mutationKey } }
    : { mutation: { mutationKey }, request: undefined };

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof requestEmailVerification>>,
    void
  > = () => {
    return requestEmailVerification(requestOptions);
  };

  return { mutationFn, ...mutationOptions };
};

export type RequestEmailVerificationMutationResult = NonNullable<
  Awaited<ReturnType<typeof requestEmailVerification>>
>;

export type RequestEmailVerificationMutationError =
  | BadRequestResponse
  | UnauthorizedResponse;

/**
 * @summary Request e-mail verification
 */
export const useRequestEmailVerification = <
  TError = BadRequestResponse | UnauthorizedResponse,
  TContext = unknown,
>(
  options?: {
    mutation?: UseMutationOptions<
      Awaited<ReturnType<typeof requestEmailVerification>>,
      TError,
      void,
      TContext
    >;
    request?: SecondParameter<typeof customFetch>;
  },
  queryClient?: QueryClient,
): UseMutationResult<
  Awaited<ReturnType<typeof requestEmailVerification>>,
  TError,
  void,
  TContext
> => {
  const mutationOptions = getRequestEmailVerificationMutationOptions(options);

  return useMutation(mutationOptions, queryClient);
};
/**
 * This endpoint will request a password reset link
 * @summary Request password reset
 */
export const getRequestPasswordResetUrl = () => {
  return `/auth/password-reset/request`;
};

export const requestPasswordReset = async (
  requestPasswordResetBody: RequestPasswordResetBody,
  options?: RequestInit,
): Promise<NoContentResponse> => {
  return customFetch<NoContentResponse>(getRequestPasswordResetUrl(), {
    ...options,
    method: "POST",
    headers: { "Content-Type": "application/json", ...options?.headers },
    body: JSON.stringify(requestPasswordResetBody),
  });
};

export const getRequestPasswordResetMutationOptions = <
  TError = BadRequestResponse,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof requestPasswordReset>>,
    TError,
    { data: RequestPasswordResetBody },
    TContext
  >;
  request?: SecondParameter<typeof customFetch>;
}): UseMutationOptions<
  Awaited<ReturnType<typeof requestPasswordReset>>,
  TError,
  { data: RequestPasswordResetBody },
  TContext
> => {
  const mutationKey = ["requestPasswordReset"];
  const { mutation: mutationOptions, request: requestOptions } = options
    ? options.mutation &&
      "mutationKey" in options.mutation &&
      options.mutation.mutationKey
      ? options
      : { ...options, mutation: { ...options.mutation, mutationKey } }
    : { mutation: { mutationKey }, request: undefined };

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof requestPasswordReset>>,
    { data: RequestPasswordResetBody }
  > = (props) => {
    const { data } = props ?? {};

    return requestPasswordReset(data, requestOptions);
  };

  return { mutationFn, ...mutationOptions };
};

export type RequestPasswordResetMutationResult = NonNullable<
  Awaited<ReturnType<typeof requestPasswordReset>>
>;
export type RequestPasswordResetMutationBody = RequestPasswordResetBody;
export type RequestPasswordResetMutationError = BadRequestResponse;

/**
 * @summary Request password reset
 */
export const useRequestPasswordReset = <
  TError = BadRequestResponse,
  TContext = unknown,
>(
  options?: {
    mutation?: UseMutationOptions<
      Awaited<ReturnType<typeof requestPasswordReset>>,
      TError,
      { data: RequestPasswordResetBody },
      TContext
    >;
    request?: SecondParameter<typeof customFetch>;
  },
  queryClient?: QueryClient,
): UseMutationResult<
  Awaited<ReturnType<typeof requestPasswordReset>>,
  TError,
  { data: RequestPasswordResetBody },
  TContext
> => {
  const mutationOptions = getRequestPasswordResetMutationOptions(options);

  return useMutation(mutationOptions, queryClient);
};
/**
 * This endpoint will verify your password change with a token
 * @summary Verify password reset
 */
export const getConfirmPasswordResetUrl = () => {
  return `/auth/password-reset/verify`;
};

export const confirmPasswordReset = async (
  confirmPasswordResetBody: ConfirmPasswordResetBody,
  options?: RequestInit,
): Promise<NotFoundResponse> => {
  return customFetch<NotFoundResponse>(getConfirmPasswordResetUrl(), {
    ...options,
    method: "POST",
    headers: { "Content-Type": "application/json", ...options?.headers },
    body: JSON.stringify(confirmPasswordResetBody),
  });
};

export const getConfirmPasswordResetMutationOptions = <
  TError = UnauthorizedResponse | NotFoundResponse,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof confirmPasswordReset>>,
    TError,
    { data: ConfirmPasswordResetBody },
    TContext
  >;
  request?: SecondParameter<typeof customFetch>;
}): UseMutationOptions<
  Awaited<ReturnType<typeof confirmPasswordReset>>,
  TError,
  { data: ConfirmPasswordResetBody },
  TContext
> => {
  const mutationKey = ["confirmPasswordReset"];
  const { mutation: mutationOptions, request: requestOptions } = options
    ? options.mutation &&
      "mutationKey" in options.mutation &&
      options.mutation.mutationKey
      ? options
      : { ...options, mutation: { ...options.mutation, mutationKey } }
    : { mutation: { mutationKey }, request: undefined };

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof confirmPasswordReset>>,
    { data: ConfirmPasswordResetBody }
  > = (props) => {
    const { data } = props ?? {};

    return confirmPasswordReset(data, requestOptions);
  };

  return { mutationFn, ...mutationOptions };
};

export type ConfirmPasswordResetMutationResult = NonNullable<
  Awaited<ReturnType<typeof confirmPasswordReset>>
>;
export type ConfirmPasswordResetMutationBody = ConfirmPasswordResetBody;
export type ConfirmPasswordResetMutationError =
  | UnauthorizedResponse
  | NotFoundResponse;

/**
 * @summary Verify password reset
 */
export const useConfirmPasswordReset = <
  TError = UnauthorizedResponse | NotFoundResponse,
  TContext = unknown,
>(
  options?: {
    mutation?: UseMutationOptions<
      Awaited<ReturnType<typeof confirmPasswordReset>>,
      TError,
      { data: ConfirmPasswordResetBody },
      TContext
    >;
    request?: SecondParameter<typeof customFetch>;
  },
  queryClient?: QueryClient,
): UseMutationResult<
  Awaited<ReturnType<typeof confirmPasswordReset>>,
  TError,
  { data: ConfirmPasswordResetBody },
  TContext
> => {
  const mutationOptions = getConfirmPasswordResetMutationOptions(options);

  return useMutation(mutationOptions, queryClient);
};
/**
 * This endpoint will request your e-mail change with a token
 * @summary Request e-mail change
 */
export const getRequestEmailChangeUrl = () => {
  return `/auth/email-change/request`;
};

export const requestEmailChange = async (
  requestEmailChangeBody: RequestEmailChangeBody,
  options?: RequestInit,
): Promise<NoContentResponse> => {
  return customFetch<NoContentResponse>(getRequestEmailChangeUrl(), {
    ...options,
    method: "POST",
    headers: { "Content-Type": "application/json", ...options?.headers },
    body: JSON.stringify(requestEmailChangeBody),
  });
};

export const getRequestEmailChangeMutationOptions = <
  TError = BadRequestResponse | UnauthorizedResponse,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof requestEmailChange>>,
    TError,
    { data: RequestEmailChangeBody },
    TContext
  >;
  request?: SecondParameter<typeof customFetch>;
}): UseMutationOptions<
  Awaited<ReturnType<typeof requestEmailChange>>,
  TError,
  { data: RequestEmailChangeBody },
  TContext
> => {
  const mutationKey = ["requestEmailChange"];
  const { mutation: mutationOptions, request: requestOptions } = options
    ? options.mutation &&
      "mutationKey" in options.mutation &&
      options.mutation.mutationKey
      ? options
      : { ...options, mutation: { ...options.mutation, mutationKey } }
    : { mutation: { mutationKey }, request: undefined };

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof requestEmailChange>>,
    { data: RequestEmailChangeBody }
  > = (props) => {
    const { data } = props ?? {};

    return requestEmailChange(data, requestOptions);
  };

  return { mutationFn, ...mutationOptions };
};

export type RequestEmailChangeMutationResult = NonNullable<
  Awaited<ReturnType<typeof requestEmailChange>>
>;
export type RequestEmailChangeMutationBody = RequestEmailChangeBody;
export type RequestEmailChangeMutationError =
  | BadRequestResponse
  | UnauthorizedResponse;

/**
 * @summary Request e-mail change
 */
export const useRequestEmailChange = <
  TError = BadRequestResponse | UnauthorizedResponse,
  TContext = unknown,
>(
  options?: {
    mutation?: UseMutationOptions<
      Awaited<ReturnType<typeof requestEmailChange>>,
      TError,
      { data: RequestEmailChangeBody },
      TContext
    >;
    request?: SecondParameter<typeof customFetch>;
  },
  queryClient?: QueryClient,
): UseMutationResult<
  Awaited<ReturnType<typeof requestEmailChange>>,
  TError,
  { data: RequestEmailChangeBody },
  TContext
> => {
  const mutationOptions = getRequestEmailChangeMutationOptions(options);

  return useMutation(mutationOptions, queryClient);
};
/**
 * This endpoint will verify your e-mail change with a token
 * @summary Verify e-mail change
 */
export const getConfirmEmailChangeUrl = () => {
  return `/auth/email-change/verify`;
};

export const confirmEmailChange = async (
  confirmEmailChangeBody: ConfirmEmailChangeBody,
  options?: RequestInit,
): Promise<NotFoundResponse> => {
  return customFetch<NotFoundResponse>(getConfirmEmailChangeUrl(), {
    ...options,
    method: "POST",
    headers: { "Content-Type": "application/json", ...options?.headers },
    body: JSON.stringify(confirmEmailChangeBody),
  });
};

export const getConfirmEmailChangeMutationOptions = <
  TError = UnauthorizedResponse | NotFoundResponse,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof confirmEmailChange>>,
    TError,
    { data: ConfirmEmailChangeBody },
    TContext
  >;
  request?: SecondParameter<typeof customFetch>;
}): UseMutationOptions<
  Awaited<ReturnType<typeof confirmEmailChange>>,
  TError,
  { data: ConfirmEmailChangeBody },
  TContext
> => {
  const mutationKey = ["confirmEmailChange"];
  const { mutation: mutationOptions, request: requestOptions } = options
    ? options.mutation &&
      "mutationKey" in options.mutation &&
      options.mutation.mutationKey
      ? options
      : { ...options, mutation: { ...options.mutation, mutationKey } }
    : { mutation: { mutationKey }, request: undefined };

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof confirmEmailChange>>,
    { data: ConfirmEmailChangeBody }
  > = (props) => {
    const { data } = props ?? {};

    return confirmEmailChange(data, requestOptions);
  };

  return { mutationFn, ...mutationOptions };
};

export type ConfirmEmailChangeMutationResult = NonNullable<
  Awaited<ReturnType<typeof confirmEmailChange>>
>;
export type ConfirmEmailChangeMutationBody = ConfirmEmailChangeBody;
export type ConfirmEmailChangeMutationError =
  | UnauthorizedResponse
  | NotFoundResponse;

/**
 * @summary Verify e-mail change
 */
export const useConfirmEmailChange = <
  TError = UnauthorizedResponse | NotFoundResponse,
  TContext = unknown,
>(
  options?: {
    mutation?: UseMutationOptions<
      Awaited<ReturnType<typeof confirmEmailChange>>,
      TError,
      { data: ConfirmEmailChangeBody },
      TContext
    >;
    request?: SecondParameter<typeof customFetch>;
  },
  queryClient?: QueryClient,
): UseMutationResult<
  Awaited<ReturnType<typeof confirmEmailChange>>,
  TError,
  { data: ConfirmEmailChangeBody },
  TContext
> => {
  const mutationOptions = getConfirmEmailChangeMutationOptions(options);

  return useMutation(mutationOptions, queryClient);
};
