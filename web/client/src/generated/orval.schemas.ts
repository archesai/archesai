/**
 * Generated by orval v7.13.0 üç∫
 * Do not edit manually.
 * Arches AI API
 * The Arches AI API
 * OpenAPI spec version: v0.0.0
 */
/**
 * Base schema for all entities with common fields
 */
export interface Base {
  /**
   * Unique identifier for the resource
   * @minLength 36
   */
  id: string;
  /**
   * The date and time when the resource was created
   * @minLength 1
   */
  createdAt: string;
  /**
   * The date and time when the resource was last updated
   * @minLength 1
   */
  updatedAt: string;
}

export type SessionAllOf = {
  /**
   * The organization ID for this session (nullable for users without org)
   * @minLength 36
   */
  organizationID?: string;
  /** The authentication method used (magic_link, oauth_google, oauth_github, etc.) */
  authMethod?: string;
  /** The authentication provider (google, github, microsoft, local) */
  authProvider?: string;
  /**
   * The expiration date of the session
   * @minLength 1
   */
  expiresAt: string;
  /**
   * The IP address of the session
   * @minLength 1
   */
  ipAddress?: string;
  /**
   * The session token
   * @minLength 1
   */
  token: string;
  /**
   * The user agent of the session
   * @minLength 1
   */
  userAgent?: string;
  /**
   * The user who owns this session
   * @minLength 36
   */
  userID: string;
};

/**
 * Schema for Session entity
 */
export type Session = Base & SessionAllOf;

/**
 * RFC 7807 (Problem Details) compliant error response
 */
export interface Problem {
  /**
   * HTTP status code
   * @minimum 100
   * @maximum 599
   */
  status: number;
  /**
   * URI identifying the problem type
   * @minLength 1
   */
  type?: string;
  /**
   * Short, human-readable summary
   * @minLength 1
   */
  title: string;
  /**
   * Human-readable explanation specific to this occurrence
   * @minLength 1
   */
  detail?: string;
  /** URI identifying the specific occurrence */
  instance?: string;
}

export type UserAllOf = {
  /**
   * The user's email address
   * @minLength 5
   * @maxLength 255
   */
  email: string;
  /** Whether the user's email has been verified */
  emailVerified: boolean;
  /**
   * The user's avatar image URL
   * @minLength 5
   * @maxLength 2048
   */
  image?: string;
  /**
   * The user's display name
   * @minLength 1
   * @maxLength 255
   */
  name: string;
};

/**
 * Schema for User entity
 */
export type User = Base & UserAllOf;

/**
 * How the magic link was delivered
 */
export type MagicLinkTokenDeliveryMethod = typeof MagicLinkTokenDeliveryMethod[keyof typeof MagicLinkTokenDeliveryMethod];


// eslint-disable-next-line @typescript-eslint/no-redeclare
export const MagicLinkTokenDeliveryMethod = {
  email: 'email',
  console: 'console',
  webhook: 'webhook',
  otp: 'otp',
  file: 'file',
} as const;

/**
 * When the token was used (null if unused)
 */
export type MagicLinkTokenUsedAt = string | null;

/**
 * Schema for MagicLinkToken entity
 */
export interface MagicLinkToken {
  /**
   * Unique identifier for the magic link token
   * @minLength 36
   */
  id: string;
  /**
   * User ID if token is for existing user
   * @minLength 36
   */
  userID?: string;
  /**
   * The raw magic link token
   * @minLength 32
   */
  token?: string;
  /**
   * SHA256 hash of the magic link token
   * @minLength 64
   * @maxLength 64
   */
  tokenHash: string;
  /**
   * Optional 6-digit OTP code
   * @minLength 6
   * @maxLength 6
   * @pattern ^[0-9]{6}$
   */
  code?: string;
  /**
   * Email or username for authentication
   * @minLength 1
   */
  identifier: string;
  /** How the magic link was delivered */
  deliveryMethod?: MagicLinkTokenDeliveryMethod;
  /** When the token expires */
  expiresAt: string;
  /** When the token was used (null if unused) */
  usedAt?: MagicLinkTokenUsedAt;
  /** IP address of the request */
  ipAddress?: string;
  /** User agent of the request */
  userAgent?: string;
  /** When the token was created */
  createdAt: string;
}

/**
 * Pagination parameters (limit & offset)
 */
export interface Page {
  /**
   * Maximum number of items to return
   * @minimum 1
   * @maximum 100
   */
  limit?: number;
  /**
   * Number of items to skip before starting to collect the result set
   * @minimum 0
   * @maximum 9007199254740991
   */
  offset?: number;
}

/**
 * The authentication provider identifier
 */
export type AccountAllOfProvider = typeof AccountAllOfProvider[keyof typeof AccountAllOfProvider];


// eslint-disable-next-line @typescript-eslint/no-redeclare
export const AccountAllOfProvider = {
  local: 'local',
  google: 'google',
  github: 'github',
  microsoft: 'microsoft',
  apple: 'apple',
} as const;

export type AccountAllOf = {
  /**
   * The unique identifier for the account from the provider
   * @minLength 1
   */
  accountIdentifier: string;
  /**
   * The user ID this account belongs to
   * @minLength 36
   */
  userID: string;
  /** The authentication provider identifier */
  provider: AccountAllOfProvider;
  /** The OAuth access token */
  accessToken?: string;
  /** The access token expiration timestamp */
  accessTokenExpiresAt?: string;
  /** The OAuth refresh token */
  refreshToken?: string;
  /** The refresh token expiration timestamp */
  refreshTokenExpiresAt?: string;
  /** The OpenID Connect ID token */
  idToken?: string;
  /** The OAuth scope granted */
  scope?: string;
};

/**
 * Schema for Account entity (authentication provider account)
 */
export type Account = Base & AccountAllOf;

/**
 * The type of filter operation
 */
export type FilterNodeType = typeof FilterNodeType[keyof typeof FilterNodeType];


// eslint-disable-next-line @typescript-eslint/no-redeclare
export const FilterNodeType = {
  and: 'and',
  or: 'or',
  eq: 'eq',
  ne: 'ne',
  gt: 'gt',
  gte: 'gte',
  lt: 'lt',
  lte: 'lte',
  contains: 'contains',
  starts_with: 'starts_with',
  ends_with: 'ends_with',
} as const;

/**
 * A recursive filter node that can be a condition or group
 */
export interface FilterNode {
  /** The type of filter operation */
  type: FilterNodeType;
  /**
   * The field to filter on (for leaf conditions)
   * @minLength 1
   */
  field?: string;
  /** The value to compare against (for leaf conditions) */
  value?: unknown;
  /** Child filter nodes (for logical operators) */
  children?: FilterNode[];
}

export type APIKeyAllOf = {
  /**
   * The user who owns this API key
   * @minLength 36
   */
  userID: string;
  /**
   * The organization this API key belongs to
   * @minLength 36
   */
  organizationID: string;
  /**
   * Hashed version of the API key for secure storage
   * @minLength 1
   */
  keyHash: string;
  /** @minLength 1 */
  name?: string;
  /** @minLength 1 */
  prefix?: string;
  scopes: string[];
  /** Requests per minute allowed for this API key */
  rateLimit: number;
  /**
   * When this API key was last used
   * @minLength 1
   */
  lastUsedAt?: string;
  /**
   * When this API key expires
   * @minLength 1
   */
  expiresAt?: string;
};

/**
 * Schema for API Key entity
 */
export type APIKey = Base & APIKeyAllOf;

/**
 * The current subscription plan
 */
export type OrganizationAllOfPlan = typeof OrganizationAllOfPlan[keyof typeof OrganizationAllOfPlan];


// eslint-disable-next-line @typescript-eslint/no-redeclare
export const OrganizationAllOfPlan = {
  FREE: 'FREE',
  BASIC: 'BASIC',
  STANDARD: 'STANDARD',
  PREMIUM: 'PREMIUM',
  UNLIMITED: 'UNLIMITED',
} as const;

export type OrganizationAllOf = {
  /**
   * The organization's display name
   * @minLength 1
   * @maxLength 255
   */
  name: string;
  /**
   * URL-friendly unique identifier for the organization
   * @minLength 3
   * @maxLength 50
   * @pattern ^[a-z0-9]+(?:-[a-z0-9]+)*$
   */
  slug: string;
  /** The organization's logo URL */
  logo?: string;
  /** Email address for billing communications */
  billingEmail?: string;
  /** The current subscription plan */
  plan: OrganizationAllOfPlan;
  /**
   * Available credits for this organization
   * @minimum 0
   */
  credits: number;
  /** Stripe customer identifier */
  stripeCustomerIdentifier: string;
};

/**
 * Schema for Organization entity
 */
export type Organization = Base & OrganizationAllOf;

/**
 * The role of the member
 */
export type MemberAllOfRole = typeof MemberAllOfRole[keyof typeof MemberAllOfRole];


// eslint-disable-next-line @typescript-eslint/no-redeclare
export const MemberAllOfRole = {
  admin: 'admin',
  owner: 'owner',
  basic: 'basic',
} as const;

export type MemberAllOf = {
  /**
   * The organization this member belongs to
   * @minLength 36
   */
  organizationID: string;
  /** The role of the member */
  role: MemberAllOfRole;
  /**
   * The user who is a member of the organization
   * @minLength 36
   */
  userID: string;
};

/**
 * Schema for Member entity
 */
export type Member = Base & MemberAllOf;

/**
 * The role of the invitation
 */
export type InvitationAllOfRole = typeof InvitationAllOfRole[keyof typeof InvitationAllOfRole];


// eslint-disable-next-line @typescript-eslint/no-redeclare
export const InvitationAllOfRole = {
  admin: 'admin',
  owner: 'owner',
  basic: 'basic',
} as const;

export type InvitationAllOf = {
  /**
   * The email of the invitated user
   * @minLength 1
   */
  email: string;
  /**
   * The date and time when the invitation expires
   * @minLength 1
   */
  expiresAt: string;
  /**
   * The ID of the user who sent this invitation
   * @minLength 36
   */
  inviterID: string;
  /**
   * The organization the user is being invited to join
   * @minLength 36
   */
  organizationID: string;
  /** The role of the invitation */
  role: InvitationAllOfRole;
  /**
   * The status of the invitation, e.g., pending, accepted, declined
   * @minLength 1
   */
  status: string;
};

/**
 * Schema for Invitation entity
 */
export type Invitation = Base & InvitationAllOf;

export type PipelineAllOf = {
  /**
   * The organization identifier
   * @minLength 36
   */
  organizationID: string;
  /**
   * The pipeline's display name
   * @minLength 1
   * @maxLength 255
   */
  name?: string;
  /**
   * Detailed description of the pipeline's purpose
   * @maxLength 1000
   */
  description?: string;
};

/**
 * Schema for Pipeline entity
 */
export type Pipeline = Base & PipelineAllOf;

export type PipelineStepAllOf = {
  /**
   * The pipeline this step belongs to
   * @minLength 36
   */
  pipelineID: string;
  /**
   * The tool used in this step
   * @minLength 36
   */
  toolID: string;
};

/**
 * Schema for PipelineStep entity
 */
export type PipelineStep = Base & PipelineStepAllOf;

export type RunAllOfStatus = typeof RunAllOfStatus[keyof typeof RunAllOfStatus];


// eslint-disable-next-line @typescript-eslint/no-redeclare
export const RunAllOfStatus = {
  COMPLETED: 'COMPLETED',
  FAILED: 'FAILED',
  PROCESSING: 'PROCESSING',
  QUEUED: 'QUEUED',
} as const;

export type RunAllOf = {
  /**
   * The timestamp when the run completed
   * @minLength 1
   */
  completedAt?: string;
  /**
   * The error message
   * @minLength 1
   */
  error?: string;
  /**
   * The organization this run belongs to
   * @minLength 36
   */
  organizationID: string;
  /**
   * The pipeline this run is executing
   * @minLength 36
   */
  pipelineID: string;
  /** The percent progress of the run */
  progress: number;
  /**
   * The timestamp when the run started
   * @minLength 1
   */
  startedAt?: string;
  status: RunAllOfStatus;
  /**
   * The tool being used in this run
   * @minLength 36
   */
  toolID: string;
};

/**
 * Schema for Run entity
 */
export type Run = Base & RunAllOf;

export type ToolAllOf = {
  /**
   * The tool description
   * @minLength 1
   */
  description: string;
  /**
   * The MIME type of the input for the tool, e.g. text/plain
   * @minLength 1
   */
  inputMimeType: string;
  /**
   * The name of the tool
   * @minLength 1
   */
  name: string;
  /**
   * The organization that owns this tool
   * @minLength 36
   */
  organizationID: string;
  /**
   * The MIME type of the output for the tool, e.g. text/plain
   * @minLength 1
   */
  outputMimeType: string;
};

/**
 * Schema for Tool entity
 */
export type Tool = Base & ToolAllOf;

export type ArtifactAllOf = {
  /** The number of credits required to access this artifact. This is used for metering and billing purposes. */
  credits: number;
  /**
   * The artifact's description
   * @minLength 1
   */
  description?: string;
  /**
   * The MIME type of the artifact, e.g. image/png
   * @minLength 1
   */
  mimeType: string;
  /**
   * The name of the artifact, used for display purposes
   * @minLength 1
   */
  name?: string;
  /**
   * The organization that owns this artifact
   * @minLength 36
   */
  organizationID: string;
  /**
   * The URL of the preview image for this artifact. This is used for displaying a thumbnail in the UI.
   * @minLength 1
   */
  previewImage?: string;
  /**
   * The ID of the entity that produced this artifact
   * @minLength 36
   */
  producerID?: string;
  /**
   * The artifact text
   * @minLength 1
   */
  text?: string;
};

/**
 * Schema for Artifact entity
 */
export type Artifact = Base & ArtifactAllOf;

export type LabelAllOf = {
  /**
   * The name of the label
   * @minLength 1
   */
  name: string;
  /**
   * The organization this label belongs to
   * @minLength 36
   */
  organizationID: string;
};

/**
 * Schema for Label entity
 */
export type Label = Base & LabelAllOf;

/**
 * Email configuration for sending emails
 */
export interface ConfigEmail {
  /** Enable email functionality */
  enabled: boolean;
  /** Email service provider (e.g., "gmail", "sendgrid", etc.) */
  service?: string;
  /** Username for the email service */
  user?: string;
  /** Password for the email service */
  password?: string;
}

/**
 * Kubernetes image pull policy
 */
export type ConfigImagePullPolicy = typeof ConfigImagePullPolicy[keyof typeof ConfigImagePullPolicy];


// eslint-disable-next-line @typescript-eslint/no-redeclare
export const ConfigImagePullPolicy = {
  Always: 'Always',
  IfNotPresent: 'IfNotPresent',
  Never: 'Never',
} as const;

/**
 * Container image configuration
 */
export interface ConfigImage {
  /** Kubernetes image pull policy */
  pullPolicy: ConfigImagePullPolicy;
  /**
   * Container image repository
   * @minLength 1
   */
  repository?: string;
  /**
   * Container image tag
   * @minLength 1
   */
  tag: string;
}

/**
 * Resource limits
 */
export type ConfigResourceLimits = {
  /**
   * Maximum CPU allocation
   * @minLength 1
   */
  cpu: string;
  /**
   * Maximum memory allocation
   * @minLength 1
   */
  memory: string;
};

/**
 * Resource requests
 */
export type ConfigResourceRequests = {
  /**
   * Requested CPU allocation
   * @minLength 1
   */
  cpu: string;
  /**
   * Requested memory allocation
   * @minLength 1
   */
  memory: string;
};

/**
 * Kubernetes resource configuration
 */
export interface ConfigResource {
  /** Resource limits */
  limits: ConfigResourceLimits;
  /** Resource requests */
  requests: ConfigResourceRequests;
}

/**
 * Configuration schema for the API server
 */
export interface ConfigAPI {
  /**
   * A comma-separated list of allowed origins for CORS requests
   * @minLength 1
   */
  cors: string;
  /** Enable or disable API documentation */
  docs: boolean;
  email?: ConfigEmail;
  /** Deployment environment (development, staging, production) */
  environment: string;
  /**
   * The host address on which the API server will listen
   * @minLength 1
   */
  readonly host: string;
  /** The port on which the API server will listen */
  port: number;
  /** Enable or disable request validation */
  validate: boolean;
  image?: ConfigImage;
  resources?: ConfigResource;
}

/**
 * Firebase authentication configuration
 */
export interface ConfigAuthFirebase {
  /** Enable Firebase authentication */
  enabled: boolean;
  /** Firebase service account client email address */
  clientEmail?: string;
  /**
   * Firebase service account private key (PEM format)
   * @minLength 1
   */
  privateKey?: string;
  /**
   * Firebase project ID for authentication
   * @minLength 1
   */
  projectID?: string;
}

/**
 * Local username/password authentication
 */
export interface ConfigAuthLocal {
  /** Enable local authentication */
  enabled: boolean;
  /**
   * Secret key for JWT token signing
   * @minLength 32
   */
  jwtSecret: string;
  /**
   * Access token time-to-live duration (e.g., "15m", "1h")
   * @minLength 2
   * @pattern ^(\d+[smhd])+$
   */
  accessTokenTtl: string;
  /**
   * Refresh token time-to-live duration (e.g., "7d", "168h")
   * @minLength 2
   * @pattern ^(\d+[smhd])+$
   */
  refreshTokenTtl: string;
}

export type ConfigAuthMagicLinkDeliveryMethodsEmail = {
  enabled?: boolean;
  from?: string;
};

export type ConfigAuthMagicLinkDeliveryMethodsConsole = {
  /** Enable console output (development only) */
  enabled?: boolean;
};

export type ConfigAuthMagicLinkDeliveryMethodsOtp = {
  enabled?: boolean;
};

export type ConfigAuthMagicLinkDeliveryMethodsWebhook = {
  enabled?: boolean;
  url?: string;
};

/**
 * Available delivery methods
 */
export type ConfigAuthMagicLinkDeliveryMethods = {
  email?: ConfigAuthMagicLinkDeliveryMethodsEmail;
  console?: ConfigAuthMagicLinkDeliveryMethodsConsole;
  otp?: ConfigAuthMagicLinkDeliveryMethodsOtp;
  webhook?: ConfigAuthMagicLinkDeliveryMethodsWebhook;
};

/**
 * Rate limiting configuration
 */
export type ConfigAuthMagicLinkRateLimit = {
  /**
   * Maximum number of attempts within window
   * @minimum 1
   */
  maxAttempts?: number;
  /**
   * Time window in minutes
   * @minimum 1
   */
  windowMinutes?: number;
};

/**
 * Magic link authentication configuration
 */
export interface ConfigAuthMagicLink {
  /** Enable magic link authentication */
  enabled: boolean;
  /**
   * Token expiry duration in minutes
   * @minimum 1
   * @maximum 60
   */
  tokenExpiry?: number;
  /**
   * Length of OTP code
   * @minimum 4
   * @maximum 8
   */
  otpLength?: number;
  /** Available delivery methods */
  deliveryMethods?: ConfigAuthMagicLinkDeliveryMethods;
  /** Rate limiting configuration */
  rateLimit?: ConfigAuthMagicLinkRateLimit;
}

/**
 * Twitter OAuth configuration
 */
export interface ConfigAuthTwitter {
  /** Enable Twitter OAuth */
  enabled: boolean;
  /**
   * OAuth callback URL
   * @minLength 1
   */
  callbackURL?: string;
  /**
   * Twitter API consumer key
   * @minLength 1
   */
  consumerKey?: string;
  /**
   * Twitter API consumer secret
   * @minLength 1
   */
  consumerSecret?: string;
}

/**
 * Google OAuth configuration
 */
export interface ConfigAuthGoogle {
  /** Enable Google OAuth */
  enabled: boolean;
  /** Google OAuth client ID */
  clientId?: string;
  /** Google OAuth client secret */
  clientSecret?: string;
  /** OAuth callback URL */
  redirectUrl?: string;
  /** OAuth scopes to request */
  scopes?: string[];
}

/**
 * GitHub OAuth configuration
 */
export interface ConfigAuthGithub {
  /** Enable GitHub OAuth */
  enabled: boolean;
  /** GitHub OAuth App client ID */
  clientId?: string;
  /** GitHub OAuth App client secret */
  clientSecret?: string;
  /** OAuth callback URL */
  redirectUrl?: string;
  /** OAuth scopes to request */
  scopes?: string[];
}

/**
 * Microsoft/Azure AD OAuth configuration
 */
export interface ConfigAuthMicrosoft {
  /** Enable Microsoft OAuth */
  enabled: boolean;
  /** Azure AD Application (client) ID */
  clientId?: string;
  /** Azure AD client secret */
  clientSecret?: string;
  /** OAuth callback URL */
  redirectUrl?: string;
  /** Azure AD tenant ID (use 'common' for multi-tenant) */
  tenant?: string;
  /** OAuth scopes to request */
  scopes?: string[];
}

/**
 * Authentication configuration for the API server
 */
export interface ConfigAuth {
  /** Enable authentication */
  enabled: boolean;
  firebase?: ConfigAuthFirebase;
  local?: ConfigAuthLocal;
  magicLink?: ConfigAuthMagicLink;
  twitter?: ConfigAuthTwitter;
  google?: ConfigAuthGoogle;
  github?: ConfigAuthGithub;
  microsoft?: ConfigAuthMicrosoft;
}

/**
 * Stripe payment configuration
 */
export interface ConfigStripe {
  /**
   * Stripe secret API key
   * @minLength 1
   */
  token: string;
  /**
   * Stripe webhook endpoint secret
   * @minLength 1
   */
  whsec: string;
}

/**
 * Billing configuration for Stripe
 */
export interface ConfigBilling {
  /** Enable billing functionality */
  enabled: boolean;
  stripe?: ConfigStripe;
}

/**
 * Persistent storage configuration
 */
export interface ConfigPersistence {
  /** Enable persistent storage */
  enabled: boolean;
  /**
   * Size of persistent volume
   * @minLength 1
   */
  size: string;
}

/**
 * Database type (postgresql or sqlite)
 */
export type ConfigDatabaseType = typeof ConfigDatabaseType[keyof typeof ConfigDatabaseType];


// eslint-disable-next-line @typescript-eslint/no-redeclare
export const ConfigDatabaseType = {
  postgresql: 'postgresql',
  sqlite: 'sqlite',
} as const;

/**
 * Database configuration for PostgreSQL
 */
export interface ConfigDatabase {
  /** Enable database */
  enabled: boolean;
  /**
   * Database connection url/string
   * @minLength 1
   */
  url: string;
  /** Database type (postgresql or sqlite) */
  type: ConfigDatabaseType;
  /**
   * Maximum number of connections in pool (PostgreSQL)
   * @minimum 1
   */
  maxConns: number;
  /**
   * Minimum number of connections in pool (PostgreSQL)
   * @minimum 0
   */
  minConns: number;
  /**
   * Maximum connection lifetime (e.g., "30m")
   * @pattern ^(\d+[smh])+$
   */
  connMaxLifetime?: string;
  /**
   * Maximum connection idle time (e.g., "5m")
   * @pattern ^(\d+[smh])+$
   */
  connMaxIdleTime?: string;
  /**
   * Health check period for connections (PostgreSQL)
   * @pattern ^(\d+[smh])+$
   */
  healthCheckPeriod?: string;
  /** Automatically run database migrations on startup */
  runMigrations: boolean;
  /** Use managed database deployment */
  managed: boolean;
  image?: ConfigImage;
  persistence?: ConfigPersistence;
  resources?: ConfigResource;
}

/**
 * LLM provider type
 */
export type ConfigLLMType = typeof ConfigLLMType[keyof typeof ConfigLLMType];


// eslint-disable-next-line @typescript-eslint/no-redeclare
export const ConfigLLMType = {
  ollama: 'ollama',
  openai: 'openai',
} as const;

/**
 * Large Language Model configuration
 */
export interface ConfigLLM {
  /** LLM provider type */
  type: ConfigLLMType;
  /**
   * LLM service endpoint URL
   * @minLength 1
   */
  endpoint?: string;
  /**
   * Authentication token for LLM service
   * @minLength 1
   */
  token?: string;
}

/**
 * RunPod serverless GPU configuration
 */
export interface ConfigRunPod {
  /** Enable RunPod integration */
  enabled: boolean;
  /**
   * RunPod API token
   * @minLength 1
   */
  token?: string;
}

/**
 * Web scraping service configuration
 */
export interface ConfigScraper {
  /** Enable scraper service */
  enabled: boolean;
  /** Use managed scraper deployment */
  managed?: boolean;
  /**
   * Web scraper service endpoint URL
   * @minLength 1
   */
  endpoint?: string;
  image?: ConfigImage;
  resources?: ConfigResource;
}

/**
 * Speech recognition and TTS services
 */
export interface ConfigSpeech {
  /** Enable speech services */
  enabled: boolean;
  /**
   * Speech-to-text service API token
   * @minLength 1
   */
  token?: string;
}

/**
 * Unstructured.io service for document parsing
 */
export interface ConfigUnstructured {
  /** Enable unstructured document parsing */
  enabled: boolean;
  /** Use managed unstructured deployment */
  managed?: boolean;
  image?: ConfigImage;
  resources?: ConfigResource;
}

/**
 * Intelligence configuration (LLMs, embeddings, scraper, speech, etc.)
 */
export interface ConfigIntelligence {
  embedding?: ConfigLLM;
  llm?: ConfigLLM;
  runpod?: ConfigRunPod;
  scraper?: ConfigScraper;
  speech?: ConfigSpeech;
  unstructured?: ConfigUnstructured;
}

/**
 * Minimum log level to output
 */
export type ConfigLoggingLevel = typeof ConfigLoggingLevel[keyof typeof ConfigLoggingLevel];


// eslint-disable-next-line @typescript-eslint/no-redeclare
export const ConfigLoggingLevel = {
  fatal: 'fatal',
  error: 'error',
  warn: 'warn',
  info: 'info',
  debug: 'debug',
  trace: 'trace',
  silent: 'silent',
} as const;

/**
 * Logging configuration
 */
export interface ConfigLogging {
  /** Minimum log level to output */
  level: ConfigLoggingLevel;
  /** Enable pretty-printed logs for development */
  pretty: boolean;
}

/**
 * Platform configuration (host, image, resources)
 */
export interface ConfigPlatform {
  /** Enable platform service */
  enabled: boolean;
  /** Use managed platform deployment */
  managed?: boolean;
  /**
   * Host address where the platform service will be accessible
   * @minLength 1
   */
  host?: string;
  image?: ConfigImage;
  resources?: ConfigResource;
}

/**
 * Redis configuration
 */
export interface ConfigRedis {
  /** Enable Redis */
  enabled: boolean;
  /** Use managed Redis deployment */
  managed?: boolean;
  /**
   * Redis authentication password
   * @minLength 1
   */
  auth: string;
  /**
   * Certificate Authority for TLS (optional)
   * @minLength 1
   */
  ca?: string;
  /**
   * Redis hostname or IP
   * @minLength 1
   */
  host: string;
  /** Redis port number */
  port: number;
  image?: ConfigImage;
  persistence?: ConfigPersistence;
  resources?: ConfigResource;
}

/**
 * Object storage configuration for MinIO or S3-compatible services
 */
export interface ConfigStorage {
  /** Enable object storage */
  enabled: boolean;
  /** Use managed storage deployment */
  managed?: boolean;
  /**
   * MinIO/S3 access key ID
   * @minLength 1
   */
  accesskey: string;
  /**
   * S3 bucket name
   * @minLength 1
   */
  bucket: string;
  /**
   * MinIO server endpoint URL
   * @minLength 1
   */
  endpoint: string;
  /**
   * MinIO/S3 secret access key
   * @minLength 1
   */
  secretkey: string;
  image?: ConfigImage;
  persistence?: ConfigPersistence;
  resources?: ConfigResource;
}

/**
 * Container image configuration
 */
export interface ConfigImages {
  /** List of Kubernetes secrets for pulling private images */
  imagePullSecrets: string[];
  /**
   * Custom container registry URL (leave empty for Docker Hub)
   * @minLength 1
   */
  imageRegistry: string;
}

/**
 * Database migration configuration
 */
export interface ConfigMigrations {
  /** Enable automatic DB migrations */
  enabled: boolean;
}

/**
 * Kubernetes service account configuration
 */
export interface ConfigServiceAccount {
  /** Create dedicated service account */
  create: boolean;
  /**
   * Custom service account name
   * @minLength 1
   */
  name: string;
}

/**
 * Infrastructure configuration for Kubernetes deployments
 */
export interface ConfigInfrastructure {
  images: ConfigImages;
  migrations: ConfigMigrations;
  /**
   * Kubernetes namespace where all resources will be deployed
   * @minLength 1
   */
  namespace: string;
  serviceAccount: ConfigServiceAccount;
}

/**
 * TLS configuration
 */
export interface ConfigTLS {
  /** Enable TLS/SSL */
  enabled: boolean;
  /**
   * Cert-manager ClusterIssuer
   * @minLength 1
   */
  issuer?: string;
  /**
   * Kubernetes secret name for TLS certificates
   * @minLength 1
   */
  secretName?: string;
}

/**
 * Ingress configuration
 */
export interface ConfigIngress {
  /** Enable ingress */
  enabled: boolean;
  /**
   * Primary domain name for ingress routing
   * @minLength 1
   */
  domain?: string;
  tls?: ConfigTLS;
}

/**
 * Grafana monitoring dashboard configuration
 */
export interface ConfigGrafana {
  /** Enable Grafana */
  enabled: boolean;
  /** Use managed Grafana deployment */
  managed?: boolean;
  image?: ConfigImage;
  resources?: ConfigResource;
}

/**
 * Loki log aggregation service configuration
 */
export interface ConfigLoki {
  /** Enable Loki */
  enabled: boolean;
  /** Use managed Loki deployment */
  managed?: boolean;
  /**
   * Loki host URL
   * @minLength 1
   */
  host?: string;
  image?: ConfigImage;
  resources?: ConfigResource;
}

/**
 * Monitoring configuration for Grafana and Loki
 */
export interface ConfigMonitoring {
  grafana: ConfigGrafana;
  loki: ConfigLoki;
}

/**
 * Kubernetes-specific deployment configuration
 */
export interface ConfigKubernetes {
  infrastructure?: ConfigInfrastructure;
  ingress?: ConfigIngress;
  monitoring?: ConfigMonitoring;
}

/**
 * Arches AI configuration schema
 */
export interface Config {
  api?: ConfigAPI;
  auth?: ConfigAuth;
  billing?: ConfigBilling;
  database?: ConfigDatabase;
  intelligence?: ConfigIntelligence;
  logging?: ConfigLogging;
  platform?: ConfigPlatform;
  redis?: ConfigRedis;
  storage?: ConfigStorage;
  kubernetes?: ConfigKubernetes;
}

export type HealthServices = {
  /** @minLength 1 */
  database: string;
  /** @minLength 1 */
  email: string;
  /** @minLength 1 */
  redis: string;
};

/**
 * Health check response
 */
export interface Health {
  services: HealthServices;
  /** @minLength 1 */
  timestamp: string;
  uptime: number;
}

/**
 * 400 Bad Request
 */
export type BadRequestResponse = Problem;

/**
 * 401 Unauthorized
 */
export type UnauthorizedResponse = Problem;

/**
 * Too many requests - rate limit exceeded
 */
export type TooManyRequestsResponse = Problem;

/**
 * Internal server error
 */
export type InternalServerErrorResponse = Problem;

/**
 * 404 Not Found
 */
export type NotFoundResponse = Problem;

/**
 * 204 No Content
 */
export type NoContentResponse = void;

/**
 * Pagination parameters (limit & offset)
 */
export type PageQueryParameter = {
  /**
   * Maximum number of items to return
   * @minimum 1
   * @maximum 100
   */
  limit?: number;
  /**
   * Number of items to skip before starting to collect the result set
   * @minimum 0
   * @maximum 9007199254740991
   */
  offset?: number;
};

export type SessionsSortParameterItemField = typeof SessionsSortParameterItemField[keyof typeof SessionsSortParameterItemField];


// eslint-disable-next-line @typescript-eslint/no-redeclare
export const SessionsSortParameterItemField = {
  createdAt: 'createdAt',
  id: 'id',
  updatedAt: 'updatedAt',
  organizationID: 'organizationID',
  expiresAt: 'expiresAt',
  ipAddress: 'ipAddress',
  token: 'token',
  userAgent: 'userAgent',
  userID: 'userID',
} as const;

export type SessionsSortParameterItemOrder = typeof SessionsSortParameterItemOrder[keyof typeof SessionsSortParameterItemOrder];


// eslint-disable-next-line @typescript-eslint/no-redeclare
export const SessionsSortParameterItemOrder = {
  asc: 'asc',
  desc: 'desc',
} as const;

export type SessionsSortParameterItem = {
  field: SessionsSortParameterItemField;
  order: SessionsSortParameterItemOrder;
};

/**
 * The sort parameter
 */
export type SessionsSortParameter = SessionsSortParameterItem[];

/**
 * The type of filter operation
 */
export type UsersFilterParameterType = typeof UsersFilterParameterType[keyof typeof UsersFilterParameterType];


// eslint-disable-next-line @typescript-eslint/no-redeclare
export const UsersFilterParameterType = {
  and: 'and',
  or: 'or',
  eq: 'eq',
  ne: 'ne',
  gt: 'gt',
  gte: 'gte',
  lt: 'lt',
  lte: 'lte',
  contains: 'contains',
  starts_with: 'starts_with',
  ends_with: 'ends_with',
} as const;

/**
 * A recursive filter node that can be a condition or group
 */
export type UsersFilterParameter = {
  /** The type of filter operation */
  type: UsersFilterParameterType;
  /**
   * The field to filter on (for leaf conditions)
   * @minLength 1
   */
  field?: string;
  /** The value to compare against (for leaf conditions) */
  value?: unknown;
  /** Child filter nodes (for logical operators) */
  children?: FilterNode[];
};

export type UsersSortParameterItemField = typeof UsersSortParameterItemField[keyof typeof UsersSortParameterItemField];


// eslint-disable-next-line @typescript-eslint/no-redeclare
export const UsersSortParameterItemField = {
  createdAt: 'createdAt',
  id: 'id',
  updatedAt: 'updatedAt',
  email: 'email',
  emailVerified: 'emailVerified',
  image: 'image',
  name: 'name',
} as const;

export type UsersSortParameterItemOrder = typeof UsersSortParameterItemOrder[keyof typeof UsersSortParameterItemOrder];


// eslint-disable-next-line @typescript-eslint/no-redeclare
export const UsersSortParameterItemOrder = {
  asc: 'asc',
  desc: 'desc',
} as const;

export type UsersSortParameterItem = {
  field: UsersSortParameterItemField;
  order: UsersSortParameterItemOrder;
};

/**
 * The sort parameter
 */
export type UsersSortParameter = UsersSortParameterItem[];

/**
 * The type of filter operation
 */
export type APIKeysFilterParameterType = typeof APIKeysFilterParameterType[keyof typeof APIKeysFilterParameterType];


// eslint-disable-next-line @typescript-eslint/no-redeclare
export const APIKeysFilterParameterType = {
  and: 'and',
  or: 'or',
  eq: 'eq',
  ne: 'ne',
  gt: 'gt',
  gte: 'gte',
  lt: 'lt',
  lte: 'lte',
  contains: 'contains',
  starts_with: 'starts_with',
  ends_with: 'ends_with',
} as const;

/**
 * A recursive filter node that can be a condition or group
 */
export type APIKeysFilterParameter = {
  /** The type of filter operation */
  type: APIKeysFilterParameterType;
  /**
   * The field to filter on (for leaf conditions)
   * @minLength 1
   */
  field?: string;
  /** The value to compare against (for leaf conditions) */
  value?: unknown;
  /** Child filter nodes (for logical operators) */
  children?: FilterNode[];
};

export type APIKeysSortParameterItemField = typeof APIKeysSortParameterItemField[keyof typeof APIKeysSortParameterItemField];


// eslint-disable-next-line @typescript-eslint/no-redeclare
export const APIKeysSortParameterItemField = {
  createdAt: 'createdAt',
  id: 'id',
  updatedAt: 'updatedAt',
  userID: 'userID',
  organizationID: 'organizationID',
  keyHash: 'keyHash',
  name: 'name',
  prefix: 'prefix',
  rateLimit: 'rateLimit',
  lastUsedAt: 'lastUsedAt',
  expiresAt: 'expiresAt',
} as const;

export type APIKeysSortParameterItemOrder = typeof APIKeysSortParameterItemOrder[keyof typeof APIKeysSortParameterItemOrder];


// eslint-disable-next-line @typescript-eslint/no-redeclare
export const APIKeysSortParameterItemOrder = {
  asc: 'asc',
  desc: 'desc',
} as const;

export type APIKeysSortParameterItem = {
  field: APIKeysSortParameterItemField;
  order: APIKeysSortParameterItemOrder;
};

/**
 * The sort parameter
 */
export type APIKeysSortParameter = APIKeysSortParameterItem[];

/**
 * The type of filter operation
 */
export type OrganizationsFilterParameterType = typeof OrganizationsFilterParameterType[keyof typeof OrganizationsFilterParameterType];


// eslint-disable-next-line @typescript-eslint/no-redeclare
export const OrganizationsFilterParameterType = {
  and: 'and',
  or: 'or',
  eq: 'eq',
  ne: 'ne',
  gt: 'gt',
  gte: 'gte',
  lt: 'lt',
  lte: 'lte',
  contains: 'contains',
  starts_with: 'starts_with',
  ends_with: 'ends_with',
} as const;

/**
 * A recursive filter node that can be a condition or group
 */
export type OrganizationsFilterParameter = {
  /** The type of filter operation */
  type: OrganizationsFilterParameterType;
  /**
   * The field to filter on (for leaf conditions)
   * @minLength 1
   */
  field?: string;
  /** The value to compare against (for leaf conditions) */
  value?: unknown;
  /** Child filter nodes (for logical operators) */
  children?: FilterNode[];
};

export type OrganizationsSortParameterItemField = typeof OrganizationsSortParameterItemField[keyof typeof OrganizationsSortParameterItemField];


// eslint-disable-next-line @typescript-eslint/no-redeclare
export const OrganizationsSortParameterItemField = {
  createdAt: 'createdAt',
  id: 'id',
  updatedAt: 'updatedAt',
  billingEmail: 'billingEmail',
  credits: 'credits',
  logo: 'logo',
  metadata: 'metadata',
  name: 'name',
  plan: 'plan',
  slug: 'slug',
  stripeCustomerIdentifier: 'stripeCustomerIdentifier',
} as const;

export type OrganizationsSortParameterItemOrder = typeof OrganizationsSortParameterItemOrder[keyof typeof OrganizationsSortParameterItemOrder];


// eslint-disable-next-line @typescript-eslint/no-redeclare
export const OrganizationsSortParameterItemOrder = {
  asc: 'asc',
  desc: 'desc',
} as const;

export type OrganizationsSortParameterItem = {
  field: OrganizationsSortParameterItemField;
  order: OrganizationsSortParameterItemOrder;
};

/**
 * The sort parameter
 */
export type OrganizationsSortParameter = OrganizationsSortParameterItem[];

/**
 * The type of filter operation
 */
export type MembersFilterParameterType = typeof MembersFilterParameterType[keyof typeof MembersFilterParameterType];


// eslint-disable-next-line @typescript-eslint/no-redeclare
export const MembersFilterParameterType = {
  and: 'and',
  or: 'or',
  eq: 'eq',
  ne: 'ne',
  gt: 'gt',
  gte: 'gte',
  lt: 'lt',
  lte: 'lte',
  contains: 'contains',
  starts_with: 'starts_with',
  ends_with: 'ends_with',
} as const;

/**
 * A recursive filter node that can be a condition or group
 */
export type MembersFilterParameter = {
  /** The type of filter operation */
  type: MembersFilterParameterType;
  /**
   * The field to filter on (for leaf conditions)
   * @minLength 1
   */
  field?: string;
  /** The value to compare against (for leaf conditions) */
  value?: unknown;
  /** Child filter nodes (for logical operators) */
  children?: FilterNode[];
};

export type MembersSortParameterItemField = typeof MembersSortParameterItemField[keyof typeof MembersSortParameterItemField];


// eslint-disable-next-line @typescript-eslint/no-redeclare
export const MembersSortParameterItemField = {
  createdAt: 'createdAt',
  id: 'id',
  updatedAt: 'updatedAt',
  organizationID: 'organizationID',
  role: 'role',
  userID: 'userID',
} as const;

export type MembersSortParameterItemOrder = typeof MembersSortParameterItemOrder[keyof typeof MembersSortParameterItemOrder];


// eslint-disable-next-line @typescript-eslint/no-redeclare
export const MembersSortParameterItemOrder = {
  asc: 'asc',
  desc: 'desc',
} as const;

export type MembersSortParameterItem = {
  field: MembersSortParameterItemField;
  order: MembersSortParameterItemOrder;
};

/**
 * The sort parameter
 */
export type MembersSortParameter = MembersSortParameterItem[];

/**
 * The type of filter operation
 */
export type InvitationsFilterParameterType = typeof InvitationsFilterParameterType[keyof typeof InvitationsFilterParameterType];


// eslint-disable-next-line @typescript-eslint/no-redeclare
export const InvitationsFilterParameterType = {
  and: 'and',
  or: 'or',
  eq: 'eq',
  ne: 'ne',
  gt: 'gt',
  gte: 'gte',
  lt: 'lt',
  lte: 'lte',
  contains: 'contains',
  starts_with: 'starts_with',
  ends_with: 'ends_with',
} as const;

/**
 * A recursive filter node that can be a condition or group
 */
export type InvitationsFilterParameter = {
  /** The type of filter operation */
  type: InvitationsFilterParameterType;
  /**
   * The field to filter on (for leaf conditions)
   * @minLength 1
   */
  field?: string;
  /** The value to compare against (for leaf conditions) */
  value?: unknown;
  /** Child filter nodes (for logical operators) */
  children?: FilterNode[];
};

export type InvitationsSortParameterItemField = typeof InvitationsSortParameterItemField[keyof typeof InvitationsSortParameterItemField];


// eslint-disable-next-line @typescript-eslint/no-redeclare
export const InvitationsSortParameterItemField = {
  createdAt: 'createdAt',
  id: 'id',
  updatedAt: 'updatedAt',
  email: 'email',
  expiresAt: 'expiresAt',
  inviterID: 'inviterID',
  organizationID: 'organizationID',
  role: 'role',
  status: 'status',
} as const;

export type InvitationsSortParameterItemOrder = typeof InvitationsSortParameterItemOrder[keyof typeof InvitationsSortParameterItemOrder];


// eslint-disable-next-line @typescript-eslint/no-redeclare
export const InvitationsSortParameterItemOrder = {
  asc: 'asc',
  desc: 'desc',
} as const;

export type InvitationsSortParameterItem = {
  field: InvitationsSortParameterItemField;
  order: InvitationsSortParameterItemOrder;
};

/**
 * The sort parameter
 */
export type InvitationsSortParameter = InvitationsSortParameterItem[];

/**
 * The type of filter operation
 */
export type PipelinesFilterParameterType = typeof PipelinesFilterParameterType[keyof typeof PipelinesFilterParameterType];


// eslint-disable-next-line @typescript-eslint/no-redeclare
export const PipelinesFilterParameterType = {
  and: 'and',
  or: 'or',
  eq: 'eq',
  ne: 'ne',
  gt: 'gt',
  gte: 'gte',
  lt: 'lt',
  lte: 'lte',
  contains: 'contains',
  starts_with: 'starts_with',
  ends_with: 'ends_with',
} as const;

/**
 * A recursive filter node that can be a condition or group
 */
export type PipelinesFilterParameter = {
  /** The type of filter operation */
  type: PipelinesFilterParameterType;
  /**
   * The field to filter on (for leaf conditions)
   * @minLength 1
   */
  field?: string;
  /** The value to compare against (for leaf conditions) */
  value?: unknown;
  /** Child filter nodes (for logical operators) */
  children?: FilterNode[];
};

export type PipelinesSortParameterItemField = typeof PipelinesSortParameterItemField[keyof typeof PipelinesSortParameterItemField];


// eslint-disable-next-line @typescript-eslint/no-redeclare
export const PipelinesSortParameterItemField = {
  createdAt: 'createdAt',
  id: 'id',
  updatedAt: 'updatedAt',
  description: 'description',
  name: 'name',
  organizationID: 'organizationID',
} as const;

export type PipelinesSortParameterItemOrder = typeof PipelinesSortParameterItemOrder[keyof typeof PipelinesSortParameterItemOrder];


// eslint-disable-next-line @typescript-eslint/no-redeclare
export const PipelinesSortParameterItemOrder = {
  asc: 'asc',
  desc: 'desc',
} as const;

export type PipelinesSortParameterItem = {
  field: PipelinesSortParameterItemField;
  order: PipelinesSortParameterItemOrder;
};

/**
 * The sort parameter
 */
export type PipelinesSortParameter = PipelinesSortParameterItem[];

/**
 * The type of filter operation
 */
export type RunsFilterParameterType = typeof RunsFilterParameterType[keyof typeof RunsFilterParameterType];


// eslint-disable-next-line @typescript-eslint/no-redeclare
export const RunsFilterParameterType = {
  and: 'and',
  or: 'or',
  eq: 'eq',
  ne: 'ne',
  gt: 'gt',
  gte: 'gte',
  lt: 'lt',
  lte: 'lte',
  contains: 'contains',
  starts_with: 'starts_with',
  ends_with: 'ends_with',
} as const;

/**
 * A recursive filter node that can be a condition or group
 */
export type RunsFilterParameter = {
  /** The type of filter operation */
  type: RunsFilterParameterType;
  /**
   * The field to filter on (for leaf conditions)
   * @minLength 1
   */
  field?: string;
  /** The value to compare against (for leaf conditions) */
  value?: unknown;
  /** Child filter nodes (for logical operators) */
  children?: FilterNode[];
};

export type RunsSortParameterItemField = typeof RunsSortParameterItemField[keyof typeof RunsSortParameterItemField];


// eslint-disable-next-line @typescript-eslint/no-redeclare
export const RunsSortParameterItemField = {
  createdAt: 'createdAt',
  id: 'id',
  updatedAt: 'updatedAt',
  completedAt: 'completedAt',
  error: 'error',
  organizationID: 'organizationID',
  pipelineID: 'pipelineID',
  progress: 'progress',
  startedAt: 'startedAt',
  status: 'status',
  toolID: 'toolID',
} as const;

export type RunsSortParameterItemOrder = typeof RunsSortParameterItemOrder[keyof typeof RunsSortParameterItemOrder];


// eslint-disable-next-line @typescript-eslint/no-redeclare
export const RunsSortParameterItemOrder = {
  asc: 'asc',
  desc: 'desc',
} as const;

export type RunsSortParameterItem = {
  field: RunsSortParameterItemField;
  order: RunsSortParameterItemOrder;
};

/**
 * The sort parameter
 */
export type RunsSortParameter = RunsSortParameterItem[];

/**
 * The type of filter operation
 */
export type ToolsFilterParameterType = typeof ToolsFilterParameterType[keyof typeof ToolsFilterParameterType];


// eslint-disable-next-line @typescript-eslint/no-redeclare
export const ToolsFilterParameterType = {
  and: 'and',
  or: 'or',
  eq: 'eq',
  ne: 'ne',
  gt: 'gt',
  gte: 'gte',
  lt: 'lt',
  lte: 'lte',
  contains: 'contains',
  starts_with: 'starts_with',
  ends_with: 'ends_with',
} as const;

/**
 * A recursive filter node that can be a condition or group
 */
export type ToolsFilterParameter = {
  /** The type of filter operation */
  type: ToolsFilterParameterType;
  /**
   * The field to filter on (for leaf conditions)
   * @minLength 1
   */
  field?: string;
  /** The value to compare against (for leaf conditions) */
  value?: unknown;
  /** Child filter nodes (for logical operators) */
  children?: FilterNode[];
};

export type ToolsSortParameterItemField = typeof ToolsSortParameterItemField[keyof typeof ToolsSortParameterItemField];


// eslint-disable-next-line @typescript-eslint/no-redeclare
export const ToolsSortParameterItemField = {
  createdAt: 'createdAt',
  id: 'id',
  updatedAt: 'updatedAt',
  description: 'description',
  inputMimeType: 'inputMimeType',
  name: 'name',
  organizationID: 'organizationID',
  outputMimeType: 'outputMimeType',
} as const;

export type ToolsSortParameterItemOrder = typeof ToolsSortParameterItemOrder[keyof typeof ToolsSortParameterItemOrder];


// eslint-disable-next-line @typescript-eslint/no-redeclare
export const ToolsSortParameterItemOrder = {
  asc: 'asc',
  desc: 'desc',
} as const;

export type ToolsSortParameterItem = {
  field: ToolsSortParameterItemField;
  order: ToolsSortParameterItemOrder;
};

/**
 * The sort parameter
 */
export type ToolsSortParameter = ToolsSortParameterItem[];

/**
 * The type of filter operation
 */
export type ArtifactsFilterParameterType = typeof ArtifactsFilterParameterType[keyof typeof ArtifactsFilterParameterType];


// eslint-disable-next-line @typescript-eslint/no-redeclare
export const ArtifactsFilterParameterType = {
  and: 'and',
  or: 'or',
  eq: 'eq',
  ne: 'ne',
  gt: 'gt',
  gte: 'gte',
  lt: 'lt',
  lte: 'lte',
  contains: 'contains',
  starts_with: 'starts_with',
  ends_with: 'ends_with',
} as const;

/**
 * A recursive filter node that can be a condition or group
 */
export type ArtifactsFilterParameter = {
  /** The type of filter operation */
  type: ArtifactsFilterParameterType;
  /**
   * The field to filter on (for leaf conditions)
   * @minLength 1
   */
  field?: string;
  /** The value to compare against (for leaf conditions) */
  value?: unknown;
  /** Child filter nodes (for logical operators) */
  children?: FilterNode[];
};

export type ArtifactsSortParameterItemField = typeof ArtifactsSortParameterItemField[keyof typeof ArtifactsSortParameterItemField];


// eslint-disable-next-line @typescript-eslint/no-redeclare
export const ArtifactsSortParameterItemField = {
  createdAt: 'createdAt',
  id: 'id',
  updatedAt: 'updatedAt',
  credits: 'credits',
  description: 'description',
  mimeType: 'mimeType',
  name: 'name',
  organizationID: 'organizationID',
  previewImage: 'previewImage',
  producerID: 'producerID',
  text: 'text',
  url: 'url',
} as const;

export type ArtifactsSortParameterItemOrder = typeof ArtifactsSortParameterItemOrder[keyof typeof ArtifactsSortParameterItemOrder];


// eslint-disable-next-line @typescript-eslint/no-redeclare
export const ArtifactsSortParameterItemOrder = {
  asc: 'asc',
  desc: 'desc',
} as const;

export type ArtifactsSortParameterItem = {
  field: ArtifactsSortParameterItemField;
  order: ArtifactsSortParameterItemOrder;
};

/**
 * The sort parameter
 */
export type ArtifactsSortParameter = ArtifactsSortParameterItem[];

/**
 * The type of filter operation
 */
export type LabelsFilterParameterType = typeof LabelsFilterParameterType[keyof typeof LabelsFilterParameterType];


// eslint-disable-next-line @typescript-eslint/no-redeclare
export const LabelsFilterParameterType = {
  and: 'and',
  or: 'or',
  eq: 'eq',
  ne: 'ne',
  gt: 'gt',
  gte: 'gte',
  lt: 'lt',
  lte: 'lte',
  contains: 'contains',
  starts_with: 'starts_with',
  ends_with: 'ends_with',
} as const;

/**
 * A recursive filter node that can be a condition or group
 */
export type LabelsFilterParameter = {
  /** The type of filter operation */
  type: LabelsFilterParameterType;
  /**
   * The field to filter on (for leaf conditions)
   * @minLength 1
   */
  field?: string;
  /** The value to compare against (for leaf conditions) */
  value?: unknown;
  /** Child filter nodes (for logical operators) */
  children?: FilterNode[];
};

export type LabelsSortParameterItemField = typeof LabelsSortParameterItemField[keyof typeof LabelsSortParameterItemField];


// eslint-disable-next-line @typescript-eslint/no-redeclare
export const LabelsSortParameterItemField = {
  createdAt: 'createdAt',
  id: 'id',
  updatedAt: 'updatedAt',
  name: 'name',
  organizationID: 'organizationID',
} as const;

export type LabelsSortParameterItemOrder = typeof LabelsSortParameterItemOrder[keyof typeof LabelsSortParameterItemOrder];


// eslint-disable-next-line @typescript-eslint/no-redeclare
export const LabelsSortParameterItemOrder = {
  asc: 'asc',
  desc: 'desc',
} as const;

export type LabelsSortParameterItem = {
  field: LabelsSortParameterItemField;
  order: LabelsSortParameterItemOrder;
};

/**
 * The sort parameter
 */
export type LabelsSortParameter = LabelsSortParameterItem[];

export type LoginBody = {
  /**
   * The email address associated with the account
   * @minLength 1
   * @pattern ^(?!\.)(?!.*\.\.)([A-Za-z0-9_'+\-\.]*)[A-Za-z0-9_+-]@([A-Za-z0-9][A-Za-z0-9\-]*\.)+[A-Za-z]{2,}$
   */
  email: string;
  /**
   * The password for the account
   * @minLength 1
   */
  password: string;
  /** Whether to create a long-lived session */
  rememberMe?: boolean;
};

export type Logout200 = {
  /** @minLength 1 */
  message: string;
};

export type LogoutAll200 = {
  /** @minLength 1 */
  message: string;
  /**
   * Number of sessions that were terminated
   * @minimum 0
   */
  count: number;
};

export type RegisterBody = {
  /**
   * The email address for the new account
   * @minLength 1
   * @pattern ^(?!\.)(?!.*\.\.)([A-Za-z0-9_'+\-\.]*)[A-Za-z0-9_+-]@([A-Za-z0-9][A-Za-z0-9\-]*\.)+[A-Za-z]{2,}$
   */
  email: string;
  /**
   * The name of the user
   * @minLength 1
   */
  name: string;
  /**
   * The password for the account
   * @minLength 8
   */
  password: string;
};

/**
 * How to deliver the magic link
 */
export type RequestMagicLinkBodyDeliveryMethod = typeof RequestMagicLinkBodyDeliveryMethod[keyof typeof RequestMagicLinkBodyDeliveryMethod];


// eslint-disable-next-line @typescript-eslint/no-redeclare
export const RequestMagicLinkBodyDeliveryMethod = {
  email: 'email',
  console: 'console',
  otp: 'otp',
  webhook: 'webhook',
} as const;

export type RequestMagicLinkBody = {
  /**
   * Email address or username
   * @minLength 1
   */
  identifier: string;
  /** How to deliver the magic link */
  deliveryMethod?: RequestMagicLinkBodyDeliveryMethod;
  /** URL to redirect to after successful authentication */
  redirectUrl?: string;
};

export type RequestMagicLink200 = {
  message?: string;
  /**
   * OTP code (only returned if deliveryMethod is 'otp')
   * @minLength 6
   * @maxLength 6
   */
  otpCode?: string;
  /** Token expiry in seconds */
  expiresIn?: number;
  /** Magic link token details (for internal use) */
  token?: MagicLinkToken;
};

export type VerifyMagicLinkBody = {
  /**
   * Magic link token from URL
   * @minLength 32
   */
  token?: string;
  /**
   * OTP code (alternative to token)
   * @minLength 6
   * @maxLength 6
   * @pattern ^[0-9]{6}$
   */
  code?: string;
  /** Required when using OTP code */
  identifier?: string;
};

/**
 * The authentication provider to link
 */
export type LinkAccountBodyProvider = typeof LinkAccountBodyProvider[keyof typeof LinkAccountBodyProvider];


// eslint-disable-next-line @typescript-eslint/no-redeclare
export const LinkAccountBodyProvider = {
  google: 'google',
  github: 'github',
  microsoft: 'microsoft',
  apple: 'apple',
} as const;

export type LinkAccountBody = {
  /** The authentication provider to link */
  provider: LinkAccountBodyProvider;
  /** URL to redirect to after successful linking */
  redirectUrl?: string;
};

export type LinkAccount200 = {
  /** URL to redirect the user to for provider authorization */
  authorizationUrl: string;
};

export type ListSessionsParams = {
/**
 * Pagination parameters (limit & offset)
 */
page?: PageQueryParameter;
/**
 * The sort parameter
 */
sort?: SessionsSortParameter;
};

export type ListSessions200Meta = {
  /**
   * Total number of sessions
   * @minimum 0
   */
  total: number;
};

export type ListSessions200 = {
  data: Session[];
  meta: ListSessions200Meta;
};

export type DeleteSession200 = {
  data: Session;
};

export type GetSession200 = {
  data: Session;
};

export type UpdateSessionBody = {
  /**
   * The organization ID to set as active for this session
   * @minLength 36
   */
  organizationID: string;
};

export type UpdateSession200 = {
  data: Session;
};

export type ListAccounts200Meta = {
  /** @minimum 0 */
  total: number;
};

export type ListAccounts200 = {
  data: Account[];
  meta: ListAccounts200Meta;
};

export type GetAccount200 = {
  data: Account;
};

export type UpdateAccountBody = {
  /** The account provider */
  provider?: string;
  /** The provider account ID */
  providerAccountIdentifier?: string;
  /** The account type */
  type?: string;
};

export type UpdateAccount200 = {
  data: Account;
};

export type DeleteAccount200 = {
  data: Account;
};

export type ConfirmEmailVerificationBody = {
  /**
   * The password reset token
   * @minLength 1
   */
  token: string;
};

export type ConfirmEmailVerification200 = {
  session: Session;
  user: User;
};

export type RequestPasswordResetBody = {
  /**
   * The e-mail to send the password reset token to
   * @minLength 1
   */
  email: string;
};

export type ConfirmPasswordResetBody = {
  /**
   * The new password
   * @minLength 1
   */
  newPassword: string;
  /**
   * The password reset token
   * @minLength 1
   */
  token: string;
};

export type RequestEmailChangeBody = {
  /**
   * The e-mail to send the confirmation token to
   * @minLength 1
   * @pattern ^(?!\.)(?!.*\.\.)([A-Za-z0-9_'+\-\.]*)[A-Za-z0-9_+-]@([A-Za-z0-9][A-Za-z0-9\-]*\.)+[A-Za-z]{2,}$
   */
  newEmail: string;
  /**
   * The user ID of the user requesting the email change
   * @minLength 36
   */
  userID: string;
};

export type ConfirmEmailChangeBody = {
  /**
   * The e-mail to send the confirmation token to
   * @minLength 1
   * @pattern ^(?!\.)(?!.*\.\.)([A-Za-z0-9_'+\-\.]*)[A-Za-z0-9_+-]@([A-Za-z0-9][A-Za-z0-9\-]*\.)+[A-Za-z]{2,}$
   */
  newEmail: string;
  /**
   * The password reset token
   * @minLength 1
   */
  token: string;
  /**
   * The user ID of the user requesting the email change
   * @minLength 36
   */
  userID: string;
};

export type ListUsersParams = {
/**
 * A recursive filter node that can be a condition or group
 */
filter?: UsersFilterParameter;
/**
 * Pagination parameters (limit & offset)
 */
page?: PageQueryParameter;
/**
 * The sort parameter
 */
sort?: UsersSortParameter;
};

export type ListUsers200Meta = {
  /** Total number of items in the collection */
  total: number;
};

export type ListUsers200 = {
  data: User[];
  meta: ListUsers200Meta;
};

export type GetCurrentUser200 = {
  data: User;
};

export type UpdateCurrentUserBody = {
  /**
   * The user's display name
   * @minLength 1
   * @maxLength 255
   */
  name?: string;
  /**
   * The user's avatar image URL
   * @minLength 5
   * @maxLength 2048
   */
  image?: string;
};

export type UpdateCurrentUser200 = {
  data: User;
};

/**
 * Confirmation string to prevent accidental deletion
 */
export type DeleteCurrentUserBodyConfirmation = typeof DeleteCurrentUserBodyConfirmation[keyof typeof DeleteCurrentUserBodyConfirmation];


// eslint-disable-next-line @typescript-eslint/no-redeclare
export const DeleteCurrentUserBodyConfirmation = {
  DELETE_MY_ACCOUNT: 'DELETE_MY_ACCOUNT',
} as const;

export type DeleteCurrentUserBody = {
  /** Confirmation string to prevent accidental deletion */
  confirmation: DeleteCurrentUserBodyConfirmation;
};

export type DeleteCurrentUser200 = {
  message: string;
};

export type DeleteUser200 = {
  data: User;
};

export type GetUser200 = {
  data: User;
};

export type UpdateUserBody = {
  /**
   * The user's e-mail
   * @minLength 1
   */
  email?: string;
  /** The user's avatar image URL */
  image?: string;
};

export type UpdateUser200 = {
  data: User;
};

export type OauthAuthorizeParams = {
/**
 * Where to redirect after authorization (optional, uses default if not provided)
 */
redirect_uri?: string;
/**
 * OAuth scopes to request (optional, uses default if not provided)
 */
scope?: string;
/**
 * State parameter for CSRF protection
 */
state?: string;
};

export type OauthAuthorize200 = {
  /**
   * URL to redirect user for OAuth authorization
   * @minLength 1
   */
  authorization_url: string;
};

export type OauthCallbackParams = {
/**
 * Authorization code from OAuth provider
 */
code?: string;
/**
 * State parameter for CSRF protection
 */
state?: string;
/**
 * Error code if authorization failed
 */
error?: string;
/**
 * Human-readable error description
 */
error_description?: string;
};

export type ListAPIKeysParams = {
/**
 * A recursive filter node that can be a condition or group
 */
filter?: APIKeysFilterParameter;
/**
 * Pagination parameters (limit & offset)
 */
page?: PageQueryParameter;
/**
 * The sort parameter
 */
sort?: APIKeysSortParameter;
};

export type ListAPIKeys200Meta = {
  total: number;
};

export type ListAPIKeys200 = {
  data: APIKey[];
  meta: ListAPIKeys200Meta;
};

export type CreateAPIKeyBody = {
  /**
   * Human-readable name for the API key
   * @minLength 1
   * @maxLength 255
   */
  name: string;
  /** List of scopes/permissions for this API key */
  scopes: string[];
  /**
   * Requests per minute limit (default 60)
   * @minimum 1
   * @maximum 10000
   */
  rateLimit?: number;
  /** When the API key expires (optional, no expiry if omitted) */
  expiresAt?: string;
};

export type UpdateAPIKeyBody = {
  /**
   * Human-readable name for the API key
   * @minLength 1
   */
  name?: string;
  /** Array of permission scopes */
  scopes?: string[];
  /**
   * Requests per minute allowed for this API key
   * @minimum 1
   * @maximum 10000
   */
  rateLimit?: number;
};

export type CreateOrganizationBody = {
  /**
   * The billing email to use for the organization
   * @minLength 1
   */
  billingEmail: string;
  /**
   * UUID identifier
   * @minLength 36
   */
  organizationID: string;
};

export type CreateOrganization201 = {
  data: Organization;
};

export type ListOrganizationsParams = {
/**
 * A recursive filter node that can be a condition or group
 */
filter?: OrganizationsFilterParameter;
/**
 * Pagination parameters (limit & offset)
 */
page?: PageQueryParameter;
/**
 * The sort parameter
 */
sort?: OrganizationsSortParameter;
};

export type ListOrganizations200Meta = {
  /** Total number of items in the collection */
  total: number;
};

export type ListOrganizations200 = {
  data: Organization[];
  meta: ListOrganizations200Meta;
};

export type DeleteOrganization200 = {
  data: Organization;
};

export type GetOrganization200 = {
  data: Organization;
};

export type UpdateOrganizationBody = {
  /** The billing email to use for the organization */
  billingEmail?: string;
  /**
   * UUID identifier
   * @minLength 36
   */
  organizationID?: string;
};

export type UpdateOrganization200 = {
  data: Organization;
};

/**
 * The role of the member
 */
export type CreateMemberBodyRole = typeof CreateMemberBodyRole[keyof typeof CreateMemberBodyRole];


// eslint-disable-next-line @typescript-eslint/no-redeclare
export const CreateMemberBodyRole = {
  admin: 'admin',
  owner: 'owner',
  member: 'member',
} as const;

export type CreateMemberBody = {
  /** The role of the member */
  role: CreateMemberBodyRole;
};

export type CreateMember201 = {
  data: Member;
};

export type ListMembersParams = {
/**
 * A recursive filter node that can be a condition or group
 */
filter?: MembersFilterParameter;
/**
 * Pagination parameters (limit & offset)
 */
page?: PageQueryParameter;
/**
 * The sort parameter
 */
sort?: MembersSortParameter;
};

export type ListMembers200Meta = {
  /** Total number of items in the collection */
  total: number;
};

export type ListMembers200 = {
  data: Member[];
  meta: ListMembers200Meta;
};

export type DeleteMember200 = {
  data: Member;
};

export type GetMember200 = {
  data: Member;
};

/**
 * The role of the member
 */
export type UpdateMemberBodyRole = typeof UpdateMemberBodyRole[keyof typeof UpdateMemberBodyRole];


// eslint-disable-next-line @typescript-eslint/no-redeclare
export const UpdateMemberBodyRole = {
  admin: 'admin',
  owner: 'owner',
  member: 'member',
} as const;

export type UpdateMemberBody = {
  /** The role of the member */
  role?: UpdateMemberBodyRole;
};

export type UpdateMember200 = {
  data: Member;
};

/**
 * The role of the invitation
 */
export type CreateInvitationBodyRole = typeof CreateInvitationBodyRole[keyof typeof CreateInvitationBodyRole];


// eslint-disable-next-line @typescript-eslint/no-redeclare
export const CreateInvitationBodyRole = {
  admin: 'admin',
  owner: 'owner',
  member: 'member',
} as const;

export type CreateInvitationBody = {
  /**
   * The email of the invitated user
   * @minLength 1
   */
  email: string;
  /** The role of the invitation */
  role: CreateInvitationBodyRole;
};

export type CreateInvitation201 = {
  data: Invitation;
};

export type ListInvitationsParams = {
/**
 * A recursive filter node that can be a condition or group
 */
filter?: InvitationsFilterParameter;
/**
 * Pagination parameters (limit & offset)
 */
page?: PageQueryParameter;
/**
 * The sort parameter
 */
sort?: InvitationsSortParameter;
};

export type ListInvitations200Meta = {
  /** Total number of items in the collection */
  total: number;
};

export type ListInvitations200 = {
  data: Invitation[];
  meta: ListInvitations200Meta;
};

export type DeleteInvitation200 = {
  data: Invitation;
};

export type GetInvitation200 = {
  data: Invitation;
};

/**
 * The role of the invitation
 */
export type UpdateInvitationBodyRole = typeof UpdateInvitationBodyRole[keyof typeof UpdateInvitationBodyRole];


// eslint-disable-next-line @typescript-eslint/no-redeclare
export const UpdateInvitationBodyRole = {
  admin: 'admin',
  owner: 'owner',
  member: 'member',
} as const;

export type UpdateInvitationBody = {
  /** The email of the invitated user */
  email?: string;
  /** The role of the invitation */
  role?: UpdateInvitationBodyRole;
};

export type UpdateInvitation200 = {
  data: Invitation;
};

export type CreatePipelineBody = {
  /**
   * The pipeline description
   * @minLength 1
   */
  description?: string;
  /**
   * The pipeline name
   * @minLength 1
   */
  name?: string;
};

export type CreatePipeline201 = {
  data: Pipeline;
};

export type ListPipelinesParams = {
/**
 * A recursive filter node that can be a condition or group
 */
filter?: PipelinesFilterParameter;
/**
 * Pagination parameters (limit & offset)
 */
page?: PageQueryParameter;
/**
 * The sort parameter
 */
sort?: PipelinesSortParameter;
};

export type ListPipelines200Meta = {
  /** Total number of items in the collection */
  total: number;
};

export type ListPipelines200 = {
  data: Pipeline[];
  meta: ListPipelines200Meta;
};

export type DeletePipeline200 = {
  data: Pipeline;
};

export type GetPipeline200 = {
  data: Pipeline;
};

export type UpdatePipelineBody = {
  /** The pipeline description */
  description?: string;
  /** The pipeline name */
  name?: string;
};

export type UpdatePipeline200 = {
  data: Pipeline;
};

export type GetPipelineSteps200 = {
  data: PipelineStep[];
};

/**
 * Configuration for the tool
 */
export type CreatePipelineStepBodyConfig = { [key: string]: unknown };

export type CreatePipelineStepBody = {
  /**
   * UUID identifier
   * @minLength 36
   */
  toolID: string;
  /**
   * Name of the step
   * @minLength 1
   * @maxLength 255
   */
  name: string;
  /**
   * Description of what this step does
   * @maxLength 1000
   */
  description?: string;
  /** Configuration for the tool */
  config?: CreatePipelineStepBodyConfig;
  /**
   * Position in the pipeline (for ordering)
   * @minimum 0
   */
  position?: number;
  /** IDs of steps this step depends on */
  dependencies?: string[];
};

export type CreatePipelineStep201 = {
  data: PipelineStep;
};

export type GetPipelineExecutionPlan200DataLevelsItem = {
  /** Execution level (0-based) */
  level: number;
  steps: string[];
};

export type GetPipelineExecutionPlan200Data = {
  /**
   * UUID identifier
   * @minLength 36
   */
  pipelineID: string;
  levels: GetPipelineExecutionPlan200DataLevelsItem[];
  /** Total number of steps in the pipeline */
  totalSteps: number;
  /** Whether the pipeline DAG is valid (no cycles) */
  isValid: boolean;
  /** Estimated execution time in seconds */
  estimatedDuration?: number;
};

export type GetPipelineExecutionPlan200 = {
  data: GetPipelineExecutionPlan200Data;
};

export type ValidatePipelineExecutionPlan200Data = {
  valid: boolean;
  /** List of any warnings or non-critical issues */
  issues?: string[];
};

export type ValidatePipelineExecutionPlan200 = {
  data: ValidatePipelineExecutionPlan200Data;
};

export type CreateRunBody = {
  /**
   * UUID identifier
   * @minLength 36
   */
  pipelineID: string;
};

export type CreateRun201 = {
  data: Run;
};

export type ListRunsParams = {
/**
 * A recursive filter node that can be a condition or group
 */
filter?: RunsFilterParameter;
/**
 * Pagination parameters (limit & offset)
 */
page?: PageQueryParameter;
/**
 * The sort parameter
 */
sort?: RunsSortParameter;
};

export type ListRuns200Meta = {
  /** Total number of items in the collection */
  total: number;
};

export type ListRuns200 = {
  data: Run[];
  meta: ListRuns200Meta;
};

export type DeleteRun200 = {
  data: Run;
};

export type GetRun200 = {
  data: Run;
};

export type UpdateRunBody = {
  /**
   * UUID identifier
   * @minLength 36
   */
  pipelineID?: string;
};

export type UpdateRun200 = {
  data: Run;
};

export type CreateToolBody = {
  /**
   * The tool description
   * @minLength 1
   */
  description: string;
  /**
   * The name of the tool
   * @minLength 1
   */
  name: string;
};

export type CreateTool201 = {
  data: Tool;
};

export type ListToolsParams = {
/**
 * A recursive filter node that can be a condition or group
 */
filter?: ToolsFilterParameter;
/**
 * Pagination parameters (limit & offset)
 */
page?: PageQueryParameter;
/**
 * The sort parameter
 */
sort?: ToolsSortParameter;
};

export type ListTools200Meta = {
  /** Total number of items in the collection */
  total: number;
};

export type ListTools200 = {
  data: Tool[];
  meta: ListTools200Meta;
};

export type DeleteTool200 = {
  data: Tool;
};

export type GetTool200 = {
  data: Tool;
};

export type UpdateToolBody = {
  /**
   * The tool description
   * @minLength 1
   */
  description?: string;
  /**
   * The name of the tool
   * @minLength 1
   */
  name?: string;
};

export type UpdateTool200 = {
  data: Tool;
};

export type CreateArtifactBody = {
  /**
   * The name of the artifact
   * @minLength 1
   */
  name?: string;
  /**
   * The artifact text
   * @minLength 1
   */
  text: string;
};

export type CreateArtifact201 = {
  data: Artifact;
};

export type ListArtifactsParams = {
/**
 * A recursive filter node that can be a condition or group
 */
filter?: ArtifactsFilterParameter;
/**
 * Pagination parameters (limit & offset)
 */
page?: PageQueryParameter;
/**
 * The sort parameter
 */
sort?: ArtifactsSortParameter;
};

export type ListArtifacts200Meta = {
  /** Total number of items in the collection */
  total: number;
};

export type ListArtifacts200 = {
  data: Artifact[];
  meta: ListArtifacts200Meta;
};

export type DeleteArtifact200 = {
  data: Artifact;
};

export type GetArtifact200 = {
  data: Artifact;
};

export type UpdateArtifactBody = {
  /**
   * The name of the artifact
   * @minLength 1
   */
  name?: string;
  /** The artifact text */
  text?: string;
  /** The artifact URL */
  url?: string;
};

export type UpdateArtifact200 = {
  data: Artifact;
};

export type CreateLabelBody = {
  /**
   * The name of the label
   * @minLength 1
   */
  name: string;
};

export type CreateLabel201 = {
  data: Label;
};

export type ListLabelsParams = {
/**
 * A recursive filter node that can be a condition or group
 */
filter?: LabelsFilterParameter;
/**
 * Pagination parameters (limit & offset)
 */
page?: PageQueryParameter;
/**
 * The sort parameter
 */
sort?: LabelsSortParameter;
};

export type ListLabels200Meta = {
  /** Total number of items in the collection */
  total: number;
};

export type ListLabels200 = {
  data: Label[];
  meta: ListLabels200Meta;
};

export type DeleteLabel200 = {
  data: Label;
};

export type GetLabel200 = {
  data: Label;
};

export type UpdateLabelBody = {
  /**
   * The name of the label
   * @minLength 1
   */
  name?: string;
};

export type UpdateLabel200 = {
  data: Label;
};

