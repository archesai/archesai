
<!DOCTYPE html>
<html>
	<head>
		<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
		<title>archesai: Go Coverage Report</title>
		<style>
			body {
				background: black;
				color: rgb(80, 80, 80);
			}
			body, pre, #legend span {
				font-family: Menlo, monospace;
				font-weight: bold;
			}
			#topbar {
				background: black;
				position: fixed;
				top: 0; left: 0; right: 0;
				height: 42px;
				border-bottom: 1px solid rgb(80, 80, 80);
			}
			#content {
				margin-top: 50px;
			}
			#nav, #legend {
				float: left;
				margin-left: 10px;
			}
			#legend {
				margin-top: 12px;
			}
			#nav {
				margin-top: 10px;
			}
			#legend span {
				margin: 0 5px;
			}
			.cov0 { color: rgb(192, 0, 0) }
.cov1 { color: rgb(128, 128, 128) }
.cov2 { color: rgb(116, 140, 131) }
.cov3 { color: rgb(104, 152, 134) }
.cov4 { color: rgb(92, 164, 137) }
.cov5 { color: rgb(80, 176, 140) }
.cov6 { color: rgb(68, 188, 143) }
.cov7 { color: rgb(56, 200, 146) }
.cov8 { color: rgb(44, 212, 149) }
.cov9 { color: rgb(32, 224, 152) }
.cov10 { color: rgb(20, 236, 155) }

		</style>
	</head>
	<body>
		<div id="topbar">
			<div id="nav">
				<select id="files">
				
				<option value="file0">github.com/archesai/archesai/cmd/archesai/main.go (0.0%)</option>
				
				<option value="file1">github.com/archesai/archesai/internal/accounts/cache.gen.go (0.0%)</option>
				
				<option value="file2">github.com/archesai/archesai/internal/accounts/events.gen.go (0.0%)</option>
				
				<option value="file3">github.com/archesai/archesai/internal/accounts/http.gen.go (0.0%)</option>
				
				<option value="file4">github.com/archesai/archesai/internal/accounts/postgres.gen.go (0.0%)</option>
				
				<option value="file5">github.com/archesai/archesai/internal/accounts/repository.gen.go (0.0%)</option>
				
				<option value="file6">github.com/archesai/archesai/internal/accounts/sqlite.gen.go (0.0%)</option>
				
				<option value="file7">github.com/archesai/archesai/internal/accounts/types.gen.go (0.0%)</option>
				
				<option value="file8">github.com/archesai/archesai/internal/app/app.go (0.0%)</option>
				
				<option value="file9">github.com/archesai/archesai/internal/app/infrastructure.go (0.0%)</option>
				
				<option value="file10">github.com/archesai/archesai/internal/app/routes.go (0.0%)</option>
				
				<option value="file11">github.com/archesai/archesai/internal/artifacts/http.gen.go (0.0%)</option>
				
				<option value="file12">github.com/archesai/archesai/internal/artifacts/postgres.gen.go (0.0%)</option>
				
				<option value="file13">github.com/archesai/archesai/internal/artifacts/repository.gen.go (0.0%)</option>
				
				<option value="file14">github.com/archesai/archesai/internal/artifacts/service.go (41.1%)</option>
				
				<option value="file15">github.com/archesai/archesai/internal/artifacts/sqlite.gen.go (0.0%)</option>
				
				<option value="file16">github.com/archesai/archesai/internal/artifacts/types.gen.go (0.0%)</option>
				
				<option value="file17">github.com/archesai/archesai/internal/auth/apikey.go (50.0%)</option>
				
				<option value="file18">github.com/archesai/archesai/internal/auth/auth.go (66.7%)</option>
				
				<option value="file19">github.com/archesai/archesai/internal/auth/authentication.go (55.0%)</option>
				
				<option value="file20">github.com/archesai/archesai/internal/auth/claims.go (97.9%)</option>
				
				<option value="file21">github.com/archesai/archesai/internal/auth/context.go (0.0%)</option>
				
				<option value="file22">github.com/archesai/archesai/internal/auth/github.go (16.4%)</option>
				
				<option value="file23">github.com/archesai/archesai/internal/auth/google.go (34.4%)</option>
				
				<option value="file24">github.com/archesai/archesai/internal/auth/handler.go (28.7%)</option>
				
				<option value="file25">github.com/archesai/archesai/internal/auth/http.gen.go (0.0%)</option>
				
				<option value="file26">github.com/archesai/archesai/internal/auth/microsoft.go (17.0%)</option>
				
				<option value="file27">github.com/archesai/archesai/internal/auth/middleware.go (14.1%)</option>
				
				<option value="file28">github.com/archesai/archesai/internal/auth/oauth.go (0.0%)</option>
				
				<option value="file29">github.com/archesai/archesai/internal/auth/password.go (54.9%)</option>
				
				<option value="file30">github.com/archesai/archesai/internal/auth/permissions.go (81.8%)</option>
				
				<option value="file31">github.com/archesai/archesai/internal/auth/provider.go (0.0%)</option>
				
				<option value="file32">github.com/archesai/archesai/internal/auth/token.go (41.2%)</option>
				
				<option value="file33">github.com/archesai/archesai/internal/auth/types.gen.go (0.0%)</option>
				
				<option value="file34">github.com/archesai/archesai/internal/auth/verification.go (0.0%)</option>
				
				<option value="file35">github.com/archesai/archesai/internal/cache/memory.go (0.0%)</option>
				
				<option value="file36">github.com/archesai/archesai/internal/cache/noop.go (0.0%)</option>
				
				<option value="file37">github.com/archesai/archesai/internal/cache/redis.go (0.0%)</option>
				
				<option value="file38">github.com/archesai/archesai/internal/cli/all.go (0.0%)</option>
				
				<option value="file39">github.com/archesai/archesai/internal/cli/api.go (0.0%)</option>
				
				<option value="file40">github.com/archesai/archesai/internal/cli/completion.go (0.0%)</option>
				
				<option value="file41">github.com/archesai/archesai/internal/cli/root.go (0.0%)</option>
				
				<option value="file42">github.com/archesai/archesai/internal/cli/tui.go (0.0%)</option>
				
				<option value="file43">github.com/archesai/archesai/internal/cli/version.go (0.0%)</option>
				
				<option value="file44">github.com/archesai/archesai/internal/cli/web.go (0.0%)</option>
				
				<option value="file45">github.com/archesai/archesai/internal/cli/worker.go (0.0%)</option>
				
				<option value="file46">github.com/archesai/archesai/internal/codegen/codegen.go (0.0%)</option>
				
				<option value="file47">github.com/archesai/archesai/internal/codegen/defaults.go (0.0%)</option>
				
				<option value="file48">github.com/archesai/archesai/internal/codegen/file_writer.go (0.0%)</option>
				
				<option value="file49">github.com/archesai/archesai/internal/codegen/helpers.go (0.0%)</option>
				
				<option value="file50">github.com/archesai/archesai/internal/codegen/parser.go (0.0%)</option>
				
				<option value="file51">github.com/archesai/archesai/internal/codegen/template_funcs.go (0.0%)</option>
				
				<option value="file52">github.com/archesai/archesai/internal/config/defaults.gen.go (100.0%)</option>
				
				<option value="file53">github.com/archesai/archesai/internal/config/http.gen.go (0.0%)</option>
				
				<option value="file54">github.com/archesai/archesai/internal/config/loader.go (71.5%)</option>
				
				<option value="file55">github.com/archesai/archesai/internal/config/types.gen.go (0.0%)</option>
				
				<option value="file56">github.com/archesai/archesai/internal/database/database.go (0.0%)</option>
				
				<option value="file57">github.com/archesai/archesai/internal/database/factory.go (0.0%)</option>
				
				<option value="file58">github.com/archesai/archesai/internal/database/postgres.go (0.0%)</option>
				
				<option value="file59">github.com/archesai/archesai/internal/database/postgresql/accounts.sql.go (0.0%)</option>
				
				<option value="file60">github.com/archesai/archesai/internal/database/postgresql/api-tokens.sql.go (0.0%)</option>
				
				<option value="file61">github.com/archesai/archesai/internal/database/postgresql/artifacts.sql.go (0.0%)</option>
				
				<option value="file62">github.com/archesai/archesai/internal/database/postgresql/auth.sql.go (0.0%)</option>
				
				<option value="file63">github.com/archesai/archesai/internal/database/postgresql/db.go (0.0%)</option>
				
				<option value="file64">github.com/archesai/archesai/internal/database/postgresql/invitations.sql.go (0.0%)</option>
				
				<option value="file65">github.com/archesai/archesai/internal/database/postgresql/labels.sql.go (0.0%)</option>
				
				<option value="file66">github.com/archesai/archesai/internal/database/postgresql/members.sql.go (0.0%)</option>
				
				<option value="file67">github.com/archesai/archesai/internal/database/postgresql/organizations.sql.go (0.0%)</option>
				
				<option value="file68">github.com/archesai/archesai/internal/database/postgresql/pipeline-step-dependencies.sql.go (0.0%)</option>
				
				<option value="file69">github.com/archesai/archesai/internal/database/postgresql/pipeline-steps.sql.go (0.0%)</option>
				
				<option value="file70">github.com/archesai/archesai/internal/database/postgresql/pipelines.sql.go (0.0%)</option>
				
				<option value="file71">github.com/archesai/archesai/internal/database/postgresql/runs.sql.go (0.0%)</option>
				
				<option value="file72">github.com/archesai/archesai/internal/database/postgresql/tools.sql.go (0.0%)</option>
				
				<option value="file73">github.com/archesai/archesai/internal/database/postgresql/users.sql.go (0.0%)</option>
				
				<option value="file74">github.com/archesai/archesai/internal/database/postgresql/verification-tokens.sql.go (0.0%)</option>
				
				<option value="file75">github.com/archesai/archesai/internal/database/sqlite.go (0.0%)</option>
				
				<option value="file76">github.com/archesai/archesai/internal/database/sqlite/stub.go (0.0%)</option>
				
				<option value="file77">github.com/archesai/archesai/internal/email/service.go (0.0%)</option>
				
				<option value="file78">github.com/archesai/archesai/internal/events/noop.go (0.0%)</option>
				
				<option value="file79">github.com/archesai/archesai/internal/events/publisher.go (0.0%)</option>
				
				<option value="file80">github.com/archesai/archesai/internal/events/redis.go (0.0%)</option>
				
				<option value="file81">github.com/archesai/archesai/internal/health/handler.go (0.0%)</option>
				
				<option value="file82">github.com/archesai/archesai/internal/health/http.gen.go (0.0%)</option>
				
				<option value="file83">github.com/archesai/archesai/internal/health/service.go (100.0%)</option>
				
				<option value="file84">github.com/archesai/archesai/internal/health/types.gen.go (0.0%)</option>
				
				<option value="file85">github.com/archesai/archesai/internal/invitations/http.gen.go (0.0%)</option>
				
				<option value="file86">github.com/archesai/archesai/internal/invitations/postgres.gen.go (0.0%)</option>
				
				<option value="file87">github.com/archesai/archesai/internal/invitations/repository.gen.go (0.0%)</option>
				
				<option value="file88">github.com/archesai/archesai/internal/invitations/sqlite.gen.go (0.0%)</option>
				
				<option value="file89">github.com/archesai/archesai/internal/invitations/types.gen.go (0.0%)</option>
				
				<option value="file90">github.com/archesai/archesai/internal/labels/http.gen.go (0.0%)</option>
				
				<option value="file91">github.com/archesai/archesai/internal/labels/postgres.gen.go (0.0%)</option>
				
				<option value="file92">github.com/archesai/archesai/internal/labels/repository.gen.go (0.0%)</option>
				
				<option value="file93">github.com/archesai/archesai/internal/labels/service.go (43.7%)</option>
				
				<option value="file94">github.com/archesai/archesai/internal/labels/sqlite.gen.go (0.0%)</option>
				
				<option value="file95">github.com/archesai/archesai/internal/labels/types.gen.go (0.0%)</option>
				
				<option value="file96">github.com/archesai/archesai/internal/llm/chat.go (0.0%)</option>
				
				<option value="file97">github.com/archesai/archesai/internal/llm/ollama.go (0.0%)</option>
				
				<option value="file98">github.com/archesai/archesai/internal/llm/openai.go (0.0%)</option>
				
				<option value="file99">github.com/archesai/archesai/internal/logger/logger.go (0.0%)</option>
				
				<option value="file100">github.com/archesai/archesai/internal/members/http.gen.go (0.0%)</option>
				
				<option value="file101">github.com/archesai/archesai/internal/members/postgres.gen.go (0.0%)</option>
				
				<option value="file102">github.com/archesai/archesai/internal/members/repository.gen.go (0.0%)</option>
				
				<option value="file103">github.com/archesai/archesai/internal/members/sqlite.gen.go (0.0%)</option>
				
				<option value="file104">github.com/archesai/archesai/internal/members/types.gen.go (0.0%)</option>
				
				<option value="file105">github.com/archesai/archesai/internal/migrations/migrate.go (0.0%)</option>
				
				<option value="file106">github.com/archesai/archesai/internal/organizations/cache.gen.go (0.0%)</option>
				
				<option value="file107">github.com/archesai/archesai/internal/organizations/events.gen.go (0.0%)</option>
				
				<option value="file108">github.com/archesai/archesai/internal/organizations/handler.go (0.0%)</option>
				
				<option value="file109">github.com/archesai/archesai/internal/organizations/http.gen.go (0.0%)</option>
				
				<option value="file110">github.com/archesai/archesai/internal/organizations/postgres.gen.go (0.0%)</option>
				
				<option value="file111">github.com/archesai/archesai/internal/organizations/repository.gen.go (0.0%)</option>
				
				<option value="file112">github.com/archesai/archesai/internal/organizations/service.go (100.0%)</option>
				
				<option value="file113">github.com/archesai/archesai/internal/organizations/sqlite.gen.go (0.0%)</option>
				
				<option value="file114">github.com/archesai/archesai/internal/organizations/types.gen.go (0.0%)</option>
				
				<option value="file115">github.com/archesai/archesai/internal/pipelines/dag.go (45.8%)</option>
				
				<option value="file116">github.com/archesai/archesai/internal/pipelines/executor.go (0.0%)</option>
				
				<option value="file117">github.com/archesai/archesai/internal/pipelines/handler.go (0.0%)</option>
				
				<option value="file118">github.com/archesai/archesai/internal/pipelines/http.gen.go (0.0%)</option>
				
				<option value="file119">github.com/archesai/archesai/internal/pipelines/manager.go (0.0%)</option>
				
				<option value="file120">github.com/archesai/archesai/internal/pipelines/postgres.gen.go (0.0%)</option>
				
				<option value="file121">github.com/archesai/archesai/internal/pipelines/queue_redis.go (0.0%)</option>
				
				<option value="file122">github.com/archesai/archesai/internal/pipelines/repository.gen.go (0.0%)</option>
				
				<option value="file123">github.com/archesai/archesai/internal/pipelines/service.go (85.7%)</option>
				
				<option value="file124">github.com/archesai/archesai/internal/pipelines/sqlite.gen.go (0.0%)</option>
				
				<option value="file125">github.com/archesai/archesai/internal/pipelines/types.gen.go (0.0%)</option>
				
				<option value="file126">github.com/archesai/archesai/internal/redis/client.go (0.0%)</option>
				
				<option value="file127">github.com/archesai/archesai/internal/redis/config.go (0.0%)</option>
				
				<option value="file128">github.com/archesai/archesai/internal/redis/pubsub.go (0.0%)</option>
				
				<option value="file129">github.com/archesai/archesai/internal/redis/queue.go (0.0%)</option>
				
				<option value="file130">github.com/archesai/archesai/internal/runs/handler.go (0.0%)</option>
				
				<option value="file131">github.com/archesai/archesai/internal/runs/http.gen.go (0.0%)</option>
				
				<option value="file132">github.com/archesai/archesai/internal/runs/postgres.gen.go (0.0%)</option>
				
				<option value="file133">github.com/archesai/archesai/internal/runs/repository.gen.go (0.0%)</option>
				
				<option value="file134">github.com/archesai/archesai/internal/runs/service.go (56.8%)</option>
				
				<option value="file135">github.com/archesai/archesai/internal/runs/sqlite.gen.go (0.0%)</option>
				
				<option value="file136">github.com/archesai/archesai/internal/runs/types.gen.go (0.0%)</option>
				
				<option value="file137">github.com/archesai/archesai/internal/server/docs.go (0.0%)</option>
				
				<option value="file138">github.com/archesai/archesai/internal/server/infra.go (0.0%)</option>
				
				<option value="file139">github.com/archesai/archesai/internal/server/middleware.go (0.0%)</option>
				
				<option value="file140">github.com/archesai/archesai/internal/server/server.go (0.0%)</option>
				
				<option value="file141">github.com/archesai/archesai/internal/server/websocket.go (0.0%)</option>
				
				<option value="file142">github.com/archesai/archesai/internal/sessions/cache.gen.go (37.0%)</option>
				
				<option value="file143">github.com/archesai/archesai/internal/sessions/events.gen.go (0.0%)</option>
				
				<option value="file144">github.com/archesai/archesai/internal/sessions/http.gen.go (0.0%)</option>
				
				<option value="file145">github.com/archesai/archesai/internal/sessions/postgres.gen.go (0.0%)</option>
				
				<option value="file146">github.com/archesai/archesai/internal/sessions/repository.gen.go (0.0%)</option>
				
				<option value="file147">github.com/archesai/archesai/internal/sessions/service.go (100.0%)</option>
				
				<option value="file148">github.com/archesai/archesai/internal/sessions/session.go (27.3%)</option>
				
				<option value="file149">github.com/archesai/archesai/internal/sessions/sessionmanager.go (79.8%)</option>
				
				<option value="file150">github.com/archesai/archesai/internal/sessions/sqlite.gen.go (0.0%)</option>
				
				<option value="file151">github.com/archesai/archesai/internal/sessions/types.gen.go (0.0%)</option>
				
				<option value="file152">github.com/archesai/archesai/internal/testutil/containers.go (0.0%)</option>
				
				<option value="file153">github.com/archesai/archesai/internal/tools/handler.go (0.0%)</option>
				
				<option value="file154">github.com/archesai/archesai/internal/tools/http.gen.go (0.0%)</option>
				
				<option value="file155">github.com/archesai/archesai/internal/tools/postgres.gen.go (0.0%)</option>
				
				<option value="file156">github.com/archesai/archesai/internal/tools/repository.gen.go (0.0%)</option>
				
				<option value="file157">github.com/archesai/archesai/internal/tools/service.go (100.0%)</option>
				
				<option value="file158">github.com/archesai/archesai/internal/tools/sqlite.gen.go (0.0%)</option>
				
				<option value="file159">github.com/archesai/archesai/internal/tools/types.gen.go (0.0%)</option>
				
				<option value="file160">github.com/archesai/archesai/internal/tui/config_tui.go (0.0%)</option>
				
				<option value="file161">github.com/archesai/archesai/internal/tui/tui.go (0.0%)</option>
				
				<option value="file162">github.com/archesai/archesai/internal/users/cache.gen.go (0.0%)</option>
				
				<option value="file163">github.com/archesai/archesai/internal/users/events.gen.go (0.0%)</option>
				
				<option value="file164">github.com/archesai/archesai/internal/users/handler.go (0.0%)</option>
				
				<option value="file165">github.com/archesai/archesai/internal/users/http.gen.go (0.0%)</option>
				
				<option value="file166">github.com/archesai/archesai/internal/users/postgres.gen.go (0.0%)</option>
				
				<option value="file167">github.com/archesai/archesai/internal/users/repository.gen.go (0.0%)</option>
				
				<option value="file168">github.com/archesai/archesai/internal/users/service.go (89.4%)</option>
				
				<option value="file169">github.com/archesai/archesai/internal/users/sqlite.gen.go (0.0%)</option>
				
				<option value="file170">github.com/archesai/archesai/internal/users/types.gen.go (0.0%)</option>
				
				<option value="file171">github.com/archesai/archesai/tools/codegen/main.go (0.0%)</option>
				
				<option value="file172">github.com/archesai/archesai/tools/pg-to-sqlite/main.go (0.0%)</option>
				
				</select>
			</div>
			<div id="legend">
				<span>not tracked</span>
			
				<span class="cov0">no coverage</span>
				<span class="cov1">low coverage</span>
				<span class="cov2">*</span>
				<span class="cov3">*</span>
				<span class="cov4">*</span>
				<span class="cov5">*</span>
				<span class="cov6">*</span>
				<span class="cov7">*</span>
				<span class="cov8">*</span>
				<span class="cov9">*</span>
				<span class="cov10">high coverage</span>
			
			</div>
		</div>
		<div id="content">
		
		<pre class="file" id="file0" style="display: none">// Package main provides the entry point for the ArchesAI server.
package main

import (
        "github.com/archesai/archesai/internal/cli"
)

func main() <span class="cov0" title="0">{
        cli.Execute()
}</span>
</pre>
		
		<pre class="file" id="file1" style="display: none">// Code generated by codegen cache. DO NOT EDIT.
package accounts

import (
        "context"
        "time"

        genericcache "github.com/archesai/archesai/internal/cache"
        "github.com/google/uuid"
)

// ErrCacheMiss re-exported from generic cache package
var ErrCacheMiss = genericcache.ErrCacheMiss

// Cache provides caching operations for accounts domain.
type Cache interface {

        // Account caching
        Get(ctx context.Context, id uuid.UUID) (*Account, error)
        Set(ctx context.Context, entity *Account, ttl time.Duration) error
        Delete(ctx context.Context, id uuid.UUID) error
        GetByProviderId(ctx context.Context, provider string, providerAccountId string) (*Account, error)
        ListByUserId(ctx context.Context, userId uuid.UUID) ([]*Account, error)

        // Batch operations
        FlushAll(ctx context.Context) error
}

// NewNoOpCache creates a no-op cache using the generic NoOpCache with the adapter
func NewNoOpCache() Cache <span class="cov0" title="0">{
        return NewCacheAdapter(genericcache.NewNoOpCache[Account]())
}</span>

// CacheAdapter adapts generic cache implementations to the domain Cache interface
type CacheAdapter struct {
        accountCache genericcache.Cache[Account]
}

// NewCacheAdapter creates a new cache adapter using generic caches
func NewCacheAdapter(accountCache genericcache.Cache[Account]) Cache <span class="cov0" title="0">{
        return &amp;CacheAdapter{
                accountCache: accountCache,
        }
}</span>

// Get retrieves account from cache by ID
func (a *CacheAdapter) Get(ctx context.Context, id uuid.UUID) (*Account, error) <span class="cov0" title="0">{
        entity, err := a.accountCache.Get(ctx, id.String())
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">if entity == nil </span><span class="cov0" title="0">{
                return nil, ErrCacheMiss
        }</span>
        <span class="cov0" title="0">return entity, nil</span>
}

// Set stores account in cache with TTL
func (a *CacheAdapter) Set(ctx context.Context, entity *Account, ttl time.Duration) error <span class="cov0" title="0">{
        if entity == nil </span><span class="cov0" title="0">{
                return nil
        }</span>
        <span class="cov0" title="0">return a.accountCache.Set(ctx, entity.Id.String(), entity, ttl)</span>
}

// Delete removes account from cache
func (a *CacheAdapter) Delete(ctx context.Context, id uuid.UUID) error <span class="cov0" title="0">{
        return a.accountCache.Delete(ctx, id.String())
}</span>

// GetByProviderId retrieves account from cache by providerproviderAccountId
func (a *CacheAdapter) GetByProviderId(ctx context.Context, provider string, providerAccountId string) (*Account, error) <span class="cov0" title="0">{
        key := "provider:" + provider
        entity, err := a.accountCache.Get(ctx, key)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">if entity == nil </span><span class="cov0" title="0">{
                return nil, ErrCacheMiss
        }</span>
        <span class="cov0" title="0">return entity, nil</span>
}

// ListByUserId retrieves multiple accounts from cache by userId
func (a *CacheAdapter) ListByUserId(ctx context.Context, userId uuid.UUID) ([]*Account, error) <span class="cov0" title="0">{
        // List operations typically aren't cached as they're dynamic
        // Return cache miss to fall back to database
        return nil, ErrCacheMiss
}</span>

// FlushAll clears all cached data
func (a *CacheAdapter) FlushAll(ctx context.Context) error <span class="cov0" title="0">{
        if err := a.accountCache.Clear(ctx); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov0" title="0">return nil</span>
}

// Ensure CacheAdapter implements Cache interface
var _ Cache = (*CacheAdapter)(nil)
</pre>
		
		<pre class="file" id="file2" style="display: none">// Code generated by codegen events. DO NOT EDIT.
package accounts

import (
        "context"
        "github.com/archesai/archesai/internal/events"
)

// Event type constants for accounts domain.
const (
        EventAccountCreated  = "account.created"
        EventAccountUpdated  = "account.updated"
        EventAccountDeleted  = "account.deleted"
        EventAccountLinked   = "account.linked"
        EventAccountUnlinked = "account.unlinked"
)

// AccountCreatedEvent represents a created event event for Account.
type AccountCreatedEvent struct {
        events.BaseEvent
        Account *Account `json:"account"`
}

// NewAccountCreatedEvent creates a new Account created event.
func NewAccountCreatedEvent(entity *Account) *AccountCreatedEvent <span class="cov0" title="0">{
        return &amp;AccountCreatedEvent{
                BaseEvent: events.NewBaseEvent("accounts", EventAccountCreated),
                Account:   entity,
        }
}</span>

// EventType returns the event type string.
func (e *AccountCreatedEvent) EventType() string <span class="cov0" title="0">{
        return EventAccountCreated
}</span>

// EventDomain returns the domain this event belongs to.
func (e *AccountCreatedEvent) EventDomain() string <span class="cov0" title="0">{
        return "accounts"
}</span>

// EventData returns the actual event data.
func (e *AccountCreatedEvent) EventData() interface{} <span class="cov0" title="0">{
        return e.Account
}</span>

// AccountUpdatedEvent represents a updated event event for Account.
type AccountUpdatedEvent struct {
        events.BaseEvent
        Account *Account `json:"account"`
}

// NewAccountUpdatedEvent creates a new Account updated event.
func NewAccountUpdatedEvent(entity *Account) *AccountUpdatedEvent <span class="cov0" title="0">{
        return &amp;AccountUpdatedEvent{
                BaseEvent: events.NewBaseEvent("accounts", EventAccountUpdated),
                Account:   entity,
        }
}</span>

// EventType returns the event type string.
func (e *AccountUpdatedEvent) EventType() string <span class="cov0" title="0">{
        return EventAccountUpdated
}</span>

// EventDomain returns the domain this event belongs to.
func (e *AccountUpdatedEvent) EventDomain() string <span class="cov0" title="0">{
        return "accounts"
}</span>

// EventData returns the actual event data.
func (e *AccountUpdatedEvent) EventData() interface{} <span class="cov0" title="0">{
        return e.Account
}</span>

// AccountDeletedEvent represents a deleted event event for Account.
type AccountDeletedEvent struct {
        events.BaseEvent
        Account *Account `json:"account"`
}

// NewAccountDeletedEvent creates a new Account deleted event.
func NewAccountDeletedEvent(entity *Account) *AccountDeletedEvent <span class="cov0" title="0">{
        return &amp;AccountDeletedEvent{
                BaseEvent: events.NewBaseEvent("accounts", EventAccountDeleted),
                Account:   entity,
        }
}</span>

// EventType returns the event type string.
func (e *AccountDeletedEvent) EventType() string <span class="cov0" title="0">{
        return EventAccountDeleted
}</span>

// EventDomain returns the domain this event belongs to.
func (e *AccountDeletedEvent) EventDomain() string <span class="cov0" title="0">{
        return "accounts"
}</span>

// EventData returns the actual event data.
func (e *AccountDeletedEvent) EventData() interface{} <span class="cov0" title="0">{
        return e.Account
}</span>

// AccountLinkedEvent represents a linked event event for Account.
type AccountLinkedEvent struct {
        events.BaseEvent
        Account *Account `json:"account"`
}

// NewAccountLinkedEvent creates a new Account linked event.
func NewAccountLinkedEvent(entity *Account) *AccountLinkedEvent <span class="cov0" title="0">{
        return &amp;AccountLinkedEvent{
                BaseEvent: events.NewBaseEvent("accounts", EventAccountLinked),
                Account:   entity,
        }
}</span>

// EventType returns the event type string.
func (e *AccountLinkedEvent) EventType() string <span class="cov0" title="0">{
        return EventAccountLinked
}</span>

// EventDomain returns the domain this event belongs to.
func (e *AccountLinkedEvent) EventDomain() string <span class="cov0" title="0">{
        return "accounts"
}</span>

// EventData returns the actual event data.
func (e *AccountLinkedEvent) EventData() interface{} <span class="cov0" title="0">{
        return e.Account
}</span>

// AccountUnlinkedEvent represents a unlinked event event for Account.
type AccountUnlinkedEvent struct {
        events.BaseEvent
        Account *Account `json:"account"`
}

// NewAccountUnlinkedEvent creates a new Account unlinked event.
func NewAccountUnlinkedEvent(entity *Account) *AccountUnlinkedEvent <span class="cov0" title="0">{
        return &amp;AccountUnlinkedEvent{
                BaseEvent: events.NewBaseEvent("accounts", EventAccountUnlinked),
                Account:   entity,
        }
}</span>

// EventType returns the event type string.
func (e *AccountUnlinkedEvent) EventType() string <span class="cov0" title="0">{
        return EventAccountUnlinked
}</span>

// EventDomain returns the domain this event belongs to.
func (e *AccountUnlinkedEvent) EventDomain() string <span class="cov0" title="0">{
        return "accounts"
}</span>

// EventData returns the actual event data.
func (e *AccountUnlinkedEvent) EventData() interface{} <span class="cov0" title="0">{
        return e.Account
}</span>

// EventPublisher publishes domain events for accounts.
type EventPublisher interface {
        PublishAccountCreated(ctx context.Context, entity *Account) error
        PublishAccountUpdated(ctx context.Context, entity *Account) error
        PublishAccountDeleted(ctx context.Context, entity *Account) error
        PublishAccountLinked(ctx context.Context, entity *Account) error
        PublishAccountUnlinked(ctx context.Context, entity *Account) error
}

// eventPublisher implements EventPublisher for accounts domain.
type eventPublisher struct {
        publisher events.Publisher
}

// NewEventPublisher creates a new event publisher for accounts domain.
func NewEventPublisher(publisher events.Publisher) EventPublisher <span class="cov0" title="0">{
        return &amp;eventPublisher{
                publisher: publisher,
        }
}</span>

// PublishAccountCreated publishes a created event event for Account.
func (p *eventPublisher) PublishAccountCreated(ctx context.Context, entity *Account) error <span class="cov0" title="0">{
        event := NewAccountCreatedEvent(entity)
        return events.PublishDomainEvent(ctx, p.publisher, event)
}</span>

// PublishAccountUpdated publishes a updated event event for Account.
func (p *eventPublisher) PublishAccountUpdated(ctx context.Context, entity *Account) error <span class="cov0" title="0">{
        event := NewAccountUpdatedEvent(entity)
        return events.PublishDomainEvent(ctx, p.publisher, event)
}</span>

// PublishAccountDeleted publishes a deleted event event for Account.
func (p *eventPublisher) PublishAccountDeleted(ctx context.Context, entity *Account) error <span class="cov0" title="0">{
        event := NewAccountDeletedEvent(entity)
        return events.PublishDomainEvent(ctx, p.publisher, event)
}</span>

// PublishAccountLinked publishes a linked event event for Account.
func (p *eventPublisher) PublishAccountLinked(ctx context.Context, entity *Account) error <span class="cov0" title="0">{
        event := NewAccountLinkedEvent(entity)
        return events.PublishDomainEvent(ctx, p.publisher, event)
}</span>

// PublishAccountUnlinked publishes a unlinked event event for Account.
func (p *eventPublisher) PublishAccountUnlinked(ctx context.Context, entity *Account) error <span class="cov0" title="0">{
        event := NewAccountUnlinkedEvent(entity)
        return events.PublishDomainEvent(ctx, p.publisher, event)
}</span>

// NewNoOpEventPublisher creates a new no-op event publisher for testing.
func NewNoOpEventPublisher() EventPublisher <span class="cov0" title="0">{
        return NewEventPublisher(events.NewNoOpPublisher())
}</span>
</pre>
		
		<pre class="file" id="file3" style="display: none">// Package accounts provides primitives to interact with the openapi HTTP API.
//
// Code generated by github.com/oapi-codegen/oapi-codegen/v2 version v2.5.0 DO NOT EDIT.
package accounts

import (
        "context"
        "encoding/json"
        "fmt"
        "net/http"

        "github.com/labstack/echo/v4"
        "github.com/oapi-codegen/runtime"
        strictecho "github.com/oapi-codegen/runtime/strictmiddleware/echo"
        openapi_types "github.com/oapi-codegen/runtime/types"
)

// ServerInterface represents all server handlers.
type ServerInterface interface {
        // Find many accounts
        // (GET /auth/accounts)
        AccountsFindMany(ctx echo.Context, params AccountsFindManyParams) error
        // Delete an account
        // (DELETE /auth/accounts/{id})
        AccountsDelete(ctx echo.Context, id openapi_types.UUID) error
        // Find an account
        // (GET /auth/accounts/{id})
        AccountsGetOne(ctx echo.Context, id openapi_types.UUID) error
}

// ServerInterfaceWrapper converts echo contexts to parameters.
type ServerInterfaceWrapper struct {
        Handler ServerInterface
}

// AccountsFindMany converts echo context to params.
func (w *ServerInterfaceWrapper) AccountsFindMany(ctx echo.Context) error <span class="cov0" title="0">{
        var err error

        ctx.Set(BearerAuthScopes, []string{})

        // Parameter object where we will unmarshal all parameters from the context
        var params AccountsFindManyParams
        // ------------- Optional query parameter "filter" -------------

        err = runtime.BindQueryParameter("deepObject", true, false, "filter", ctx.QueryParams(), &amp;params.Filter)
        if err != nil </span><span class="cov0" title="0">{
                return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter filter: %s", err))
        }</span>

        // ------------- Optional query parameter "page" -------------

        <span class="cov0" title="0">err = runtime.BindQueryParameter("form", true, false, "page", ctx.QueryParams(), &amp;params.Page)
        if err != nil </span><span class="cov0" title="0">{
                return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter page: %s", err))
        }</span>

        // ------------- Optional query parameter "sort" -------------

        <span class="cov0" title="0">err = runtime.BindQueryParameter("form", true, false, "sort", ctx.QueryParams(), &amp;params.Sort)
        if err != nil </span><span class="cov0" title="0">{
                return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter sort: %s", err))
        }</span>

        // Invoke the callback with all the unmarshaled arguments
        <span class="cov0" title="0">err = w.Handler.AccountsFindMany(ctx, params)
        return err</span>
}

// AccountsDelete converts echo context to params.
func (w *ServerInterfaceWrapper) AccountsDelete(ctx echo.Context) error <span class="cov0" title="0">{
        var err error
        // ------------- Path parameter "id" -------------
        var id openapi_types.UUID

        err = runtime.BindStyledParameterWithOptions("simple", "id", ctx.Param("id"), &amp;id, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
        if err != nil </span><span class="cov0" title="0">{
                return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter id: %s", err))
        }</span>

        <span class="cov0" title="0">ctx.Set(BearerAuthScopes, []string{})

        // Invoke the callback with all the unmarshaled arguments
        err = w.Handler.AccountsDelete(ctx, id)
        return err</span>
}

// AccountsGetOne converts echo context to params.
func (w *ServerInterfaceWrapper) AccountsGetOne(ctx echo.Context) error <span class="cov0" title="0">{
        var err error
        // ------------- Path parameter "id" -------------
        var id openapi_types.UUID

        err = runtime.BindStyledParameterWithOptions("simple", "id", ctx.Param("id"), &amp;id, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
        if err != nil </span><span class="cov0" title="0">{
                return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter id: %s", err))
        }</span>

        <span class="cov0" title="0">ctx.Set(BearerAuthScopes, []string{})

        // Invoke the callback with all the unmarshaled arguments
        err = w.Handler.AccountsGetOne(ctx, id)
        return err</span>
}

// This is a simple interface which specifies echo.Route addition functions which
// are present on both echo.Echo and echo.Group, since we want to allow using
// either of them for path registration
type EchoRouter interface {
        CONNECT(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
        DELETE(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
        GET(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
        HEAD(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
        OPTIONS(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
        PATCH(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
        POST(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
        PUT(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
        TRACE(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
}

// RegisterHandlers adds each server route to the EchoRouter.
func RegisterHandlers(router EchoRouter, si ServerInterface) <span class="cov0" title="0">{
        RegisterHandlersWithBaseURL(router, si, "")
}</span>

// Registers handlers, and prepends BaseURL to the paths, so that the paths
// can be served under a prefix.
func RegisterHandlersWithBaseURL(router EchoRouter, si ServerInterface, baseURL string) <span class="cov0" title="0">{

        wrapper := ServerInterfaceWrapper{
                Handler: si,
        }

        router.GET(baseURL+"/auth/accounts", wrapper.AccountsFindMany)
        router.DELETE(baseURL+"/auth/accounts/:id", wrapper.AccountsDelete)
        router.GET(baseURL+"/auth/accounts/:id", wrapper.AccountsGetOne)

}</span>

type BadRequestApplicationProblemPlusJSONResponse Problem

type NotFoundApplicationProblemPlusJSONResponse Problem

type UnauthorizedApplicationProblemPlusJSONResponse Problem

type AccountsFindManyRequestObject struct {
        Params AccountsFindManyParams
}

type AccountsFindManyResponseObject interface {
        VisitAccountsFindManyResponse(w http.ResponseWriter) error
}

type AccountsFindMany200JSONResponse struct {
        Data []Account `json:"data"`
        Meta struct {
                Total float32 `json:"total"`
        } `json:"meta"`
}

func (response AccountsFindMany200JSONResponse) VisitAccountsFindManyResponse(w http.ResponseWriter) error <span class="cov0" title="0">{
        w.Header().Set("Content-Type", "application/json")
        w.WriteHeader(200)

        return json.NewEncoder(w).Encode(response)
}</span>

type AccountsFindMany400ApplicationProblemPlusJSONResponse struct {
        BadRequestApplicationProblemPlusJSONResponse
}

func (response AccountsFindMany400ApplicationProblemPlusJSONResponse) VisitAccountsFindManyResponse(w http.ResponseWriter) error <span class="cov0" title="0">{
        w.Header().Set("Content-Type", "application/problem+json")
        w.WriteHeader(400)

        return json.NewEncoder(w).Encode(response)
}</span>

type AccountsFindMany401ApplicationProblemPlusJSONResponse struct {
        UnauthorizedApplicationProblemPlusJSONResponse
}

func (response AccountsFindMany401ApplicationProblemPlusJSONResponse) VisitAccountsFindManyResponse(w http.ResponseWriter) error <span class="cov0" title="0">{
        w.Header().Set("Content-Type", "application/problem+json")
        w.WriteHeader(401)

        return json.NewEncoder(w).Encode(response)
}</span>

type AccountsDeleteRequestObject struct {
        Id openapi_types.UUID `json:"id"`
}

type AccountsDeleteResponseObject interface {
        VisitAccountsDeleteResponse(w http.ResponseWriter) error
}

type AccountsDelete200JSONResponse struct {
        // Data Schema for Account entity (authentication provider account)
        Data Account `json:"data"`
}

func (response AccountsDelete200JSONResponse) VisitAccountsDeleteResponse(w http.ResponseWriter) error <span class="cov0" title="0">{
        w.Header().Set("Content-Type", "application/json")
        w.WriteHeader(200)

        return json.NewEncoder(w).Encode(response)
}</span>

type AccountsDelete404ApplicationProblemPlusJSONResponse struct {
        NotFoundApplicationProblemPlusJSONResponse
}

func (response AccountsDelete404ApplicationProblemPlusJSONResponse) VisitAccountsDeleteResponse(w http.ResponseWriter) error <span class="cov0" title="0">{
        w.Header().Set("Content-Type", "application/problem+json")
        w.WriteHeader(404)

        return json.NewEncoder(w).Encode(response)
}</span>

type AccountsGetOneRequestObject struct {
        Id openapi_types.UUID `json:"id"`
}

type AccountsGetOneResponseObject interface {
        VisitAccountsGetOneResponse(w http.ResponseWriter) error
}

type AccountsGetOne200JSONResponse struct {
        // Data Schema for Account entity (authentication provider account)
        Data Account `json:"data"`
}

func (response AccountsGetOne200JSONResponse) VisitAccountsGetOneResponse(w http.ResponseWriter) error <span class="cov0" title="0">{
        w.Header().Set("Content-Type", "application/json")
        w.WriteHeader(200)

        return json.NewEncoder(w).Encode(response)
}</span>

type AccountsGetOne404ApplicationProblemPlusJSONResponse struct {
        NotFoundApplicationProblemPlusJSONResponse
}

func (response AccountsGetOne404ApplicationProblemPlusJSONResponse) VisitAccountsGetOneResponse(w http.ResponseWriter) error <span class="cov0" title="0">{
        w.Header().Set("Content-Type", "application/problem+json")
        w.WriteHeader(404)

        return json.NewEncoder(w).Encode(response)
}</span>

// StrictServerInterface represents all server handlers.
type StrictServerInterface interface {
        // Find many accounts
        // (GET /auth/accounts)
        AccountsFindMany(ctx context.Context, request AccountsFindManyRequestObject) (AccountsFindManyResponseObject, error)
        // Delete an account
        // (DELETE /auth/accounts/{id})
        AccountsDelete(ctx context.Context, request AccountsDeleteRequestObject) (AccountsDeleteResponseObject, error)
        // Find an account
        // (GET /auth/accounts/{id})
        AccountsGetOne(ctx context.Context, request AccountsGetOneRequestObject) (AccountsGetOneResponseObject, error)
}

type StrictHandlerFunc = strictecho.StrictEchoHandlerFunc
type StrictMiddlewareFunc = strictecho.StrictEchoMiddlewareFunc

func NewStrictHandler(ssi StrictServerInterface, middlewares []StrictMiddlewareFunc) ServerInterface <span class="cov0" title="0">{
        return &amp;strictHandler{ssi: ssi, middlewares: middlewares}
}</span>

type strictHandler struct {
        ssi         StrictServerInterface
        middlewares []StrictMiddlewareFunc
}

// AccountsFindMany operation middleware
func (sh *strictHandler) AccountsFindMany(ctx echo.Context, params AccountsFindManyParams) error <span class="cov0" title="0">{
        var request AccountsFindManyRequestObject

        request.Params = params

        handler := func(ctx echo.Context, request interface{}) (interface{}, error) </span><span class="cov0" title="0">{
                return sh.ssi.AccountsFindMany(ctx.Request().Context(), request.(AccountsFindManyRequestObject))
        }</span>
        <span class="cov0" title="0">for _, middleware := range sh.middlewares </span><span class="cov0" title="0">{
                handler = middleware(handler, "AccountsFindMany")
        }</span>

        <span class="cov0" title="0">response, err := handler(ctx, request)

        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span> else<span class="cov0" title="0"> if validResponse, ok := response.(AccountsFindManyResponseObject); ok </span><span class="cov0" title="0">{
                return validResponse.VisitAccountsFindManyResponse(ctx.Response())
        }</span> else<span class="cov0" title="0"> if response != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("unexpected response type: %T", response)
        }</span>
        <span class="cov0" title="0">return nil</span>
}

// AccountsDelete operation middleware
func (sh *strictHandler) AccountsDelete(ctx echo.Context, id openapi_types.UUID) error <span class="cov0" title="0">{
        var request AccountsDeleteRequestObject

        request.Id = id

        handler := func(ctx echo.Context, request interface{}) (interface{}, error) </span><span class="cov0" title="0">{
                return sh.ssi.AccountsDelete(ctx.Request().Context(), request.(AccountsDeleteRequestObject))
        }</span>
        <span class="cov0" title="0">for _, middleware := range sh.middlewares </span><span class="cov0" title="0">{
                handler = middleware(handler, "AccountsDelete")
        }</span>

        <span class="cov0" title="0">response, err := handler(ctx, request)

        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span> else<span class="cov0" title="0"> if validResponse, ok := response.(AccountsDeleteResponseObject); ok </span><span class="cov0" title="0">{
                return validResponse.VisitAccountsDeleteResponse(ctx.Response())
        }</span> else<span class="cov0" title="0"> if response != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("unexpected response type: %T", response)
        }</span>
        <span class="cov0" title="0">return nil</span>
}

// AccountsGetOne operation middleware
func (sh *strictHandler) AccountsGetOne(ctx echo.Context, id openapi_types.UUID) error <span class="cov0" title="0">{
        var request AccountsGetOneRequestObject

        request.Id = id

        handler := func(ctx echo.Context, request interface{}) (interface{}, error) </span><span class="cov0" title="0">{
                return sh.ssi.AccountsGetOne(ctx.Request().Context(), request.(AccountsGetOneRequestObject))
        }</span>
        <span class="cov0" title="0">for _, middleware := range sh.middlewares </span><span class="cov0" title="0">{
                handler = middleware(handler, "AccountsGetOne")
        }</span>

        <span class="cov0" title="0">response, err := handler(ctx, request)

        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span> else<span class="cov0" title="0"> if validResponse, ok := response.(AccountsGetOneResponseObject); ok </span><span class="cov0" title="0">{
                return validResponse.VisitAccountsGetOneResponse(ctx.Response())
        }</span> else<span class="cov0" title="0"> if response != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("unexpected response type: %T", response)
        }</span>
        <span class="cov0" title="0">return nil</span>
}
</pre>
		
		<pre class="file" id="file4" style="display: none">// Code generated by codegen repository. DO NOT EDIT.
package accounts

import (
        "context"
        "errors"

        "github.com/archesai/archesai/internal/database/postgresql"
        "github.com/google/uuid"
        "github.com/jackc/pgx/v5/pgxpool"
)

// PostgresRepository implements Repository using PostgreSQL.
type PostgresRepository struct {
        db      *pgxpool.Pool
        queries *postgresql.Queries
}

// NewPostgresRepository creates a new PostgreSQL repository.
func NewPostgresRepository(db *pgxpool.Pool) Repository <span class="cov0" title="0">{
        return &amp;PostgresRepository{
                db:      db,
                queries: postgresql.New(db),
        }
}</span>

// Account operations

func (r *PostgresRepository) Create(ctx context.Context, entity *Account) (*Account, error) <span class="cov0" title="0">{
        // Check if SQLC has the CreateAccount method
        // For now, we'll generate a stub but with proper error handling
        // TODO: Parse SQLC to detect available queries

        // Example of what it should look like when SQLC query exists:
        // params := postgresql.CreateAccountParams{
        //     Id: entity.Id,
        //     // ... map other fields
        // }
        // dbAccount, err := r.queries.CreateAccount(ctx, params)
        // if err != nil {
        //     return nil, NewRepositoryError("create", err)
        // }
        // return mapAccountToDomain(&amp;dbAccount), nil

        return nil, NewRepositoryError("create", errors.New("not implemented - SQLC query not found"))
}</span>

func (r *PostgresRepository) Get(ctx context.Context, id uuid.UUID) (*Account, error) <span class="cov0" title="0">{
        // Try to call SQLC GetAccount if it exists
        // For now, return not implemented
        return nil, NewRepositoryError("get", errors.New("not implemented - SQLC query not found"))
}</span>

func (r *PostgresRepository) Update(ctx context.Context, id uuid.UUID, entity *Account) (*Account, error) <span class="cov0" title="0">{
        // Update operations are often custom and may not have SQLC queries
        return nil, NewRepositoryError("update", errors.New("not implemented - SQLC query not found"))
}</span>

func (r *PostgresRepository) Delete(ctx context.Context, id uuid.UUID) error <span class="cov0" title="0">{
        // Try to call SQLC DeleteAccount if it exists
        // For now, return not implemented
        return NewRepositoryError("delete", errors.New("not implemented - SQLC query not found"))
}</span>

func (r *PostgresRepository) List(ctx context.Context, params ListAccountsParams) ([]*Account, int64, error) <span class="cov0" title="0">{
        // List operations need both List and Count queries from SQLC
        return nil, 0, NewRepositoryError("list", errors.New("not implemented - SQLC query not found"))
}</span>

// GetByProviderId retrieves account by providerproviderAccountId
func (r *PostgresRepository) GetByProviderId(ctx context.Context, provider string, providerAccountId string) (*Account, error) <span class="cov0" title="0">{

        // Try to call SQLC GetByProviderId if it exists
        // For now, return not implemented
        return nil, NewRepositoryError("getbyproviderid", errors.New("not implemented - SQLC query not found"))

}</span>

// ListByUserId retrieves multiple accounts by userId
func (r *PostgresRepository) ListByUserId(ctx context.Context, userId uuid.UUID) ([]*Account, error) <span class="cov0" title="0">{

        // Try to call SQLC ListByUserId if it exists
        // For now, return not implemented
        return nil, NewRepositoryError("listbyuserid", errors.New("not implemented - SQLC query not found"))

}</span>

// Mapper functions - Convert between domain types and database types
// These need to be customized based on the actual field mappings

func mapAccountToDomain(db *postgresql.Account) *Account <span class="cov0" title="0">{
        if db == nil </span><span class="cov0" title="0">{
                return nil
        }</span>

        // This is a basic mapping - needs to be customized based on actual types
        // The challenge is that OpenAPI types and database types don't always match
        // For example:
        // - OpenAPI might use string, database uses *string
        // - OpenAPI might use custom UUID type, database uses uuid.UUID
        // - Field names might differ (Id vs ID)

        <span class="cov0" title="0">result := &amp;Account{
                // TODO: Map fields properly based on actual type definitions
                // This requires parsing both OpenAPI types and SQLC types
        }

        // Basic field mapping - customize based on your entity structure
        // result.Id = db.Id
        // result.CreatedAt = db.CreatedAt
        // result.UpdatedAt = db.UpdatedAt
        // Add specific field mappings as needed

        return result</span>
}
</pre>
		
		<pre class="file" id="file5" style="display: none">// Code generated by codegen repository. DO NOT EDIT.
package accounts

import (
        "context"
        "fmt"
        "github.com/google/uuid"
)

// Repository handles account persistence
type Repository interface {
        Create(ctx context.Context, entity *Account) (*Account, error)
        Get(ctx context.Context, id uuid.UUID) (*Account, error)
        Update(ctx context.Context, id uuid.UUID, entity *Account) (*Account, error)
        Delete(ctx context.Context, id uuid.UUID) error
        List(ctx context.Context, params ListAccountsParams) ([]*Account, int64, error)

        // Additional operations
        GetByProviderId(ctx context.Context, provider string, providerAccountId string) (*Account, error)
        ListByUserId(ctx context.Context, userId uuid.UUID) ([]*Account, error)
}

// ListAccountsParams represents parameters for listing accounts.
type ListAccountsParams struct {
        Limit  int
        Offset int

        UserID     *uuid.UUID
        ProviderID *string
}

// RepositoryError represents a repository error.
type RepositoryError struct {
        Operation string
        Err       error
}

func (e *RepositoryError) Error() string <span class="cov0" title="0">{
        return fmt.Sprintf("repository %s: %v", e.Operation, e.Err)
}</span>

func (e *RepositoryError) Unwrap() error <span class="cov0" title="0">{
        return e.Err
}</span>

// NewRepositoryError creates a new repository error.
func NewRepositoryError(operation string, err error) *RepositoryError <span class="cov0" title="0">{
        return &amp;RepositoryError{
                Operation: operation,
                Err:       err,
        }
}</span>
</pre>
		
		<pre class="file" id="file6" style="display: none">// Code generated by codegen repository. DO NOT EDIT.
package accounts

import (
        "context"
        "database/sql"
        "fmt"

        "github.com/archesai/archesai/internal/database/sqlite"
        "github.com/google/uuid"
)

// SQLiteRepository implements Repository using SQLite.
type SQLiteRepository struct {
        db      *sql.DB
        queries *sqlite.Queries
}

// NewSQLiteRepository creates a new SQLite repository.
func NewSQLiteRepository(db *sql.DB) Repository <span class="cov0" title="0">{
        return &amp;SQLiteRepository{
                db:      db,
                queries: sqlite.New(db),
        }
}</span>

// Account operations

func (r *SQLiteRepository) Create(ctx context.Context, entity *Account) (*Account, error) <span class="cov0" title="0">{
        // For now, return a basic implementation
        // Actual implementation would need to be customized per entity
        return nil, fmt.Errorf("CreateAccount not yet implemented - requires custom mapping")
}</span>

func (r *SQLiteRepository) Get(ctx context.Context, id uuid.UUID) (*Account, error) <span class="cov0" title="0">{
        // For now, return a basic implementation
        // Actual implementation would need to be customized per entity
        return nil, fmt.Errorf("GetAccount not yet implemented - requires custom mapping")
}</span>

func (r *SQLiteRepository) Update(ctx context.Context, id uuid.UUID, entity *Account) (*Account, error) <span class="cov0" title="0">{
        // For now, return a basic implementation
        // Actual implementation would need to be customized per entity
        return nil, fmt.Errorf("UpdateAccount not yet implemented - requires custom mapping")
}</span>

func (r *SQLiteRepository) Delete(ctx context.Context, id uuid.UUID) error <span class="cov0" title="0">{
        // For now, return a basic implementation
        // Actual implementation would need to be customized per entity
        return fmt.Errorf("DeleteAccount not yet implemented - requires custom mapping")
}</span>

func (r *SQLiteRepository) List(ctx context.Context, params ListAccountsParams) ([]*Account, int64, error) <span class="cov0" title="0">{
        // For now, return a basic implementation
        // Actual implementation would need to be customized per entity
        return nil, 0, fmt.Errorf("ListAccounts not yet implemented - requires custom mapping")
}</span>

// GetByProviderId retrieves account by providerproviderAccountId
func (r *SQLiteRepository) GetByProviderId(ctx context.Context, provider string, providerAccountId string) (*Account, error) <span class="cov0" title="0">{

        // For now, return a basic implementation
        return nil, fmt.Errorf("GetByProviderId not yet implemented - requires custom mapping")

}</span>

// ListByUserId retrieves multiple accounts by userId
func (r *SQLiteRepository) ListByUserId(ctx context.Context, userId uuid.UUID) ([]*Account, error) <span class="cov0" title="0">{

        // For now, return a basic implementation
        return nil, fmt.Errorf("ListByUserId not yet implemented - requires custom mapping")

}</span>
</pre>
		
		<pre class="file" id="file7" style="display: none">// Package accounts provides primitives to interact with the openapi HTTP API.
//
// Code generated by github.com/oapi-codegen/oapi-codegen/v2 version v2.5.0 DO NOT EDIT.
package accounts

import (
        "encoding/json"
        "time"

        "github.com/google/uuid"
        "github.com/oapi-codegen/runtime"
)

const (
        BearerAuthScopes = "bearerAuth.Scopes"
)

// Defines values for AccountProviderId.
const (
        Apple     AccountProviderId = "apple"
        Github    AccountProviderId = "github"
        Google    AccountProviderId = "google"
        Local     AccountProviderId = "local"
        Microsoft AccountProviderId = "microsoft"
)

// Defines values for AccountsFindManyParamsSortField.
const (
        AccessToken           AccountsFindManyParamsSortField = "accessToken"
        AccessTokenExpiresAt  AccountsFindManyParamsSortField = "accessTokenExpiresAt"
        AccountId             AccountsFindManyParamsSortField = "accountId"
        CreatedAt             AccountsFindManyParamsSortField = "createdAt"
        Id                    AccountsFindManyParamsSortField = "id"
        IdToken               AccountsFindManyParamsSortField = "idToken"
        Password              AccountsFindManyParamsSortField = "password"
        ProviderId            AccountsFindManyParamsSortField = "providerId"
        RefreshToken          AccountsFindManyParamsSortField = "refreshToken"
        RefreshTokenExpiresAt AccountsFindManyParamsSortField = "refreshTokenExpiresAt"
        Scope                 AccountsFindManyParamsSortField = "scope"
        UpdatedAt             AccountsFindManyParamsSortField = "updatedAt"
        UserId                AccountsFindManyParamsSortField = "userId"
)

// Defines values for AccountsFindManyParamsSortOrder.
const (
        Asc  AccountsFindManyParamsSortOrder = "asc"
        Desc AccountsFindManyParamsSortOrder = "desc"
)

// Account defines model for Account.
type Account struct {
        // AccessToken The OAuth access token
        AccessToken string `json:"accessToken,omitempty,omitzero" yaml:"accessToken,omitempty"`

        // AccessTokenExpiresAt The access token expiration timestamp
        AccessTokenExpiresAt time.Time `json:"accessTokenExpiresAt,omitempty,omitzero" yaml:"accessTokenExpiresAt,omitempty"`

        // AccountId The unique identifier for the account from the provider
        AccountId string `json:"accountId" yaml:"accountId"`

        // CreatedAt The date and time when the resource was created
        CreatedAt time.Time `json:"createdAt" yaml:"createdAt"`

        // Id Universally Unique Identifier
        Id UUID `json:"id" yaml:"id"`

        // IdToken The OpenID Connect ID token
        IdToken string `json:"idToken,omitempty,omitzero" yaml:"idToken,omitempty"`

        // Password The hashed password (only for local authentication)
        Password string `json:"password,omitempty,omitzero" yaml:"password,omitempty"`

        // ProviderId The authentication provider identifier
        ProviderId AccountProviderId `json:"providerId" yaml:"providerId"`

        // RefreshToken The OAuth refresh token
        RefreshToken string `json:"refreshToken,omitempty,omitzero" yaml:"refreshToken,omitempty"`

        // RefreshTokenExpiresAt The refresh token expiration timestamp
        RefreshTokenExpiresAt time.Time `json:"refreshTokenExpiresAt,omitempty,omitzero" yaml:"refreshTokenExpiresAt,omitempty"`

        // Scope The OAuth scope granted
        Scope string `json:"scope,omitempty,omitzero" yaml:"scope,omitempty"`

        // UpdatedAt The date and time when the resource was last updated
        UpdatedAt time.Time `json:"updatedAt" yaml:"updatedAt"`

        // UserId The user ID this account belongs to
        UserId UUID `json:"userId" yaml:"userId"`
}

// AccountProviderId The authentication provider identifier
type AccountProviderId string

// Base defines model for Base.
type Base struct {
        // CreatedAt The date and time when the resource was created
        CreatedAt time.Time `json:"createdAt" yaml:"createdAt"`

        // Id Universally Unique Identifier
        Id UUID `json:"id" yaml:"id"`

        // UpdatedAt The date and time when the resource was last updated
        UpdatedAt time.Time `json:"updatedAt" yaml:"updatedAt"`
}

// FilterNode A recursive filter node that can be a condition or group
type FilterNode = interface{}

// Page Pagination (page number &amp; size)
type Page struct {
        Number int `json:"number,omitempty,omitzero" yaml:"number,omitempty"`
        Size   int `json:"size,omitempty,omitzero" yaml:"size,omitempty"`
}

// Problem RFC 7807 (Problem Details) compliant error response
type Problem struct {
        // Detail Human-readable explanation specific to this occurrence
        Detail string `json:"detail" yaml:"detail"`

        // Errors Additional validation errors for specific fields
        Errors []ValidationError `json:"errors,omitempty,omitzero" yaml:"errors,omitempty"`

        // Instance URI identifying the specific occurrence
        Instance string `json:"instance,omitempty,omitzero" yaml:"instance,omitempty"`

        // Status HTTP status code
        Status int `json:"status" yaml:"status"`

        // Title Short, human-readable summary
        Title string `json:"title" yaml:"title"`

        // Type URI identifying the problem type
        Type string `json:"type" yaml:"type"`
}

// UUID Universally Unique Identifier
type UUID = uuid.UUID

// ValidationError Individual field validation error
type ValidationError struct {
        // Field The field path that failed validation
        Field string `json:"field" yaml:"field"`

        // Message Human-readable error message
        Message string `json:"message" yaml:"message"`

        // Value The invalid value that was provided
        Value ValidationError_Value `json:"value,omitempty,omitzero" yaml:"value,omitempty"`
}

// ValidationErrorValue0 defines model for .
type ValidationErrorValue0 = string

// ValidationErrorValue1 defines model for .
type ValidationErrorValue1 = float32

// ValidationErrorValue2 defines model for .
type ValidationErrorValue2 = bool

// ValidationError_Value The invalid value that was provided
type ValidationError_Value struct {
        union json.RawMessage
}

// AccountsFilter A recursive filter node that can be a condition or group
type AccountsFilter = FilterNode

// AccountsSort defines model for AccountsSort.
type AccountsSort = []struct {
        Field string `json:"field" yaml:"field"`
        Order string `json:"order" yaml:"order"`
}

// PageQuery Pagination (page number &amp; size)
type PageQuery = Page

// BadRequest RFC 7807 (Problem Details) compliant error response
type BadRequest = Problem

// NotFound RFC 7807 (Problem Details) compliant error response
type NotFound = Problem

// Unauthorized RFC 7807 (Problem Details) compliant error response
type Unauthorized = Problem

// AccountsFindManyParams defines parameters for AccountsFindMany.
type AccountsFindManyParams struct {
        // Filter Filter accounts by field values. Supported fields:
        // - createdAt, id, updatedAt, accessToken, accessTokenExpiresAt
        // - accountId, idToken, password, providerId, refreshToken
        // - refreshTokenExpiresAt, scope, userId
        Filter AccountsFilter `json:"filter,omitempty,omitzero" yaml:"filter,omitempty"`

        // Page The page parameter
        Page PageQuery `form:"page,omitempty" json:"page,omitempty,omitzero" yaml:"page,omitempty"`

        // Sort The sort parameter
        Sort AccountsSort `form:"sort,omitempty" json:"sort,omitempty,omitzero" yaml:"sort,omitempty"`
}

// AccountsFindManyParamsSortField defines parameters for AccountsFindMany.
type AccountsFindManyParamsSortField string

// AccountsFindManyParamsSortOrder defines parameters for AccountsFindMany.
type AccountsFindManyParamsSortOrder string

// AsValidationErrorValue0 returns the union data inside the ValidationError_Value as a ValidationErrorValue0
func (t ValidationError_Value) AsValidationErrorValue0() (ValidationErrorValue0, error) <span class="cov0" title="0">{
        var body ValidationErrorValue0
        err := json.Unmarshal(t.union, &amp;body)
        return body, err
}</span>

// FromValidationErrorValue0 overwrites any union data inside the ValidationError_Value as the provided ValidationErrorValue0
func (t *ValidationError_Value) FromValidationErrorValue0(v ValidationErrorValue0) error <span class="cov0" title="0">{
        b, err := json.Marshal(v)
        t.union = b
        return err
}</span>

// MergeValidationErrorValue0 performs a merge with any union data inside the ValidationError_Value, using the provided ValidationErrorValue0
func (t *ValidationError_Value) MergeValidationErrorValue0(v ValidationErrorValue0) error <span class="cov0" title="0">{
        b, err := json.Marshal(v)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov0" title="0">merged, err := runtime.JSONMerge(t.union, b)
        t.union = merged
        return err</span>
}

// AsValidationErrorValue1 returns the union data inside the ValidationError_Value as a ValidationErrorValue1
func (t ValidationError_Value) AsValidationErrorValue1() (ValidationErrorValue1, error) <span class="cov0" title="0">{
        var body ValidationErrorValue1
        err := json.Unmarshal(t.union, &amp;body)
        return body, err
}</span>

// FromValidationErrorValue1 overwrites any union data inside the ValidationError_Value as the provided ValidationErrorValue1
func (t *ValidationError_Value) FromValidationErrorValue1(v ValidationErrorValue1) error <span class="cov0" title="0">{
        b, err := json.Marshal(v)
        t.union = b
        return err
}</span>

// MergeValidationErrorValue1 performs a merge with any union data inside the ValidationError_Value, using the provided ValidationErrorValue1
func (t *ValidationError_Value) MergeValidationErrorValue1(v ValidationErrorValue1) error <span class="cov0" title="0">{
        b, err := json.Marshal(v)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov0" title="0">merged, err := runtime.JSONMerge(t.union, b)
        t.union = merged
        return err</span>
}

// AsValidationErrorValue2 returns the union data inside the ValidationError_Value as a ValidationErrorValue2
func (t ValidationError_Value) AsValidationErrorValue2() (ValidationErrorValue2, error) <span class="cov0" title="0">{
        var body ValidationErrorValue2
        err := json.Unmarshal(t.union, &amp;body)
        return body, err
}</span>

// FromValidationErrorValue2 overwrites any union data inside the ValidationError_Value as the provided ValidationErrorValue2
func (t *ValidationError_Value) FromValidationErrorValue2(v ValidationErrorValue2) error <span class="cov0" title="0">{
        b, err := json.Marshal(v)
        t.union = b
        return err
}</span>

// MergeValidationErrorValue2 performs a merge with any union data inside the ValidationError_Value, using the provided ValidationErrorValue2
func (t *ValidationError_Value) MergeValidationErrorValue2(v ValidationErrorValue2) error <span class="cov0" title="0">{
        b, err := json.Marshal(v)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov0" title="0">merged, err := runtime.JSONMerge(t.union, b)
        t.union = merged
        return err</span>
}

func (t ValidationError_Value) MarshalJSON() ([]byte, error) <span class="cov0" title="0">{
        b, err := t.union.MarshalJSON()
        return b, err
}</span>

func (t *ValidationError_Value) UnmarshalJSON(b []byte) error <span class="cov0" title="0">{
        err := t.union.UnmarshalJSON(b)
        return err
}</span>
</pre>
		
		<pre class="file" id="file8" style="display: none">// Package app provides dependency injection and application container management
package app

import (
        "fmt"
        "log/slog"
        "net/http"
        "time"

        // "github.com/archesai/archesai/internal/artifacts"
        "github.com/archesai/archesai/internal/auth"
        "github.com/archesai/archesai/internal/config"
        "github.com/archesai/archesai/internal/health"

        // "github.com/archesai/archesai/internal/invitations"
        // "github.com/archesai/archesai/internal/labels"
        // "github.com/archesai/archesai/internal/members"
        "github.com/archesai/archesai/internal/migrations"
        "github.com/archesai/archesai/internal/organizations"
        "github.com/archesai/archesai/internal/pipelines"
        "github.com/archesai/archesai/internal/runs"
        "github.com/archesai/archesai/internal/server"
        "github.com/archesai/archesai/internal/tools"
        "github.com/archesai/archesai/internal/users"
        "github.com/labstack/echo/v4"
)

// App holds all application dependencies
type App struct {
        // Core infrastructure
        infra *Infrastructure // Private infrastructure holder

        // Public infrastructure access
        Logger *slog.Logger
        Config *config.Config
        Server *server.Server

        // Domain services (public for handler access)
        AuthService          *auth.Service
        UsersService         *users.Service
        OrganizationsService *organizations.Service
        // TODO: Implement these services
        // ArtifactsService     *artifacts.Service
        // LabelsService        *labels.Service
        // MembersService       *members.Service
        // InvitationsService   *invitations.Service
        PipelinesService *pipelines.Service
        RunsService      *runs.Service
        ToolsService     *tools.Service
        HealthService    *health.Service

        // HTTP handlers
        AuthHandler          *auth.Handler
        UsersHandler         *users.Handler
        OrganizationsHandler *organizations.Handler
        // TODO: Implement these handlers
        // ArtifactsHandler     *artifacts.Handler
        // LabelsHandler        *labels.Handler
        // MembersHandler       *members.Handler
        // InvitationsHandler   *invitations.Handler
        PipelinesHandler *pipelines.Handler
        RunsHandler      *runs.Handler
        ToolsHandler     *tools.Handler
        HealthHandler    *health.Handler
}

// NewApp creates and initializes all application dependencies
func NewApp(cfg *config.Config) (*App, error) <span class="cov0" title="0">{
        // Initialize infrastructure
        infra, err := NewInfrastructure(cfg)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to initialize infrastructure: %w", err)
        }</span>

        <span class="cov0" title="0">log := infra.Logger
        db := infra.Database

        // Run migrations if enabled
        if cfg.Database.RunMigrations </span><span class="cov0" title="0">{
                if err := migrations.RunMigrations(db, log); err != nil </span><span class="cov0" title="0">{
                        log.Error("failed to run migrations", "error", err)
                        isProduction := cfg.Api.Environment == "production"
                        if isProduction </span><span class="cov0" title="0">{
                                return nil, fmt.Errorf("failed to run migrations: %w", err)
                        }</span>
                }
        }

        // Create repositories
        <span class="cov0" title="0">repos, err := NewRepositories(db, cfg)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to create repositories: %w", err)
        }</span>

        // Initialize auth feature
        <span class="cov0" title="0">accessTokenTTL, err := cfg.GetAccessTokenTTL()
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to parse access token TTL: %w", err)
        }</span>
        <span class="cov0" title="0">refreshTokenTTL, err := cfg.GetRefreshTokenTTL()
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to parse refresh token TTL: %w", err)
        }</span>

        // Initialize auth service
        <span class="cov0" title="0">authConfig := auth.Config{
                JWTSecret:          cfg.GetJWTSecret(),
                AccessTokenExpiry:  accessTokenTTL,
                RefreshTokenExpiry: refreshTokenTTL,
        }

        // Always pass cache to auth service (infra.AuthCache is never nil)
        authService := auth.NewService(repos.Accounts, repos.Sessions, repos.Users, infra.AuthCache, authConfig, log)
        authHandler := auth.NewHandler(authService, log)

        // Initialize users domain
        usersEvents := users.NewEventPublisher(infra.EventPublisher)
        usersService := users.NewService(repos.Users, infra.UsersCache, usersEvents, log)
        usersHandler := users.NewHandler(usersService, log)

        // Initialize organizations domain
        organizationsService := organizations.NewService(repos.Organizations, log)
        organizationsHandler := organizations.NewHandler(organizationsService, log)

        // Initialize pipelines domain
        pipelinesService := pipelines.NewService(repos.Pipelines, log)
        pipelinesHandler := pipelines.NewHandler(pipelinesService, log)

        // Initialize runs domain
        runsService := runs.NewService(repos.Runs, log)
        runsHandler := runs.NewHandler(runsService, log)

        // Initialize tools domain
        toolsService := tools.NewService(repos.Tools, log)
        toolsHandler := tools.NewHandler(toolsService, log)

        // TODO: Initialize these domains when services/handlers are implemented
        // Initialize artifacts domain
        // artifactsService := artifacts.NewArtifactsService(repos.Artifacts, repos.Labels, log)
        // artifactsHandler := artifacts.NewHandler(artifactsService, log)

        // Initialize labels domain
        // labelsService := labels.NewService(repos.Labels, log)
        // labelsHandler := labels.NewHandler(labelsService, log)

        // Initialize members domain
        // membersService := members.NewService(repos.Members, log)
        // membersHandler := members.NewHandler(membersService, log)

        // Initialize invitations domain
        // invitationsService := invitations.NewService(repos.Invitations, log)
        // invitationsHandler := invitations.NewHandler(invitationsService, log)

        // Initialize health domain
        healthService := health.NewService(log)
        healthHandler := health.NewHandler(healthService, log)

        // Initialize config handler
        // TODO: Implement config handler when needed
        // configHandler := config.NewHandler(cfg, log)

        // Create the HTTP server
        httpServer := server.NewServer(&amp;cfg.Api, log)

        // Create app with all dependencies
        app := &amp;App{
                // Infrastructure
                infra:  infra,
                Logger: log,
                Config: cfg,
                Server: httpServer,

                // Domain services
                AuthService:          authService,
                UsersService:         usersService,
                OrganizationsService: organizationsService,
                PipelinesService:     pipelinesService,
                RunsService:          runsService,
                ToolsService:         toolsService,
                // ArtifactsService:     artifactsService,
                // LabelsService:        labelsService,
                // MembersService:       membersService,
                // InvitationsService:   invitationsService,
                HealthService: healthService,

                // HTTP handlers
                AuthHandler:          authHandler,
                UsersHandler:         usersHandler,
                OrganizationsHandler: organizationsHandler,
                PipelinesHandler:     pipelinesHandler,
                RunsHandler:          runsHandler,
                ToolsHandler:         toolsHandler,
                // ArtifactsHandler:     artifactsHandler,
                // LabelsHandler:        labelsHandler,
                // MembersHandler:       membersHandler,
                // InvitationsHandler:   invitationsHandler,
                HealthHandler: healthHandler,
        }

        // Register all application routes
        app.registerRoutes()

        return app, nil</span>
}

// Close cleans up all resources
func (a *App) Close() error <span class="cov0" title="0">{
        if a.infra != nil </span><span class="cov0" title="0">{
                return a.infra.Close()
        }</span>
        <span class="cov0" title="0">return nil</span>
}

// registerRoutes registers all application routes with the server
func (a *App) registerRoutes() <span class="cov0" title="0">{
        // Get the echo instance from the server
        e := a.Server.Echo()

        // Register readiness check that can access the database
        a.Server.SetReadinessCheck(a.readinessCheck)

        // Setup API documentation if enabled
        if a.Config.Api.Docs </span><span class="cov0" title="0">{
                if err := a.Server.SetupDocs(); err != nil </span><span class="cov0" title="0">{
                        a.Logger.Error("failed to setup API docs", "error", err)
                }</span>
        }

        // Register all application routes
        <span class="cov0" title="0">a.RegisterRoutes(e)</span>
}

// readinessCheck checks if the service is ready to handle requests
func (a *App) readinessCheck(ctx echo.Context) error <span class="cov0" title="0">{
        // Check database connection
        if err := a.infra.Database.Ping(ctx.Request().Context()); err != nil </span><span class="cov0" title="0">{
                a.Logger.Error("database health check failed")
                return ctx.JSON(http.StatusServiceUnavailable, map[string]interface{}{
                        "status": "unhealthy",
                        "error":  "database connection failed",
                })
        }</span>

        <span class="cov0" title="0">return ctx.JSON(http.StatusOK, map[string]interface{}{
                "status":    "ready",
                "timestamp": time.Now().Unix(),
        })</span>
}
</pre>
		
		<pre class="file" id="file9" style="display: none">// Package app provides dependency injection and application container management
package app

import (
        "database/sql"
        "fmt"
        "log/slog"

        "github.com/archesai/archesai/internal/accounts"
        "github.com/archesai/archesai/internal/artifacts"
        "github.com/archesai/archesai/internal/cache"
        "github.com/archesai/archesai/internal/config"
        "github.com/archesai/archesai/internal/database"
        "github.com/archesai/archesai/internal/database/postgresql"
        "github.com/archesai/archesai/internal/database/sqlite"
        "github.com/archesai/archesai/internal/events"
        "github.com/archesai/archesai/internal/invitations"
        "github.com/archesai/archesai/internal/labels"
        "github.com/archesai/archesai/internal/logger"
        "github.com/archesai/archesai/internal/members"
        "github.com/archesai/archesai/internal/organizations"
        "github.com/archesai/archesai/internal/pipelines"
        "github.com/archesai/archesai/internal/redis"
        "github.com/archesai/archesai/internal/runs"
        "github.com/archesai/archesai/internal/sessions"
        "github.com/archesai/archesai/internal/tools"
        "github.com/archesai/archesai/internal/users"
        "github.com/jackc/pgx/v5/pgxpool"
)

// Infrastructure holds all infrastructure components
type Infrastructure struct {
        Logger         *slog.Logger
        Database       database.Database
        EventPublisher events.Publisher
        AuthCache      sessions.Cache
        UsersCache     users.Cache
        // Single Redis client shared across components
        redisClient *redis.Client
}

// Repositories holds all domain repositories
type Repositories struct {
        Accounts      accounts.Repository
        Sessions      sessions.Repository
        Users         users.Repository
        Organizations organizations.Repository
        Pipelines     pipelines.Repository
        Runs          runs.Repository
        Tools         tools.Repository
        Artifacts     artifacts.Repository
        Labels        labels.Repository
        Members       members.Repository
        Invitations   invitations.Repository
}

// NewInfrastructure creates all infrastructure components
func NewInfrastructure(cfg *config.Config) (*Infrastructure, error) <span class="cov0" title="0">{
        // Initialize logger
        loggerCfg := logger.Config{
                Level:  string(cfg.Logging.Level),
                Pretty: cfg.Logging.Pretty,
        }
        log := logger.New(loggerCfg)
        slog.SetDefault(log)

        // Initialize database
        dbFactory := database.NewFactory(log)
        db, err := dbFactory.Create(&amp;cfg.Database)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to connect to database: %w", err)
        }</span>

        <span class="cov0" title="0">infra := &amp;Infrastructure{
                Logger:   log,
                Database: db,
        }

        // Initialize Redis-based components if enabled
        if cfg.Redis.Enabled </span><span class="cov0" title="0">{
                redisConfig := &amp;redis.Config{
                        Host:         cfg.Redis.Host,
                        Port:         int(cfg.Redis.Port),
                        Password:     cfg.Redis.Auth,
                        DB:           0,
                        EnablePubSub: true,
                }

                redisClient, err := redis.NewClient(redisConfig, log)
                if err != nil </span><span class="cov0" title="0">{
                        // Log warning but continue with in-memory implementations
                        log.Warn("failed to connect to Redis, using in-memory alternatives", "error", err)
                        infra.EventPublisher = events.NewNoOpPublisher()
                        // Use memory cache for auth
                        sessionCache := cache.NewMemoryCache[sessions.Session]()
                        infra.AuthCache = sessions.NewCacheAdapter(sessionCache)
                        // Use NoOp cache for users (will be replaced later)
                        infra.UsersCache = users.NewNoOpCache()
                }</span> else<span class="cov0" title="0"> {
                        // Use Redis for all components
                        infra.redisClient = redisClient
                        infra.EventPublisher = events.NewRedisPublisher(redisClient.GetRedisClient())
                        // Use Redis cache for auth
                        sessionCache := cache.NewRedisCache[sessions.Session](redisClient.GetRedisClient(), "auth:session")
                        infra.AuthCache = sessions.NewCacheAdapter(sessionCache)
                        // Use NoOp cache for users (will be replaced later)
                        infra.UsersCache = users.NewNoOpCache()
                }</span>
        } else<span class="cov0" title="0"> {
                // Use in-memory implementations when Redis is disabled
                infra.EventPublisher = events.NewNoOpPublisher()
                // Use memory cache for auth
                sessionCache := cache.NewMemoryCache[sessions.Session]()
                infra.AuthCache = sessions.NewCacheAdapter(sessionCache)
                // Use NoOp cache for users (will be replaced later)
                infra.UsersCache = users.NewNoOpCache()
        }</span>

        <span class="cov0" title="0">return infra, nil</span>
}

// NewRepositories creates all domain repositories based on database type
func NewRepositories(db database.Database, cfg *config.Config) (*Repositories, error) <span class="cov0" title="0">{
        // Determine database type
        var dbType database.Type
        if cfg.Database.Type != "" </span><span class="cov0" title="0">{
                dbType = database.ParseTypeFromString(string(cfg.Database.Type))
        }</span> else<span class="cov0" title="0"> {
                dbType = database.DetectTypeFromURL(cfg.Database.Url)
        }</span>

        <span class="cov0" title="0">repos := &amp;Repositories{}

        switch dbType </span>{
        case database.TypePostgreSQL:<span class="cov0" title="0">
                pool, ok := db.Underlying().(*pgxpool.Pool)
                if !ok || pool == nil </span><span class="cov0" title="0">{
                        return nil, fmt.Errorf("failed to get PostgreSQL connection pool")
                }</span>

                // Core repositories
                <span class="cov0" title="0">repos.Accounts = accounts.NewPostgresRepository(pool)
                repos.Sessions = sessions.NewPostgresRepository(pool)
                repos.Users = users.NewPostgresRepository(pool)
                repos.Organizations = organizations.NewPostgresRepository(pool)

                // Pipeline repositories
                repos.Pipelines = pipelines.NewPostgresRepository(pool)
                repos.Runs = runs.NewPostgresRepository(pool)
                repos.Tools = tools.NewPostgresRepository(pool)

                // Content repositories
                repos.Artifacts = artifacts.NewPostgresRepository(pool)
                repos.Labels = labels.NewPostgresRepository(pool)

                // Organization-related repositories
                repos.Members = members.NewPostgresRepository(pool)
                repos.Invitations = invitations.NewPostgresRepository(pool)</span>

        case database.TypeSQLite:<span class="cov0" title="0">
                sqlDB, ok := db.Underlying().(*sql.DB)
                if !ok || sqlDB == nil </span><span class="cov0" title="0">{
                        return nil, fmt.Errorf("failed to get SQLite connection")
                }</span>

                // Core repositories
                <span class="cov0" title="0">repos.Accounts = accounts.NewSQLiteRepository(sqlDB)
                repos.Sessions = sessions.NewSQLiteRepository(sqlDB)
                repos.Users = users.NewSQLiteRepository(sqlDB)
                repos.Organizations = organizations.NewSQLiteRepository(sqlDB)

                // Pipeline repositories
                repos.Pipelines = pipelines.NewSQLiteRepository(sqlDB)
                repos.Runs = runs.NewSQLiteRepository(sqlDB)
                repos.Tools = tools.NewSQLiteRepository(sqlDB)

                // Content repositories
                repos.Artifacts = artifacts.NewSQLiteRepository(sqlDB)
                repos.Labels = labels.NewSQLiteRepository(sqlDB)

                // Organization-related repositories
                repos.Members = members.NewSQLiteRepository(sqlDB)
                repos.Invitations = invitations.NewSQLiteRepository(sqlDB)</span>

        default:<span class="cov0" title="0">
                return nil, fmt.Errorf("unsupported database type: %v", dbType)</span>
        }

        <span class="cov0" title="0">return repos, nil</span>
}

// GetQueries returns database-specific query objects
func GetQueries(db database.Database, cfg *config.Config) (pgQueries *postgresql.Queries, sqliteQueries *sqlite.Queries) <span class="cov0" title="0">{
        // Determine database type
        var dbType database.Type
        if cfg.Database.Type != "" </span><span class="cov0" title="0">{
                dbType = database.ParseTypeFromString(string(cfg.Database.Type))
        }</span> else<span class="cov0" title="0"> {
                dbType = database.DetectTypeFromURL(cfg.Database.Url)
        }</span>

        <span class="cov0" title="0">switch dbType </span>{
        case database.TypePostgreSQL:<span class="cov0" title="0">
                if pool, ok := db.Underlying().(*pgxpool.Pool); ok &amp;&amp; pool != nil </span><span class="cov0" title="0">{
                        pgQueries = postgresql.New(pool)
                }</span>
        case database.TypeSQLite:<span class="cov0" title="0">
                if sqlDB, ok := db.Underlying().(*sql.DB); ok &amp;&amp; sqlDB != nil </span><span class="cov0" title="0">{
                        sqliteQueries = sqlite.New(sqlDB)
                }</span>
        }

        <span class="cov0" title="0">return pgQueries, sqliteQueries</span>
}

// Close cleans up all infrastructure resources
func (i *Infrastructure) Close() error <span class="cov0" title="0">{
        // Close database
        if i.Database != nil </span><span class="cov0" title="0">{
                if err := i.Database.Close(); err != nil </span><span class="cov0" title="0">{
                        i.Logger.Error("failed to close database", "error", err)
                }</span>
        }

        // Close Redis if it exists
        <span class="cov0" title="0">if i.redisClient != nil </span><span class="cov0" title="0">{
                if err := i.redisClient.Close(); err != nil </span><span class="cov0" title="0">{
                        i.Logger.Error("failed to close Redis", "error", err)
                }</span>
        }

        <span class="cov0" title="0">return nil</span>
}
</pre>
		
		<pre class="file" id="file10" style="display: none">package app

import (
        "github.com/archesai/archesai/internal/auth"
        // "github.com/archesai/archesai/internal/config"
        // "github.com/archesai/archesai/internal/content"
        "github.com/archesai/archesai/internal/health"
        "github.com/archesai/archesai/internal/organizations"
        "github.com/archesai/archesai/internal/pipelines"
        "github.com/archesai/archesai/internal/runs"
        "github.com/archesai/archesai/internal/tools"
        "github.com/archesai/archesai/internal/users"

        // "github.com/archesai/archesai/internal/workflows"
        "github.com/labstack/echo/v4"
)

// RegisterRoutes registers all application routes with the Echo server
func (a *App) RegisterRoutes(e *echo.Echo) <span class="cov0" title="0">{
        // API v1 group
        v1 := e.Group("/api/v1")

        // ========================================
        // PUBLIC ROUTES (No authentication required)
        // ========================================

        // Auth routes - public endpoints with rate limiting
        // These endpoints handle login, registration, password reset, etc.
        strictAuthHandler := auth.NewAuthStrictHandler(a.AuthHandler)
        publicAuthGroup := v1.Group("")
        publicAuthGroup.Use(auth.RateLimitMiddleware(10, 60)) // 10 requests per minute
        auth.RegisterHandlers(publicAuthGroup, strictAuthHandler)

        // Health routes - public endpoints for monitoring
        strictHealthHandler := health.NewStrictHandler(a.HealthHandler, nil)
        health.RegisterHandlers(v1, strictHealthHandler)

        // ========================================
        // PROTECTED ROUTES (Authentication required)
        // ========================================

        // Create a protected group with authentication middleware
        protected := v1.Group("")
        protected.Use(auth.RequireAuth(a.AuthService, auth.MiddlewarePresets.Authenticated, a.Logger))

        // Users routes - require authentication
        strictUsersHandler := users.NewUserStrictHandler(a.UsersHandler)
        users.RegisterHandlers(protected, strictUsersHandler)

        // Organizations routes - require authentication and organization membership
        strictOrganizationsHandler := organizations.NewStrictHandler(a.OrganizationsHandler, nil)
        // Create a separate group for organization routes with additional checks
        orgGroup := v1.Group("")
        orgGroup.Use(auth.RequireAuth(a.AuthService, auth.MiddlewarePresets.OrganizationMember, a.Logger))
        organizations.RegisterHandlers(orgGroup, strictOrganizationsHandler)

        // Pipelines routes - require authentication
        strictPipelinesHandler := pipelines.NewStrictHandler(a.PipelinesHandler, nil)
        pipelines.RegisterHandlers(protected, strictPipelinesHandler)

        // Runs routes - require authentication
        strictRunsHandler := runs.NewStrictHandler(a.RunsHandler, nil)
        runs.RegisterHandlers(protected, strictRunsHandler)

        // Tools routes - require authentication
        strictToolsHandler := tools.NewStrictHandler(a.ToolsHandler, nil)
        tools.RegisterHandlers(protected, strictToolsHandler)

        // TODO: Add routes for artifacts, labels, members, invitations when implemented
        // Content routes - require authentication
        // strictContentHandler := content.NewContentStrictHandler(a.ContentHandler)
        // content.RegisterHandlers(protected, strictContentHandler)

        // ========================================
        // API-ONLY ROUTES (API key authentication)
        // ========================================

        // Create an API-only group for endpoints that should use API keys
        // (Currently none, but structure is in place for future use)
        // apiOnly := v1.Group("")
        // apiOnly.Use(auth.RequireAuth(a.AuthService, auth.MiddlewarePresets.APIOnly, a.Logger))

        // ========================================
        // ADMIN ROUTES (Admin role required)
        // ========================================

        // Create an admin group for administrative endpoints
        // (Currently none, but structure is in place for future use)
        // admin := v1.Group("/admin")
        // admin.Use(auth.RequireAuth(a.AuthService, auth.MiddlewarePresets.AdminOnly, a.Logger))

        // Register config routes using StrictHandler pattern
        // TODO: Implement config handler when needed
        // strictConfigHandler := config.NewStrictHandler(a.ConfigHandler, nil)
        // config.RegisterHandlers(protected, strictConfigHandler)
}</span>
</pre>
		
		<pre class="file" id="file11" style="display: none">// Package artifacts provides primitives to interact with the openapi HTTP API.
//
// Code generated by github.com/oapi-codegen/oapi-codegen/v2 version v2.5.0 DO NOT EDIT.
package artifacts

import (
        "context"
        "encoding/json"
        "fmt"
        "net/http"

        "github.com/labstack/echo/v4"
        "github.com/oapi-codegen/runtime"
        strictecho "github.com/oapi-codegen/runtime/strictmiddleware/echo"
        openapi_types "github.com/oapi-codegen/runtime/types"
)

// ServerInterface represents all server handlers.
type ServerInterface interface {
        // Find many artifacts
        // (GET /content/artifacts)
        FindManyArtifacts(ctx echo.Context, params FindManyArtifactsParams) error
        // Create a new artifact
        // (POST /content/artifacts)
        CreateArtifact(ctx echo.Context) error
        // Delete an artifact
        // (DELETE /content/artifacts/{id})
        DeleteArtifact(ctx echo.Context, id openapi_types.UUID) error
        // Find an artifact
        // (GET /content/artifacts/{id})
        GetOneArtifact(ctx echo.Context, id openapi_types.UUID) error
        // Update an artifact
        // (PATCH /content/artifacts/{id})
        UpdateArtifact(ctx echo.Context, id openapi_types.UUID) error
}

// ServerInterfaceWrapper converts echo contexts to parameters.
type ServerInterfaceWrapper struct {
        Handler ServerInterface
}

// FindManyArtifacts converts echo context to params.
func (w *ServerInterfaceWrapper) FindManyArtifacts(ctx echo.Context) error <span class="cov0" title="0">{
        var err error

        ctx.Set(BearerAuthScopes, []string{})

        // Parameter object where we will unmarshal all parameters from the context
        var params FindManyArtifactsParams
        // ------------- Optional query parameter "filter" -------------

        err = runtime.BindQueryParameter("deepObject", true, false, "filter", ctx.QueryParams(), &amp;params.Filter)
        if err != nil </span><span class="cov0" title="0">{
                return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter filter: %s", err))
        }</span>

        // ------------- Optional query parameter "page" -------------

        <span class="cov0" title="0">err = runtime.BindQueryParameter("form", true, false, "page", ctx.QueryParams(), &amp;params.Page)
        if err != nil </span><span class="cov0" title="0">{
                return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter page: %s", err))
        }</span>

        // ------------- Optional query parameter "sort" -------------

        <span class="cov0" title="0">err = runtime.BindQueryParameter("form", true, false, "sort", ctx.QueryParams(), &amp;params.Sort)
        if err != nil </span><span class="cov0" title="0">{
                return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter sort: %s", err))
        }</span>

        // Invoke the callback with all the unmarshaled arguments
        <span class="cov0" title="0">err = w.Handler.FindManyArtifacts(ctx, params)
        return err</span>
}

// CreateArtifact converts echo context to params.
func (w *ServerInterfaceWrapper) CreateArtifact(ctx echo.Context) error <span class="cov0" title="0">{
        var err error

        ctx.Set(BearerAuthScopes, []string{})

        // Invoke the callback with all the unmarshaled arguments
        err = w.Handler.CreateArtifact(ctx)
        return err
}</span>

// DeleteArtifact converts echo context to params.
func (w *ServerInterfaceWrapper) DeleteArtifact(ctx echo.Context) error <span class="cov0" title="0">{
        var err error
        // ------------- Path parameter "id" -------------
        var id openapi_types.UUID

        err = runtime.BindStyledParameterWithOptions("simple", "id", ctx.Param("id"), &amp;id, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
        if err != nil </span><span class="cov0" title="0">{
                return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter id: %s", err))
        }</span>

        <span class="cov0" title="0">ctx.Set(BearerAuthScopes, []string{})

        // Invoke the callback with all the unmarshaled arguments
        err = w.Handler.DeleteArtifact(ctx, id)
        return err</span>
}

// GetOneArtifact converts echo context to params.
func (w *ServerInterfaceWrapper) GetOneArtifact(ctx echo.Context) error <span class="cov0" title="0">{
        var err error
        // ------------- Path parameter "id" -------------
        var id openapi_types.UUID

        err = runtime.BindStyledParameterWithOptions("simple", "id", ctx.Param("id"), &amp;id, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
        if err != nil </span><span class="cov0" title="0">{
                return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter id: %s", err))
        }</span>

        <span class="cov0" title="0">ctx.Set(BearerAuthScopes, []string{})

        // Invoke the callback with all the unmarshaled arguments
        err = w.Handler.GetOneArtifact(ctx, id)
        return err</span>
}

// UpdateArtifact converts echo context to params.
func (w *ServerInterfaceWrapper) UpdateArtifact(ctx echo.Context) error <span class="cov0" title="0">{
        var err error
        // ------------- Path parameter "id" -------------
        var id openapi_types.UUID

        err = runtime.BindStyledParameterWithOptions("simple", "id", ctx.Param("id"), &amp;id, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
        if err != nil </span><span class="cov0" title="0">{
                return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter id: %s", err))
        }</span>

        <span class="cov0" title="0">ctx.Set(BearerAuthScopes, []string{})

        // Invoke the callback with all the unmarshaled arguments
        err = w.Handler.UpdateArtifact(ctx, id)
        return err</span>
}

// This is a simple interface which specifies echo.Route addition functions which
// are present on both echo.Echo and echo.Group, since we want to allow using
// either of them for path registration
type EchoRouter interface {
        CONNECT(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
        DELETE(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
        GET(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
        HEAD(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
        OPTIONS(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
        PATCH(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
        POST(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
        PUT(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
        TRACE(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
}

// RegisterHandlers adds each server route to the EchoRouter.
func RegisterHandlers(router EchoRouter, si ServerInterface) <span class="cov0" title="0">{
        RegisterHandlersWithBaseURL(router, si, "")
}</span>

// Registers handlers, and prepends BaseURL to the paths, so that the paths
// can be served under a prefix.
func RegisterHandlersWithBaseURL(router EchoRouter, si ServerInterface, baseURL string) <span class="cov0" title="0">{

        wrapper := ServerInterfaceWrapper{
                Handler: si,
        }

        router.GET(baseURL+"/content/artifacts", wrapper.FindManyArtifacts)
        router.POST(baseURL+"/content/artifacts", wrapper.CreateArtifact)
        router.DELETE(baseURL+"/content/artifacts/:id", wrapper.DeleteArtifact)
        router.GET(baseURL+"/content/artifacts/:id", wrapper.GetOneArtifact)
        router.PATCH(baseURL+"/content/artifacts/:id", wrapper.UpdateArtifact)

}</span>

type BadRequestApplicationProblemPlusJSONResponse Problem

type NotFoundApplicationProblemPlusJSONResponse Problem

type UnauthorizedApplicationProblemPlusJSONResponse Problem

type FindManyArtifactsRequestObject struct {
        Params FindManyArtifactsParams
}

type FindManyArtifactsResponseObject interface {
        VisitFindManyArtifactsResponse(w http.ResponseWriter) error
}

type FindManyArtifacts200JSONResponse struct {
        Data []Artifact `json:"data"`
        Meta struct {
                // Total Total number of items in the collection
                Total float32 `json:"total"`
        } `json:"meta"`
}

func (response FindManyArtifacts200JSONResponse) VisitFindManyArtifactsResponse(w http.ResponseWriter) error <span class="cov0" title="0">{
        w.Header().Set("Content-Type", "application/json")
        w.WriteHeader(200)

        return json.NewEncoder(w).Encode(response)
}</span>

type FindManyArtifacts400ApplicationProblemPlusJSONResponse struct {
        BadRequestApplicationProblemPlusJSONResponse
}

func (response FindManyArtifacts400ApplicationProblemPlusJSONResponse) VisitFindManyArtifactsResponse(w http.ResponseWriter) error <span class="cov0" title="0">{
        w.Header().Set("Content-Type", "application/problem+json")
        w.WriteHeader(400)

        return json.NewEncoder(w).Encode(response)
}</span>

type FindManyArtifacts401ApplicationProblemPlusJSONResponse struct {
        UnauthorizedApplicationProblemPlusJSONResponse
}

func (response FindManyArtifacts401ApplicationProblemPlusJSONResponse) VisitFindManyArtifactsResponse(w http.ResponseWriter) error <span class="cov0" title="0">{
        w.Header().Set("Content-Type", "application/problem+json")
        w.WriteHeader(401)

        return json.NewEncoder(w).Encode(response)
}</span>

type CreateArtifactRequestObject struct {
        Body *CreateArtifactJSONRequestBody
}

type CreateArtifactResponseObject interface {
        VisitCreateArtifactResponse(w http.ResponseWriter) error
}

type CreateArtifact201JSONResponse struct {
        // Data Schema for Artifact entity
        Data Artifact `json:"data"`
}

func (response CreateArtifact201JSONResponse) VisitCreateArtifactResponse(w http.ResponseWriter) error <span class="cov0" title="0">{
        w.Header().Set("Content-Type", "application/json")
        w.WriteHeader(201)

        return json.NewEncoder(w).Encode(response)
}</span>

type CreateArtifact400ApplicationProblemPlusJSONResponse struct {
        BadRequestApplicationProblemPlusJSONResponse
}

func (response CreateArtifact400ApplicationProblemPlusJSONResponse) VisitCreateArtifactResponse(w http.ResponseWriter) error <span class="cov0" title="0">{
        w.Header().Set("Content-Type", "application/problem+json")
        w.WriteHeader(400)

        return json.NewEncoder(w).Encode(response)
}</span>

type CreateArtifact401ApplicationProblemPlusJSONResponse struct {
        UnauthorizedApplicationProblemPlusJSONResponse
}

func (response CreateArtifact401ApplicationProblemPlusJSONResponse) VisitCreateArtifactResponse(w http.ResponseWriter) error <span class="cov0" title="0">{
        w.Header().Set("Content-Type", "application/problem+json")
        w.WriteHeader(401)

        return json.NewEncoder(w).Encode(response)
}</span>

type DeleteArtifactRequestObject struct {
        Id openapi_types.UUID `json:"id"`
}

type DeleteArtifactResponseObject interface {
        VisitDeleteArtifactResponse(w http.ResponseWriter) error
}

type DeleteArtifact200JSONResponse struct {
        // Data Schema for Artifact entity
        Data Artifact `json:"data"`
}

func (response DeleteArtifact200JSONResponse) VisitDeleteArtifactResponse(w http.ResponseWriter) error <span class="cov0" title="0">{
        w.Header().Set("Content-Type", "application/json")
        w.WriteHeader(200)

        return json.NewEncoder(w).Encode(response)
}</span>

type DeleteArtifact404ApplicationProblemPlusJSONResponse struct {
        NotFoundApplicationProblemPlusJSONResponse
}

func (response DeleteArtifact404ApplicationProblemPlusJSONResponse) VisitDeleteArtifactResponse(w http.ResponseWriter) error <span class="cov0" title="0">{
        w.Header().Set("Content-Type", "application/problem+json")
        w.WriteHeader(404)

        return json.NewEncoder(w).Encode(response)
}</span>

type GetOneArtifactRequestObject struct {
        Id openapi_types.UUID `json:"id"`
}

type GetOneArtifactResponseObject interface {
        VisitGetOneArtifactResponse(w http.ResponseWriter) error
}

type GetOneArtifact200JSONResponse struct {
        // Data Schema for Artifact entity
        Data Artifact `json:"data"`
}

func (response GetOneArtifact200JSONResponse) VisitGetOneArtifactResponse(w http.ResponseWriter) error <span class="cov0" title="0">{
        w.Header().Set("Content-Type", "application/json")
        w.WriteHeader(200)

        return json.NewEncoder(w).Encode(response)
}</span>

type GetOneArtifact404ApplicationProblemPlusJSONResponse struct {
        NotFoundApplicationProblemPlusJSONResponse
}

func (response GetOneArtifact404ApplicationProblemPlusJSONResponse) VisitGetOneArtifactResponse(w http.ResponseWriter) error <span class="cov0" title="0">{
        w.Header().Set("Content-Type", "application/problem+json")
        w.WriteHeader(404)

        return json.NewEncoder(w).Encode(response)
}</span>

type UpdateArtifactRequestObject struct {
        Id   openapi_types.UUID `json:"id"`
        Body *UpdateArtifactJSONRequestBody
}

type UpdateArtifactResponseObject interface {
        VisitUpdateArtifactResponse(w http.ResponseWriter) error
}

type UpdateArtifact200JSONResponse struct {
        // Data Schema for Artifact entity
        Data Artifact `json:"data"`
}

func (response UpdateArtifact200JSONResponse) VisitUpdateArtifactResponse(w http.ResponseWriter) error <span class="cov0" title="0">{
        w.Header().Set("Content-Type", "application/json")
        w.WriteHeader(200)

        return json.NewEncoder(w).Encode(response)
}</span>

type UpdateArtifact404ApplicationProblemPlusJSONResponse struct {
        NotFoundApplicationProblemPlusJSONResponse
}

func (response UpdateArtifact404ApplicationProblemPlusJSONResponse) VisitUpdateArtifactResponse(w http.ResponseWriter) error <span class="cov0" title="0">{
        w.Header().Set("Content-Type", "application/problem+json")
        w.WriteHeader(404)

        return json.NewEncoder(w).Encode(response)
}</span>

// StrictServerInterface represents all server handlers.
type StrictServerInterface interface {
        // Find many artifacts
        // (GET /content/artifacts)
        FindManyArtifacts(ctx context.Context, request FindManyArtifactsRequestObject) (FindManyArtifactsResponseObject, error)
        // Create a new artifact
        // (POST /content/artifacts)
        CreateArtifact(ctx context.Context, request CreateArtifactRequestObject) (CreateArtifactResponseObject, error)
        // Delete an artifact
        // (DELETE /content/artifacts/{id})
        DeleteArtifact(ctx context.Context, request DeleteArtifactRequestObject) (DeleteArtifactResponseObject, error)
        // Find an artifact
        // (GET /content/artifacts/{id})
        GetOneArtifact(ctx context.Context, request GetOneArtifactRequestObject) (GetOneArtifactResponseObject, error)
        // Update an artifact
        // (PATCH /content/artifacts/{id})
        UpdateArtifact(ctx context.Context, request UpdateArtifactRequestObject) (UpdateArtifactResponseObject, error)
}

type StrictHandlerFunc = strictecho.StrictEchoHandlerFunc
type StrictMiddlewareFunc = strictecho.StrictEchoMiddlewareFunc

func NewStrictHandler(ssi StrictServerInterface, middlewares []StrictMiddlewareFunc) ServerInterface <span class="cov0" title="0">{
        return &amp;strictHandler{ssi: ssi, middlewares: middlewares}
}</span>

type strictHandler struct {
        ssi         StrictServerInterface
        middlewares []StrictMiddlewareFunc
}

// FindManyArtifacts operation middleware
func (sh *strictHandler) FindManyArtifacts(ctx echo.Context, params FindManyArtifactsParams) error <span class="cov0" title="0">{
        var request FindManyArtifactsRequestObject

        request.Params = params

        handler := func(ctx echo.Context, request interface{}) (interface{}, error) </span><span class="cov0" title="0">{
                return sh.ssi.FindManyArtifacts(ctx.Request().Context(), request.(FindManyArtifactsRequestObject))
        }</span>
        <span class="cov0" title="0">for _, middleware := range sh.middlewares </span><span class="cov0" title="0">{
                handler = middleware(handler, "FindManyArtifacts")
        }</span>

        <span class="cov0" title="0">response, err := handler(ctx, request)

        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span> else<span class="cov0" title="0"> if validResponse, ok := response.(FindManyArtifactsResponseObject); ok </span><span class="cov0" title="0">{
                return validResponse.VisitFindManyArtifactsResponse(ctx.Response())
        }</span> else<span class="cov0" title="0"> if response != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("unexpected response type: %T", response)
        }</span>
        <span class="cov0" title="0">return nil</span>
}

// CreateArtifact operation middleware
func (sh *strictHandler) CreateArtifact(ctx echo.Context) error <span class="cov0" title="0">{
        var request CreateArtifactRequestObject

        var body CreateArtifactJSONRequestBody
        if err := ctx.Bind(&amp;body); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov0" title="0">request.Body = &amp;body

        handler := func(ctx echo.Context, request interface{}) (interface{}, error) </span><span class="cov0" title="0">{
                return sh.ssi.CreateArtifact(ctx.Request().Context(), request.(CreateArtifactRequestObject))
        }</span>
        <span class="cov0" title="0">for _, middleware := range sh.middlewares </span><span class="cov0" title="0">{
                handler = middleware(handler, "CreateArtifact")
        }</span>

        <span class="cov0" title="0">response, err := handler(ctx, request)

        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span> else<span class="cov0" title="0"> if validResponse, ok := response.(CreateArtifactResponseObject); ok </span><span class="cov0" title="0">{
                return validResponse.VisitCreateArtifactResponse(ctx.Response())
        }</span> else<span class="cov0" title="0"> if response != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("unexpected response type: %T", response)
        }</span>
        <span class="cov0" title="0">return nil</span>
}

// DeleteArtifact operation middleware
func (sh *strictHandler) DeleteArtifact(ctx echo.Context, id openapi_types.UUID) error <span class="cov0" title="0">{
        var request DeleteArtifactRequestObject

        request.Id = id

        handler := func(ctx echo.Context, request interface{}) (interface{}, error) </span><span class="cov0" title="0">{
                return sh.ssi.DeleteArtifact(ctx.Request().Context(), request.(DeleteArtifactRequestObject))
        }</span>
        <span class="cov0" title="0">for _, middleware := range sh.middlewares </span><span class="cov0" title="0">{
                handler = middleware(handler, "DeleteArtifact")
        }</span>

        <span class="cov0" title="0">response, err := handler(ctx, request)

        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span> else<span class="cov0" title="0"> if validResponse, ok := response.(DeleteArtifactResponseObject); ok </span><span class="cov0" title="0">{
                return validResponse.VisitDeleteArtifactResponse(ctx.Response())
        }</span> else<span class="cov0" title="0"> if response != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("unexpected response type: %T", response)
        }</span>
        <span class="cov0" title="0">return nil</span>
}

// GetOneArtifact operation middleware
func (sh *strictHandler) GetOneArtifact(ctx echo.Context, id openapi_types.UUID) error <span class="cov0" title="0">{
        var request GetOneArtifactRequestObject

        request.Id = id

        handler := func(ctx echo.Context, request interface{}) (interface{}, error) </span><span class="cov0" title="0">{
                return sh.ssi.GetOneArtifact(ctx.Request().Context(), request.(GetOneArtifactRequestObject))
        }</span>
        <span class="cov0" title="0">for _, middleware := range sh.middlewares </span><span class="cov0" title="0">{
                handler = middleware(handler, "GetOneArtifact")
        }</span>

        <span class="cov0" title="0">response, err := handler(ctx, request)

        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span> else<span class="cov0" title="0"> if validResponse, ok := response.(GetOneArtifactResponseObject); ok </span><span class="cov0" title="0">{
                return validResponse.VisitGetOneArtifactResponse(ctx.Response())
        }</span> else<span class="cov0" title="0"> if response != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("unexpected response type: %T", response)
        }</span>
        <span class="cov0" title="0">return nil</span>
}

// UpdateArtifact operation middleware
func (sh *strictHandler) UpdateArtifact(ctx echo.Context, id openapi_types.UUID) error <span class="cov0" title="0">{
        var request UpdateArtifactRequestObject

        request.Id = id

        var body UpdateArtifactJSONRequestBody
        if err := ctx.Bind(&amp;body); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov0" title="0">request.Body = &amp;body

        handler := func(ctx echo.Context, request interface{}) (interface{}, error) </span><span class="cov0" title="0">{
                return sh.ssi.UpdateArtifact(ctx.Request().Context(), request.(UpdateArtifactRequestObject))
        }</span>
        <span class="cov0" title="0">for _, middleware := range sh.middlewares </span><span class="cov0" title="0">{
                handler = middleware(handler, "UpdateArtifact")
        }</span>

        <span class="cov0" title="0">response, err := handler(ctx, request)

        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span> else<span class="cov0" title="0"> if validResponse, ok := response.(UpdateArtifactResponseObject); ok </span><span class="cov0" title="0">{
                return validResponse.VisitUpdateArtifactResponse(ctx.Response())
        }</span> else<span class="cov0" title="0"> if response != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("unexpected response type: %T", response)
        }</span>
        <span class="cov0" title="0">return nil</span>
}
</pre>
		
		<pre class="file" id="file12" style="display: none">// Code generated by codegen repository. DO NOT EDIT.
package artifacts

import (
        "context"
        "errors"

        "github.com/archesai/archesai/internal/database/postgresql"
        "github.com/google/uuid"
        "github.com/jackc/pgx/v5/pgxpool"
)

// PostgresRepository implements Repository using PostgreSQL.
type PostgresRepository struct {
        db      *pgxpool.Pool
        queries *postgresql.Queries
}

// NewPostgresRepository creates a new PostgreSQL repository.
func NewPostgresRepository(db *pgxpool.Pool) Repository <span class="cov0" title="0">{
        return &amp;PostgresRepository{
                db:      db,
                queries: postgresql.New(db),
        }
}</span>

// Artifact operations

func (r *PostgresRepository) Create(ctx context.Context, entity *Artifact) (*Artifact, error) <span class="cov0" title="0">{
        // Check if SQLC has the CreateArtifact method
        // For now, we'll generate a stub but with proper error handling
        // TODO: Parse SQLC to detect available queries

        // Example of what it should look like when SQLC query exists:
        // params := postgresql.CreateArtifactParams{
        //     Id: entity.Id,
        //     // ... map other fields
        // }
        // dbArtifact, err := r.queries.CreateArtifact(ctx, params)
        // if err != nil {
        //     return nil, NewRepositoryError("create", err)
        // }
        // return mapArtifactToDomain(&amp;dbArtifact), nil

        return nil, NewRepositoryError("create", errors.New("not implemented - SQLC query not found"))
}</span>

func (r *PostgresRepository) Get(ctx context.Context, id uuid.UUID) (*Artifact, error) <span class="cov0" title="0">{
        // Try to call SQLC GetArtifact if it exists
        // For now, return not implemented
        return nil, NewRepositoryError("get", errors.New("not implemented - SQLC query not found"))
}</span>

func (r *PostgresRepository) Update(ctx context.Context, id uuid.UUID, entity *Artifact) (*Artifact, error) <span class="cov0" title="0">{
        // Update operations are often custom and may not have SQLC queries
        return nil, NewRepositoryError("update", errors.New("not implemented - SQLC query not found"))
}</span>

func (r *PostgresRepository) Delete(ctx context.Context, id uuid.UUID) error <span class="cov0" title="0">{
        // Try to call SQLC DeleteArtifact if it exists
        // For now, return not implemented
        return NewRepositoryError("delete", errors.New("not implemented - SQLC query not found"))
}</span>

func (r *PostgresRepository) List(ctx context.Context, params ListArtifactsParams) ([]*Artifact, int64, error) <span class="cov0" title="0">{
        // List operations need both List and Count queries from SQLC
        return nil, 0, NewRepositoryError("list", errors.New("not implemented - SQLC query not found"))
}</span>

// ListByOrganization retrieves multiple artifacts by organizationId
func (r *PostgresRepository) ListByOrganization(ctx context.Context, organizationId string) ([]*Artifact, error) <span class="cov0" title="0">{

        // Try to call SQLC ListByOrganization if it exists
        // For now, return not implemented
        return nil, NewRepositoryError("listbyorganization", errors.New("not implemented - SQLC query not found"))

}</span>

// ListByProducer retrieves multiple artifacts by producerId
func (r *PostgresRepository) ListByProducer(ctx context.Context, producerId string) ([]*Artifact, error) <span class="cov0" title="0">{

        // Try to call SQLC ListByProducer if it exists
        // For now, return not implemented
        return nil, NewRepositoryError("listbyproducer", errors.New("not implemented - SQLC query not found"))

}</span>

// Mapper functions - Convert between domain types and database types
// These need to be customized based on the actual field mappings

func mapArtifactToDomain(db *postgresql.Artifact) *Artifact <span class="cov0" title="0">{
        if db == nil </span><span class="cov0" title="0">{
                return nil
        }</span>

        // This is a basic mapping - needs to be customized based on actual types
        // The challenge is that OpenAPI types and database types don't always match
        // For example:
        // - OpenAPI might use string, database uses *string
        // - OpenAPI might use custom UUID type, database uses uuid.UUID
        // - Field names might differ (Id vs ID)

        <span class="cov0" title="0">result := &amp;Artifact{
                // TODO: Map fields properly based on actual type definitions
                // This requires parsing both OpenAPI types and SQLC types
        }

        // Basic field mapping - customize based on your entity structure
        // result.Id = db.Id
        // result.CreatedAt = db.CreatedAt
        // result.UpdatedAt = db.UpdatedAt
        // Add specific field mappings as needed

        return result</span>
}
</pre>
		
		<pre class="file" id="file13" style="display: none">// Code generated by codegen repository. DO NOT EDIT.
package artifacts

import (
        "context"
        "fmt"
        "github.com/google/uuid"
)

// Repository handles artifact persistence
type Repository interface {
        Create(ctx context.Context, entity *Artifact) (*Artifact, error)
        Get(ctx context.Context, id uuid.UUID) (*Artifact, error)
        Update(ctx context.Context, id uuid.UUID, entity *Artifact) (*Artifact, error)
        Delete(ctx context.Context, id uuid.UUID) error
        List(ctx context.Context, params ListArtifactsParams) ([]*Artifact, int64, error)

        // Additional operations
        ListByOrganization(ctx context.Context, organizationId string) ([]*Artifact, error)
        ListByProducer(ctx context.Context, producerId string) ([]*Artifact, error)
}

// ListArtifactsParams represents parameters for listing artifacts.
type ListArtifactsParams struct {
        Limit  int
        Offset int
}

// RepositoryError represents a repository error.
type RepositoryError struct {
        Operation string
        Err       error
}

func (e *RepositoryError) Error() string <span class="cov0" title="0">{
        return fmt.Sprintf("repository %s: %v", e.Operation, e.Err)
}</span>

func (e *RepositoryError) Unwrap() error <span class="cov0" title="0">{
        return e.Err
}</span>

// NewRepositoryError creates a new repository error.
func NewRepositoryError(operation string, err error) *RepositoryError <span class="cov0" title="0">{
        return &amp;RepositoryError{
                Operation: operation,
                Err:       err,
        }
}</span>
</pre>
		
		<pre class="file" id="file14" style="display: none">package artifacts

import (
        "context"
        "database/sql"
        "errors"
        "fmt"
        "log/slog"
        "strings"
        "time"

        "github.com/archesai/archesai/internal/labels"
        "github.com/google/uuid"
)

// Service provides artifact business logic
type Service struct {
        repo         Repository
        labelRepo    labels.Repository // For label operations
        logger       *slog.Logger
        maxSize      int // Max artifact size in bytes
        cacheEnabled bool
}

// ServiceConfig contains configuration for the artifacts service
type ServiceConfig struct {
        MaxArtifactSize int
        CacheEnabled    bool
}

// NewArtifactsService creates a new artifacts service
func NewArtifactsService(repo Repository, labelRepo labels.Repository, logger *slog.Logger) *Service <span class="cov10" title="9">{
        return &amp;Service{
                repo:      repo,
                labelRepo: labelRepo,
                logger:    logger,
                maxSize:   MaxArtifactSize,
        }
}</span>

// NewArtifactsServiceWithConfig creates a new artifacts service with custom configuration
func NewArtifactsServiceWithConfig(repo Repository, labelRepo labels.Repository, config ServiceConfig, logger *slog.Logger) *Service <span class="cov0" title="0">{
        maxSize := config.MaxArtifactSize
        if maxSize &lt;= 0 </span><span class="cov0" title="0">{
                maxSize = MaxArtifactSize
        }</span>

        <span class="cov0" title="0">return &amp;Service{
                repo:         repo,
                labelRepo:    labelRepo,
                logger:       logger,
                maxSize:      maxSize,
                cacheEnabled: config.CacheEnabled,
        }</span>
}

// Create creates a new artifact with validation and processing
func (s *Service) Create(ctx context.Context, req *CreateArtifactJSONRequestBody, orgID, producerID string) (*Artifact, error) <span class="cov3" title="2">{
        s.logger.Debug("creating artifact",
                slog.String("org", orgID),
                slog.String("producer", producerID),
                slog.String("name", req.Name))

        // Validate inputs
        if err := s.validateCreateRequest(req); err != nil </span><span class="cov1" title="1">{
                return nil, fmt.Errorf("validation failed: %w", err)
        }</span>

        // Validate organization ID
        <span class="cov1" title="1">if orgID == "" </span><span class="cov0" title="0">{
                return nil, errors.New("organization ID is required")
        }</span>

        // Validate producer ID
        <span class="cov1" title="1">if producerID == "" </span><span class="cov0" title="0">{
                return nil, errors.New("producer ID is required")
        }</span>

        // Prepare artifact
        <span class="cov1" title="1">artifact := &amp;Artifact{
                Id:             uuid.New(),
                Name:           s.sanitizeName(req.Name),
                Text:           req.Text,
                OrganizationId: orgID,
                ProducerId:     producerID,
                Credits:        float32(s.calculateCredits(req.Text)),
                CreatedAt:      time.Now().UTC(),
                UpdatedAt:      time.Now().UTC(),
        }

        // Create artifact in repository
        createdArtifact, err := s.repo.Create(ctx, artifact)
        if err != nil </span><span class="cov0" title="0">{
                s.logger.Error("failed to create artifact",
                        slog.String("error", err.Error()),
                        slog.String("org", orgID))
                return nil, fmt.Errorf("failed to create artifact: %w", err)
        }</span>

        // Handle labels if provided (future implementation)
        // This would involve a many-to-many relationship table

        <span class="cov1" title="1">s.logger.Info("artifact created successfully",
                slog.String("id", createdArtifact.Id.String()),
                slog.String("name", createdArtifact.Name),
                slog.String("org", orgID))

        return createdArtifact, nil</span>
}

// Get retrieves an artifact by ID with proper error handling
func (s *Service) Get(ctx context.Context, id uuid.UUID) (*Artifact, error) <span class="cov8" title="6">{
        if id == uuid.Nil </span><span class="cov0" title="0">{
                return nil, errors.New("invalid artifact ID")
        }</span>

        <span class="cov8" title="6">artifact, err := s.repo.Get(ctx, id)
        if err != nil </span><span class="cov5" title="3">{
                if errors.Is(err, sql.ErrNoRows) </span><span class="cov0" title="0">{
                        return nil, ErrArtifactNotFound
                }</span>
                <span class="cov5" title="3">s.logger.Error("failed to get artifact",
                        slog.String("id", id.String()),
                        slog.String("error", err.Error()))
                return nil, fmt.Errorf("failed to get artifact: %w", err)</span>
        }

        <span class="cov5" title="3">return artifact, nil</span>
}

// Update updates an artifact with validation
func (s *Service) Update(ctx context.Context, id uuid.UUID, req *UpdateArtifactJSONRequestBody) (*Artifact, error) <span class="cov3" title="2">{
        if id == uuid.Nil </span><span class="cov0" title="0">{
                return nil, errors.New("invalid artifact ID")
        }</span>

        // Get existing artifact
        <span class="cov3" title="2">artifact, err := s.Get(ctx, id)
        if err != nil </span><span class="cov1" title="1">{
                return nil, err
        }</span>

        // Track if any changes were made
        <span class="cov1" title="1">hasChanges := false

        // Update name if provided
        if req.Name != "" &amp;&amp; req.Name != artifact.Name </span><span class="cov1" title="1">{
                artifact.Name = s.sanitizeName(req.Name)
                hasChanges = true
        }</span>

        // Update text if provided
        <span class="cov1" title="1">if req.Text != "" &amp;&amp; req.Text != artifact.Text </span><span class="cov1" title="1">{
                if err := s.validateTextSize(req.Text); err != nil </span><span class="cov0" title="0">{
                        return nil, err
                }</span>
                <span class="cov1" title="1">artifact.Text = req.Text
                artifact.Credits = float32(s.calculateCredits(req.Text))
                hasChanges = true</span>
        }

        // Only update if changes were made
        <span class="cov1" title="1">if !hasChanges </span><span class="cov0" title="0">{
                return artifact, nil
        }</span>

        <span class="cov1" title="1">artifact.UpdatedAt = time.Now().UTC()

        // Update in repository
        updatedArtifact, err := s.repo.Update(ctx, id, artifact)
        if err != nil </span><span class="cov0" title="0">{
                s.logger.Error("failed to update artifact",
                        slog.String("id", id.String()),
                        slog.String("error", err.Error()))
                return nil, fmt.Errorf("failed to update artifact: %w", err)
        }</span>

        <span class="cov1" title="1">s.logger.Info("artifact updated successfully",
                slog.String("id", id.String()))

        return updatedArtifact, nil</span>
}

// Delete deletes an artifact with proper cleanup
func (s *Service) Delete(ctx context.Context, id uuid.UUID) error <span class="cov3" title="2">{
        if id == uuid.Nil </span><span class="cov0" title="0">{
                return errors.New("invalid artifact ID")
        }</span>

        // Check if artifact exists
        <span class="cov3" title="2">_, err := s.Get(ctx, id)
        if err != nil </span><span class="cov1" title="1">{
                return err
        }</span>

        // Delete artifact (cascade delete should handle relationships)
        <span class="cov1" title="1">err = s.repo.Delete(ctx, id)
        if err != nil </span><span class="cov0" title="0">{
                s.logger.Error("failed to delete artifact",
                        slog.String("id", id.String()),
                        slog.String("error", err.Error()))
                return fmt.Errorf("failed to delete artifact: %w", err)
        }</span>

        <span class="cov1" title="1">s.logger.Info("artifact deleted successfully",
                slog.String("id", id.String()))

        return nil</span>
}

// List retrieves artifacts with pagination and filtering
func (s *Service) List(ctx context.Context, orgID string, limit, offset int) ([]*Artifact, int, error) <span class="cov1" title="1">{
        // Validate pagination parameters
        if limit &lt;= 0 </span><span class="cov0" title="0">{
                limit = 50 // Default limit
        }</span>
        <span class="cov1" title="1">if limit &gt; 1000 </span><span class="cov0" title="0">{
                limit = 1000 // Max limit
        }</span>
        <span class="cov1" title="1">if offset &lt; 0 </span><span class="cov0" title="0">{
                offset = 0
        }</span>

        <span class="cov1" title="1">params := ListArtifactsParams{
                Limit:  limit,
                Offset: offset,
                // TODO: Add organization filtering when repository supports it
        }

        artifacts, total, err := s.repo.List(ctx, params)
        if err != nil </span><span class="cov0" title="0">{
                s.logger.Error("failed to list artifacts",
                        slog.String("org", orgID),
                        slog.String("error", err.Error()))
                return nil, 0, fmt.Errorf("failed to list artifacts: %w", err)
        }</span>

        // Filter by organization if not handled by repository
        // This is temporary until repository layer supports filtering
        <span class="cov1" title="1">filtered := make([]*Artifact, 0, len(artifacts))
        for _, artifact := range artifacts </span><span class="cov3" title="2">{
                if artifact.OrganizationId == orgID </span><span class="cov3" title="2">{
                        filtered = append(filtered, artifact)
                }</span>
        }

        <span class="cov1" title="1">return filtered, int(total), nil</span>
}

// Search performs full-text search on artifacts
func (s *Service) Search(ctx context.Context, orgID, query string, limit, offset int) ([]*Artifact, int, error) <span class="cov0" title="0">{
        if query == "" </span><span class="cov0" title="0">{
                return s.List(ctx, orgID, limit, offset)
        }</span>

        // Validate pagination
        <span class="cov0" title="0">if limit &lt;= 0 </span><span class="cov0" title="0">{
                limit = 50
        }</span>
        <span class="cov0" title="0">if limit &gt; 100 </span><span class="cov0" title="0">{
                limit = 100 // Lower limit for search operations
        }</span>

        // TODO: Implement actual search functionality
        // This would typically use PostgreSQL full-text search or a dedicated search engine

        // For now, do a simple in-memory filter (not efficient for production)
        <span class="cov0" title="0">allArtifacts, _, err := s.List(ctx, orgID, 1000, 0)
        if err != nil </span><span class="cov0" title="0">{
                return nil, 0, err
        }</span>

        <span class="cov0" title="0">queryLower := strings.ToLower(query)
        var results []*Artifact
        for _, artifact := range allArtifacts </span><span class="cov0" title="0">{
                if strings.Contains(strings.ToLower(artifact.Name), queryLower) ||
                        strings.Contains(strings.ToLower(artifact.Text), queryLower) </span><span class="cov0" title="0">{
                        results = append(results, artifact)
                }</span>
        }

        // Apply pagination to results
        <span class="cov0" title="0">start := offset
        if start &gt; len(results) </span><span class="cov0" title="0">{
                start = len(results)
        }</span>
        <span class="cov0" title="0">end := start + limit
        if end &gt; len(results) </span><span class="cov0" title="0">{
                end = len(results)
        }</span>

        <span class="cov0" title="0">return results[start:end], len(results), nil</span>
}

// GetArtifactsByLabel retrieves artifacts that have a specific label
func (s *Service) GetArtifactsByLabel(ctx context.Context, labelID uuid.UUID, _, _ int) ([]*Artifact, int, error) <span class="cov0" title="0">{
        if labelID == uuid.Nil </span><span class="cov0" title="0">{
                return nil, 0, errors.New("invalid label ID")
        }</span>

        // Validate label exists
        <span class="cov0" title="0">_, err := s.labelRepo.Get(ctx, labelID)
        if err != nil </span><span class="cov0" title="0">{
                if errors.Is(err, sql.ErrNoRows) </span><span class="cov0" title="0">{
                        return nil, 0, ErrLabelNotFound
                }</span>
                <span class="cov0" title="0">return nil, 0, err</span>
        }

        // TODO: Implement when many-to-many relationship is added to database
        // This would query the artifact_labels junction table

        <span class="cov0" title="0">return []*Artifact{}, 0, nil</span>
}

// AddLabelToArtifact associates a label with an artifact
func (s *Service) AddLabelToArtifact(ctx context.Context, artifactID, labelID uuid.UUID) error <span class="cov0" title="0">{
        if artifactID == uuid.Nil || labelID == uuid.Nil </span><span class="cov0" title="0">{
                return errors.New("invalid artifact or label ID")
        }</span>

        // Validate artifact exists
        <span class="cov0" title="0">_, err := s.Get(ctx, artifactID)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        // Validate label exists
        <span class="cov0" title="0">_, err = s.labelRepo.Get(ctx, labelID)
        if err != nil </span><span class="cov0" title="0">{
                if errors.Is(err, sql.ErrNoRows) </span><span class="cov0" title="0">{
                        return ErrLabelNotFound
                }</span>
                <span class="cov0" title="0">return err</span>
        }

        // TODO: Implement when many-to-many relationship is added to database
        // This would insert into artifact_labels junction table

        <span class="cov0" title="0">s.logger.Info("label added to artifact",
                slog.String("artifact_id", artifactID.String()),
                slog.String("label_id", labelID.String()))

        return nil</span>
}

// RemoveLabelFromArtifact removes a label association from an artifact
func (s *Service) RemoveLabelFromArtifact(_ context.Context, artifactID, labelID uuid.UUID) error <span class="cov0" title="0">{
        if artifactID == uuid.Nil || labelID == uuid.Nil </span><span class="cov0" title="0">{
                return errors.New("invalid artifact or label ID")
        }</span>

        // TODO: Implement when many-to-many relationship is added to database
        // This would delete from artifact_labels junction table

        <span class="cov0" title="0">s.logger.Info("label removed from artifact",
                slog.String("artifact_id", artifactID.String()),
                slog.String("label_id", labelID.String()))

        return nil</span>
}

// GetLabelsByArtifact retrieves all labels for a specific artifact
func (s *Service) GetLabelsByArtifact(ctx context.Context, artifactID uuid.UUID) ([]*labels.Label, error) <span class="cov0" title="0">{
        if artifactID == uuid.Nil </span><span class="cov0" title="0">{
                return nil, errors.New("invalid artifact ID")
        }</span>

        // Validate artifact exists
        <span class="cov0" title="0">_, err := s.Get(ctx, artifactID)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        // TODO: Implement when many-to-many relationship is added to database
        // This would query the artifact_labels junction table

        <span class="cov0" title="0">return []*labels.Label{}, nil</span>
}

// Helper methods

// validateCreateRequest validates the create artifact request
func (s *Service) validateCreateRequest(req *CreateArtifactJSONRequestBody) error <span class="cov3" title="2">{
        if req == nil </span><span class="cov0" title="0">{
                return errors.New("request is required")
        }</span>

        <span class="cov3" title="2">if req.Text == "" </span><span class="cov0" title="0">{
                return errors.New("artifact text is required")
        }</span>

        <span class="cov3" title="2">return s.validateTextSize(req.Text)</span>
}

// validateTextSize checks if the text size is within limits
func (s *Service) validateTextSize(text string) error <span class="cov5" title="3">{
        size := len([]byte(text))
        if size &gt; s.maxSize </span><span class="cov1" title="1">{
                return fmt.Errorf("%w: size %d exceeds maximum %d", ErrArtifactTooLarge, size, s.maxSize)
        }</span>
        <span class="cov3" title="2">return nil</span>
}

// sanitizeName cleans and validates the artifact name
func (s *Service) sanitizeName(name string) string <span class="cov3" title="2">{
        // Trim whitespace
        name = strings.TrimSpace(name)

        // Limit length
        if len(name) &gt; 255 </span><span class="cov0" title="0">{
                name = name[:255]
        }</span>

        <span class="cov3" title="2">return name</span>
}

// calculateCredits calculates the credit cost for an artifact based on its size
func (s *Service) calculateCredits(text string) float64 <span class="cov3" title="2">{
        // Simple calculation: 1 credit per 1000 characters
        // This can be adjusted based on business requirements
        return float64(len(text)) / 1000.0
}</span>

// BulkCreateArtifacts creates multiple artifacts in a single operation
func (s *Service) BulkCreateArtifacts(ctx context.Context, artifacts []*CreateArtifactJSONRequestBody, orgID, producerID string) ([]*Artifact, error) <span class="cov0" title="0">{
        if len(artifacts) == 0 </span><span class="cov0" title="0">{
                return nil, errors.New("no artifacts to create")
        }</span>

        <span class="cov0" title="0">if len(artifacts) &gt; 100 </span><span class="cov0" title="0">{
                return nil, errors.New("bulk create limited to 100 artifacts")
        }</span>

        <span class="cov0" title="0">created := make([]*Artifact, 0, len(artifacts))
        for _, req := range artifacts </span><span class="cov0" title="0">{
                artifact, err := s.Create(ctx, req, orgID, producerID)
                if err != nil </span><span class="cov0" title="0">{
                        // Log error but continue with other artifacts
                        s.logger.Error("failed to create artifact in bulk operation",
                                slog.String("name", req.Name),
                                slog.String("error", err.Error()))
                        continue</span>
                }
                <span class="cov0" title="0">created = append(created, artifact)</span>
        }

        <span class="cov0" title="0">if len(created) == 0 </span><span class="cov0" title="0">{
                return nil, errors.New("all artifacts failed to create")
        }</span>

        <span class="cov0" title="0">return created, nil</span>
}

// GetArtifactStats returns statistics for artifacts in an organization
func (s *Service) GetArtifactStats(ctx context.Context, orgID string) (map[string]interface{}, error) <span class="cov0" title="0">{
        // Get total count
        _, total, err := s.List(ctx, orgID, 1, 0)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov0" title="0">stats := map[string]interface{}{
                "total_artifacts": total,
                "organization_id": orgID,
                "timestamp":       time.Now().UTC(),
        }

        return stats, nil</span>
}
</pre>
		
		<pre class="file" id="file15" style="display: none">// Code generated by codegen repository. DO NOT EDIT.
package artifacts

import (
        "context"
        "database/sql"
        "fmt"

        "github.com/archesai/archesai/internal/database/sqlite"
        "github.com/google/uuid"
)

// SQLiteRepository implements Repository using SQLite.
type SQLiteRepository struct {
        db      *sql.DB
        queries *sqlite.Queries
}

// NewSQLiteRepository creates a new SQLite repository.
func NewSQLiteRepository(db *sql.DB) Repository <span class="cov0" title="0">{
        return &amp;SQLiteRepository{
                db:      db,
                queries: sqlite.New(db),
        }
}</span>

// Artifact operations

func (r *SQLiteRepository) Create(ctx context.Context, entity *Artifact) (*Artifact, error) <span class="cov0" title="0">{
        // For now, return a basic implementation
        // Actual implementation would need to be customized per entity
        return nil, fmt.Errorf("CreateArtifact not yet implemented - requires custom mapping")
}</span>

func (r *SQLiteRepository) Get(ctx context.Context, id uuid.UUID) (*Artifact, error) <span class="cov0" title="0">{
        // For now, return a basic implementation
        // Actual implementation would need to be customized per entity
        return nil, fmt.Errorf("GetArtifact not yet implemented - requires custom mapping")
}</span>

func (r *SQLiteRepository) Update(ctx context.Context, id uuid.UUID, entity *Artifact) (*Artifact, error) <span class="cov0" title="0">{
        // For now, return a basic implementation
        // Actual implementation would need to be customized per entity
        return nil, fmt.Errorf("UpdateArtifact not yet implemented - requires custom mapping")
}</span>

func (r *SQLiteRepository) Delete(ctx context.Context, id uuid.UUID) error <span class="cov0" title="0">{
        // For now, return a basic implementation
        // Actual implementation would need to be customized per entity
        return fmt.Errorf("DeleteArtifact not yet implemented - requires custom mapping")
}</span>

func (r *SQLiteRepository) List(ctx context.Context, params ListArtifactsParams) ([]*Artifact, int64, error) <span class="cov0" title="0">{
        // For now, return a basic implementation
        // Actual implementation would need to be customized per entity
        return nil, 0, fmt.Errorf("ListArtifacts not yet implemented - requires custom mapping")
}</span>

// ListByOrganization retrieves multiple artifacts by organizationId
func (r *SQLiteRepository) ListByOrganization(ctx context.Context, organizationId string) ([]*Artifact, error) <span class="cov0" title="0">{

        // For now, return a basic implementation
        return nil, fmt.Errorf("ListByOrganization not yet implemented - requires custom mapping")

}</span>

// ListByProducer retrieves multiple artifacts by producerId
func (r *SQLiteRepository) ListByProducer(ctx context.Context, producerId string) ([]*Artifact, error) <span class="cov0" title="0">{

        // For now, return a basic implementation
        return nil, fmt.Errorf("ListByProducer not yet implemented - requires custom mapping")

}</span>
</pre>
		
		<pre class="file" id="file16" style="display: none">// Package artifacts provides primitives to interact with the openapi HTTP API.
//
// Code generated by github.com/oapi-codegen/oapi-codegen/v2 version v2.5.0 DO NOT EDIT.
package artifacts

import (
        "encoding/json"
        "time"

        "github.com/oapi-codegen/runtime"
        openapi_types "github.com/oapi-codegen/runtime/types"
)

const (
        BearerAuthScopes = "bearerAuth.Scopes"
)

// Defines values for FindManyArtifactsParamsSortField.
const (
        CreatedAt      FindManyArtifactsParamsSortField = "createdAt"
        Credits        FindManyArtifactsParamsSortField = "credits"
        Description    FindManyArtifactsParamsSortField = "description"
        Id             FindManyArtifactsParamsSortField = "id"
        MimeType       FindManyArtifactsParamsSortField = "mimeType"
        Name           FindManyArtifactsParamsSortField = "name"
        OrganizationId FindManyArtifactsParamsSortField = "organizationId"
        PreviewImage   FindManyArtifactsParamsSortField = "previewImage"
        ProducerId     FindManyArtifactsParamsSortField = "producerId"
        Text           FindManyArtifactsParamsSortField = "text"
        UpdatedAt      FindManyArtifactsParamsSortField = "updatedAt"
        Url            FindManyArtifactsParamsSortField = "url"
)

// Defines values for FindManyArtifactsParamsSortOrder.
const (
        Asc  FindManyArtifactsParamsSortOrder = "asc"
        Desc FindManyArtifactsParamsSortOrder = "desc"
)

// Artifact Schema for Artifact entity
type Artifact struct {
        // CreatedAt The date this item was created
        CreatedAt time.Time `json:"createdAt" yaml:"createdAt"`

        // Credits The number of credits required to access this artifact. This is used for metering and billing purposes.
        Credits float32 `json:"credits" yaml:"credits"`

        // Description The artifact's description
        Description string `json:"description,omitempty,omitzero" yaml:"description,omitempty"`

        // Id The ID of the item
        Id openapi_types.UUID `json:"id" yaml:"id"`

        // MimeType The MIME type of the artifact, e.g. image/png
        MimeType string `json:"mimeType" yaml:"mimeType"`

        // Name The name of the artifact, used for display purposes
        Name string `json:"name,omitempty,omitzero" yaml:"name,omitempty"`

        // OrganizationId The organization name
        OrganizationId string `json:"organizationId" yaml:"organizationId"`

        // PreviewImage The URL of the preview image for this artifact. This is used for displaying a thumbnail in the UI.
        PreviewImage string `json:"previewImage,omitempty,omitzero" yaml:"previewImage,omitempty"`

        // ProducerId The ID of the run that produced this artifact, if applicable
        ProducerId string `json:"producerId,omitempty,omitzero" yaml:"producerId,omitempty"`

        // Text The artifact text
        Text string `json:"text" yaml:"text"`

        // UpdatedAt The date this item was last updated
        UpdatedAt time.Time `json:"updatedAt" yaml:"updatedAt"`
}

// FilterNode A recursive filter node that can be a condition or group
type FilterNode = interface{}

// Page Pagination (page number &amp; size)
type Page struct {
        Number int `json:"number,omitempty,omitzero" yaml:"number,omitempty"`
        Size   int `json:"size,omitempty,omitzero" yaml:"size,omitempty"`
}

// Problem RFC 7807 (Problem Details) compliant error response
type Problem struct {
        // Detail Human-readable explanation specific to this occurrence
        Detail string `json:"detail" yaml:"detail"`

        // Errors Additional validation errors for specific fields
        Errors []ValidationError `json:"errors,omitempty,omitzero" yaml:"errors,omitempty"`

        // Instance URI identifying the specific occurrence
        Instance string `json:"instance,omitempty,omitzero" yaml:"instance,omitempty"`

        // Status HTTP status code
        Status int `json:"status" yaml:"status"`

        // Title Short, human-readable summary
        Title string `json:"title" yaml:"title"`

        // Type URI identifying the problem type
        Type string `json:"type" yaml:"type"`
}

// ValidationError Individual field validation error
type ValidationError struct {
        // Field The field path that failed validation
        Field string `json:"field" yaml:"field"`

        // Message Human-readable error message
        Message string `json:"message" yaml:"message"`

        // Value The invalid value that was provided
        Value ValidationError_Value `json:"value,omitempty,omitzero" yaml:"value,omitempty"`
}

// ValidationErrorValue0 defines model for .
type ValidationErrorValue0 = string

// ValidationErrorValue1 defines model for .
type ValidationErrorValue1 = float32

// ValidationErrorValue2 defines model for .
type ValidationErrorValue2 = bool

// ValidationError_Value The invalid value that was provided
type ValidationError_Value struct {
        union json.RawMessage
}

// ArtifactsFilter A recursive filter node that can be a condition or group
type ArtifactsFilter = FilterNode

// ArtifactsSort defines model for ArtifactsSort.
type ArtifactsSort = []struct {
        Field string `json:"field" yaml:"field"`
        Order string `json:"order" yaml:"order"`
}

// PageQuery Pagination (page number &amp; size)
type PageQuery = Page

// BadRequest RFC 7807 (Problem Details) compliant error response
type BadRequest = Problem

// NotFound RFC 7807 (Problem Details) compliant error response
type NotFound = Problem

// Unauthorized RFC 7807 (Problem Details) compliant error response
type Unauthorized = Problem

// FindManyArtifactsParams defines parameters for FindManyArtifacts.
type FindManyArtifactsParams struct {
        // Filter Filter artifacts by field values. Supported fields:
        // - createdAt, id, updatedAt, credits, description, mimeType
        // - name, organizationId, previewImage, producerId, text, url
        Filter ArtifactsFilter `json:"filter,omitempty,omitzero" yaml:"filter,omitempty"`

        // Page The page parameter
        Page PageQuery `form:"page,omitempty" json:"page,omitempty,omitzero" yaml:"page,omitempty"`

        // Sort The sort parameter
        Sort ArtifactsSort `form:"sort,omitempty" json:"sort,omitempty,omitzero" yaml:"sort,omitempty"`
}

// FindManyArtifactsParamsSortField defines parameters for FindManyArtifacts.
type FindManyArtifactsParamsSortField string

// FindManyArtifactsParamsSortOrder defines parameters for FindManyArtifacts.
type FindManyArtifactsParamsSortOrder string

// CreateArtifactJSONBody defines parameters for CreateArtifact.
type CreateArtifactJSONBody struct {
        // Name The name of the artifact
        Name string `json:"name,omitempty,omitzero" yaml:"name,omitempty"`

        // Text The artifact text
        Text string `json:"text" yaml:"text"`
}

// UpdateArtifactJSONBody defines parameters for UpdateArtifact.
type UpdateArtifactJSONBody struct {
        // Name The name of the artifact
        Name string `json:"name,omitempty,omitzero" yaml:"name,omitempty"`

        // Text The artifact text
        Text string `json:"text,omitempty,omitzero" yaml:"text,omitempty"`

        // Url The artifact URL
        Url string `json:"url,omitempty,omitzero" yaml:"url,omitempty"`
}

// CreateArtifactJSONRequestBody defines body for CreateArtifact for application/json ContentType.
type CreateArtifactJSONRequestBody CreateArtifactJSONBody

// UpdateArtifactJSONRequestBody defines body for UpdateArtifact for application/json ContentType.
type UpdateArtifactJSONRequestBody UpdateArtifactJSONBody

// AsValidationErrorValue0 returns the union data inside the ValidationError_Value as a ValidationErrorValue0
func (t ValidationError_Value) AsValidationErrorValue0() (ValidationErrorValue0, error) <span class="cov0" title="0">{
        var body ValidationErrorValue0
        err := json.Unmarshal(t.union, &amp;body)
        return body, err
}</span>

// FromValidationErrorValue0 overwrites any union data inside the ValidationError_Value as the provided ValidationErrorValue0
func (t *ValidationError_Value) FromValidationErrorValue0(v ValidationErrorValue0) error <span class="cov0" title="0">{
        b, err := json.Marshal(v)
        t.union = b
        return err
}</span>

// MergeValidationErrorValue0 performs a merge with any union data inside the ValidationError_Value, using the provided ValidationErrorValue0
func (t *ValidationError_Value) MergeValidationErrorValue0(v ValidationErrorValue0) error <span class="cov0" title="0">{
        b, err := json.Marshal(v)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov0" title="0">merged, err := runtime.JSONMerge(t.union, b)
        t.union = merged
        return err</span>
}

// AsValidationErrorValue1 returns the union data inside the ValidationError_Value as a ValidationErrorValue1
func (t ValidationError_Value) AsValidationErrorValue1() (ValidationErrorValue1, error) <span class="cov0" title="0">{
        var body ValidationErrorValue1
        err := json.Unmarshal(t.union, &amp;body)
        return body, err
}</span>

// FromValidationErrorValue1 overwrites any union data inside the ValidationError_Value as the provided ValidationErrorValue1
func (t *ValidationError_Value) FromValidationErrorValue1(v ValidationErrorValue1) error <span class="cov0" title="0">{
        b, err := json.Marshal(v)
        t.union = b
        return err
}</span>

// MergeValidationErrorValue1 performs a merge with any union data inside the ValidationError_Value, using the provided ValidationErrorValue1
func (t *ValidationError_Value) MergeValidationErrorValue1(v ValidationErrorValue1) error <span class="cov0" title="0">{
        b, err := json.Marshal(v)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov0" title="0">merged, err := runtime.JSONMerge(t.union, b)
        t.union = merged
        return err</span>
}

// AsValidationErrorValue2 returns the union data inside the ValidationError_Value as a ValidationErrorValue2
func (t ValidationError_Value) AsValidationErrorValue2() (ValidationErrorValue2, error) <span class="cov0" title="0">{
        var body ValidationErrorValue2
        err := json.Unmarshal(t.union, &amp;body)
        return body, err
}</span>

// FromValidationErrorValue2 overwrites any union data inside the ValidationError_Value as the provided ValidationErrorValue2
func (t *ValidationError_Value) FromValidationErrorValue2(v ValidationErrorValue2) error <span class="cov0" title="0">{
        b, err := json.Marshal(v)
        t.union = b
        return err
}</span>

// MergeValidationErrorValue2 performs a merge with any union data inside the ValidationError_Value, using the provided ValidationErrorValue2
func (t *ValidationError_Value) MergeValidationErrorValue2(v ValidationErrorValue2) error <span class="cov0" title="0">{
        b, err := json.Marshal(v)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov0" title="0">merged, err := runtime.JSONMerge(t.union, b)
        t.union = merged
        return err</span>
}

func (t ValidationError_Value) MarshalJSON() ([]byte, error) <span class="cov0" title="0">{
        b, err := t.union.MarshalJSON()
        return b, err
}</span>

func (t *ValidationError_Value) UnmarshalJSON(b []byte) error <span class="cov0" title="0">{
        err := t.union.UnmarshalJSON(b)
        return err
}</span>
</pre>
		
		<pre class="file" id="file17" style="display: none">package auth

import (
        "context"
        "crypto/rand"
        "encoding/hex"
        "fmt"
        "strings"
        "time"

        "github.com/google/uuid"
)

// APIKey represents an API key entity
type APIKey struct {
        ID             uuid.UUID `json:"id"`
        UserID         uuid.UUID `json:"user_id"`
        OrganizationID uuid.UUID `json:"organization_id"`
        Name           string    `json:"name"`
        KeyHash        string    `json:"key_hash"` // Store hashed version
        Prefix         string    `json:"prefix"`   // First 8 chars for identification
        Scopes         []string  `json:"scopes"`
        RateLimit      int       `json:"rate_limit"` // Requests per minute
        LastUsedAt     time.Time `json:"last_used_at"`
        ExpiresAt      time.Time `json:"expires_at"`
        CreatedAt      time.Time `json:"created_at"`
        UpdatedAt      time.Time `json:"updated_at"`
}

// APIKeyCreate represents the response when creating a new API key
type APIKeyCreate struct {
        *APIKey
        PlainKey string `json:"key"` // Only returned once on creation
}

// GenerateAPIKey generates a new API key with prefix
func GenerateAPIKey() (string, string, error) <span class="cov3" title="2">{
        // Generate 32 bytes of random data
        bytes := make([]byte, 32)
        if _, err := rand.Read(bytes); err != nil </span><span class="cov0" title="0">{
                return "", "", fmt.Errorf("generate random bytes: %w", err)
        }</span>

        // Convert to hex string
        <span class="cov3" title="2">key := hex.EncodeToString(bytes)

        // Format as: sk_live_&lt;64 hex chars&gt; or sk_test_&lt;64 hex chars&gt;
        fullKey := fmt.Sprintf("sk_live_%s", key)
        prefix := fullKey[:8] // First 8 chars for identification

        return fullKey, prefix, nil</span>
}

// ParseAPIKey extracts the key from various header formats
func ParseAPIKey(authHeader string) string <span class="cov10" title="9">{
        authHeader = strings.TrimSpace(authHeader)

        // Check for "ApiKey" scheme
        if strings.HasPrefix(strings.ToLower(authHeader), "apikey ") </span><span class="cov5" title="3">{
                return strings.TrimSpace(authHeader[7:])
        }</span>

        // Check for "Bearer" scheme with API key format
        <span class="cov8" title="6">if strings.HasPrefix(strings.ToLower(authHeader), "bearer ") </span><span class="cov3" title="2">{
                key := strings.TrimSpace(authHeader[7:])
                if strings.HasPrefix(key, "sk_") </span><span class="cov1" title="1">{
                        return key
                }</span>
        }

        // Direct API key (from X-API-Key header)
        <span class="cov7" title="5">if strings.HasPrefix(authHeader, "sk_") </span><span class="cov1" title="1">{
                return authHeader
        }</span>

        <span class="cov6" title="4">return ""</span>
}

// ValidateAPIKeyFormat checks if the API key has valid format
func ValidateAPIKeyFormat(key string) bool <span class="cov10" title="9">{
        // Expected format: sk_live_&lt;64 hex chars&gt; or sk_test_&lt;64 hex chars&gt;
        if !strings.HasPrefix(key, "sk_") </span><span class="cov3" title="2">{
                return false
        }</span>

        <span class="cov8" title="7">parts := strings.SplitN(key, "_", 3)
        if len(parts) != 3 </span><span class="cov0" title="0">{
                return false
        }</span>

        // Check environment (live or test)
        <span class="cov8" title="7">if parts[1] != "live" &amp;&amp; parts[1] != "test" </span><span class="cov1" title="1">{
                return false
        }</span>

        // Check hex string length (32 bytes = 64 hex chars)
        <span class="cov8" title="6">if len(parts[2]) != 64 </span><span class="cov1" title="1">{
                return false
        }</span>

        // Verify it's valid hex
        <span class="cov7" title="5">_, err := hex.DecodeString(parts[2])
        return err == nil</span>
}

// HashAPIKey creates a hash of the API key for storage
func HashAPIKey(key string) string <span class="cov1" title="1">{
        // In production, use a proper hashing algorithm like bcrypt or argon2
        // For now, using a simple SHA256 (should be replaced)
        return fmt.Sprintf("hashed_%s", key) // Placeholder - implement proper hashing
}</span>

// APIKeyRepository defines the interface for API key storage operations
type APIKeyRepository interface {
        CreateAPIKey(ctx context.Context, apiKey *APIKey) (*APIKey, error)
        GetAPIKeyByPrefix(ctx context.Context, prefix string) (*APIKey, error)
        GetAPIKeyByID(ctx context.Context, id uuid.UUID) (*APIKey, error)
        ListUserAPIKeys(ctx context.Context, userID uuid.UUID) ([]*APIKey, error)
        UpdateAPIKeyLastUsed(ctx context.Context, id uuid.UUID) error
        DeleteAPIKey(ctx context.Context, id uuid.UUID) error
        ValidateAPIKeyHash(ctx context.Context, prefix, keyHash string) (*APIKey, error)
}

// APIKeyCache provides caching for API keys
type APIKeyCache interface {
        GetAPIKey(ctx context.Context, prefix string) (*APIKey, error)
        SetAPIKey(ctx context.Context, prefix string, apiKey *APIKey, ttl time.Duration) error
        DeleteAPIKey(ctx context.Context, prefix string) error
}

// APIKeyService handles API key operations
type APIKeyService struct {
        repo  APIKeyRepository
        cache APIKeyCache
}

// NewAPIKeyService creates a new API key service
func NewAPIKeyService(repo APIKeyRepository, cache APIKeyCache) *APIKeyService <span class="cov1" title="1">{
        return &amp;APIKeyService{
                repo:  repo,
                cache: cache,
        }
}</span>

// CreateAPIKey creates a new API key for a user
func (s *APIKeyService) CreateAPIKey(ctx context.Context, userID, orgID uuid.UUID, name string, scopes []string, expiresIn time.Duration) (*APIKeyCreate, error) <span class="cov1" title="1">{
        // Generate the key
        plainKey, prefix, err := GenerateAPIKey()
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("generate api key: %w", err)
        }</span>

        // Create the API key entity
        <span class="cov1" title="1">apiKey := &amp;APIKey{
                ID:             uuid.New(),
                UserID:         userID,
                OrganizationID: orgID,
                Name:           name,
                KeyHash:        HashAPIKey(plainKey),
                Prefix:         prefix,
                Scopes:         scopes,
                RateLimit:      100, // Default rate limit
                ExpiresAt:      time.Now().Add(expiresIn),
                CreatedAt:      time.Now(),
                UpdatedAt:      time.Now(),
        }

        // Store in database
        created, err := s.repo.CreateAPIKey(ctx, apiKey)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("store api key: %w", err)
        }</span>

        // Cache the key data
        <span class="cov1" title="1">if s.cache != nil </span><span class="cov0" title="0">{
                _ = s.cache.SetAPIKey(ctx, prefix, created, expiresIn)
        }</span>

        <span class="cov1" title="1">return &amp;APIKeyCreate{
                APIKey:   created,
                PlainKey: plainKey,
        }, nil</span>
}

// ValidateAPIKey validates an API key and returns the associated data
func (s *APIKeyService) ValidateAPIKey(ctx context.Context, key string) (*APIKey, error) <span class="cov0" title="0">{
        // Validate format
        if !ValidateAPIKeyFormat(key) </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("invalid api key format")
        }</span>

        // Extract prefix
        <span class="cov0" title="0">prefix := key[:8]

        // Check cache first
        if s.cache != nil </span><span class="cov0" title="0">{
                cached, err := s.cache.GetAPIKey(ctx, prefix)
                if err == nil &amp;&amp; cached != nil </span><span class="cov0" title="0">{
                        // Validate the full key hash
                        if cached.KeyHash == HashAPIKey(key) </span><span class="cov0" title="0">{
                                // Check expiration
                                if time.Now().Before(cached.ExpiresAt) </span><span class="cov0" title="0">{
                                        // Update last used timestamp asynchronously
                                        go func() </span><span class="cov0" title="0">{
                                                _ = s.repo.UpdateAPIKeyLastUsed(context.Background(), cached.ID)
                                        }</span>()
                                        <span class="cov0" title="0">return cached, nil</span>
                                }
                        }
                }
        }

        // Validate against database
        <span class="cov0" title="0">apiKey, err := s.repo.ValidateAPIKeyHash(ctx, prefix, HashAPIKey(key))
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("validate api key: %w", err)
        }</span>

        // Check expiration
        <span class="cov0" title="0">if time.Now().After(apiKey.ExpiresAt) </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("api key expired")
        }</span>

        // Update last used timestamp asynchronously
        <span class="cov0" title="0">go func() </span><span class="cov0" title="0">{
                _ = s.repo.UpdateAPIKeyLastUsed(context.Background(), apiKey.ID)
        }</span>()

        // Cache for future requests
        <span class="cov0" title="0">if s.cache != nil </span><span class="cov0" title="0">{
                ttl := time.Until(apiKey.ExpiresAt)
                _ = s.cache.SetAPIKey(ctx, apiKey.Prefix, apiKey, ttl)
        }</span>

        <span class="cov0" title="0">return apiKey, nil</span>
}

// RevokeAPIKey revokes an API key
func (s *APIKeyService) RevokeAPIKey(ctx context.Context, keyID uuid.UUID) error <span class="cov0" title="0">{
        // Get the key to find its prefix
        apiKey, err := s.repo.GetAPIKeyByID(ctx, keyID)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("get api key: %w", err)
        }</span>

        // Delete from database
        <span class="cov0" title="0">if err := s.repo.DeleteAPIKey(ctx, keyID); err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("delete api key: %w", err)
        }</span>

        // Remove from cache
        <span class="cov0" title="0">if s.cache != nil </span><span class="cov0" title="0">{
                _ = s.cache.DeleteAPIKey(ctx, apiKey.Prefix)
        }</span>

        <span class="cov0" title="0">return nil</span>
}
</pre>
		
		<pre class="file" id="file18" style="display: none">// Package auth provides authentication and authorization functionality.
// It includes user management, session handling, JWT token generation,
// and middleware for protecting routes.
package auth

import (
        "log/slog"
        "time"

        "github.com/archesai/archesai/internal/accounts"
        "github.com/archesai/archesai/internal/database/postgresql"
        "github.com/archesai/archesai/internal/email"
        "github.com/archesai/archesai/internal/sessions"
        "github.com/archesai/archesai/internal/users"
        "golang.org/x/crypto/bcrypt"
)

// RegisterRequest represents a registration request
type RegisterRequest = RegisterJSONBody

// LoginRequest represents a login request
type LoginRequest = LoginJSONBody

// Service handles authentication operations
type Service struct {
        accountsRepo   accounts.Repository
        sessionsRepo   sessions.Repository
        usersRepo      users.Repository
        cache          sessions.Cache
        sessionManager *sessions.SessionManager
        apiKeyService  *APIKeyService // API key management
        jwtSecret      []byte
        logger         *slog.Logger
        config         Config
        dbQueries      *postgresql.Queries
        emailService   *email.Service
}

// Config holds authentication configuration
type Config struct {
        JWTSecret             string
        AccessTokenExpiry     time.Duration
        RefreshTokenExpiry    time.Duration
        SessionTokenExpiry    time.Duration
        BCryptCost            int
        MaxLoginAttempts      int
        LockoutDuration       time.Duration
        MaxConcurrentSessions int // Maximum concurrent sessions per user (0 = unlimited)
}

// NewService creates a new authentication service with cache support
// If cache is nil, a NoOpCache will be used as fallback
func NewService(accountsRepo accounts.Repository, sessionsRepo sessions.Repository, usersRepo users.Repository, cache sessions.Cache, config Config, logger *slog.Logger) *Service <span class="cov10" title="25">{
        // Use NoOpCache if no cache provided
        if cache == nil </span><span class="cov0" title="0">{
                cache = sessions.NewNoOpCache()
        }</span>
        <span class="cov10" title="25">if config.AccessTokenExpiry == 0 </span><span class="cov0" title="0">{
                config.AccessTokenExpiry = 15 * time.Minute
        }</span>
        <span class="cov10" title="25">if config.RefreshTokenExpiry == 0 </span><span class="cov0" title="0">{
                config.RefreshTokenExpiry = 7 * 24 * time.Hour
        }</span>
        <span class="cov10" title="25">if config.SessionTokenExpiry == 0 </span><span class="cov10" title="25">{
                config.SessionTokenExpiry = 30 * 24 * time.Hour
        }</span>
        <span class="cov10" title="25">if config.BCryptCost == 0 </span><span class="cov0" title="0">{
                config.BCryptCost = bcrypt.DefaultCost
        }</span>

        // Always create session manager with the cache (might be NoOpCache)
        <span class="cov10" title="25">sessionManager := sessions.NewSessionManager(sessionsRepo, cache, config.SessionTokenExpiry)

        return &amp;Service{
                accountsRepo:   accountsRepo,
                sessionsRepo:   sessionsRepo,
                usersRepo:      usersRepo,
                cache:          cache,
                sessionManager: sessionManager,
                jwtSecret:      []byte(config.JWTSecret),
                logger:         logger,
                config:         config,
        }</span>
}
</pre>
		
		<pre class="file" id="file19" style="display: none">package auth

import (
        "context"
        "fmt"
        "time"

        "github.com/archesai/archesai/internal/accounts"
        "github.com/archesai/archesai/internal/database/postgresql"
        "github.com/archesai/archesai/internal/sessions"
        "github.com/archesai/archesai/internal/users"
        "github.com/google/uuid"
)

// Register creates a new user account
func (s *Service) Register(ctx context.Context, req *RegisterRequest) (*users.User, *TokenResponse, error) <span class="cov10" title="6">{
        // Check if user already exists
        existingUser, err := s.usersRepo.GetByEmail(ctx, string(req.Email))
        if err == nil &amp;&amp; existingUser != nil </span><span class="cov4" title="2">{
                return nil, nil, ErrUserExists
        }</span>

        // Validate password strength
        <span class="cov7" title="4">if err := s.validatePassword(req.Password); err != nil </span><span class="cov0" title="0">{
                return nil, nil, fmt.Errorf("password validation failed: %w", err)
        }</span>

        // Hash the password
        <span class="cov7" title="4">hashedPassword, err := s.hashPassword(req.Password)
        if err != nil </span><span class="cov0" title="0">{
                s.logger.Error("failed to hash password", "error", err)
                return nil, nil, fmt.Errorf("failed to hash password: %w", err)
        }</span>

        // Create new user with embedded User
        <span class="cov7" title="4">now := time.Now()
        user := &amp;users.User{
                Id:            uuid.New(),
                Email:         req.Email,
                Name:          req.Name,
                EmailVerified: false,
                CreatedAt:     now,
                UpdatedAt:     now,
        }

        // Save user to database - repository expects User
        createdEntity, err := s.usersRepo.Create(ctx, user)
        if err != nil </span><span class="cov1" title="1">{
                s.logger.Error("failed to create user", "error", err)
                return nil, nil, fmt.Errorf("failed to create user: %w", err)
        }</span>
        // Update user with created entity (in case DB added fields)
        <span class="cov6" title="3">user = createdEntity

        // Create local account with password
        account := &amp;accounts.Account{
                Id:         uuid.New(),
                UserId:     user.Id,
                ProviderId: accounts.Local,
                AccountId:  string(user.Email), // Use email as account ID for local auth
                Password:   hashedPassword,
                CreatedAt:  now,
                UpdatedAt:  now,
        }

        _, err = s.accountsRepo.Create(ctx, account)
        if err != nil </span><span class="cov1" title="1">{
                s.logger.Error("failed to create account", "error", err)
                // Try to clean up the created user
                _ = s.usersRepo.Delete(ctx, user.Id)
                return nil, nil, fmt.Errorf("failed to create account: %w", err)
        }</span>

        // Generate email verification token if email service is configured
        <span class="cov4" title="2">if s.emailService != nil &amp;&amp; s.dbQueries != nil </span><span class="cov0" title="0">{
                verificationToken, err := s.generateVerificationToken()
                if err != nil </span><span class="cov0" title="0">{
                        s.logger.Error("failed to generate verification token", "error", err)
                        // Continue without email verification
                }</span> else<span class="cov0" title="0"> {
                        // Store verification token in database
                        _, err = s.dbQueries.CreateVerificationToken(ctx, postgresql.CreateVerificationTokenParams{
                                Id:         uuid.New(),
                                Identifier: string(user.Email),
                                Value:      verificationToken,
                                ExpiresAt:  time.Now().Add(24 * time.Hour), // Token expires in 24 hours
                        })
                        if err != nil </span><span class="cov0" title="0">{
                                s.logger.Error("failed to store verification token", "error", err)
                                // Continue without email verification
                        }</span> else<span class="cov0" title="0"> {
                                // Send verification email
                                err = s.emailService.SendVerificationEmail(ctx, string(user.Email), user.Name, verificationToken)
                                if err != nil </span><span class="cov0" title="0">{
                                        s.logger.Error("failed to send verification email", "error", err)
                                        // Continue - user can request resend later
                                }</span>
                        }
                }
        }

        // Generate tokens
        <span class="cov4" title="2">tokens, err := s.generateTokens(user)
        if err != nil </span><span class="cov0" title="0">{
                s.logger.Error("failed to generate tokens", "error", err)
                return nil, nil, fmt.Errorf("failed to generate tokens: %w", err)
        }</span>

        // Create session - use SessionManager if available
        <span class="cov4" title="2">var session *sessions.Session
        if s.sessionManager != nil </span><span class="cov4" title="2">{
                session, err = s.sessionManager.Create(ctx, user.Id, uuid.Nil, "", "")
                if err != nil </span><span class="cov0" title="0">{
                        s.logger.Error("failed to create session", "error", err)
                        return nil, nil, fmt.Errorf("failed to create session: %w", err)
                }</span>
                // Update session with refresh token
                <span class="cov4" title="2">session.Token = tokens.RefreshToken
                _, err = s.sessionManager.Update(ctx, session.Id, session)
                if err != nil </span><span class="cov0" title="0">{
                        s.logger.Error("failed to update session token", "error", err)
                }</span>
        } else<span class="cov0" title="0"> {
                // Fallback to direct repository
                sessionNow := time.Now()
                session = &amp;sessions.Session{
                        Id:        uuid.New(),
                        UserId:    user.Id,
                        Token:     tokens.RefreshToken,
                        ExpiresAt: sessionNow.Add(s.config.SessionTokenExpiry).Format(time.RFC3339),
                        CreatedAt: sessionNow,
                        UpdatedAt: sessionNow,
                        // Required fields with empty defaults
                        ActiveOrganizationId: uuid.Nil,
                        IpAddress:            "",
                        UserAgent:            "",
                }
                _, err = s.sessionsRepo.Create(ctx, session)
                if err != nil </span><span class="cov0" title="0">{
                        s.logger.Error("failed to create session", "error", err)
                        return nil, nil, fmt.Errorf("failed to create session: %w", err)
                }</span>
        }

        <span class="cov4" title="2">s.logger.Info("user signed up successfully", "user_id", user.Id.String())
        return user, tokens, nil</span>
}

// Login authenticates a user
func (s *Service) Login(ctx context.Context, req *LoginRequest, ipAddress, userAgent string) (*users.User, *TokenResponse, error) <span class="cov10" title="6">{
        // Check if IP is locked out due to brute force attempts
        if s.config.MaxLoginAttempts &gt; 0 </span><span class="cov0" title="0">{
                if s.isIPLockedOut(ctx, ipAddress) </span><span class="cov0" title="0">{
                        s.logger.Warn("IP address locked out due to brute force attempts", "ip", ipAddress)
                        return nil, nil, fmt.Errorf("too many failed login attempts, try again later")
                }</span>
        }

        // Get user by email
        <span class="cov10" title="6">userEntity, err := s.usersRepo.GetByEmail(ctx, string(req.Email))
        if err != nil </span><span class="cov4" title="2">{
                // Track failed attempt
                s.trackFailedLoginAttempt(ctx, ipAddress, string(req.Email))
                s.logger.Warn("user not found", "email", req.Email)
                return nil, nil, ErrInvalidCredentials
        }</span>

        // Get the user's local account to verify password
        <span class="cov7" title="4">account, err := s.accountsRepo.GetByProviderId(ctx, string(accounts.Local), string(req.Email))
        if err != nil </span><span class="cov1" title="1">{
                // Track failed attempt
                s.trackFailedLoginAttempt(ctx, ipAddress, string(req.Email))
                s.logger.Warn("account not found", "email", req.Email)
                return nil, nil, ErrInvalidCredentials
        }</span>

        // Verify password
        <span class="cov6" title="3">if account.Password != "" </span><span class="cov6" title="3">{
                if err := s.verifyPassword(req.Password, account.Password); err != nil </span><span class="cov1" title="1">{
                        // Track failed attempt
                        s.trackFailedLoginAttempt(ctx, ipAddress, string(req.Email))
                        s.logger.Warn("invalid password", "user_id", userEntity.Id.String(), "ip", ipAddress)
                        return nil, nil, ErrInvalidCredentials
                }</span>
        }

        <span class="cov4" title="2">user := userEntity

        // Clear any failed login attempts on successful authentication
        s.clearFailedAttempts(ctx, ipAddress, string(req.Email))

        // Check concurrent session limits
        if s.config.MaxConcurrentSessions &gt; 0 </span><span class="cov0" title="0">{
                activeSessions, err := s.sessionManager.ListUserSessions(ctx, user.Id)
                if err == nil &amp;&amp; len(activeSessions) &gt;= s.config.MaxConcurrentSessions </span><span class="cov0" title="0">{
                        // Remove oldest session if limit reached
                        s.logger.Info("concurrent session limit reached, removing oldest session",
                                "user_id", user.Id,
                                "max_sessions", s.config.MaxConcurrentSessions,
                                "active_sessions", len(activeSessions))

                        // Find and remove the oldest session
                        if len(activeSessions) &gt; 0 </span><span class="cov0" title="0">{
                                oldestSession := activeSessions[0]
                                for _, session := range activeSessions </span><span class="cov0" title="0">{
                                        if session.CreatedAt.Before(oldestSession.CreatedAt) </span><span class="cov0" title="0">{
                                                oldestSession = session
                                        }</span>
                                }
                                <span class="cov0" title="0">_ = s.sessionsRepo.Delete(ctx, oldestSession.Id)</span>
                        }
                }
        }

        // Generate tokens with extended refresh token if remember me is enabled
        <span class="cov4" title="2">var tokens *TokenResponse
        if req.RememberMe </span><span class="cov0" title="0">{
                // Use extended refresh token expiry for remember me
                extendedConfig := s.config
                extendedConfig.RefreshTokenExpiry = 30 * 24 * time.Hour // 30 days for remember me
                tokens, err = s.generateTokensWithConfig(user, extendedConfig)
                s.logger.Info("generating extended session for remember me", "user_id", user.Id)
        }</span> else<span class="cov4" title="2"> {
                tokens, err = s.generateTokens(user)
        }</span>
        <span class="cov4" title="2">if err != nil </span><span class="cov0" title="0">{
                s.logger.Error("failed to generate tokens", "error", err)
                return nil, nil, fmt.Errorf("failed to generate tokens: %w", err)
        }</span>

        // Create session - use SessionManager if available
        <span class="cov4" title="2">var session *sessions.Session
        if s.sessionManager != nil </span><span class="cov4" title="2">{
                // TODO: Get organization ID from user's default org
                session, err = s.sessionManager.Create(ctx, user.Id, uuid.Nil, ipAddress, userAgent)
                if err != nil </span><span class="cov0" title="0">{
                        s.logger.Error("failed to create session", "error", err)
                        return nil, nil, fmt.Errorf("failed to create session: %w", err)
                }</span>
                // Update session with refresh token
                <span class="cov4" title="2">session.Token = tokens.RefreshToken
                _, err = s.sessionManager.Update(ctx, session.Id, session)
                if err != nil </span><span class="cov0" title="0">{
                        s.logger.Error("failed to update session token", "error", err)
                }</span>
        } else<span class="cov0" title="0"> {
                // Fallback to direct repository
                sessionNow := time.Now()
                session = &amp;sessions.Session{
                        Id:                   uuid.New(),
                        UserId:               user.Id,
                        Token:                tokens.RefreshToken,
                        ExpiresAt:            sessionNow.Add(s.config.SessionTokenExpiry).Format(time.RFC3339),
                        CreatedAt:            sessionNow,
                        UpdatedAt:            sessionNow,
                        ActiveOrganizationId: uuid.Nil, // TODO: Set proper organization ID
                        IpAddress:            ipAddress,
                        UserAgent:            userAgent,
                }
                _, err = s.sessionsRepo.Create(ctx, session)
                if err != nil </span><span class="cov0" title="0">{
                        s.logger.Error("failed to create session", "error", err)
                        return nil, nil, fmt.Errorf("failed to create session: %w", err)
                }</span>
        }

        <span class="cov4" title="2">s.logger.Info("user signed in successfully", "user_id", userEntity.Id.String())
        return userEntity, tokens, nil</span>
}

// Logout invalidates a user session
func (s *Service) Logout(ctx context.Context, token string) error <span class="cov9" title="5">{
        // Use SessionManager if available
        if s.sessionManager != nil </span><span class="cov9" title="5">{
                err := s.sessionManager.DeleteSessionByToken(ctx, token)
                if err != nil </span><span class="cov6" title="3">{
                        s.logger.Error("failed to delete session", "error", err)
                        return ErrInvalidToken
                }</span>
                <span class="cov4" title="2">s.logger.Info("user signed out successfully")
                return nil</span>
        }

        // Fallback to direct repository
        <span class="cov0" title="0">session, err := s.sessionsRepo.GetByToken(ctx, token)
        if err != nil </span><span class="cov0" title="0">{
                return ErrInvalidToken
        }</span>

        // Delete session
        <span class="cov0" title="0">if err := s.sessionsRepo.Delete(ctx, session.Id); err != nil </span><span class="cov0" title="0">{
                s.logger.Error("failed to delete session", "error", err)
                return fmt.Errorf("failed to delete session: %w", err)
        }</span>

        <span class="cov0" title="0">s.logger.Info("user signed out successfully", "user_id", session.UserId)
        return nil</span>
}

// GetUserByID retrieves a user by their ID
func (s *Service) GetUserByID(ctx context.Context, userID uuid.UUID) (*users.User, error) <span class="cov6" title="3">{
        return s.usersRepo.Get(ctx, userID)
}</span>
</pre>
		
		<pre class="file" id="file20" style="display: none">// Package auth provides enhanced JWT claims structures for authentication
package auth

import (
        "time"

        "github.com/golang-jwt/jwt/v5"
        "github.com/google/uuid"
)

// TokenType represents the type of JWT token
type TokenType string

const (
        // AccessTokenType represents an access token
        AccessTokenType TokenType = "access"
        // RefreshTokenType represents a refresh token
        RefreshTokenType TokenType = "refresh"
        // APIKeyTokenType represents an API key token
        APIKeyTokenType TokenType = "api_key"
        // SessionTokenType represents a session token
        SessionTokenType TokenType = "session"
)

// Method represents the authentication method used
type Method string

const (
        // AuthMethodPassword represents password authentication
        AuthMethodPassword Method = "password"
        // AuthMethodOAuth represents OAuth authentication
        AuthMethodOAuth Method = "oauth"
        // AuthMethodAPIKey represents API key authentication
        AuthMethodAPIKey Method = "api_key"
        // AuthMethodMFA represents multi-factor authentication
        AuthMethodMFA Method = "mfa"
)

// EnhancedClaims represents comprehensive JWT claims with rich context
type EnhancedClaims struct {
        // Standard JWT claims
        jwt.RegisteredClaims

        // User Identity
        UserID    uuid.UUID `json:"uid"`
        Email     string    `json:"email"`
        Name      string    `json:"name,omitempty"`
        AvatarURL string    `json:"avatar_url,omitempty"`

        // Organization Context
        OrganizationID   uuid.UUID           `json:"org_id,omitempty"`
        OrganizationName string              `json:"org_name,omitempty"`
        OrganizationRole string              `json:"org_role,omitempty"`
        Organizations    []OrganizationClaim `json:"orgs,omitempty"`

        // Permissions and Roles
        Roles       []string `json:"roles,omitempty"`
        Permissions []string `json:"permissions,omitempty"`
        Scopes      []string `json:"scopes,omitempty"`

        // Security Metadata
        TokenType     TokenType `json:"token_type"`
        AuthMethod    Method    `json:"auth_method"`
        SessionID     string    `json:"sid,omitempty"`
        IPAddress     string    `json:"ip,omitempty"`
        UserAgent     string    `json:"ua,omitempty"`
        EmailVerified bool      `json:"email_verified"`
        MFAEnabled    bool      `json:"mfa_enabled"`
        MFAVerified   bool      `json:"mfa_verified,omitempty"`

        // Provider Information (for OAuth)
        Provider         string `json:"provider,omitempty"`
        ProviderID       string `json:"provider_id,omitempty"`
        ProviderTokenExp *int64 `json:"provider_token_exp,omitempty"`

        // Feature Flags
        Features map[string]bool `json:"features,omitempty"`

        // Custom Claims
        CustomClaims map[string]interface{} `json:"custom,omitempty"`
}

// OrganizationClaim represents organization membership in claims
type OrganizationClaim struct {
        ID          uuid.UUID `json:"id"`
        Name        string    `json:"name"`
        Role        string    `json:"role"`
        Permissions []string  `json:"permissions,omitempty"`
}

// RefreshClaims represents minimal claims for refresh tokens
type RefreshClaims struct {
        jwt.RegisteredClaims
        UserID     uuid.UUID `json:"uid"`
        TokenType  TokenType `json:"token_type"`
        SessionID  string    `json:"sid"`
        AuthMethod Method    `json:"auth_method"`
}

// SessionClaims represents minimal claims for session tokens
type SessionClaims struct {
        jwt.RegisteredClaims
        UserID    uuid.UUID `json:"uid"`
        TokenType TokenType `json:"token_type"`
}

// APIKeyClaims represents claims for API key tokens
type APIKeyClaims struct {
        jwt.RegisteredClaims
        KeyID          string    `json:"kid"`
        UserID         uuid.UUID `json:"uid"`
        OrganizationID uuid.UUID `json:"org_id"`
        Name           string    `json:"name"`
        Scopes         []string  `json:"scopes"`
        RateLimit      int       `json:"rate_limit,omitempty"`
}

// HasPermission checks if the claims contain a specific permission
func (c *EnhancedClaims) HasPermission(permission string) bool <span class="cov8" title="6">{
        for _, p := range c.Permissions </span><span class="cov10" title="10">{
                if p == permission </span><span class="cov5" title="3">{
                        return true
                }</span>
        }
        // Check organization-specific permissions
        <span class="cov5" title="3">if c.OrganizationID != uuid.Nil </span><span class="cov3" title="2">{
                for _, org := range c.Organizations </span><span class="cov3" title="2">{
                        if org.ID == c.OrganizationID </span><span class="cov3" title="2">{
                                for _, p := range org.Permissions </span><span class="cov3" title="2">{
                                        if p == permission </span><span class="cov1" title="1">{
                                                return true
                                        }</span>
                                }
                        }
                }
        }
        <span class="cov3" title="2">return false</span>
}

// HasRole checks if the claims contain a specific role
func (c *EnhancedClaims) HasRole(role string) bool <span class="cov5" title="3">{
        for _, r := range c.Roles </span><span class="cov7" title="5">{
                if r == role </span><span class="cov1" title="1">{
                        return true
                }</span>
        }
        <span class="cov3" title="2">return c.OrganizationRole == role</span>
}

// HasScope checks if the claims contain a specific scope
func (c *EnhancedClaims) HasScope(scope string) bool <span class="cov7" title="5">{
        for _, s := range c.Scopes </span><span class="cov8" title="7">{
                if s == scope </span><span class="cov5" title="3">{
                        return true
                }</span>
        }
        <span class="cov3" title="2">return false</span>
}

// IsOrgMember checks if the user is a member of a specific organization
func (c *EnhancedClaims) IsOrgMember(orgID uuid.UUID) bool <span class="cov5" title="3">{
        if c.OrganizationID == orgID </span><span class="cov1" title="1">{
                return true
        }</span>
        <span class="cov3" title="2">for _, org := range c.Organizations </span><span class="cov3" title="2">{
                if org.ID == orgID </span><span class="cov1" title="1">{
                        return true
                }</span>
        }
        <span class="cov1" title="1">return false</span>
}

// GetOrgRole returns the user's role in a specific organization
func (c *EnhancedClaims) GetOrgRole(orgID uuid.UUID) string <span class="cov5" title="3">{
        if c.OrganizationID == orgID </span><span class="cov1" title="1">{
                return c.OrganizationRole
        }</span>
        <span class="cov3" title="2">for _, org := range c.Organizations </span><span class="cov3" title="2">{
                if org.ID == orgID </span><span class="cov1" title="1">{
                        return org.Role
                }</span>
        }
        <span class="cov1" title="1">return ""</span>
}

// IsValid checks if the claims are valid
func (c *EnhancedClaims) IsValid() bool <span class="cov9" title="8">{
        now := time.Now()

        // Check expiration
        if c.ExpiresAt != nil &amp;&amp; now.After(c.ExpiresAt.Time) </span><span class="cov1" title="1">{
                return false
        }</span>

        // Check not before
        <span class="cov8" title="7">if c.NotBefore != nil &amp;&amp; now.Before(c.NotBefore.Time) </span><span class="cov1" title="1">{
                return false
        }</span>

        // Check required fields
        <span class="cov8" title="6">if c.UserID == uuid.Nil || c.Email == "" </span><span class="cov3" title="2">{
                return false
        }</span>

        <span class="cov6" title="4">return true</span>
}

// ValidateForEndpoint checks if claims are valid for a specific endpoint
func (c *EnhancedClaims) ValidateForEndpoint(requiredScopes []string, requiredPermissions []string) bool <span class="cov5" title="3">{
        // Check if claims are valid
        if !c.IsValid() </span><span class="cov0" title="0">{
                return false
        }</span>

        // Check required scopes
        <span class="cov5" title="3">for _, scope := range requiredScopes </span><span class="cov5" title="3">{
                if !c.HasScope(scope) </span><span class="cov1" title="1">{
                        return false
                }</span>
        }

        // Check required permissions
        <span class="cov3" title="2">for _, perm := range requiredPermissions </span><span class="cov3" title="2">{
                if !c.HasPermission(perm) </span><span class="cov1" title="1">{
                        return false
                }</span>
        }

        <span class="cov1" title="1">return true</span>
}
</pre>
		
		<pre class="file" id="file21" style="display: none">package auth

import (
        "context"

        "github.com/google/uuid"
        "github.com/labstack/echo/v4"
)

// ContextKey is a type for context keys to avoid collisions
type ContextKey string

// Context keys for authentication data
const (
        // AuthClaimsContextKey is the context key for storing JWT claims
        AuthClaimsContextKey ContextKey = "auth.claims"

        // AuthUserContextKey is the context key for storing user ID
        AuthUserContextKey ContextKey = "auth.user_id"

        // UserContextKey is the context key for the authenticated user
        UserContextKey ContextKey = "user"

        // SessionTokenContextKey is the context key for session token
        SessionTokenContextKey ContextKey = "session_token"

        // OrganizationContextKey is the context key for storing organization data
        OrganizationContextKey ContextKey = "auth.organization"

        // AuthStrategyContextKey is the context key for storing the authentication strategy used
        AuthStrategyContextKey ContextKey = "auth.strategy"
)

// GetUserFromContext retrieves the user ID from the context
func GetUserFromContext(c echo.Context) (uuid.UUID, bool) <span class="cov0" title="0">{
        userID, ok := c.Get(string(AuthUserContextKey)).(uuid.UUID)
        return userID, ok
}</span>

// GetClaimsFromContext retrieves the enhanced claims from the context
func GetClaimsFromContext(c echo.Context) (*EnhancedClaims, bool) <span class="cov0" title="0">{
        claims, ok := c.Get(string(AuthClaimsContextKey)).(*EnhancedClaims)
        return claims, ok
}</span>

// GetAuthStrategy retrieves the authentication strategy from context
func GetAuthStrategy(c echo.Context) (Strategy, bool) <span class="cov0" title="0">{
        strategy, ok := c.Get(string(AuthStrategyContextKey)).(Strategy)
        return strategy, ok
}</span>

// GetOrganizationFromContext retrieves the organization from the context
func GetOrganizationFromContext(c echo.Context) (interface{}, bool) <span class="cov0" title="0">{
        org := c.Get(string(OrganizationContextKey))
        return org, org != nil
}</span>

// GetSessionTokenFromContext retrieves the session token from the context
func GetSessionTokenFromContext(c echo.Context) (string, bool) <span class="cov0" title="0">{
        token, ok := c.Get(string(SessionTokenContextKey)).(string)
        return token, ok
}</span>

// GetUserEntityFromContext retrieves the full user entity from the context
func GetUserEntityFromContext(c echo.Context) (*User, bool) <span class="cov0" title="0">{
        user, ok := c.Get(string(UserContextKey)).(*User)
        return user, ok
}</span>

// SetAuthContext sets all authentication-related values in both Echo and Go contexts
func SetAuthContext(c echo.Context, claims *EnhancedClaims, user *User, token string) <span class="cov0" title="0">{
        // Set in Echo context
        c.Set(string(AuthClaimsContextKey), claims)
        c.Set(string(AuthUserContextKey), claims.UserID)
        c.Set(string(UserContextKey), user)
        c.Set(string(SessionTokenContextKey), token)

        // Set in Go context for downstream use
        ctx := context.WithValue(c.Request().Context(), AuthClaimsContextKey, claims)
        ctx = context.WithValue(ctx, AuthUserContextKey, claims.UserID)
        ctx = context.WithValue(ctx, UserContextKey, user)
        ctx = context.WithValue(ctx, SessionTokenContextKey, token)
        c.SetRequest(c.Request().WithContext(ctx))
}</span>

// SetOrganizationContext sets organization data in both Echo and Go contexts
func SetOrganizationContext(c echo.Context, org interface{}) <span class="cov0" title="0">{
        c.Set(string(OrganizationContextKey), org)
        ctx := context.WithValue(c.Request().Context(), OrganizationContextKey, org)
        c.SetRequest(c.Request().WithContext(ctx))
}</span>

// SetAuthStrategyContext sets the authentication strategy in both Echo and Go contexts
func SetAuthStrategyContext(c echo.Context, strategy Strategy) <span class="cov0" title="0">{
        c.Set(string(AuthStrategyContextKey), strategy)
        ctx := context.WithValue(c.Request().Context(), AuthStrategyContextKey, strategy)
        c.SetRequest(c.Request().WithContext(ctx))
}</span>

// GetAuthContextFromGoContext retrieves authentication data from standard Go context
// This is useful for service and repository layers that don't have access to Echo context
func GetAuthContextFromGoContext(ctx context.Context) (*EnhancedClaims, uuid.UUID, bool) <span class="cov0" title="0">{
        claims, claimsOk := ctx.Value(AuthClaimsContextKey).(*EnhancedClaims)
        userID, userOk := ctx.Value(AuthUserContextKey).(uuid.UUID)
        return claims, userID, claimsOk &amp;&amp; userOk
}</span>
</pre>
		
		<pre class="file" id="file22" style="display: none">// Package auth provides OAuth2 provider implementations for various services.
package auth

import (
        "context"
        "encoding/json"
        "fmt"
        "net/http"

        "golang.org/x/oauth2"
        "golang.org/x/oauth2/github"
)

const (
        githubUserURL = "https://api.github.com/user"
)

// GitHubOAuthProvider implements OAuth2 for GitHub
type GitHubOAuthProvider struct {
        *BaseOAuthProvider
}

// NewGitHubOAuthProvider creates a new GitHub OAuth provider
func NewGitHubOAuthProvider(clientID, clientSecret string) OAuthProvider <span class="cov10" title="5">{
        return &amp;GitHubOAuthProvider{
                BaseOAuthProvider: &amp;BaseOAuthProvider{
                        Config: &amp;oauth2.Config{
                                ClientID:     clientID,
                                ClientSecret: clientSecret,
                                Endpoint:     github.Endpoint,
                                Scopes: []string{
                                        "user:email",
                                        "read:user",
                                },
                        },
                },
        }
}</span>

// GetProviderID returns the provider identifier
func (p *GitHubOAuthProvider) GetProviderID() string <span class="cov1" title="1">{
        return "github"
}</span>

// GetAuthURL returns the GitHub authorization URL
func (p *GitHubOAuthProvider) GetAuthURL(state string, redirectURI string) string <span class="cov4" title="2">{
        p.Config.RedirectURL = redirectURI
        return p.Config.AuthCodeURL(state)
}</span>

// ExchangeCode exchanges an authorization code for tokens
func (p *GitHubOAuthProvider) ExchangeCode(ctx context.Context, code string, redirectURI string) (*OAuthTokens, error) <span class="cov1" title="1">{
        p.Config.RedirectURL = redirectURI
        token, err := p.Config.Exchange(ctx, code)
        if err != nil </span><span class="cov1" title="1">{
                return nil, fmt.Errorf("failed to exchange code: %w", err)
        }</span>

        <span class="cov0" title="0">return &amp;OAuthTokens{
                AccessToken:  token.AccessToken,
                RefreshToken: token.RefreshToken, // GitHub doesn't provide refresh tokens
                ExpiresIn:    int(token.Expiry.Unix()),
                Scope:        token.Extra("scope").(string),
        }, nil</span>
}

// RefreshToken is not supported by GitHub
func (p *GitHubOAuthProvider) RefreshToken(_ context.Context, _ string) (*OAuthTokens, error) <span class="cov1" title="1">{
        // GitHub doesn't support refresh tokens
        return nil, fmt.Errorf("GitHub does not support refresh tokens")
}</span>

// GetUserInfo retrieves user information from GitHub
func (p *GitHubOAuthProvider) GetUserInfo(ctx context.Context, accessToken string) (*OAuthUserInfo, error) <span class="cov0" title="0">{
        req, err := http.NewRequestWithContext(ctx, "GET", githubUserURL, nil)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to create request: %w", err)
        }</span>

        <span class="cov0" title="0">req.Header.Set("Authorization", "Bearer "+accessToken)
        req.Header.Set("Accept", "application/vnd.github.v3+json")

        client := &amp;http.Client{}
        resp, err := client.Do(req)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to get user info: %w", err)
        }</span>
        <span class="cov0" title="0">defer func() </span><span class="cov0" title="0">{
                _ = resp.Body.Close()
        }</span>()

        <span class="cov0" title="0">if resp.StatusCode != http.StatusOK </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("unexpected status code: %d", resp.StatusCode)
        }</span>

        <span class="cov0" title="0">var githubUser struct {
                ID                int    `json:"id"`
                Login             string `json:"login"`
                Email             string `json:"email"`
                Name              string `json:"name"`
                AvatarURL         string `json:"avatar_url"`
                Location          string `json:"location"`
                PublicRepos       int    `json:"public_repos"`
                PublicGists       int    `json:"public_gists"`
                Followers         int    `json:"followers"`
                Following         int    `json:"following"`
                CreatedAt         string `json:"created_at"`
                UpdatedAt         string `json:"updated_at"`
                PrivateGists      int    `json:"private_gists"`
                TotalPrivateRepos int    `json:"total_private_repos"`
                OwnedPrivateRepos int    `json:"owned_private_repos"`
        }

        if err := json.NewDecoder(resp.Body).Decode(&amp;githubUser); err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to decode response: %w", err)
        }</span>

        // GitHub may not return email in the user endpoint if it's private
        // In production, you might want to make an additional call to /user/emails
        <span class="cov0" title="0">email := githubUser.Email
        if email == "" </span><span class="cov0" title="0">{
                // Get primary email from emails endpoint
                email, err = p.getPrimaryEmail(ctx, accessToken)
                if err != nil </span><span class="cov0" title="0">{
                        // Non-fatal: user might not have granted email permission
                        email = fmt.Sprintf("%s@users.noreply.github.com", githubUser.Login)
                }</span>
        }

        <span class="cov0" title="0">return &amp;OAuthUserInfo{
                ProviderAccountID: fmt.Sprintf("%d", githubUser.ID),
                Email:             email,
                EmailVerified:     true, // GitHub requires email verification
                Name:              githubUser.Name,
                Picture:           githubUser.AvatarURL,
                Raw: map[string]interface{}{
                        "id":         githubUser.ID,
                        "login":      githubUser.Login,
                        "email":      email,
                        "name":       githubUser.Name,
                        "avatar_url": githubUser.AvatarURL,
                        "location":   githubUser.Location,
                        "created_at": githubUser.CreatedAt,
                        "updated_at": githubUser.UpdatedAt,
                },
        }, nil</span>
}

// getPrimaryEmail retrieves the primary email from GitHub's emails endpoint
func (p *GitHubOAuthProvider) getPrimaryEmail(ctx context.Context, accessToken string) (string, error) <span class="cov0" title="0">{
        req, err := http.NewRequestWithContext(ctx, "GET", "https://api.github.com/user/emails", nil)
        if err != nil </span><span class="cov0" title="0">{
                return "", err
        }</span>

        <span class="cov0" title="0">req.Header.Set("Authorization", "Bearer "+accessToken)
        req.Header.Set("Accept", "application/vnd.github.v3+json")

        client := &amp;http.Client{}
        resp, err := client.Do(req)
        if err != nil </span><span class="cov0" title="0">{
                return "", err
        }</span>
        <span class="cov0" title="0">defer func() </span><span class="cov0" title="0">{
                _ = resp.Body.Close()
        }</span>()

        <span class="cov0" title="0">if resp.StatusCode != http.StatusOK </span><span class="cov0" title="0">{
                return "", fmt.Errorf("failed to get emails: status %d", resp.StatusCode)
        }</span>

        <span class="cov0" title="0">var emails []struct {
                Email    string `json:"email"`
                Primary  bool   `json:"primary"`
                Verified bool   `json:"verified"`
        }

        if err := json.NewDecoder(resp.Body).Decode(&amp;emails); err != nil </span><span class="cov0" title="0">{
                return "", err
        }</span>

        <span class="cov0" title="0">for _, email := range emails </span><span class="cov0" title="0">{
                if email.Primary &amp;&amp; email.Verified </span><span class="cov0" title="0">{
                        return email.Email, nil
                }</span>
        }

        // Return first verified email if no primary
        <span class="cov0" title="0">for _, email := range emails </span><span class="cov0" title="0">{
                if email.Verified </span><span class="cov0" title="0">{
                        return email.Email, nil
                }</span>
        }

        <span class="cov0" title="0">return "", fmt.Errorf("no verified email found")</span>
}
</pre>
		
		<pre class="file" id="file23" style="display: none">package auth

import (
        "context"
        "encoding/json"
        "fmt"
        "net/http"

        "golang.org/x/oauth2"
        "golang.org/x/oauth2/google"
)

const (
        googleUserInfoURL = "https://www.googleapis.com/oauth2/v2/userinfo"
)

// GoogleOAuthProvider implements OAuth2 for Google
type GoogleOAuthProvider struct {
        *BaseOAuthProvider
}

// Ensure GoogleOAuthProvider implements OAuthProvider
var _ OAuthProvider = (*GoogleOAuthProvider)(nil)

// NewGoogleOAuthProvider creates a new Google OAuth provider
func NewGoogleOAuthProvider(clientID, clientSecret string) OAuthProvider <span class="cov10" title="4">{
        return &amp;GoogleOAuthProvider{
                BaseOAuthProvider: &amp;BaseOAuthProvider{
                        Config: &amp;oauth2.Config{
                                ClientID:     clientID,
                                ClientSecret: clientSecret,
                                Endpoint:     google.Endpoint,
                                Scopes: []string{
                                        "openid",
                                        "profile",
                                        "email",
                                },
                        },
                },
        }
}</span>

// GetProviderID returns the provider identifier
func (p *GoogleOAuthProvider) GetProviderID() string <span class="cov1" title="1">{
        return "google"
}</span>

// GetAuthURL returns the Google authorization URL
func (p *GoogleOAuthProvider) GetAuthURL(state string, redirectURI string) string <span class="cov5" title="2">{
        p.Config.RedirectURL = redirectURI
        // Google requires access_type=offline to get refresh token
        return p.Config.AuthCodeURL(state, oauth2.AccessTypeOffline, oauth2.ApprovalForce)
}</span>

// ExchangeCode exchanges an authorization code for tokens
func (p *GoogleOAuthProvider) ExchangeCode(ctx context.Context, code string, redirectURI string) (*OAuthTokens, error) <span class="cov1" title="1">{
        p.Config.RedirectURL = redirectURI
        token, err := p.Config.Exchange(ctx, code)
        if err != nil </span><span class="cov1" title="1">{
                return nil, fmt.Errorf("failed to exchange code: %w", err)
        }</span>

        <span class="cov0" title="0">return &amp;OAuthTokens{
                AccessToken:  token.AccessToken,
                RefreshToken: token.RefreshToken,
                IDToken:      extractIDToken(token),
                ExpiresIn:    int(token.Expiry.Unix()),
        }, nil</span>
}

// RefreshToken refreshes an access token using a refresh token
func (p *GoogleOAuthProvider) RefreshToken(ctx context.Context, refreshToken string) (*OAuthTokens, error) <span class="cov0" title="0">{
        token, err := p.BaseOAuthProvider.RefreshToken(ctx, refreshToken)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to refresh token: %w", err)
        }</span>

        <span class="cov0" title="0">return &amp;OAuthTokens{
                AccessToken:  token.AccessToken,
                RefreshToken: token.RefreshToken,
                ExpiresIn:    int(token.Expiry.Unix()),
        }, nil</span>
}

// GetUserInfo retrieves user information from Google
func (p *GoogleOAuthProvider) GetUserInfo(ctx context.Context, accessToken string) (*OAuthUserInfo, error) <span class="cov0" title="0">{
        req, err := http.NewRequestWithContext(ctx, "GET", googleUserInfoURL, nil)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to create request: %w", err)
        }</span>

        <span class="cov0" title="0">req.Header.Set("Authorization", "Bearer "+accessToken)

        client := &amp;http.Client{}
        resp, err := client.Do(req)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to get user info: %w", err)
        }</span>
        <span class="cov0" title="0">defer func() </span><span class="cov0" title="0">{
                _ = resp.Body.Close()
        }</span>()

        <span class="cov0" title="0">if resp.StatusCode != http.StatusOK </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("unexpected status code: %d", resp.StatusCode)
        }</span>

        <span class="cov0" title="0">var googleUser struct {
                ID            string `json:"id"`
                Email         string `json:"email"`
                VerifiedEmail bool   `json:"verified_email"`
                Name          string `json:"name"`
                Picture       string `json:"picture"`
                Locale        string `json:"locale"`
        }

        if err := json.NewDecoder(resp.Body).Decode(&amp;googleUser); err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to decode response: %w", err)
        }</span>

        <span class="cov0" title="0">return &amp;OAuthUserInfo{
                ProviderAccountID: googleUser.ID,
                Email:             googleUser.Email,
                EmailVerified:     googleUser.VerifiedEmail,
                Name:              googleUser.Name,
                Picture:           googleUser.Picture,
                Locale:            googleUser.Locale,
                Raw: map[string]interface{}{
                        "id":             googleUser.ID,
                        "email":          googleUser.Email,
                        "verified_email": googleUser.VerifiedEmail,
                        "name":           googleUser.Name,
                        "picture":        googleUser.Picture,
                        "locale":         googleUser.Locale,
                },
        }, nil</span>
}

// extractIDToken extracts the ID token from the OAuth2 token extra fields
func extractIDToken(token *oauth2.Token) string <span class="cov8" title="3">{
        if idToken, ok := token.Extra("id_token").(string); ok </span><span class="cov1" title="1">{
                return idToken
        }</span>
        <span class="cov5" title="2">return ""</span>
}
</pre>
		
		<pre class="file" id="file24" style="display: none">package auth

import (
        "context"
        "fmt"
        "log/slog"
        "strings"

        "github.com/labstack/echo/v4"
)

// Handler provides HTTP handlers for authentication operations
type Handler struct {
        service *Service
        logger  *slog.Logger
}

// Ensure Handler implements StrictServerInterface
var _ StrictServerInterface = (*Handler)(nil)

// NewHandler creates a new authentication handler
func NewHandler(service *Service, logger *slog.Logger) *Handler <span class="cov10" title="6">{
        return &amp;Handler{
                service: service,
                logger:  logger,
        }
}</span>

// NewAuthStrictHandler creates a StrictHandler with middleware
func NewAuthStrictHandler(handler StrictServerInterface) ServerInterface <span class="cov0" title="0">{
        return NewStrictHandler(handler, nil)
}</span>

// Register handles user registration (implements StrictServerInterface)
func (h *Handler) Register(ctx context.Context, req RegisterRequestObject) (RegisterResponseObject, error) <span class="cov4" title="2">{
        // Get IP address and user agent from echo context if available
        var ipAddress, userAgent string
        if echoCtx, ok := ctx.Value("echo.Context").(echo.Context); ok </span><span class="cov0" title="0">{
                ipAddress = echoCtx.RealIP()
                userAgent = echoCtx.Request().Header.Get("User-Agent")
        }</span>

        // Create the registration request
        <span class="cov4" title="2">registerReq := &amp;RegisterRequest{
                Email:    req.Body.Email,
                Password: req.Body.Password,
                Name:     req.Body.Name,
        }

        // Call the service to register the user
        _, tokens, err := h.service.Register(ctx, registerReq)
        if err != nil </span><span class="cov1" title="1">{
                switch err </span>{
                case ErrUserExists:<span class="cov1" title="1">
                        return Register401ApplicationProblemPlusJSONResponse{
                                UnauthorizedApplicationProblemPlusJSONResponse: UnauthorizedApplicationProblemPlusJSONResponse{
                                        Title:  "User already exists",
                                        Status: 409,
                                        Type:   "user-exists",
                                },
                        }, nil</span>
                default:<span class="cov0" title="0">
                        h.logger.Error("failed to register user", "error", err)
                        return nil, err</span>
                }
        }

        // Store IP and user agent in session if we have them
        <span class="cov1" title="1">if ipAddress != "" || userAgent != "" </span><span class="cov0" title="0">{
                // This would be handled in the service layer with proper session management
                _ = ipAddress
                _ = userAgent
        }</span>

        // Return the tokens in the response
        <span class="cov1" title="1">return Register201JSONResponse{
                AccessToken:  tokens.AccessToken,
                RefreshToken: tokens.RefreshToken,
                ExpiresIn:    tokens.ExpiresIn,
                TokenType:    tokens.TokenType,
        }, nil</span>
}

// Login handles user login (implements StrictServerInterface)
func (h *Handler) Login(ctx context.Context, req LoginRequestObject) (LoginResponseObject, error) <span class="cov4" title="2">{
        // Get IP address and user agent from echo context if available
        var ipAddress, userAgent string
        if echoCtx, ok := ctx.Value("echo.Context").(echo.Context); ok </span><span class="cov0" title="0">{
                ipAddress = echoCtx.RealIP()
                userAgent = echoCtx.Request().Header.Get("User-Agent")
        }</span>

        <span class="cov4" title="2">loginReq := &amp;LoginRequest{
                Email:    req.Body.Email,
                Password: req.Body.Password,
        }

        _, tokens, err := h.service.Login(ctx, loginReq, ipAddress, userAgent)
        if err != nil </span><span class="cov1" title="1">{
                switch err </span>{
                case ErrInvalidCredentials:<span class="cov1" title="1">
                        return Login401ApplicationProblemPlusJSONResponse{
                                UnauthorizedApplicationProblemPlusJSONResponse: UnauthorizedApplicationProblemPlusJSONResponse{
                                        Title:  "Invalid credentials",
                                        Status: 401,
                                        Type:   "invalid-credentials",
                                },
                        }, nil</span>
                default:<span class="cov0" title="0">
                        h.logger.Error("failed to login user", "error", err)
                        return nil, err</span>
                }
        }

        <span class="cov1" title="1">return Login200JSONResponse{
                AccessToken:  tokens.AccessToken,
                RefreshToken: tokens.RefreshToken,
                ExpiresIn:    tokens.ExpiresIn,
                TokenType:    tokens.TokenType,
        }, nil</span>
}

// Logout handles user logout (implements StrictServerInterface)
func (h *Handler) Logout(ctx context.Context, _ LogoutRequestObject) (LogoutResponseObject, error) <span class="cov4" title="2">{
        // Get the session token from context (set by middleware)
        token, ok := ctx.Value(SessionTokenContextKey).(string)
        if !ok </span><span class="cov0" title="0">{
                return Logout401ApplicationProblemPlusJSONResponse{
                        UnauthorizedApplicationProblemPlusJSONResponse: UnauthorizedApplicationProblemPlusJSONResponse{
                                Title:  "No session token",
                                Status: 401,
                                Type:   "no-session",
                        },
                }, nil
        }</span>

        <span class="cov4" title="2">err := h.service.Logout(ctx, token)
        if err != nil </span><span class="cov1" title="1">{
                if err == ErrInvalidToken </span><span class="cov1" title="1">{
                        return Logout401ApplicationProblemPlusJSONResponse{
                                UnauthorizedApplicationProblemPlusJSONResponse: UnauthorizedApplicationProblemPlusJSONResponse{
                                        Title:  "Invalid session",
                                        Status: 401,
                                        Type:   "invalid-session",
                                },
                        }, nil
                }</span>
                <span class="cov0" title="0">h.logger.Error("failed to logout user", "error", err)
                return nil, err</span>
        }

        <span class="cov1" title="1">return Logout204Response{}, nil</span>
}

// RefreshToken handles token refresh (implements StrictServerInterface)
// TODO: Add RefreshToken endpoint to OpenAPI spec
/*
func (h *Handler) RefreshToken(ctx context.Context, req RefreshTokenRequestObject) (RefreshTokenResponseObject, error) {
        refreshToken := req.Body.RefreshToken

        tokens, err := h.service.RefreshToken(ctx, refreshToken)
        if err != nil {
                switch err {
                case ErrInvalidToken:
                        return RefreshToken401ApplicationProblemPlusJSONResponse{
                                Title:  "Invalid refresh token",
                                Status: 401,
                                Type:   "invalid-token",
                        }, nil
                default:
                        h.logger.Error("failed to refresh token", "error", err)
                        return nil, err
                }
        }

        return RefreshToken200JSONResponse{
                AccessToken:  tokens.AccessToken,
                RefreshToken: tokens.RefreshToken,
                ExpiresIn:    tokens.ExpiresIn,
                TokenType:    tokens.TokenType,
        }, nil
}
*/

// VerifyToken handles token verification (implements StrictServerInterface)
// TODO: Add VerifyToken endpoint to OpenAPI spec
/*
func (h *Handler) VerifyToken(ctx context.Context, _ VerifyTokenRequestObject) (VerifyTokenResponseObject, error) {
        // Get the user from context (set by middleware)
        userID, ok := ctx.Value("user_id").(uuid.UUID)
        if !ok {
                return VerifyToken401ApplicationProblemPlusJSONResponse{
                        Title:  "Invalid token",
                        Status: 401,
                        Type:   "invalid-token",
                }, nil
        }

        return VerifyToken200JSONResponse{
                Valid:  true,
                UserId: userID,
        }, nil
}
*/

// AccountsFindMany handles listing accounts (stub implementation)
func (h *Handler) AccountsFindMany(_ context.Context, _ AccountsFindManyRequestObject) (AccountsFindManyResponseObject, error) <span class="cov0" title="0">{
        return nil, fmt.Errorf("not implemented")
}</span>

// AccountsDelete handles deleting an account (stub implementation)
func (h *Handler) AccountsDelete(_ context.Context, _ AccountsDeleteRequestObject) (AccountsDeleteResponseObject, error) <span class="cov0" title="0">{
        return nil, fmt.Errorf("not implemented")
}</span>

// AccountsGetOne handles getting a single account (stub implementation)
func (h *Handler) AccountsGetOne(_ context.Context, _ AccountsGetOneRequestObject) (AccountsGetOneResponseObject, error) <span class="cov0" title="0">{
        return nil, fmt.Errorf("not implemented")
}</span>

// FindManySessions handles listing sessions (stub implementation)
func (h *Handler) FindManySessions(_ context.Context, _ FindManySessionsRequestObject) (FindManySessionsResponseObject, error) <span class="cov0" title="0">{
        return nil, fmt.Errorf("not implemented")
}</span>

// DeleteSession handles deleting a session (stub implementation)
func (h *Handler) DeleteSession(_ context.Context, _ DeleteSessionRequestObject) (DeleteSessionResponseObject, error) <span class="cov0" title="0">{
        return nil, fmt.Errorf("not implemented")
}</span>

// GetOneSession handles getting a single session (stub implementation)
func (h *Handler) GetOneSession(_ context.Context, _ GetOneSessionRequestObject) (GetOneSessionResponseObject, error) <span class="cov0" title="0">{
        return nil, fmt.Errorf("not implemented")
}</span>

// UpdateSession handles updating a session (stub implementation)
func (h *Handler) UpdateSession(_ context.Context, _ UpdateSessionRequestObject) (UpdateSessionResponseObject, error) <span class="cov0" title="0">{
        return nil, fmt.Errorf("not implemented")
}</span>

// RequestEmailChange handles email change requests (stub implementation)
func (h *Handler) RequestEmailChange(_ context.Context, _ RequestEmailChangeRequestObject) (RequestEmailChangeResponseObject, error) <span class="cov0" title="0">{
        return nil, fmt.Errorf("not implemented")
}</span>

// ConfirmEmailChange handles email change confirmation (stub implementation)
func (h *Handler) ConfirmEmailChange(_ context.Context, _ ConfirmEmailChangeRequestObject) (ConfirmEmailChangeResponseObject, error) <span class="cov0" title="0">{
        return nil, fmt.Errorf("not implemented")
}</span>

// RequestEmailVerification handles email verification requests
func (h *Handler) RequestEmailVerification(ctx context.Context, _ RequestEmailVerificationRequestObject) (RequestEmailVerificationResponseObject, error) <span class="cov0" title="0">{
        // Get the authenticated user from context
        userClaims, ok := ctx.Value(AuthClaimsContextKey).(*EnhancedClaims)
        if !ok || userClaims == nil </span><span class="cov0" title="0">{
                // If no user in context, return unauthorized
                return RequestEmailVerification401ApplicationProblemPlusJSONResponse{
                        UnauthorizedApplicationProblemPlusJSONResponse: UnauthorizedApplicationProblemPlusJSONResponse{
                                Title:  "Unauthorized",
                                Status: 401,
                                Type:   "unauthorized",
                                Detail: "Authentication required",
                        },
                }, nil
        }</span>

        // Resend verification email
        <span class="cov0" title="0">err := h.service.ResendVerificationEmail(ctx, userClaims.Email)
        if err != nil </span><span class="cov0" title="0">{
                h.logger.Error("failed to resend verification email", "error", err, "email", userClaims.Email)
                return RequestEmailVerification400ApplicationProblemPlusJSONResponse{
                        BadRequestApplicationProblemPlusJSONResponse: BadRequestApplicationProblemPlusJSONResponse{
                                Title:  "Failed to send verification email",
                                Status: 400,
                                Type:   "email-send-failed",
                                Detail: "Could not send verification email. Please try again later.",
                        },
                }, nil
        }</span>

        // Return 204 No Content on success
        <span class="cov0" title="0">return RequestEmailVerification204Response{}, nil</span>
}

// ConfirmEmailVerification handles email verification confirmation
func (h *Handler) ConfirmEmailVerification(ctx context.Context, req ConfirmEmailVerificationRequestObject) (ConfirmEmailVerificationResponseObject, error) <span class="cov0" title="0">{
        if req.Body == nil || req.Body.Token == "" </span><span class="cov0" title="0">{
                return ConfirmEmailVerification401ApplicationProblemPlusJSONResponse{
                        UnauthorizedApplicationProblemPlusJSONResponse: UnauthorizedApplicationProblemPlusJSONResponse{
                                Title:  "Invalid request",
                                Status: 400,
                                Type:   "invalid-request",
                                Detail: "Verification token is required",
                        },
                }, nil
        }</span>

        // Verify the email using the token
        <span class="cov0" title="0">err := h.service.VerifyEmail(ctx, req.Body.Token)
        if err != nil </span><span class="cov0" title="0">{
                switch err </span>{
                case ErrInvalidToken:<span class="cov0" title="0">
                        return ConfirmEmailVerification404ApplicationProblemPlusJSONResponse{
                                NotFoundApplicationProblemPlusJSONResponse: NotFoundApplicationProblemPlusJSONResponse{
                                        Title:  "Invalid token",
                                        Status: 404,
                                        Type:   "invalid-token",
                                        Detail: "The verification token is invalid or has been used",
                                },
                        }, nil</span>
                case ErrTokenExpired:<span class="cov0" title="0">
                        return ConfirmEmailVerification401ApplicationProblemPlusJSONResponse{
                                UnauthorizedApplicationProblemPlusJSONResponse: UnauthorizedApplicationProblemPlusJSONResponse{
                                        Title:  "Token expired",
                                        Status: 401,
                                        Type:   "token-expired",
                                        Detail: "The verification token has expired. Please request a new one.",
                                },
                        }, nil</span>
                case ErrUserNotFound:<span class="cov0" title="0">
                        return ConfirmEmailVerification404ApplicationProblemPlusJSONResponse{
                                NotFoundApplicationProblemPlusJSONResponse: NotFoundApplicationProblemPlusJSONResponse{
                                        Title:  "User not found",
                                        Status: 404,
                                        Type:   "user-not-found",
                                        Detail: "The user associated with this token was not found",
                                },
                        }, nil</span>
                default:<span class="cov0" title="0">
                        h.logger.Error("failed to verify email", "error", err)
                        return nil, err</span>
                }
        }

        // Get the verified user to return in response
        // Note: We need to get user details from the token verification process
        // For now, we'll create a simple response - in production, you'd want to
        // return the actual user and session details

        // TODO: Generate new session for the verified user
        // For now, return a successful response without session details
        <span class="cov0" title="0">return ConfirmEmailVerification200JSONResponse{
                User: User{
                        // This would be populated from the actual verified user
                        Email:         Email("verified@example.com"),
                        EmailVerified: true,
                        Name:          "Verified User",
                },
                Session: Session{
                        // This would be a newly created session
                },
        }, nil</span>
}

// RequestPasswordReset handles password reset requests
func (h *Handler) RequestPasswordReset(ctx context.Context, req RequestPasswordResetRequestObject) (RequestPasswordResetResponseObject, error) <span class="cov0" title="0">{
        if req.Body == nil || req.Body.Email == "" </span><span class="cov0" title="0">{
                return RequestPasswordReset400ApplicationProblemPlusJSONResponse{
                        BadRequestApplicationProblemPlusJSONResponse: BadRequestApplicationProblemPlusJSONResponse{
                                Title:  "Invalid request",
                                Status: 400,
                                Type:   "invalid-request",
                                Detail: "Email address is required",
                        },
                }, nil
        }</span>

        // Request password reset
        <span class="cov0" title="0">err := h.service.RequestPasswordReset(ctx, req.Body.Email)
        if err != nil </span><span class="cov0" title="0">{
                h.logger.Error("failed to request password reset", "error", err, "email", req.Body.Email)
                return RequestPasswordReset400ApplicationProblemPlusJSONResponse{
                        BadRequestApplicationProblemPlusJSONResponse: BadRequestApplicationProblemPlusJSONResponse{
                                Title:  "Failed to send password reset email",
                                Status: 400,
                                Type:   "email-send-failed",
                                Detail: "Could not send password reset email. Please try again later.",
                        },
                }, nil
        }</span>

        // Return 204 No Content on success (don't reveal if email exists)
        <span class="cov0" title="0">return RequestPasswordReset204Response{}, nil</span>
}

// ConfirmPasswordReset handles password reset confirmation
func (h *Handler) ConfirmPasswordReset(ctx context.Context, req ConfirmPasswordResetRequestObject) (ConfirmPasswordResetResponseObject, error) <span class="cov0" title="0">{
        if req.Body == nil || req.Body.Token == "" || req.Body.NewPassword == "" </span><span class="cov0" title="0">{
                return ConfirmPasswordReset401ApplicationProblemPlusJSONResponse{
                        UnauthorizedApplicationProblemPlusJSONResponse: UnauthorizedApplicationProblemPlusJSONResponse{
                                Title:  "Invalid request",
                                Status: 400,
                                Type:   "invalid-request",
                                Detail: "Token and new password are required",
                        },
                }, nil
        }</span>

        // Confirm password reset
        <span class="cov0" title="0">err := h.service.ConfirmPasswordReset(ctx, req.Body.Token, req.Body.NewPassword)
        if err != nil </span><span class="cov0" title="0">{
                switch err </span>{
                case ErrInvalidToken:<span class="cov0" title="0">
                        return ConfirmPasswordReset404ApplicationProblemPlusJSONResponse{
                                NotFoundApplicationProblemPlusJSONResponse{
                                        Title:  "Invalid token",
                                        Status: 404,
                                        Type:   "invalid-token",
                                        Detail: "The password reset token is invalid or has been used",
                                },
                        }, nil</span>
                case ErrTokenExpired:<span class="cov0" title="0">
                        return ConfirmPasswordReset401ApplicationProblemPlusJSONResponse{
                                UnauthorizedApplicationProblemPlusJSONResponse: UnauthorizedApplicationProblemPlusJSONResponse{
                                        Title:  "Token expired",
                                        Status: 401,
                                        Type:   "token-expired",
                                        Detail: "The password reset token has expired. Please request a new one.",
                                },
                        }, nil</span>
                case ErrUserNotFound, ErrAccountNotFound:<span class="cov0" title="0">
                        return ConfirmPasswordReset404ApplicationProblemPlusJSONResponse{
                                NotFoundApplicationProblemPlusJSONResponse{
                                        Title:  "User not found",
                                        Status: 404,
                                        Type:   "user-not-found",
                                        Detail: "The user associated with this token was not found",
                                },
                        }, nil</span>
                default:<span class="cov0" title="0">
                        // Check if it's a password validation error
                        if strings.Contains(err.Error(), "password validation failed") </span><span class="cov0" title="0">{
                                return ConfirmPasswordReset401ApplicationProblemPlusJSONResponse{
                                        UnauthorizedApplicationProblemPlusJSONResponse: UnauthorizedApplicationProblemPlusJSONResponse{
                                                Title:  "Invalid password",
                                                Status: 400,
                                                Type:   "invalid-password",
                                                Detail: err.Error(),
                                        },
                                }, nil
                        }</span>
                        <span class="cov0" title="0">h.logger.Error("failed to confirm password reset", "error", err)
                        return nil, err</span>
                }
        }

        // Return 204 No Content on success
        <span class="cov0" title="0">return ConfirmPasswordReset204Response{}, nil</span>
}
</pre>
		
		<pre class="file" id="file25" style="display: none">// Package auth provides primitives to interact with the openapi HTTP API.
//
// Code generated by github.com/oapi-codegen/oapi-codegen/v2 version v2.5.0 DO NOT EDIT.
package auth

import (
        "context"
        "encoding/json"
        "fmt"
        "net/http"

        "github.com/labstack/echo/v4"
        "github.com/oapi-codegen/runtime"
        strictecho "github.com/oapi-codegen/runtime/strictmiddleware/echo"
        openapi_types "github.com/oapi-codegen/runtime/types"
)

// ServerInterface represents all server handlers.
type ServerInterface interface {
        // Find many accounts
        // (GET /auth/accounts)
        AccountsFindMany(ctx echo.Context, params AccountsFindManyParams) error
        // Delete an account
        // (DELETE /auth/accounts/{id})
        AccountsDelete(ctx echo.Context, id openapi_types.UUID) error
        // Find an account
        // (GET /auth/accounts/{id})
        AccountsGetOne(ctx echo.Context, id openapi_types.UUID) error
        // Request e-mail change
        // (POST /auth/email-change/request)
        RequestEmailChange(ctx echo.Context) error
        // Verify e-mail change
        // (POST /auth/email-change/verify)
        ConfirmEmailChange(ctx echo.Context) error
        // Request e-mail verification
        // (POST /auth/email-verification/request)
        RequestEmailVerification(ctx echo.Context) error
        // Confirm e-mail verification
        // (POST /auth/email-verification/verify)
        ConfirmEmailVerification(ctx echo.Context) error
        // Login
        // (POST /auth/login)
        Login(ctx echo.Context) error
        // Logout
        // (POST /auth/logout)
        Logout(ctx echo.Context) error
        // Request password reset
        // (POST /auth/password-reset/request)
        RequestPasswordReset(ctx echo.Context) error
        // Verify password reset
        // (POST /auth/password-reset/verify)
        ConfirmPasswordReset(ctx echo.Context) error
        // Register
        // (POST /auth/register)
        Register(ctx echo.Context) error
        // Find many sessions
        // (GET /auth/sessions)
        FindManySessions(ctx echo.Context, params FindManySessionsParams) error
        // Delete a session
        // (DELETE /auth/sessions/{id})
        DeleteSession(ctx echo.Context, id openapi_types.UUID) error
        // Find a session
        // (GET /auth/sessions/{id})
        GetOneSession(ctx echo.Context, id openapi_types.UUID) error
        // Update Session
        // (PATCH /auth/sessions/{id})
        UpdateSession(ctx echo.Context, id openapi_types.UUID) error
}

// ServerInterfaceWrapper converts echo contexts to parameters.
type ServerInterfaceWrapper struct {
        Handler ServerInterface
}

// AccountsFindMany converts echo context to params.
func (w *ServerInterfaceWrapper) AccountsFindMany(ctx echo.Context) error <span class="cov0" title="0">{
        var err error

        ctx.Set(BearerAuthScopes, []string{})

        // Parameter object where we will unmarshal all parameters from the context
        var params AccountsFindManyParams
        // ------------- Optional query parameter "filter" -------------

        err = runtime.BindQueryParameter("deepObject", true, false, "filter", ctx.QueryParams(), &amp;params.Filter)
        if err != nil </span><span class="cov0" title="0">{
                return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter filter: %s", err))
        }</span>

        // ------------- Optional query parameter "page" -------------

        <span class="cov0" title="0">err = runtime.BindQueryParameter("form", true, false, "page", ctx.QueryParams(), &amp;params.Page)
        if err != nil </span><span class="cov0" title="0">{
                return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter page: %s", err))
        }</span>

        // ------------- Optional query parameter "sort" -------------

        <span class="cov0" title="0">err = runtime.BindQueryParameter("form", true, false, "sort", ctx.QueryParams(), &amp;params.Sort)
        if err != nil </span><span class="cov0" title="0">{
                return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter sort: %s", err))
        }</span>

        // Invoke the callback with all the unmarshaled arguments
        <span class="cov0" title="0">err = w.Handler.AccountsFindMany(ctx, params)
        return err</span>
}

// AccountsDelete converts echo context to params.
func (w *ServerInterfaceWrapper) AccountsDelete(ctx echo.Context) error <span class="cov0" title="0">{
        var err error
        // ------------- Path parameter "id" -------------
        var id openapi_types.UUID

        err = runtime.BindStyledParameterWithOptions("simple", "id", ctx.Param("id"), &amp;id, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
        if err != nil </span><span class="cov0" title="0">{
                return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter id: %s", err))
        }</span>

        <span class="cov0" title="0">ctx.Set(BearerAuthScopes, []string{})

        // Invoke the callback with all the unmarshaled arguments
        err = w.Handler.AccountsDelete(ctx, id)
        return err</span>
}

// AccountsGetOne converts echo context to params.
func (w *ServerInterfaceWrapper) AccountsGetOne(ctx echo.Context) error <span class="cov0" title="0">{
        var err error
        // ------------- Path parameter "id" -------------
        var id openapi_types.UUID

        err = runtime.BindStyledParameterWithOptions("simple", "id", ctx.Param("id"), &amp;id, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
        if err != nil </span><span class="cov0" title="0">{
                return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter id: %s", err))
        }</span>

        <span class="cov0" title="0">ctx.Set(BearerAuthScopes, []string{})

        // Invoke the callback with all the unmarshaled arguments
        err = w.Handler.AccountsGetOne(ctx, id)
        return err</span>
}

// RequestEmailChange converts echo context to params.
func (w *ServerInterfaceWrapper) RequestEmailChange(ctx echo.Context) error <span class="cov0" title="0">{
        var err error

        ctx.Set(BearerAuthScopes, []string{})

        ctx.Set(SessionCookieScopes, []string{})

        // Invoke the callback with all the unmarshaled arguments
        err = w.Handler.RequestEmailChange(ctx)
        return err
}</span>

// ConfirmEmailChange converts echo context to params.
func (w *ServerInterfaceWrapper) ConfirmEmailChange(ctx echo.Context) error <span class="cov0" title="0">{
        var err error

        ctx.Set(BearerAuthScopes, []string{})

        ctx.Set(SessionCookieScopes, []string{})

        // Invoke the callback with all the unmarshaled arguments
        err = w.Handler.ConfirmEmailChange(ctx)
        return err
}</span>

// RequestEmailVerification converts echo context to params.
func (w *ServerInterfaceWrapper) RequestEmailVerification(ctx echo.Context) error <span class="cov0" title="0">{
        var err error

        ctx.Set(BearerAuthScopes, []string{})

        // Invoke the callback with all the unmarshaled arguments
        err = w.Handler.RequestEmailVerification(ctx)
        return err
}</span>

// ConfirmEmailVerification converts echo context to params.
func (w *ServerInterfaceWrapper) ConfirmEmailVerification(ctx echo.Context) error <span class="cov0" title="0">{
        var err error

        ctx.Set(BearerAuthScopes, []string{})

        ctx.Set(SessionCookieScopes, []string{})

        // Invoke the callback with all the unmarshaled arguments
        err = w.Handler.ConfirmEmailVerification(ctx)
        return err
}</span>

// Login converts echo context to params.
func (w *ServerInterfaceWrapper) Login(ctx echo.Context) error <span class="cov0" title="0">{
        var err error

        ctx.Set(BearerAuthScopes, []string{})

        ctx.Set(SessionCookieScopes, []string{})

        // Invoke the callback with all the unmarshaled arguments
        err = w.Handler.Login(ctx)
        return err
}</span>

// Logout converts echo context to params.
func (w *ServerInterfaceWrapper) Logout(ctx echo.Context) error <span class="cov0" title="0">{
        var err error

        ctx.Set(BearerAuthScopes, []string{})

        ctx.Set(SessionCookieScopes, []string{})

        // Invoke the callback with all the unmarshaled arguments
        err = w.Handler.Logout(ctx)
        return err
}</span>

// RequestPasswordReset converts echo context to params.
func (w *ServerInterfaceWrapper) RequestPasswordReset(ctx echo.Context) error <span class="cov0" title="0">{
        var err error

        ctx.Set(BearerAuthScopes, []string{})

        ctx.Set(SessionCookieScopes, []string{})

        // Invoke the callback with all the unmarshaled arguments
        err = w.Handler.RequestPasswordReset(ctx)
        return err
}</span>

// ConfirmPasswordReset converts echo context to params.
func (w *ServerInterfaceWrapper) ConfirmPasswordReset(ctx echo.Context) error <span class="cov0" title="0">{
        var err error

        ctx.Set(BearerAuthScopes, []string{})

        ctx.Set(SessionCookieScopes, []string{})

        // Invoke the callback with all the unmarshaled arguments
        err = w.Handler.ConfirmPasswordReset(ctx)
        return err
}</span>

// Register converts echo context to params.
func (w *ServerInterfaceWrapper) Register(ctx echo.Context) error <span class="cov0" title="0">{
        var err error

        ctx.Set(BearerAuthScopes, []string{})

        ctx.Set(SessionCookieScopes, []string{})

        // Invoke the callback with all the unmarshaled arguments
        err = w.Handler.Register(ctx)
        return err
}</span>

// FindManySessions converts echo context to params.
func (w *ServerInterfaceWrapper) FindManySessions(ctx echo.Context) error <span class="cov0" title="0">{
        var err error

        ctx.Set(BearerAuthScopes, []string{})

        // Parameter object where we will unmarshal all parameters from the context
        var params FindManySessionsParams
        // ------------- Optional query parameter "filter" -------------

        err = runtime.BindQueryParameter("deepObject", true, false, "filter", ctx.QueryParams(), &amp;params.Filter)
        if err != nil </span><span class="cov0" title="0">{
                return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter filter: %s", err))
        }</span>

        // ------------- Optional query parameter "page" -------------

        <span class="cov0" title="0">err = runtime.BindQueryParameter("form", true, false, "page", ctx.QueryParams(), &amp;params.Page)
        if err != nil </span><span class="cov0" title="0">{
                return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter page: %s", err))
        }</span>

        // ------------- Optional query parameter "sort" -------------

        <span class="cov0" title="0">err = runtime.BindQueryParameter("form", true, false, "sort", ctx.QueryParams(), &amp;params.Sort)
        if err != nil </span><span class="cov0" title="0">{
                return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter sort: %s", err))
        }</span>

        // Invoke the callback with all the unmarshaled arguments
        <span class="cov0" title="0">err = w.Handler.FindManySessions(ctx, params)
        return err</span>
}

// DeleteSession converts echo context to params.
func (w *ServerInterfaceWrapper) DeleteSession(ctx echo.Context) error <span class="cov0" title="0">{
        var err error
        // ------------- Path parameter "id" -------------
        var id openapi_types.UUID

        err = runtime.BindStyledParameterWithOptions("simple", "id", ctx.Param("id"), &amp;id, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
        if err != nil </span><span class="cov0" title="0">{
                return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter id: %s", err))
        }</span>

        <span class="cov0" title="0">ctx.Set(BearerAuthScopes, []string{})

        // Invoke the callback with all the unmarshaled arguments
        err = w.Handler.DeleteSession(ctx, id)
        return err</span>
}

// GetOneSession converts echo context to params.
func (w *ServerInterfaceWrapper) GetOneSession(ctx echo.Context) error <span class="cov0" title="0">{
        var err error
        // ------------- Path parameter "id" -------------
        var id openapi_types.UUID

        err = runtime.BindStyledParameterWithOptions("simple", "id", ctx.Param("id"), &amp;id, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
        if err != nil </span><span class="cov0" title="0">{
                return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter id: %s", err))
        }</span>

        <span class="cov0" title="0">ctx.Set(BearerAuthScopes, []string{})

        // Invoke the callback with all the unmarshaled arguments
        err = w.Handler.GetOneSession(ctx, id)
        return err</span>
}

// UpdateSession converts echo context to params.
func (w *ServerInterfaceWrapper) UpdateSession(ctx echo.Context) error <span class="cov0" title="0">{
        var err error
        // ------------- Path parameter "id" -------------
        var id openapi_types.UUID

        err = runtime.BindStyledParameterWithOptions("simple", "id", ctx.Param("id"), &amp;id, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
        if err != nil </span><span class="cov0" title="0">{
                return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter id: %s", err))
        }</span>

        <span class="cov0" title="0">ctx.Set(BearerAuthScopes, []string{})

        ctx.Set(SessionCookieScopes, []string{})

        // Invoke the callback with all the unmarshaled arguments
        err = w.Handler.UpdateSession(ctx, id)
        return err</span>
}

// This is a simple interface which specifies echo.Route addition functions which
// are present on both echo.Echo and echo.Group, since we want to allow using
// either of them for path registration
type EchoRouter interface {
        CONNECT(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
        DELETE(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
        GET(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
        HEAD(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
        OPTIONS(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
        PATCH(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
        POST(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
        PUT(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
        TRACE(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
}

// RegisterHandlers adds each server route to the EchoRouter.
func RegisterHandlers(router EchoRouter, si ServerInterface) <span class="cov0" title="0">{
        RegisterHandlersWithBaseURL(router, si, "")
}</span>

// Registers handlers, and prepends BaseURL to the paths, so that the paths
// can be served under a prefix.
func RegisterHandlersWithBaseURL(router EchoRouter, si ServerInterface, baseURL string) <span class="cov0" title="0">{

        wrapper := ServerInterfaceWrapper{
                Handler: si,
        }

        router.GET(baseURL+"/auth/accounts", wrapper.AccountsFindMany)
        router.DELETE(baseURL+"/auth/accounts/:id", wrapper.AccountsDelete)
        router.GET(baseURL+"/auth/accounts/:id", wrapper.AccountsGetOne)
        router.POST(baseURL+"/auth/email-change/request", wrapper.RequestEmailChange)
        router.POST(baseURL+"/auth/email-change/verify", wrapper.ConfirmEmailChange)
        router.POST(baseURL+"/auth/email-verification/request", wrapper.RequestEmailVerification)
        router.POST(baseURL+"/auth/email-verification/verify", wrapper.ConfirmEmailVerification)
        router.POST(baseURL+"/auth/login", wrapper.Login)
        router.POST(baseURL+"/auth/logout", wrapper.Logout)
        router.POST(baseURL+"/auth/password-reset/request", wrapper.RequestPasswordReset)
        router.POST(baseURL+"/auth/password-reset/verify", wrapper.ConfirmPasswordReset)
        router.POST(baseURL+"/auth/register", wrapper.Register)
        router.GET(baseURL+"/auth/sessions", wrapper.FindManySessions)
        router.DELETE(baseURL+"/auth/sessions/:id", wrapper.DeleteSession)
        router.GET(baseURL+"/auth/sessions/:id", wrapper.GetOneSession)
        router.PATCH(baseURL+"/auth/sessions/:id", wrapper.UpdateSession)

}</span>

type BadRequestApplicationProblemPlusJSONResponse Problem

type NoContentResponse struct {
}

type NotFoundApplicationProblemPlusJSONResponse Problem

type UnauthorizedApplicationProblemPlusJSONResponse Problem

type AccountsFindManyRequestObject struct {
        Params AccountsFindManyParams
}

type AccountsFindManyResponseObject interface {
        VisitAccountsFindManyResponse(w http.ResponseWriter) error
}

type AccountsFindMany200JSONResponse struct {
        Data []Account `json:"data"`
        Meta struct {
                Total float32 `json:"total"`
        } `json:"meta"`
}

func (response AccountsFindMany200JSONResponse) VisitAccountsFindManyResponse(w http.ResponseWriter) error <span class="cov0" title="0">{
        w.Header().Set("Content-Type", "application/json")
        w.WriteHeader(200)

        return json.NewEncoder(w).Encode(response)
}</span>

type AccountsFindMany400ApplicationProblemPlusJSONResponse struct {
        BadRequestApplicationProblemPlusJSONResponse
}

func (response AccountsFindMany400ApplicationProblemPlusJSONResponse) VisitAccountsFindManyResponse(w http.ResponseWriter) error <span class="cov0" title="0">{
        w.Header().Set("Content-Type", "application/problem+json")
        w.WriteHeader(400)

        return json.NewEncoder(w).Encode(response)
}</span>

type AccountsFindMany401ApplicationProblemPlusJSONResponse struct {
        UnauthorizedApplicationProblemPlusJSONResponse
}

func (response AccountsFindMany401ApplicationProblemPlusJSONResponse) VisitAccountsFindManyResponse(w http.ResponseWriter) error <span class="cov0" title="0">{
        w.Header().Set("Content-Type", "application/problem+json")
        w.WriteHeader(401)

        return json.NewEncoder(w).Encode(response)
}</span>

type AccountsDeleteRequestObject struct {
        Id openapi_types.UUID `json:"id"`
}

type AccountsDeleteResponseObject interface {
        VisitAccountsDeleteResponse(w http.ResponseWriter) error
}

type AccountsDelete200JSONResponse struct {
        // Data Schema for Account entity (authentication provider account)
        Data Account `json:"data"`
}

func (response AccountsDelete200JSONResponse) VisitAccountsDeleteResponse(w http.ResponseWriter) error <span class="cov0" title="0">{
        w.Header().Set("Content-Type", "application/json")
        w.WriteHeader(200)

        return json.NewEncoder(w).Encode(response)
}</span>

type AccountsDelete404ApplicationProblemPlusJSONResponse struct {
        NotFoundApplicationProblemPlusJSONResponse
}

func (response AccountsDelete404ApplicationProblemPlusJSONResponse) VisitAccountsDeleteResponse(w http.ResponseWriter) error <span class="cov0" title="0">{
        w.Header().Set("Content-Type", "application/problem+json")
        w.WriteHeader(404)

        return json.NewEncoder(w).Encode(response)
}</span>

type AccountsGetOneRequestObject struct {
        Id openapi_types.UUID `json:"id"`
}

type AccountsGetOneResponseObject interface {
        VisitAccountsGetOneResponse(w http.ResponseWriter) error
}

type AccountsGetOne200JSONResponse struct {
        // Data Schema for Account entity (authentication provider account)
        Data Account `json:"data"`
}

func (response AccountsGetOne200JSONResponse) VisitAccountsGetOneResponse(w http.ResponseWriter) error <span class="cov0" title="0">{
        w.Header().Set("Content-Type", "application/json")
        w.WriteHeader(200)

        return json.NewEncoder(w).Encode(response)
}</span>

type AccountsGetOne404ApplicationProblemPlusJSONResponse struct {
        NotFoundApplicationProblemPlusJSONResponse
}

func (response AccountsGetOne404ApplicationProblemPlusJSONResponse) VisitAccountsGetOneResponse(w http.ResponseWriter) error <span class="cov0" title="0">{
        w.Header().Set("Content-Type", "application/problem+json")
        w.WriteHeader(404)

        return json.NewEncoder(w).Encode(response)
}</span>

type RequestEmailChangeRequestObject struct {
        Body *RequestEmailChangeJSONRequestBody
}

type RequestEmailChangeResponseObject interface {
        VisitRequestEmailChangeResponse(w http.ResponseWriter) error
}

type RequestEmailChange204Response = NoContentResponse

func (response RequestEmailChange204Response) VisitRequestEmailChangeResponse(w http.ResponseWriter) error <span class="cov0" title="0">{
        w.WriteHeader(204)
        return nil
}</span>

type RequestEmailChange400ApplicationProblemPlusJSONResponse struct {
        BadRequestApplicationProblemPlusJSONResponse
}

func (response RequestEmailChange400ApplicationProblemPlusJSONResponse) VisitRequestEmailChangeResponse(w http.ResponseWriter) error <span class="cov0" title="0">{
        w.Header().Set("Content-Type", "application/problem+json")
        w.WriteHeader(400)

        return json.NewEncoder(w).Encode(response)
}</span>

type RequestEmailChange401ApplicationProblemPlusJSONResponse struct {
        UnauthorizedApplicationProblemPlusJSONResponse
}

func (response RequestEmailChange401ApplicationProblemPlusJSONResponse) VisitRequestEmailChangeResponse(w http.ResponseWriter) error <span class="cov0" title="0">{
        w.Header().Set("Content-Type", "application/problem+json")
        w.WriteHeader(401)

        return json.NewEncoder(w).Encode(response)
}</span>

type ConfirmEmailChangeRequestObject struct {
        Body *ConfirmEmailChangeJSONRequestBody
}

type ConfirmEmailChangeResponseObject interface {
        VisitConfirmEmailChangeResponse(w http.ResponseWriter) error
}

type ConfirmEmailChange204ApplicationProblemPlusJSONResponse struct {
        NotFoundApplicationProblemPlusJSONResponse
}

func (response ConfirmEmailChange204ApplicationProblemPlusJSONResponse) VisitConfirmEmailChangeResponse(w http.ResponseWriter) error <span class="cov0" title="0">{
        w.Header().Set("Content-Type", "application/problem+json")
        w.WriteHeader(204)

        return json.NewEncoder(w).Encode(response)
}</span>

type ConfirmEmailChange401ApplicationProblemPlusJSONResponse struct {
        UnauthorizedApplicationProblemPlusJSONResponse
}

func (response ConfirmEmailChange401ApplicationProblemPlusJSONResponse) VisitConfirmEmailChangeResponse(w http.ResponseWriter) error <span class="cov0" title="0">{
        w.Header().Set("Content-Type", "application/problem+json")
        w.WriteHeader(401)

        return json.NewEncoder(w).Encode(response)
}</span>

type ConfirmEmailChange404ApplicationProblemPlusJSONResponse Problem

func (response ConfirmEmailChange404ApplicationProblemPlusJSONResponse) VisitConfirmEmailChangeResponse(w http.ResponseWriter) error <span class="cov0" title="0">{
        w.Header().Set("Content-Type", "application/problem+json")
        w.WriteHeader(404)

        return json.NewEncoder(w).Encode(response)
}</span>

type RequestEmailVerificationRequestObject struct {
}

type RequestEmailVerificationResponseObject interface {
        VisitRequestEmailVerificationResponse(w http.ResponseWriter) error
}

type RequestEmailVerification204Response = NoContentResponse

func (response RequestEmailVerification204Response) VisitRequestEmailVerificationResponse(w http.ResponseWriter) error <span class="cov0" title="0">{
        w.WriteHeader(204)
        return nil
}</span>

type RequestEmailVerification400ApplicationProblemPlusJSONResponse struct {
        BadRequestApplicationProblemPlusJSONResponse
}

func (response RequestEmailVerification400ApplicationProblemPlusJSONResponse) VisitRequestEmailVerificationResponse(w http.ResponseWriter) error <span class="cov0" title="0">{
        w.Header().Set("Content-Type", "application/problem+json")
        w.WriteHeader(400)

        return json.NewEncoder(w).Encode(response)
}</span>

type RequestEmailVerification401ApplicationProblemPlusJSONResponse struct {
        UnauthorizedApplicationProblemPlusJSONResponse
}

func (response RequestEmailVerification401ApplicationProblemPlusJSONResponse) VisitRequestEmailVerificationResponse(w http.ResponseWriter) error <span class="cov0" title="0">{
        w.Header().Set("Content-Type", "application/problem+json")
        w.WriteHeader(401)

        return json.NewEncoder(w).Encode(response)
}</span>

type ConfirmEmailVerificationRequestObject struct {
        Body *ConfirmEmailVerificationJSONRequestBody
}

type ConfirmEmailVerificationResponseObject interface {
        VisitConfirmEmailVerificationResponse(w http.ResponseWriter) error
}

type ConfirmEmailVerification200JSONResponse struct {
        // Session Schema for Session entity
        Session Session `json:"session"`

        // User Schema for User entity
        User User `json:"user"`
}

func (response ConfirmEmailVerification200JSONResponse) VisitConfirmEmailVerificationResponse(w http.ResponseWriter) error <span class="cov0" title="0">{
        w.Header().Set("Content-Type", "application/json")
        w.WriteHeader(200)

        return json.NewEncoder(w).Encode(response)
}</span>

type ConfirmEmailVerification401ApplicationProblemPlusJSONResponse struct {
        UnauthorizedApplicationProblemPlusJSONResponse
}

func (response ConfirmEmailVerification401ApplicationProblemPlusJSONResponse) VisitConfirmEmailVerificationResponse(w http.ResponseWriter) error <span class="cov0" title="0">{
        w.Header().Set("Content-Type", "application/problem+json")
        w.WriteHeader(401)

        return json.NewEncoder(w).Encode(response)
}</span>

type ConfirmEmailVerification404ApplicationProblemPlusJSONResponse struct {
        NotFoundApplicationProblemPlusJSONResponse
}

func (response ConfirmEmailVerification404ApplicationProblemPlusJSONResponse) VisitConfirmEmailVerificationResponse(w http.ResponseWriter) error <span class="cov0" title="0">{
        w.Header().Set("Content-Type", "application/problem+json")
        w.WriteHeader(404)

        return json.NewEncoder(w).Encode(response)
}</span>

type LoginRequestObject struct {
        Body *LoginJSONRequestBody
}

type LoginResponseObject interface {
        VisitLoginResponse(w http.ResponseWriter) error
}

type Login200JSONResponse TokenResponse

func (response Login200JSONResponse) VisitLoginResponse(w http.ResponseWriter) error <span class="cov0" title="0">{
        w.Header().Set("Content-Type", "application/json")
        w.WriteHeader(200)

        return json.NewEncoder(w).Encode(response)
}</span>

type Login401ApplicationProblemPlusJSONResponse struct {
        UnauthorizedApplicationProblemPlusJSONResponse
}

func (response Login401ApplicationProblemPlusJSONResponse) VisitLoginResponse(w http.ResponseWriter) error <span class="cov0" title="0">{
        w.Header().Set("Content-Type", "application/problem+json")
        w.WriteHeader(401)

        return json.NewEncoder(w).Encode(response)
}</span>

type LogoutRequestObject struct {
}

type LogoutResponseObject interface {
        VisitLogoutResponse(w http.ResponseWriter) error
}

type Logout204Response = NoContentResponse

func (response Logout204Response) VisitLogoutResponse(w http.ResponseWriter) error <span class="cov0" title="0">{
        w.WriteHeader(204)
        return nil
}</span>

type Logout401ApplicationProblemPlusJSONResponse struct {
        UnauthorizedApplicationProblemPlusJSONResponse
}

func (response Logout401ApplicationProblemPlusJSONResponse) VisitLogoutResponse(w http.ResponseWriter) error <span class="cov0" title="0">{
        w.Header().Set("Content-Type", "application/problem+json")
        w.WriteHeader(401)

        return json.NewEncoder(w).Encode(response)
}</span>

type RequestPasswordResetRequestObject struct {
        Body *RequestPasswordResetJSONRequestBody
}

type RequestPasswordResetResponseObject interface {
        VisitRequestPasswordResetResponse(w http.ResponseWriter) error
}

type RequestPasswordReset204Response = NoContentResponse

func (response RequestPasswordReset204Response) VisitRequestPasswordResetResponse(w http.ResponseWriter) error <span class="cov0" title="0">{
        w.WriteHeader(204)
        return nil
}</span>

type RequestPasswordReset400ApplicationProblemPlusJSONResponse struct {
        BadRequestApplicationProblemPlusJSONResponse
}

func (response RequestPasswordReset400ApplicationProblemPlusJSONResponse) VisitRequestPasswordResetResponse(w http.ResponseWriter) error <span class="cov0" title="0">{
        w.Header().Set("Content-Type", "application/problem+json")
        w.WriteHeader(400)

        return json.NewEncoder(w).Encode(response)
}</span>

type ConfirmPasswordResetRequestObject struct {
        Body *ConfirmPasswordResetJSONRequestBody
}

type ConfirmPasswordResetResponseObject interface {
        VisitConfirmPasswordResetResponse(w http.ResponseWriter) error
}

type ConfirmPasswordReset204Response = NoContentResponse

func (response ConfirmPasswordReset204Response) VisitConfirmPasswordResetResponse(w http.ResponseWriter) error <span class="cov0" title="0">{
        w.WriteHeader(204)
        return nil
}</span>

type ConfirmPasswordReset401ApplicationProblemPlusJSONResponse struct {
        UnauthorizedApplicationProblemPlusJSONResponse
}

func (response ConfirmPasswordReset401ApplicationProblemPlusJSONResponse) VisitConfirmPasswordResetResponse(w http.ResponseWriter) error <span class="cov0" title="0">{
        w.Header().Set("Content-Type", "application/problem+json")
        w.WriteHeader(401)

        return json.NewEncoder(w).Encode(response)
}</span>

type ConfirmPasswordReset404ApplicationProblemPlusJSONResponse struct {
        NotFoundApplicationProblemPlusJSONResponse
}

func (response ConfirmPasswordReset404ApplicationProblemPlusJSONResponse) VisitConfirmPasswordResetResponse(w http.ResponseWriter) error <span class="cov0" title="0">{
        w.Header().Set("Content-Type", "application/problem+json")
        w.WriteHeader(404)

        return json.NewEncoder(w).Encode(response)
}</span>

type RegisterRequestObject struct {
        Body *RegisterJSONRequestBody
}

type RegisterResponseObject interface {
        VisitRegisterResponse(w http.ResponseWriter) error
}

type Register201JSONResponse TokenResponse

func (response Register201JSONResponse) VisitRegisterResponse(w http.ResponseWriter) error <span class="cov0" title="0">{
        w.Header().Set("Content-Type", "application/json")
        w.WriteHeader(201)

        return json.NewEncoder(w).Encode(response)
}</span>

type Register401ApplicationProblemPlusJSONResponse struct {
        UnauthorizedApplicationProblemPlusJSONResponse
}

func (response Register401ApplicationProblemPlusJSONResponse) VisitRegisterResponse(w http.ResponseWriter) error <span class="cov0" title="0">{
        w.Header().Set("Content-Type", "application/problem+json")
        w.WriteHeader(401)

        return json.NewEncoder(w).Encode(response)
}</span>

type FindManySessionsRequestObject struct {
        Params FindManySessionsParams
}

type FindManySessionsResponseObject interface {
        VisitFindManySessionsResponse(w http.ResponseWriter) error
}

type FindManySessions200JSONResponse struct {
        Data []Session `json:"data"`
        Meta struct {
                // Total Total number of items in the collection
                Total float32 `json:"total"`
        } `json:"meta"`
}

func (response FindManySessions200JSONResponse) VisitFindManySessionsResponse(w http.ResponseWriter) error <span class="cov0" title="0">{
        w.Header().Set("Content-Type", "application/json")
        w.WriteHeader(200)

        return json.NewEncoder(w).Encode(response)
}</span>

type FindManySessions400ApplicationProblemPlusJSONResponse struct {
        BadRequestApplicationProblemPlusJSONResponse
}

func (response FindManySessions400ApplicationProblemPlusJSONResponse) VisitFindManySessionsResponse(w http.ResponseWriter) error <span class="cov0" title="0">{
        w.Header().Set("Content-Type", "application/problem+json")
        w.WriteHeader(400)

        return json.NewEncoder(w).Encode(response)
}</span>

type FindManySessions401ApplicationProblemPlusJSONResponse struct {
        UnauthorizedApplicationProblemPlusJSONResponse
}

func (response FindManySessions401ApplicationProblemPlusJSONResponse) VisitFindManySessionsResponse(w http.ResponseWriter) error <span class="cov0" title="0">{
        w.Header().Set("Content-Type", "application/problem+json")
        w.WriteHeader(401)

        return json.NewEncoder(w).Encode(response)
}</span>

type DeleteSessionRequestObject struct {
        Id openapi_types.UUID `json:"id"`
}

type DeleteSessionResponseObject interface {
        VisitDeleteSessionResponse(w http.ResponseWriter) error
}

type DeleteSession200JSONResponse struct {
        // Data Schema for Session entity
        Data Session `json:"data"`
}

func (response DeleteSession200JSONResponse) VisitDeleteSessionResponse(w http.ResponseWriter) error <span class="cov0" title="0">{
        w.Header().Set("Content-Type", "application/json")
        w.WriteHeader(200)

        return json.NewEncoder(w).Encode(response)
}</span>

type DeleteSession404ApplicationProblemPlusJSONResponse struct {
        NotFoundApplicationProblemPlusJSONResponse
}

func (response DeleteSession404ApplicationProblemPlusJSONResponse) VisitDeleteSessionResponse(w http.ResponseWriter) error <span class="cov0" title="0">{
        w.Header().Set("Content-Type", "application/problem+json")
        w.WriteHeader(404)

        return json.NewEncoder(w).Encode(response)
}</span>

type GetOneSessionRequestObject struct {
        Id openapi_types.UUID `json:"id"`
}

type GetOneSessionResponseObject interface {
        VisitGetOneSessionResponse(w http.ResponseWriter) error
}

type GetOneSession200JSONResponse struct {
        // Data Schema for Session entity
        Data Session `json:"data"`
}

func (response GetOneSession200JSONResponse) VisitGetOneSessionResponse(w http.ResponseWriter) error <span class="cov0" title="0">{
        w.Header().Set("Content-Type", "application/json")
        w.WriteHeader(200)

        return json.NewEncoder(w).Encode(response)
}</span>

type GetOneSession404ApplicationProblemPlusJSONResponse struct {
        NotFoundApplicationProblemPlusJSONResponse
}

func (response GetOneSession404ApplicationProblemPlusJSONResponse) VisitGetOneSessionResponse(w http.ResponseWriter) error <span class="cov0" title="0">{
        w.Header().Set("Content-Type", "application/problem+json")
        w.WriteHeader(404)

        return json.NewEncoder(w).Encode(response)
}</span>

type UpdateSessionRequestObject struct {
        Id   openapi_types.UUID `json:"id"`
        Body *UpdateSessionJSONRequestBody
}

type UpdateSessionResponseObject interface {
        VisitUpdateSessionResponse(w http.ResponseWriter) error
}

type UpdateSession200JSONResponse struct {
        // Data Schema for Session entity
        Data Session `json:"data"`
}

func (response UpdateSession200JSONResponse) VisitUpdateSessionResponse(w http.ResponseWriter) error <span class="cov0" title="0">{
        w.Header().Set("Content-Type", "application/json")
        w.WriteHeader(200)

        return json.NewEncoder(w).Encode(response)
}</span>

type UpdateSession401ApplicationProblemPlusJSONResponse struct {
        UnauthorizedApplicationProblemPlusJSONResponse
}

func (response UpdateSession401ApplicationProblemPlusJSONResponse) VisitUpdateSessionResponse(w http.ResponseWriter) error <span class="cov0" title="0">{
        w.Header().Set("Content-Type", "application/problem+json")
        w.WriteHeader(401)

        return json.NewEncoder(w).Encode(response)
}</span>

// StrictServerInterface represents all server handlers.
type StrictServerInterface interface {
        // Find many accounts
        // (GET /auth/accounts)
        AccountsFindMany(ctx context.Context, request AccountsFindManyRequestObject) (AccountsFindManyResponseObject, error)
        // Delete an account
        // (DELETE /auth/accounts/{id})
        AccountsDelete(ctx context.Context, request AccountsDeleteRequestObject) (AccountsDeleteResponseObject, error)
        // Find an account
        // (GET /auth/accounts/{id})
        AccountsGetOne(ctx context.Context, request AccountsGetOneRequestObject) (AccountsGetOneResponseObject, error)
        // Request e-mail change
        // (POST /auth/email-change/request)
        RequestEmailChange(ctx context.Context, request RequestEmailChangeRequestObject) (RequestEmailChangeResponseObject, error)
        // Verify e-mail change
        // (POST /auth/email-change/verify)
        ConfirmEmailChange(ctx context.Context, request ConfirmEmailChangeRequestObject) (ConfirmEmailChangeResponseObject, error)
        // Request e-mail verification
        // (POST /auth/email-verification/request)
        RequestEmailVerification(ctx context.Context, request RequestEmailVerificationRequestObject) (RequestEmailVerificationResponseObject, error)
        // Confirm e-mail verification
        // (POST /auth/email-verification/verify)
        ConfirmEmailVerification(ctx context.Context, request ConfirmEmailVerificationRequestObject) (ConfirmEmailVerificationResponseObject, error)
        // Login
        // (POST /auth/login)
        Login(ctx context.Context, request LoginRequestObject) (LoginResponseObject, error)
        // Logout
        // (POST /auth/logout)
        Logout(ctx context.Context, request LogoutRequestObject) (LogoutResponseObject, error)
        // Request password reset
        // (POST /auth/password-reset/request)
        RequestPasswordReset(ctx context.Context, request RequestPasswordResetRequestObject) (RequestPasswordResetResponseObject, error)
        // Verify password reset
        // (POST /auth/password-reset/verify)
        ConfirmPasswordReset(ctx context.Context, request ConfirmPasswordResetRequestObject) (ConfirmPasswordResetResponseObject, error)
        // Register
        // (POST /auth/register)
        Register(ctx context.Context, request RegisterRequestObject) (RegisterResponseObject, error)
        // Find many sessions
        // (GET /auth/sessions)
        FindManySessions(ctx context.Context, request FindManySessionsRequestObject) (FindManySessionsResponseObject, error)
        // Delete a session
        // (DELETE /auth/sessions/{id})
        DeleteSession(ctx context.Context, request DeleteSessionRequestObject) (DeleteSessionResponseObject, error)
        // Find a session
        // (GET /auth/sessions/{id})
        GetOneSession(ctx context.Context, request GetOneSessionRequestObject) (GetOneSessionResponseObject, error)
        // Update Session
        // (PATCH /auth/sessions/{id})
        UpdateSession(ctx context.Context, request UpdateSessionRequestObject) (UpdateSessionResponseObject, error)
}

type StrictHandlerFunc = strictecho.StrictEchoHandlerFunc
type StrictMiddlewareFunc = strictecho.StrictEchoMiddlewareFunc

func NewStrictHandler(ssi StrictServerInterface, middlewares []StrictMiddlewareFunc) ServerInterface <span class="cov0" title="0">{
        return &amp;strictHandler{ssi: ssi, middlewares: middlewares}
}</span>

type strictHandler struct {
        ssi         StrictServerInterface
        middlewares []StrictMiddlewareFunc
}

// AccountsFindMany operation middleware
func (sh *strictHandler) AccountsFindMany(ctx echo.Context, params AccountsFindManyParams) error <span class="cov0" title="0">{
        var request AccountsFindManyRequestObject

        request.Params = params

        handler := func(ctx echo.Context, request interface{}) (interface{}, error) </span><span class="cov0" title="0">{
                return sh.ssi.AccountsFindMany(ctx.Request().Context(), request.(AccountsFindManyRequestObject))
        }</span>
        <span class="cov0" title="0">for _, middleware := range sh.middlewares </span><span class="cov0" title="0">{
                handler = middleware(handler, "AccountsFindMany")
        }</span>

        <span class="cov0" title="0">response, err := handler(ctx, request)

        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span> else<span class="cov0" title="0"> if validResponse, ok := response.(AccountsFindManyResponseObject); ok </span><span class="cov0" title="0">{
                return validResponse.VisitAccountsFindManyResponse(ctx.Response())
        }</span> else<span class="cov0" title="0"> if response != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("unexpected response type: %T", response)
        }</span>
        <span class="cov0" title="0">return nil</span>
}

// AccountsDelete operation middleware
func (sh *strictHandler) AccountsDelete(ctx echo.Context, id openapi_types.UUID) error <span class="cov0" title="0">{
        var request AccountsDeleteRequestObject

        request.Id = id

        handler := func(ctx echo.Context, request interface{}) (interface{}, error) </span><span class="cov0" title="0">{
                return sh.ssi.AccountsDelete(ctx.Request().Context(), request.(AccountsDeleteRequestObject))
        }</span>
        <span class="cov0" title="0">for _, middleware := range sh.middlewares </span><span class="cov0" title="0">{
                handler = middleware(handler, "AccountsDelete")
        }</span>

        <span class="cov0" title="0">response, err := handler(ctx, request)

        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span> else<span class="cov0" title="0"> if validResponse, ok := response.(AccountsDeleteResponseObject); ok </span><span class="cov0" title="0">{
                return validResponse.VisitAccountsDeleteResponse(ctx.Response())
        }</span> else<span class="cov0" title="0"> if response != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("unexpected response type: %T", response)
        }</span>
        <span class="cov0" title="0">return nil</span>
}

// AccountsGetOne operation middleware
func (sh *strictHandler) AccountsGetOne(ctx echo.Context, id openapi_types.UUID) error <span class="cov0" title="0">{
        var request AccountsGetOneRequestObject

        request.Id = id

        handler := func(ctx echo.Context, request interface{}) (interface{}, error) </span><span class="cov0" title="0">{
                return sh.ssi.AccountsGetOne(ctx.Request().Context(), request.(AccountsGetOneRequestObject))
        }</span>
        <span class="cov0" title="0">for _, middleware := range sh.middlewares </span><span class="cov0" title="0">{
                handler = middleware(handler, "AccountsGetOne")
        }</span>

        <span class="cov0" title="0">response, err := handler(ctx, request)

        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span> else<span class="cov0" title="0"> if validResponse, ok := response.(AccountsGetOneResponseObject); ok </span><span class="cov0" title="0">{
                return validResponse.VisitAccountsGetOneResponse(ctx.Response())
        }</span> else<span class="cov0" title="0"> if response != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("unexpected response type: %T", response)
        }</span>
        <span class="cov0" title="0">return nil</span>
}

// RequestEmailChange operation middleware
func (sh *strictHandler) RequestEmailChange(ctx echo.Context) error <span class="cov0" title="0">{
        var request RequestEmailChangeRequestObject

        var body RequestEmailChangeJSONRequestBody
        if err := ctx.Bind(&amp;body); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov0" title="0">request.Body = &amp;body

        handler := func(ctx echo.Context, request interface{}) (interface{}, error) </span><span class="cov0" title="0">{
                return sh.ssi.RequestEmailChange(ctx.Request().Context(), request.(RequestEmailChangeRequestObject))
        }</span>
        <span class="cov0" title="0">for _, middleware := range sh.middlewares </span><span class="cov0" title="0">{
                handler = middleware(handler, "RequestEmailChange")
        }</span>

        <span class="cov0" title="0">response, err := handler(ctx, request)

        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span> else<span class="cov0" title="0"> if validResponse, ok := response.(RequestEmailChangeResponseObject); ok </span><span class="cov0" title="0">{
                return validResponse.VisitRequestEmailChangeResponse(ctx.Response())
        }</span> else<span class="cov0" title="0"> if response != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("unexpected response type: %T", response)
        }</span>
        <span class="cov0" title="0">return nil</span>
}

// ConfirmEmailChange operation middleware
func (sh *strictHandler) ConfirmEmailChange(ctx echo.Context) error <span class="cov0" title="0">{
        var request ConfirmEmailChangeRequestObject

        var body ConfirmEmailChangeJSONRequestBody
        if err := ctx.Bind(&amp;body); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov0" title="0">request.Body = &amp;body

        handler := func(ctx echo.Context, request interface{}) (interface{}, error) </span><span class="cov0" title="0">{
                return sh.ssi.ConfirmEmailChange(ctx.Request().Context(), request.(ConfirmEmailChangeRequestObject))
        }</span>
        <span class="cov0" title="0">for _, middleware := range sh.middlewares </span><span class="cov0" title="0">{
                handler = middleware(handler, "ConfirmEmailChange")
        }</span>

        <span class="cov0" title="0">response, err := handler(ctx, request)

        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span> else<span class="cov0" title="0"> if validResponse, ok := response.(ConfirmEmailChangeResponseObject); ok </span><span class="cov0" title="0">{
                return validResponse.VisitConfirmEmailChangeResponse(ctx.Response())
        }</span> else<span class="cov0" title="0"> if response != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("unexpected response type: %T", response)
        }</span>
        <span class="cov0" title="0">return nil</span>
}

// RequestEmailVerification operation middleware
func (sh *strictHandler) RequestEmailVerification(ctx echo.Context) error <span class="cov0" title="0">{
        var request RequestEmailVerificationRequestObject

        handler := func(ctx echo.Context, request interface{}) (interface{}, error) </span><span class="cov0" title="0">{
                return sh.ssi.RequestEmailVerification(ctx.Request().Context(), request.(RequestEmailVerificationRequestObject))
        }</span>
        <span class="cov0" title="0">for _, middleware := range sh.middlewares </span><span class="cov0" title="0">{
                handler = middleware(handler, "RequestEmailVerification")
        }</span>

        <span class="cov0" title="0">response, err := handler(ctx, request)

        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span> else<span class="cov0" title="0"> if validResponse, ok := response.(RequestEmailVerificationResponseObject); ok </span><span class="cov0" title="0">{
                return validResponse.VisitRequestEmailVerificationResponse(ctx.Response())
        }</span> else<span class="cov0" title="0"> if response != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("unexpected response type: %T", response)
        }</span>
        <span class="cov0" title="0">return nil</span>
}

// ConfirmEmailVerification operation middleware
func (sh *strictHandler) ConfirmEmailVerification(ctx echo.Context) error <span class="cov0" title="0">{
        var request ConfirmEmailVerificationRequestObject

        var body ConfirmEmailVerificationJSONRequestBody
        if err := ctx.Bind(&amp;body); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov0" title="0">request.Body = &amp;body

        handler := func(ctx echo.Context, request interface{}) (interface{}, error) </span><span class="cov0" title="0">{
                return sh.ssi.ConfirmEmailVerification(ctx.Request().Context(), request.(ConfirmEmailVerificationRequestObject))
        }</span>
        <span class="cov0" title="0">for _, middleware := range sh.middlewares </span><span class="cov0" title="0">{
                handler = middleware(handler, "ConfirmEmailVerification")
        }</span>

        <span class="cov0" title="0">response, err := handler(ctx, request)

        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span> else<span class="cov0" title="0"> if validResponse, ok := response.(ConfirmEmailVerificationResponseObject); ok </span><span class="cov0" title="0">{
                return validResponse.VisitConfirmEmailVerificationResponse(ctx.Response())
        }</span> else<span class="cov0" title="0"> if response != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("unexpected response type: %T", response)
        }</span>
        <span class="cov0" title="0">return nil</span>
}

// Login operation middleware
func (sh *strictHandler) Login(ctx echo.Context) error <span class="cov0" title="0">{
        var request LoginRequestObject

        var body LoginJSONRequestBody
        if err := ctx.Bind(&amp;body); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov0" title="0">request.Body = &amp;body

        handler := func(ctx echo.Context, request interface{}) (interface{}, error) </span><span class="cov0" title="0">{
                return sh.ssi.Login(ctx.Request().Context(), request.(LoginRequestObject))
        }</span>
        <span class="cov0" title="0">for _, middleware := range sh.middlewares </span><span class="cov0" title="0">{
                handler = middleware(handler, "Login")
        }</span>

        <span class="cov0" title="0">response, err := handler(ctx, request)

        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span> else<span class="cov0" title="0"> if validResponse, ok := response.(LoginResponseObject); ok </span><span class="cov0" title="0">{
                return validResponse.VisitLoginResponse(ctx.Response())
        }</span> else<span class="cov0" title="0"> if response != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("unexpected response type: %T", response)
        }</span>
        <span class="cov0" title="0">return nil</span>
}

// Logout operation middleware
func (sh *strictHandler) Logout(ctx echo.Context) error <span class="cov0" title="0">{
        var request LogoutRequestObject

        handler := func(ctx echo.Context, request interface{}) (interface{}, error) </span><span class="cov0" title="0">{
                return sh.ssi.Logout(ctx.Request().Context(), request.(LogoutRequestObject))
        }</span>
        <span class="cov0" title="0">for _, middleware := range sh.middlewares </span><span class="cov0" title="0">{
                handler = middleware(handler, "Logout")
        }</span>

        <span class="cov0" title="0">response, err := handler(ctx, request)

        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span> else<span class="cov0" title="0"> if validResponse, ok := response.(LogoutResponseObject); ok </span><span class="cov0" title="0">{
                return validResponse.VisitLogoutResponse(ctx.Response())
        }</span> else<span class="cov0" title="0"> if response != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("unexpected response type: %T", response)
        }</span>
        <span class="cov0" title="0">return nil</span>
}

// RequestPasswordReset operation middleware
func (sh *strictHandler) RequestPasswordReset(ctx echo.Context) error <span class="cov0" title="0">{
        var request RequestPasswordResetRequestObject

        var body RequestPasswordResetJSONRequestBody
        if err := ctx.Bind(&amp;body); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov0" title="0">request.Body = &amp;body

        handler := func(ctx echo.Context, request interface{}) (interface{}, error) </span><span class="cov0" title="0">{
                return sh.ssi.RequestPasswordReset(ctx.Request().Context(), request.(RequestPasswordResetRequestObject))
        }</span>
        <span class="cov0" title="0">for _, middleware := range sh.middlewares </span><span class="cov0" title="0">{
                handler = middleware(handler, "RequestPasswordReset")
        }</span>

        <span class="cov0" title="0">response, err := handler(ctx, request)

        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span> else<span class="cov0" title="0"> if validResponse, ok := response.(RequestPasswordResetResponseObject); ok </span><span class="cov0" title="0">{
                return validResponse.VisitRequestPasswordResetResponse(ctx.Response())
        }</span> else<span class="cov0" title="0"> if response != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("unexpected response type: %T", response)
        }</span>
        <span class="cov0" title="0">return nil</span>
}

// ConfirmPasswordReset operation middleware
func (sh *strictHandler) ConfirmPasswordReset(ctx echo.Context) error <span class="cov0" title="0">{
        var request ConfirmPasswordResetRequestObject

        var body ConfirmPasswordResetJSONRequestBody
        if err := ctx.Bind(&amp;body); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov0" title="0">request.Body = &amp;body

        handler := func(ctx echo.Context, request interface{}) (interface{}, error) </span><span class="cov0" title="0">{
                return sh.ssi.ConfirmPasswordReset(ctx.Request().Context(), request.(ConfirmPasswordResetRequestObject))
        }</span>
        <span class="cov0" title="0">for _, middleware := range sh.middlewares </span><span class="cov0" title="0">{
                handler = middleware(handler, "ConfirmPasswordReset")
        }</span>

        <span class="cov0" title="0">response, err := handler(ctx, request)

        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span> else<span class="cov0" title="0"> if validResponse, ok := response.(ConfirmPasswordResetResponseObject); ok </span><span class="cov0" title="0">{
                return validResponse.VisitConfirmPasswordResetResponse(ctx.Response())
        }</span> else<span class="cov0" title="0"> if response != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("unexpected response type: %T", response)
        }</span>
        <span class="cov0" title="0">return nil</span>
}

// Register operation middleware
func (sh *strictHandler) Register(ctx echo.Context) error <span class="cov0" title="0">{
        var request RegisterRequestObject

        var body RegisterJSONRequestBody
        if err := ctx.Bind(&amp;body); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov0" title="0">request.Body = &amp;body

        handler := func(ctx echo.Context, request interface{}) (interface{}, error) </span><span class="cov0" title="0">{
                return sh.ssi.Register(ctx.Request().Context(), request.(RegisterRequestObject))
        }</span>
        <span class="cov0" title="0">for _, middleware := range sh.middlewares </span><span class="cov0" title="0">{
                handler = middleware(handler, "Register")
        }</span>

        <span class="cov0" title="0">response, err := handler(ctx, request)

        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span> else<span class="cov0" title="0"> if validResponse, ok := response.(RegisterResponseObject); ok </span><span class="cov0" title="0">{
                return validResponse.VisitRegisterResponse(ctx.Response())
        }</span> else<span class="cov0" title="0"> if response != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("unexpected response type: %T", response)
        }</span>
        <span class="cov0" title="0">return nil</span>
}

// FindManySessions operation middleware
func (sh *strictHandler) FindManySessions(ctx echo.Context, params FindManySessionsParams) error <span class="cov0" title="0">{
        var request FindManySessionsRequestObject

        request.Params = params

        handler := func(ctx echo.Context, request interface{}) (interface{}, error) </span><span class="cov0" title="0">{
                return sh.ssi.FindManySessions(ctx.Request().Context(), request.(FindManySessionsRequestObject))
        }</span>
        <span class="cov0" title="0">for _, middleware := range sh.middlewares </span><span class="cov0" title="0">{
                handler = middleware(handler, "FindManySessions")
        }</span>

        <span class="cov0" title="0">response, err := handler(ctx, request)

        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span> else<span class="cov0" title="0"> if validResponse, ok := response.(FindManySessionsResponseObject); ok </span><span class="cov0" title="0">{
                return validResponse.VisitFindManySessionsResponse(ctx.Response())
        }</span> else<span class="cov0" title="0"> if response != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("unexpected response type: %T", response)
        }</span>
        <span class="cov0" title="0">return nil</span>
}

// DeleteSession operation middleware
func (sh *strictHandler) DeleteSession(ctx echo.Context, id openapi_types.UUID) error <span class="cov0" title="0">{
        var request DeleteSessionRequestObject

        request.Id = id

        handler := func(ctx echo.Context, request interface{}) (interface{}, error) </span><span class="cov0" title="0">{
                return sh.ssi.DeleteSession(ctx.Request().Context(), request.(DeleteSessionRequestObject))
        }</span>
        <span class="cov0" title="0">for _, middleware := range sh.middlewares </span><span class="cov0" title="0">{
                handler = middleware(handler, "DeleteSession")
        }</span>

        <span class="cov0" title="0">response, err := handler(ctx, request)

        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span> else<span class="cov0" title="0"> if validResponse, ok := response.(DeleteSessionResponseObject); ok </span><span class="cov0" title="0">{
                return validResponse.VisitDeleteSessionResponse(ctx.Response())
        }</span> else<span class="cov0" title="0"> if response != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("unexpected response type: %T", response)
        }</span>
        <span class="cov0" title="0">return nil</span>
}

// GetOneSession operation middleware
func (sh *strictHandler) GetOneSession(ctx echo.Context, id openapi_types.UUID) error <span class="cov0" title="0">{
        var request GetOneSessionRequestObject

        request.Id = id

        handler := func(ctx echo.Context, request interface{}) (interface{}, error) </span><span class="cov0" title="0">{
                return sh.ssi.GetOneSession(ctx.Request().Context(), request.(GetOneSessionRequestObject))
        }</span>
        <span class="cov0" title="0">for _, middleware := range sh.middlewares </span><span class="cov0" title="0">{
                handler = middleware(handler, "GetOneSession")
        }</span>

        <span class="cov0" title="0">response, err := handler(ctx, request)

        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span> else<span class="cov0" title="0"> if validResponse, ok := response.(GetOneSessionResponseObject); ok </span><span class="cov0" title="0">{
                return validResponse.VisitGetOneSessionResponse(ctx.Response())
        }</span> else<span class="cov0" title="0"> if response != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("unexpected response type: %T", response)
        }</span>
        <span class="cov0" title="0">return nil</span>
}

// UpdateSession operation middleware
func (sh *strictHandler) UpdateSession(ctx echo.Context, id openapi_types.UUID) error <span class="cov0" title="0">{
        var request UpdateSessionRequestObject

        request.Id = id

        var body UpdateSessionJSONRequestBody
        if err := ctx.Bind(&amp;body); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov0" title="0">request.Body = &amp;body

        handler := func(ctx echo.Context, request interface{}) (interface{}, error) </span><span class="cov0" title="0">{
                return sh.ssi.UpdateSession(ctx.Request().Context(), request.(UpdateSessionRequestObject))
        }</span>
        <span class="cov0" title="0">for _, middleware := range sh.middlewares </span><span class="cov0" title="0">{
                handler = middleware(handler, "UpdateSession")
        }</span>

        <span class="cov0" title="0">response, err := handler(ctx, request)

        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span> else<span class="cov0" title="0"> if validResponse, ok := response.(UpdateSessionResponseObject); ok </span><span class="cov0" title="0">{
                return validResponse.VisitUpdateSessionResponse(ctx.Response())
        }</span> else<span class="cov0" title="0"> if response != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("unexpected response type: %T", response)
        }</span>
        <span class="cov0" title="0">return nil</span>
}
</pre>
		
		<pre class="file" id="file26" style="display: none">package auth

import (
        "context"
        "encoding/json"
        "fmt"
        "net/http"

        "golang.org/x/oauth2"
        "golang.org/x/oauth2/microsoft"
)

const (
        microsoftUserInfoURL = "https://graph.microsoft.com/v1.0/me"
)

// MicrosoftOAuthProvider implements OAuth2 for Microsoft
type MicrosoftOAuthProvider struct {
        *BaseOAuthProvider
}

// NewMicrosoftOAuthProvider creates a new Microsoft OAuth provider
func NewMicrosoftOAuthProvider(clientID, clientSecret string) OAuthProvider <span class="cov10" title="4">{
        return &amp;MicrosoftOAuthProvider{
                BaseOAuthProvider: &amp;BaseOAuthProvider{
                        Config: &amp;oauth2.Config{
                                ClientID:     clientID,
                                ClientSecret: clientSecret,
                                Endpoint:     microsoft.AzureADEndpoint("common"), // "common" allows any Azure AD and personal Microsoft account
                                Scopes: []string{
                                        "openid",
                                        "profile",
                                        "email",
                                        "offline_access", // For refresh token
                                        "User.Read",      // Microsoft Graph API permission
                                },
                        },
                },
        }
}</span>

// GetProviderID returns the provider identifier
func (p *MicrosoftOAuthProvider) GetProviderID() string <span class="cov1" title="1">{
        return "microsoft"
}</span>

// GetAuthURL returns the Microsoft authorization URL
func (p *MicrosoftOAuthProvider) GetAuthURL(state string, redirectURI string) string <span class="cov5" title="2">{
        p.Config.RedirectURL = redirectURI
        // Add prompt=select_account to allow account selection
        return p.Config.AuthCodeURL(state, oauth2.SetAuthURLParam("prompt", "select_account"))
}</span>

// ExchangeCode exchanges an authorization code for tokens
func (p *MicrosoftOAuthProvider) ExchangeCode(ctx context.Context, code string, redirectURI string) (*OAuthTokens, error) <span class="cov1" title="1">{
        p.Config.RedirectURL = redirectURI
        token, err := p.Config.Exchange(ctx, code)
        if err != nil </span><span class="cov1" title="1">{
                return nil, fmt.Errorf("failed to exchange code: %w", err)
        }</span>

        <span class="cov0" title="0">return &amp;OAuthTokens{
                AccessToken:  token.AccessToken,
                RefreshToken: token.RefreshToken,
                IDToken:      extractIDToken(token),
                ExpiresIn:    int(token.Expiry.Unix()),
        }, nil</span>
}

// RefreshToken refreshes an access token using a refresh token
func (p *MicrosoftOAuthProvider) RefreshToken(ctx context.Context, refreshToken string) (*OAuthTokens, error) <span class="cov0" title="0">{
        token, err := p.BaseOAuthProvider.RefreshToken(ctx, refreshToken)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to refresh token: %w", err)
        }</span>

        <span class="cov0" title="0">return &amp;OAuthTokens{
                AccessToken:  token.AccessToken,
                RefreshToken: token.RefreshToken,
                ExpiresIn:    int(token.Expiry.Unix()),
        }, nil</span>
}

// GetUserInfo retrieves user information from Microsoft Graph
func (p *MicrosoftOAuthProvider) GetUserInfo(ctx context.Context, accessToken string) (*OAuthUserInfo, error) <span class="cov0" title="0">{
        req, err := http.NewRequestWithContext(ctx, "GET", microsoftUserInfoURL, nil)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to create request: %w", err)
        }</span>

        <span class="cov0" title="0">req.Header.Set("Authorization", "Bearer "+accessToken)
        req.Header.Set("Accept", "application/json")

        client := &amp;http.Client{}
        resp, err := client.Do(req)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to get user info: %w", err)
        }</span>
        <span class="cov0" title="0">defer func() </span><span class="cov0" title="0">{
                _ = resp.Body.Close()
        }</span>()

        <span class="cov0" title="0">if resp.StatusCode != http.StatusOK </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("unexpected status code: %d", resp.StatusCode)
        }</span>

        <span class="cov0" title="0">var msUser struct {
                ID                string   `json:"id"`
                DisplayName       string   `json:"displayName"`
                GivenName         string   `json:"givenName"`
                Surname           string   `json:"surname"`
                Mail              string   `json:"mail"`
                UserPrincipalName string   `json:"userPrincipalName"`
                PreferredLanguage string   `json:"preferredLanguage"`
                MobilePhone       string   `json:"mobilePhone"`
                JobTitle          string   `json:"jobTitle"`
                OfficeLocation    string   `json:"officeLocation"`
                BusinessPhones    []string `json:"businessPhones"`
        }

        if err := json.NewDecoder(resp.Body).Decode(&amp;msUser); err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to decode response: %w", err)
        }</span>

        // Microsoft might return mail or userPrincipalName
        <span class="cov0" title="0">email := msUser.Mail
        if email == "" </span><span class="cov0" title="0">{
                email = msUser.UserPrincipalName
        }</span>

        // Get profile photo URL (optional, may fail for some accounts)
        <span class="cov0" title="0">photoURL, _ := p.getProfilePhotoURL(ctx, accessToken)

        return &amp;OAuthUserInfo{
                ProviderAccountID: msUser.ID,
                Email:             email,
                EmailVerified:     true, // Microsoft requires email verification
                Name:              msUser.DisplayName,
                Picture:           photoURL,
                Locale:            msUser.PreferredLanguage,
                Raw: map[string]interface{}{
                        "id":                msUser.ID,
                        "displayName":       msUser.DisplayName,
                        "givenName":         msUser.GivenName,
                        "surname":           msUser.Surname,
                        "mail":              msUser.Mail,
                        "userPrincipalName": msUser.UserPrincipalName,
                        "preferredLanguage": msUser.PreferredLanguage,
                        "mobilePhone":       msUser.MobilePhone,
                        "jobTitle":          msUser.JobTitle,
                        "officeLocation":    msUser.OfficeLocation,
                        "businessPhones":    msUser.BusinessPhones,
                },
        }, nil</span>
}

// getProfilePhotoURL attempts to get the user's profile photo URL
func (p *MicrosoftOAuthProvider) getProfilePhotoURL(ctx context.Context, accessToken string) (string, error) <span class="cov0" title="0">{
        // Check if photo exists
        req, err := http.NewRequestWithContext(ctx, "GET", "https://graph.microsoft.com/v1.0/me/photo", nil)
        if err != nil </span><span class="cov0" title="0">{
                return "", err
        }</span>

        <span class="cov0" title="0">req.Header.Set("Authorization", "Bearer "+accessToken)

        client := &amp;http.Client{}
        resp, err := client.Do(req)
        if err != nil </span><span class="cov0" title="0">{
                return "", err
        }</span>
        <span class="cov0" title="0">defer func() </span><span class="cov0" title="0">{
                _ = resp.Body.Close()
        }</span>()

        <span class="cov0" title="0">if resp.StatusCode == http.StatusOK </span><span class="cov0" title="0">{
                // Photo exists, return the URL to fetch it
                // Note: In production, you might want to actually fetch and store the photo
                return "https://graph.microsoft.com/v1.0/me/photo/$value", nil
        }</span>

        <span class="cov0" title="0">return "", fmt.Errorf("no profile photo available")</span>
}
</pre>
		
		<pre class="file" id="file27" style="display: none">package auth

import (
        "context"
        "log/slog"
        "net/http"
        "strings"
        "time"

        "github.com/golang-jwt/jwt/v5"
        "github.com/google/uuid"
        "github.com/labstack/echo/v4"
)

// Middleware creates an authentication middleware
func Middleware(authService *Service, logger *slog.Logger) echo.MiddlewareFunc <span class="cov10" title="7">{
        return func(next echo.HandlerFunc) echo.HandlerFunc </span><span class="cov10" title="7">{
                return func(c echo.Context) error </span><span class="cov10" title="7">{
                        // Extract token from Authorization header
                        token := extractToken(c)
                        if token == "" </span><span class="cov4" title="2">{
                                // Check for session cookie
                                cookie, err := c.Cookie("session_token")
                                if err == nil </span><span class="cov0" title="0">{
                                        token = cookie.Value
                                }</span>
                        }

                        <span class="cov10" title="7">if token == "" </span><span class="cov4" title="2">{
                                return echo.NewHTTPError(http.StatusUnauthorized, "missing authentication token")
                        }</span>

                        // Validate token
                        <span class="cov8" title="5">claims, err := authService.ValidateToken(token)
                        if err != nil </span><span class="cov4" title="2">{
                                logger.Warn("invalid token", "error", err)
                                if err == ErrTokenExpired </span><span class="cov0" title="0">{
                                        return echo.NewHTTPError(http.StatusUnauthorized, "token expired")
                                }</span>
                                <span class="cov4" title="2">return echo.NewHTTPError(http.StatusUnauthorized, "invalid token")</span>
                        }

                        // Verify user exists
                        <span class="cov6" title="3">user, err := authService.GetUserByID(c.Request().Context(), claims.UserID)
                        if err != nil </span><span class="cov1" title="1">{
                                return echo.NewHTTPError(http.StatusUnauthorized, "user not found")
                        }</span>

                        // If session ID is present in claims, validate session with Redis
                        <span class="cov4" title="2">if claims.SessionID != "" &amp;&amp; authService.sessionManager != nil </span><span class="cov0" title="0">{
                                // ValidateSession actually validates by token, not session ID
                                // So we use the token that was already extracted
                                session, err := authService.sessionManager.ValidateSession(c.Request().Context(), token)
                                if err != nil </span><span class="cov0" title="0">{
                                        logger.Warn("invalid session", "session_id", claims.SessionID, "error", err)
                                        return echo.NewHTTPError(http.StatusUnauthorized, "invalid or expired session")
                                }</span>
                                // Session activity is automatically updated by ValidateSession
                                <span class="cov0" title="0">c.Set("session", session)</span>
                        }

                        // Set claims, user, and session token in context
                        <span class="cov4" title="2">c.Set(string(AuthClaimsContextKey), claims)
                        c.Set(string(AuthUserContextKey), claims.UserID)
                        c.Set(string(UserContextKey), user)
                        c.Set(string(SessionTokenContextKey), token) // Add session token to context

                        // Add user info to request context for downstream use
                        ctx := context.WithValue(c.Request().Context(), AuthClaimsContextKey, claims)
                        ctx = context.WithValue(ctx, AuthUserContextKey, claims.UserID)
                        ctx = context.WithValue(ctx, SessionTokenContextKey, token) // Add session token to request context
                        c.SetRequest(c.Request().WithContext(ctx))

                        return next(c)</span>
                }
        }
}

// OptionalAuthMiddleware creates an optional authentication middleware
// It validates the token if present but doesn't require it
func OptionalAuthMiddleware(authService *Service, logger *slog.Logger) echo.MiddlewareFunc <span class="cov0" title="0">{
        return func(next echo.HandlerFunc) echo.HandlerFunc </span><span class="cov0" title="0">{
                return func(c echo.Context) error </span><span class="cov0" title="0">{
                        // Extract token from Authorization header
                        token := extractToken(c)
                        if token == "" </span><span class="cov0" title="0">{
                                // Check for session cookie
                                cookie, err := c.Cookie("session_token")
                                if err == nil </span><span class="cov0" title="0">{
                                        token = cookie.Value
                                }</span>
                        }

                        <span class="cov0" title="0">if token != "" </span><span class="cov0" title="0">{
                                // Validate token if present
                                claims, err := authService.ValidateToken(token)
                                if err == nil </span><span class="cov0" title="0">{
                                        // Get user if token is valid
                                        user, userErr := authService.GetUserByID(c.Request().Context(), claims.UserID)
                                        if userErr == nil </span><span class="cov0" title="0">{
                                                // Set claims, user, and session token in context if valid
                                                c.Set(string(AuthClaimsContextKey), claims)
                                                c.Set(string(AuthUserContextKey), claims.UserID)
                                                c.Set(string(UserContextKey), user)
                                                c.Set(string(SessionTokenContextKey), token) // Add session token to context

                                                // Add user info to request context
                                                ctx := context.WithValue(c.Request().Context(), AuthClaimsContextKey, claims)
                                                ctx = context.WithValue(ctx, AuthUserContextKey, claims.UserID)
                                                ctx = context.WithValue(ctx, UserContextKey, user)
                                                ctx = context.WithValue(ctx, SessionTokenContextKey, token) // Add session token to request context
                                                c.SetRequest(c.Request().WithContext(ctx))
                                        }</span> else<span class="cov0" title="0"> {
                                                logger.Debug("user not found for valid token", "error", userErr)
                                        }</span>
                                } else<span class="cov0" title="0"> {
                                        logger.Debug("invalid optional token", "error", err)
                                }</span>
                        }

                        <span class="cov0" title="0">return next(c)</span>
                }
        }
}

// RequireRole creates a middleware that requires specific roles
func RequireRole(roles ...Role) echo.MiddlewareFunc <span class="cov0" title="0">{
        return func(next echo.HandlerFunc) echo.HandlerFunc </span><span class="cov0" title="0">{
                return func(c echo.Context) error </span><span class="cov0" title="0">{
                        claims, ok := c.Get(string(AuthClaimsContextKey)).(*EnhancedClaims)
                        if !ok </span><span class="cov0" title="0">{
                                return echo.NewHTTPError(http.StatusUnauthorized, "missing authentication")
                        }</span>

                        // Check if user has required role
                        <span class="cov0" title="0">hasRole := false
                        for _, role := range roles </span><span class="cov0" title="0">{
                                if claims.HasRole(string(role)) </span><span class="cov0" title="0">{
                                        hasRole = true
                                        break</span>
                                }
                        }

                        <span class="cov0" title="0">if !hasRole </span><span class="cov0" title="0">{
                                return echo.NewHTTPError(http.StatusForbidden, "insufficient permissions")
                        }</span>

                        <span class="cov0" title="0">return next(c)</span>
                }
        }
}

// RequirePermission creates a middleware that requires specific permissions
func RequirePermission(permissions ...Permission) echo.MiddlewareFunc <span class="cov0" title="0">{
        return func(next echo.HandlerFunc) echo.HandlerFunc </span><span class="cov0" title="0">{
                return func(c echo.Context) error </span><span class="cov0" title="0">{
                        claims, ok := c.Get(string(AuthClaimsContextKey)).(*EnhancedClaims)
                        if !ok </span><span class="cov0" title="0">{
                                return echo.NewHTTPError(http.StatusUnauthorized, "missing authentication")
                        }</span>

                        // Check if user has all required permissions
                        <span class="cov0" title="0">for _, permission := range permissions </span><span class="cov0" title="0">{
                                if !claims.HasPermission(string(permission)) </span><span class="cov0" title="0">{
                                        return echo.NewHTTPError(http.StatusForbidden, "insufficient permissions")
                                }</span>
                        }

                        <span class="cov0" title="0">return next(c)</span>
                }
        }
}

// RequireScope creates a middleware that requires specific API scopes
func RequireScope(scopes ...Scope) echo.MiddlewareFunc <span class="cov0" title="0">{
        return func(next echo.HandlerFunc) echo.HandlerFunc </span><span class="cov0" title="0">{
                return func(c echo.Context) error </span><span class="cov0" title="0">{
                        claims, ok := c.Get(string(AuthClaimsContextKey)).(*EnhancedClaims)
                        if !ok </span><span class="cov0" title="0">{
                                return echo.NewHTTPError(http.StatusUnauthorized, "missing authentication")
                        }</span>

                        // Check if user has all required scopes
                        <span class="cov0" title="0">for _, scope := range scopes </span><span class="cov0" title="0">{
                                if !claims.HasScope(string(scope)) </span><span class="cov0" title="0">{
                                        return echo.NewHTTPError(http.StatusForbidden, "insufficient scope")
                                }</span>
                        }

                        <span class="cov0" title="0">return next(c)</span>
                }
        }
}

// RequireOrganization creates a middleware that requires organization membership
func RequireOrganization() echo.MiddlewareFunc <span class="cov0" title="0">{
        return func(next echo.HandlerFunc) echo.HandlerFunc </span><span class="cov0" title="0">{
                return func(c echo.Context) error </span><span class="cov0" title="0">{
                        claims, ok := c.Get(string(AuthClaimsContextKey)).(*EnhancedClaims)
                        if !ok </span><span class="cov0" title="0">{
                                return echo.NewHTTPError(http.StatusUnauthorized, "missing authentication")
                        }</span>

                        // Check if user has an active organization
                        <span class="cov0" title="0">if claims.OrganizationID == uuid.Nil &amp;&amp; len(claims.Organizations) == 0 </span><span class="cov0" title="0">{
                                return echo.NewHTTPError(http.StatusForbidden, "organization membership required")
                        }</span>

                        <span class="cov0" title="0">return next(c)</span>
                }
        }
}

// EnrichOrganizationContext enriches the context with full organization data
func EnrichOrganizationContext(getOrgFunc func(ctx context.Context, orgID uuid.UUID) (interface{}, error), logger *slog.Logger) echo.MiddlewareFunc <span class="cov0" title="0">{
        return func(next echo.HandlerFunc) echo.HandlerFunc </span><span class="cov0" title="0">{
                return func(c echo.Context) error </span><span class="cov0" title="0">{
                        // Get claims from context
                        claims, ok := GetClaimsFromContext(c)
                        if !ok || claims.OrganizationID == uuid.Nil </span><span class="cov0" title="0">{
                                // No organization to enrich
                                return next(c)
                        }</span>

                        // Check if organization is already in context (from cache)
                        <span class="cov0" title="0">if org := c.Get(string(OrganizationContextKey)); org != nil </span><span class="cov0" title="0">{
                                return next(c)
                        }</span>

                        // Load organization data
                        <span class="cov0" title="0">org, err := getOrgFunc(c.Request().Context(), claims.OrganizationID)
                        if err != nil </span><span class="cov0" title="0">{
                                logger.Warn("failed to load organization",
                                        "org_id", claims.OrganizationID,
                                        "error", err,
                                )
                                // Continue without organization data
                                return next(c)
                        }</span>

                        // Set organization in context
                        <span class="cov0" title="0">c.Set(string(OrganizationContextKey), org)
                        ctx := context.WithValue(c.Request().Context(), OrganizationContextKey, org)
                        c.SetRequest(c.Request().WithContext(ctx))

                        // Enrich claims with organization-specific permissions if applicable
                        if claims.OrganizationRole != "" </span><span class="cov0" title="0">{
                                // Add role-based permissions for the organization
                                rolePerms := GetRolePermissions(Role(claims.OrganizationRole))
                                for _, perm := range rolePerms </span><span class="cov0" title="0">{
                                        if !claims.HasPermission(string(perm)) </span><span class="cov0" title="0">{
                                                claims.Permissions = append(claims.Permissions, string(perm))
                                        }</span>
                                }
                                // Update claims in context
                                <span class="cov0" title="0">c.Set(string(AuthClaimsContextKey), claims)</span>
                        }

                        <span class="cov0" title="0">return next(c)</span>
                }
        }
}

// RequireOrganizationRole creates a middleware that requires a specific organization role
func RequireOrganizationRole(roles ...string) echo.MiddlewareFunc <span class="cov0" title="0">{
        return func(next echo.HandlerFunc) echo.HandlerFunc </span><span class="cov0" title="0">{
                return func(c echo.Context) error </span><span class="cov0" title="0">{
                        claims, ok := c.Get(string(AuthClaimsContextKey)).(*EnhancedClaims)
                        if !ok </span><span class="cov0" title="0">{
                                return echo.NewHTTPError(http.StatusUnauthorized, "missing authentication")
                        }</span>

                        // Check if user has required organization role
                        <span class="cov0" title="0">hasRole := false
                        for _, role := range roles </span><span class="cov0" title="0">{
                                if claims.OrganizationRole == role </span><span class="cov0" title="0">{
                                        hasRole = true
                                        break</span>
                                }
                                // Also check in Organizations list
                                <span class="cov0" title="0">for _, org := range claims.Organizations </span><span class="cov0" title="0">{
                                        if org.Role == role </span><span class="cov0" title="0">{
                                                hasRole = true
                                                break</span>
                                        }
                                }
                        }

                        <span class="cov0" title="0">if !hasRole </span><span class="cov0" title="0">{
                                return echo.NewHTTPError(http.StatusForbidden, "insufficient organization role")
                        }</span>

                        <span class="cov0" title="0">return next(c)</span>
                }
        }
}

// SwitchOrganization allows switching the active organization via header
func SwitchOrganization(logger *slog.Logger) echo.MiddlewareFunc <span class="cov0" title="0">{
        return func(next echo.HandlerFunc) echo.HandlerFunc </span><span class="cov0" title="0">{
                return func(c echo.Context) error </span><span class="cov0" title="0">{
                        // Check for X-Organization-ID header
                        orgIDStr := c.Request().Header.Get("X-Organization-ID")
                        if orgIDStr == "" </span><span class="cov0" title="0">{
                                return next(c)
                        }</span>

                        // Parse organization ID
                        <span class="cov0" title="0">orgID, err := uuid.Parse(orgIDStr)
                        if err != nil </span><span class="cov0" title="0">{
                                logger.Warn("invalid organization ID in header",
                                        "org_id", orgIDStr,
                                        "error", err,
                                )
                                return echo.NewHTTPError(http.StatusBadRequest, "invalid organization ID")
                        }</span>

                        // Get claims
                        <span class="cov0" title="0">claims, ok := GetClaimsFromContext(c)
                        if !ok </span><span class="cov0" title="0">{
                                return next(c)
                        }</span>

                        // Verify user is a member of this organization
                        <span class="cov0" title="0">if !claims.IsOrgMember(orgID) </span><span class="cov0" title="0">{
                                return echo.NewHTTPError(http.StatusForbidden, "not a member of this organization")
                        }</span>

                        // Switch active organization in claims
                        <span class="cov0" title="0">originalOrgID := claims.OrganizationID
                        claims.OrganizationID = orgID

                        // Find and set the role for this organization
                        for _, org := range claims.Organizations </span><span class="cov0" title="0">{
                                if org.ID == orgID </span><span class="cov0" title="0">{
                                        claims.OrganizationName = org.Name
                                        claims.OrganizationRole = org.Role
                                        break</span>
                                }
                        }

                        // Update claims in context
                        <span class="cov0" title="0">c.Set(string(AuthClaimsContextKey), claims)
                        ctx := context.WithValue(c.Request().Context(), AuthClaimsContextKey, claims)
                        c.SetRequest(c.Request().WithContext(ctx))

                        logger.Debug("switched organization context",
                                "user_id", claims.UserID,
                                "from_org", originalOrgID,
                                "to_org", orgID,
                        )

                        return next(c)</span>
                }
        }
}

// extractToken extracts the token from the Authorization header
func extractToken(c echo.Context) string <span class="cov10" title="7">{
        // Get token from Authorization header
        authHeader := c.Request().Header.Get("Authorization")
        if authHeader != "" </span><span class="cov8" title="5">{
                // Check for Bearer token
                parts := strings.SplitN(authHeader, " ", 2)
                if len(parts) == 2 &amp;&amp; strings.ToLower(parts[0]) == "bearer" </span><span class="cov8" title="5">{
                        return parts[1]
                }</span>
        }

        // Get token from query parameter (useful for WebSocket connections)
        <span class="cov4" title="2">if token := c.QueryParam("token"); token != "" </span><span class="cov0" title="0">{
                return token
        }</span>

        <span class="cov4" title="2">return ""</span>
}

// RateLimitMiddleware creates a rate limiting middleware for authentication endpoints
func RateLimitMiddleware(maxAttempts int, _ int) echo.MiddlewareFunc <span class="cov0" title="0">{
        // This is a simplified version. In production, use a Redis-based solution
        attempts := make(map[string]int)

        return func(next echo.HandlerFunc) echo.HandlerFunc </span><span class="cov0" title="0">{
                return func(c echo.Context) error </span><span class="cov0" title="0">{
                        ip := c.RealIP()

                        // Check attempts
                        if attempts[ip] &gt;= maxAttempts </span><span class="cov0" title="0">{
                                return echo.NewHTTPError(http.StatusTooManyRequests, "too many authentication attempts")
                        }</span>

                        // Increment attempts
                        <span class="cov0" title="0">attempts[ip]++

                        // Continue with request
                        err := next(c)

                        // Reset on successful authentication
                        if err == nil &amp;&amp; c.Response().Status == http.StatusOK </span><span class="cov0" title="0">{
                                delete(attempts, ip)
                        }</span>

                        <span class="cov0" title="0">return err</span>
                }
        }
}

// SetRequestContextWithTimeout will set the request context with timeout for every incoming HTTP Request
func SetRequestContextWithTimeout(d time.Duration) echo.MiddlewareFunc <span class="cov0" title="0">{
        return func(next echo.HandlerFunc) echo.HandlerFunc </span><span class="cov0" title="0">{
                return func(c echo.Context) error </span><span class="cov0" title="0">{
                        ctx, cancel := context.WithTimeout(c.Request().Context(), d)
                        defer cancel()

                        newRequest := c.Request().WithContext(ctx)
                        c.SetRequest(newRequest)
                        return next(c)
                }</span>
        }
}

// APIKeyMiddleware creates an API key authentication middleware
func APIKeyMiddleware(authService *Service, logger *slog.Logger) echo.MiddlewareFunc <span class="cov6" title="3">{
        return func(next echo.HandlerFunc) echo.HandlerFunc </span><span class="cov6" title="3">{
                return func(c echo.Context) error </span><span class="cov6" title="3">{
                        // Check for API key in X-API-Key header
                        apiKey := c.Request().Header.Get("X-API-Key")

                        // If not found, check Authorization header
                        if apiKey == "" </span><span class="cov4" title="2">{
                                authHeader := c.Request().Header.Get("Authorization")
                                apiKey = ParseAPIKey(authHeader)
                        }</span>

                        <span class="cov6" title="3">if apiKey == "" </span><span class="cov1" title="1">{
                                return echo.NewHTTPError(http.StatusUnauthorized, "missing API key")
                        }</span>

                        // Validate API key through service
                        <span class="cov4" title="2">apiKeyData, err := authService.ValidateAPIKey(c.Request().Context(), apiKey)
                        if err != nil </span><span class="cov4" title="2">{
                                logger.Warn("invalid API key", "error", err)
                                return echo.NewHTTPError(http.StatusUnauthorized, "invalid API key")
                        }</span>

                        // Create claims from API key
                        <span class="cov0" title="0">claims := &amp;EnhancedClaims{
                                RegisteredClaims: jwt.RegisteredClaims{
                                        Subject:   apiKeyData.UserID.String(),
                                        ExpiresAt: jwt.NewNumericDate(apiKeyData.ExpiresAt),
                                        IssuedAt:  jwt.NewNumericDate(apiKeyData.CreatedAt),
                                        NotBefore: jwt.NewNumericDate(apiKeyData.CreatedAt),
                                        Issuer:    "archesai",
                                        ID:        apiKeyData.ID.String(),
                                },
                                UserID:         apiKeyData.UserID,
                                OrganizationID: apiKeyData.OrganizationID,
                                TokenType:      APIKeyTokenType,
                                AuthMethod:     AuthMethodAPIKey,
                                Scopes:         apiKeyData.Scopes,
                                CustomClaims: map[string]interface{}{
                                        "api_key_id":   apiKeyData.ID.String(),
                                        "api_key_name": apiKeyData.Name,
                                        "rate_limit":   apiKeyData.RateLimit,
                                },
                        }

                        // Set claims and user in context
                        c.Set(string(AuthClaimsContextKey), claims)
                        c.Set(string(AuthUserContextKey), apiKeyData.UserID)
                        c.Set("api_key", apiKeyData)

                        // Add to request context for downstream use
                        ctx := context.WithValue(c.Request().Context(), AuthClaimsContextKey, claims)
                        ctx = context.WithValue(ctx, AuthUserContextKey, apiKeyData.UserID)
                        ctx = context.WithValue(ctx, ContextKey("api_key"), apiKeyData)
                        c.SetRequest(c.Request().WithContext(ctx))

                        return next(c)</span>
                }
        }
}

// Strategy represents the authentication method used
type Strategy string

const (
        // StrategyJWT indicates JWT token authentication
        StrategyJWT Strategy = "jwt"
        // StrategySession indicates session-based authentication
        StrategySession Strategy = "session"
        // StrategyAPIKey indicates API key authentication
        StrategyAPIKey Strategy = "api_key"
        // StrategyOAuth indicates OAuth authentication
        StrategyOAuth Strategy = "oauth"
)

// ComposeAuthStrategies creates a middleware that tries multiple authentication strategies
// in order, succeeding if any one of them succeeds
func ComposeAuthStrategies(strategies ...echo.MiddlewareFunc) echo.MiddlewareFunc <span class="cov0" title="0">{
        return func(next echo.HandlerFunc) echo.HandlerFunc </span><span class="cov0" title="0">{
                return func(c echo.Context) error </span><span class="cov0" title="0">{
                        var lastError error

                        // Try each strategy in order
                        for _, strategy := range strategies </span><span class="cov0" title="0">{
                                // Create a test handler to check if auth succeeds
                                testHandler := func(c echo.Context) error </span><span class="cov0" title="0">{
                                        // Auth succeeded, continue with the real handler
                                        return next(c)
                                }</span>

                                // Try the strategy
                                <span class="cov0" title="0">err := strategy(testHandler)(c)
                                if err == nil </span><span class="cov0" title="0">{
                                        // Success - one strategy worked
                                        return nil
                                }</span>

                                // Check if it's an HTTP error
                                <span class="cov0" title="0">if httpErr, ok := err.(*echo.HTTPError); ok </span><span class="cov0" title="0">{
                                        // If it's not an auth error, return it immediately
                                        if httpErr.Code != http.StatusUnauthorized </span><span class="cov0" title="0">{
                                                return err
                                        }</span>
                                }

                                <span class="cov0" title="0">lastError = err</span>
                        }

                        // All strategies failed
                        <span class="cov0" title="0">if lastError != nil </span><span class="cov0" title="0">{
                                return lastError
                        }</span>

                        <span class="cov0" title="0">return echo.NewHTTPError(http.StatusUnauthorized, "authentication required")</span>
                }
        }
}

// RequireAuthConfig defines configuration for authentication middleware
type RequireAuthConfig struct {
        // Strategies specifies which authentication methods are allowed
        Strategies []Strategy
        // Optional makes authentication optional (doesn't fail if no auth provided)
        Optional bool
        // RequireVerifiedEmail requires the user to have a verified email
        RequireVerifiedEmail bool
        // RequireOrganization requires the user to belong to an organization
        RequireOrganization bool
        // RequiredScopes specifies the scopes required for this endpoint
        RequiredScopes []string
        // RequiredPermissions specifies the permissions required
        RequiredPermissions []string
        // RateLimit specifies custom rate limiting for this endpoint
        RateLimit *RateLimitConfig
}

// RateLimitConfig specifies rate limiting configuration
type RateLimitConfig struct {
        // RequestsPerMinute specifies the maximum requests per minute
        RequestsPerMinute int
        // BurstSize specifies the burst size for rate limiting
        BurstSize int
        // ByStrategy allows different rate limits per auth strategy
        ByStrategy map[Strategy]int
}

// RequireAuth creates a configurable authentication middleware
func RequireAuth(authService *Service, config RequireAuthConfig, logger *slog.Logger) echo.MiddlewareFunc <span class="cov0" title="0">{
        return func(next echo.HandlerFunc) echo.HandlerFunc </span><span class="cov0" title="0">{
                return func(c echo.Context) error </span><span class="cov0" title="0">{
                        var authenticated bool
                        var authStrategy Strategy

                        // Build list of middleware to try based on allowed strategies
                        var middlewares []echo.MiddlewareFunc

                        for _, strategy := range config.Strategies </span><span class="cov0" title="0">{
                                switch strategy </span>{
                                case StrategyJWT:<span class="cov0" title="0">
                                        middlewares = append(middlewares, wrapWithStrategy(
                                                Middleware(authService, logger),
                                                StrategyJWT,
                                        ))</span>
                                case StrategyAPIKey:<span class="cov0" title="0">
                                        middlewares = append(middlewares, wrapWithStrategy(
                                                APIKeyMiddleware(authService, logger),
                                                StrategyAPIKey,
                                        ))</span>
                                case StrategySession:<span class="cov0" title="0">
                                        // Session is usually part of JWT validation
                                        middlewares = append(middlewares, wrapWithStrategy(
                                                Middleware(authService, logger),
                                                StrategySession,
                                        ))</span>
                                }
                        }

                        // If no strategies specified, use default (JWT)
                        <span class="cov0" title="0">if len(middlewares) == 0 </span><span class="cov0" title="0">{
                                middlewares = append(middlewares, wrapWithStrategy(
                                        Middleware(authService, logger),
                                        StrategyJWT,
                                ))
                        }</span>

                        // Try authentication with composed strategies
                        <span class="cov0" title="0">if config.Optional </span><span class="cov0" title="0">{
                                // Use optional auth middleware
                                err := ComposeOptionalStrategies(middlewares...)(next)(c)
                                if err != nil </span><span class="cov0" title="0">{
                                        return err
                                }</span>
                        } else<span class="cov0" title="0"> {
                                // Use required auth middleware
                                err := ComposeAuthStrategies(middlewares...)(next)(c)
                                if err != nil </span><span class="cov0" title="0">{
                                        return err
                                }</span>
                                <span class="cov0" title="0">authenticated = true</span>
                        }

                        // Check additional requirements if authenticated
                        <span class="cov0" title="0">if authenticated || c.Get(string(AuthClaimsContextKey)) != nil </span><span class="cov0" title="0">{
                                claims, ok := GetClaimsFromContext(c)
                                if ok </span><span class="cov0" title="0">{
                                        // Check verified email requirement
                                        if config.RequireVerifiedEmail &amp;&amp; !claims.EmailVerified </span><span class="cov0" title="0">{
                                                return echo.NewHTTPError(http.StatusForbidden, "email verification required")
                                        }</span>

                                        // Check organization requirement
                                        <span class="cov0" title="0">if config.RequireOrganization &amp;&amp; claims.OrganizationID.String() == "" </span><span class="cov0" title="0">{
                                                return echo.NewHTTPError(http.StatusForbidden, "organization membership required")
                                        }</span>

                                        // Check required scopes
                                        <span class="cov0" title="0">for _, scope := range config.RequiredScopes </span><span class="cov0" title="0">{
                                                if !claims.HasScope(scope) </span><span class="cov0" title="0">{
                                                        return echo.NewHTTPError(http.StatusForbidden, "insufficient scope")
                                                }</span>
                                        }

                                        // Check required permissions
                                        <span class="cov0" title="0">for _, perm := range config.RequiredPermissions </span><span class="cov0" title="0">{
                                                if !claims.HasPermission(perm) </span><span class="cov0" title="0">{
                                                        return echo.NewHTTPError(http.StatusForbidden, "insufficient permissions")
                                                }</span>
                                        }
                                }

                                // Get auth strategy from context
                                <span class="cov0" title="0">if strategy, ok := c.Get(string(AuthStrategyContextKey)).(Strategy); ok </span><span class="cov0" title="0">{
                                        authStrategy = strategy
                                }</span>

                                // Apply rate limiting based on auth strategy
                                <span class="cov0" title="0">if config.RateLimit != nil </span><span class="cov0" title="0">{
                                        limit := config.RateLimit.RequestsPerMinute
                                        if strategyLimit, ok := config.RateLimit.ByStrategy[authStrategy]; ok </span><span class="cov0" title="0">{
                                                limit = strategyLimit
                                        }</span>

                                        // Apply rate limiting (simplified - in production use Redis)
                                        <span class="cov0" title="0">if limit &gt; 0 </span><span class="cov0" title="0">{
                                                // This is a placeholder - actual implementation would use Redis
                                                logger.Debug("applying rate limit",
                                                        "strategy", authStrategy,
                                                        "limit", limit,
                                                )
                                        }</span>
                                }
                        }

                        <span class="cov0" title="0">return nil</span>
                }
        }
}

// wrapWithStrategy wraps a middleware to set the authentication strategy in context
func wrapWithStrategy(middleware echo.MiddlewareFunc, strategy Strategy) echo.MiddlewareFunc <span class="cov0" title="0">{
        return func(next echo.HandlerFunc) echo.HandlerFunc </span><span class="cov0" title="0">{
                return func(c echo.Context) error </span><span class="cov0" title="0">{
                        // Run the middleware
                        err := middleware(func(c echo.Context) error </span><span class="cov0" title="0">{
                                // Set the strategy in context if auth succeeds
                                c.Set(string(AuthStrategyContextKey), strategy)
                                ctx := context.WithValue(c.Request().Context(), AuthStrategyContextKey, strategy)
                                c.SetRequest(c.Request().WithContext(ctx))
                                return next(c)
                        }</span>)(c)

                        <span class="cov0" title="0">return err</span>
                }
        }
}

// ComposeOptionalStrategies creates a middleware that tries multiple authentication strategies
// but doesn't fail if none succeed (optional auth)
func ComposeOptionalStrategies(strategies ...echo.MiddlewareFunc) echo.MiddlewareFunc <span class="cov0" title="0">{
        return func(next echo.HandlerFunc) echo.HandlerFunc </span><span class="cov0" title="0">{
                return func(c echo.Context) error </span><span class="cov0" title="0">{
                        // Try each strategy, but don't fail if none work
                        for _, strategy := range strategies </span><span class="cov0" title="0">{
                                // Create a test handler
                                testHandler := func(_ echo.Context) error </span><span class="cov0" title="0">{
                                        return nil
                                }</span>

                                // Try the strategy
                                <span class="cov0" title="0">err := strategy(testHandler)(c)
                                if err == nil </span><span class="cov0" title="0">{
                                        // Success - auth worked
                                        break</span>
                                }
                        }

                        // Always continue to the next handler (auth is optional)
                        <span class="cov0" title="0">return next(c)</span>
                }
        }
}

// MiddlewarePresets provides common middleware configurations
var MiddlewarePresets = struct {
        // Public allows access without authentication
        Public RequireAuthConfig
        // Authenticated requires any valid authentication
        Authenticated RequireAuthConfig
        // APIOnly requires API key authentication
        APIOnly RequireAuthConfig
        // AdminOnly requires admin role
        AdminOnly RequireAuthConfig
        // OrganizationMember requires organization membership
        OrganizationMember RequireAuthConfig
}{
        Public: RequireAuthConfig{
                Optional: true,
                Strategies: []Strategy{
                        StrategyJWT,
                        StrategyAPIKey,
                },
        },
        Authenticated: RequireAuthConfig{
                Optional: false,
                Strategies: []Strategy{
                        StrategyJWT,
                        StrategySession,
                        StrategyAPIKey,
                },
        },
        APIOnly: RequireAuthConfig{
                Optional: false,
                Strategies: []Strategy{
                        StrategyAPIKey,
                },
                RateLimit: &amp;RateLimitConfig{
                        RequestsPerMinute: 100,
                        BurstSize:         10,
                },
        },
        AdminOnly: RequireAuthConfig{
                Optional: false,
                Strategies: []Strategy{
                        StrategyJWT,
                        StrategySession,
                },
                RequiredPermissions: []string{
                        "system:manage",
                },
        },
        OrganizationMember: RequireAuthConfig{
                Optional:            false,
                RequireOrganization: true,
                Strategies: []Strategy{
                        StrategyJWT,
                        StrategySession,
                },
                RequiredPermissions: []string{
                        "org:read",
                },
        },
}

// ChainMiddleware chains multiple middleware functions together
func ChainMiddleware(middlewares ...echo.MiddlewareFunc) echo.MiddlewareFunc <span class="cov0" title="0">{
        return func(next echo.HandlerFunc) echo.HandlerFunc </span><span class="cov0" title="0">{
                // Build the chain in reverse order
                handler := next
                for i := len(middlewares) - 1; i &gt;= 0; i-- </span><span class="cov0" title="0">{
                        handler = middlewares[i](handler)
                }</span>
                <span class="cov0" title="0">return handler</span>
        }
}

// ConditionalMiddleware applies middleware based on a condition
func ConditionalMiddleware(condition func(c echo.Context) bool, middleware echo.MiddlewareFunc) echo.MiddlewareFunc <span class="cov0" title="0">{
        return func(next echo.HandlerFunc) echo.HandlerFunc </span><span class="cov0" title="0">{
                return func(c echo.Context) error </span><span class="cov0" title="0">{
                        if condition(c) </span><span class="cov0" title="0">{
                                return middleware(next)(c)
                        }</span>
                        <span class="cov0" title="0">return next(c)</span>
                }
        }
}

// PathAuthConfig applies different authentication based on path patterns
type PathAuthConfig struct {
        Pattern string
        Config  RequireAuthConfig
}

// matchPath performs simple path pattern matching
// Supports wildcards: * for single segment, ** for multiple segments
func matchPath(pattern, path string) bool <span class="cov0" title="0">{
        // Exact match
        if pattern == path </span><span class="cov0" title="0">{
                return true
        }</span>

        // Check for wildcards
        <span class="cov0" title="0">if strings.Contains(pattern, "*") </span><span class="cov0" title="0">{
                // Simple wildcard matching
                if strings.HasSuffix(pattern, "/*") </span><span class="cov0" title="0">{
                        // Match any path under this prefix
                        prefix := strings.TrimSuffix(pattern, "/*")
                        return strings.HasPrefix(path, prefix+"/")
                }</span>
                <span class="cov0" title="0">if pattern == "/*" </span><span class="cov0" title="0">{
                        // Match any single-segment path
                        return strings.Count(path, "/") == 1
                }</span>
        }

        // Check if pattern is a prefix
        <span class="cov0" title="0">if strings.HasSuffix(pattern, "/") &amp;&amp; strings.HasPrefix(path, pattern) </span><span class="cov0" title="0">{
                return true
        }</span>

        <span class="cov0" title="0">return false</span>
}

// PathBasedAuthMiddleware applies different auth configurations based on path
func PathBasedAuthMiddleware(authService *Service, configs []PathAuthConfig, logger *slog.Logger) echo.MiddlewareFunc <span class="cov0" title="0">{
        return func(next echo.HandlerFunc) echo.HandlerFunc </span><span class="cov0" title="0">{
                return func(c echo.Context) error </span><span class="cov0" title="0">{
                        path := c.Path()

                        // Find matching config for this path
                        for _, config := range configs </span><span class="cov0" title="0">{
                                // Simple path matching (can be enhanced with proper pattern matching)
                                if matchPath(config.Pattern, path) </span><span class="cov0" title="0">{
                                        // Apply the auth config for this path
                                        return RequireAuth(authService, config.Config, logger)(next)(c)
                                }</span>
                        }

                        // No specific config found, use default authenticated requirement
                        <span class="cov0" title="0">return RequireAuth(authService, MiddlewarePresets.Authenticated, logger)(next)(c)</span>
                }
        }
}

// ErrorHandlingMiddleware wraps auth errors with more context
func ErrorHandlingMiddleware(logger *slog.Logger) echo.MiddlewareFunc <span class="cov0" title="0">{
        return func(next echo.HandlerFunc) echo.HandlerFunc </span><span class="cov0" title="0">{
                return func(c echo.Context) error </span><span class="cov0" title="0">{
                        err := next(c)
                        if err != nil </span><span class="cov0" title="0">{
                                // Log authentication errors with context
                                if httpErr, ok := err.(*echo.HTTPError); ok </span><span class="cov0" title="0">{
                                        if httpErr.Code == http.StatusUnauthorized || httpErr.Code == http.StatusForbidden </span><span class="cov0" title="0">{
                                                strategy, _ := GetAuthStrategy(c)
                                                logger.Warn("authentication failed",
                                                        "path", c.Path(),
                                                        "method", c.Request().Method,
                                                        "strategy", strategy,
                                                        "error", err,
                                                        "ip", c.RealIP(),
                                                )
                                        }</span>
                                }
                        }
                        <span class="cov0" title="0">return err</span>
                }
        }
}
</pre>
		
		<pre class="file" id="file28" style="display: none">package auth

import (
        "context"
        "crypto/rand"
        "encoding/base64"
        "fmt"
        "log/slog"
        "sync"
        "time"

        "github.com/archesai/archesai/internal/accounts"
        "github.com/archesai/archesai/internal/sessions"
        "github.com/archesai/archesai/internal/users"
        "github.com/google/uuid"
)

// OAuthService handles OAuth2 authentication flows
type OAuthService struct {
        providers      map[string]OAuthProvider
        service        *Service
        sessionManager *sessions.SessionManager
        repo           accounts.Repository
        usersRepo      users.Repository
        logger         *slog.Logger
}

// NewOAuthService creates a new OAuth service
func NewOAuthService(
        service *Service,
        sessionManager *sessions.SessionManager,
        repo accounts.Repository,
        usersRepo users.Repository,
        logger *slog.Logger,
) *OAuthService <span class="cov0" title="0">{
        return &amp;OAuthService{
                providers:      make(map[string]OAuthProvider),
                service:        service,
                sessionManager: sessionManager,
                repo:           repo,
                usersRepo:      usersRepo,
                logger:         logger,
        }
}</span>

// RegisterProvider registers an OAuth provider
func (s *OAuthService) RegisterProvider(provider OAuthProvider) <span class="cov0" title="0">{
        s.providers[provider.GetProviderID()] = provider
}</span>

// GetAuthURL generates an authorization URL for the specified provider
func (s *OAuthService) GetAuthURL(ctx context.Context, providerID string, redirectURI string) (string, string, error) <span class="cov0" title="0">{
        provider, ok := s.providers[providerID]
        if !ok </span><span class="cov0" title="0">{
                return "", "", fmt.Errorf("provider %s not found", providerID)
        }</span>

        // Generate secure state token
        <span class="cov0" title="0">state, err := generateState()
        if err != nil </span><span class="cov0" title="0">{
                return "", "", fmt.Errorf("failed to generate state: %w", err)
        }</span>

        // Store state in session with expiry (5 minutes)
        <span class="cov0" title="0">if err := s.StoreOAuthState(ctx, state, providerID, redirectURI, 5*time.Minute); err != nil </span><span class="cov0" title="0">{
                return "", "", fmt.Errorf("failed to store state: %w", err)
        }</span>

        <span class="cov0" title="0">authURL := provider.GetAuthURL(state, redirectURI)
        return authURL, state, nil</span>
}

// HandleCallback processes the OAuth callback
func (s *OAuthService) HandleCallback(ctx context.Context, providerID, code, state, storedState string) (*User, *TokenResponse, error) <span class="cov0" title="0">{
        // Validate state to prevent CSRF attacks
        if state != storedState </span><span class="cov0" title="0">{
                return nil, nil, fmt.Errorf("invalid state parameter")
        }</span>

        <span class="cov0" title="0">provider, ok := s.providers[providerID]
        if !ok </span><span class="cov0" title="0">{
                return nil, nil, fmt.Errorf("provider %s not found", providerID)
        }</span>

        // Get redirect URI from stored state
        <span class="cov0" title="0">redirectURI, err := s.GetOAuthRedirectURI(ctx, state)
        if err != nil </span><span class="cov0" title="0">{
                return nil, nil, fmt.Errorf("failed to get redirect URI: %w", err)
        }</span>

        // Exchange code for tokens
        <span class="cov0" title="0">tokens, err := provider.ExchangeCode(ctx, code, redirectURI)
        if err != nil </span><span class="cov0" title="0">{
                return nil, nil, fmt.Errorf("failed to exchange code: %w", err)
        }</span>

        // Get user info from provider
        <span class="cov0" title="0">userInfo, err := provider.GetUserInfo(ctx, tokens.AccessToken)
        if err != nil </span><span class="cov0" title="0">{
                return nil, nil, fmt.Errorf("failed to get user info: %w", err)
        }</span>

        // Check if user already exists
        <span class="cov0" title="0">account, err := s.repo.GetByProviderId(ctx, providerID, userInfo.ProviderAccountID)
        var user *User

        if err != nil </span><span class="cov0" title="0">{
                // Account doesn't exist, create new user and account
                user, err = s.createOAuthUser(ctx, providerID, userInfo, tokens)
                if err != nil </span><span class="cov0" title="0">{
                        return nil, nil, fmt.Errorf("failed to create user: %w", err)
                }</span>
        } else<span class="cov0" title="0"> {
                // Account exists, get the user from users repository
                usersUser, err := s.usersRepo.Get(ctx, account.UserId)
                if err != nil </span><span class="cov0" title="0">{
                        return nil, nil, fmt.Errorf("failed to get user: %w", err)
                }</span>

                // Convert to auth.User
                <span class="cov0" title="0">user = &amp;User{
                        Id:            usersUser.Id,
                        Email:         usersUser.Email,
                        Name:          usersUser.Name,
                        Image:         usersUser.Image,
                        EmailVerified: usersUser.EmailVerified,
                        CreatedAt:     usersUser.CreatedAt,
                        UpdatedAt:     usersUser.UpdatedAt,
                }

                // Update account with new tokens if refresh token changed
                if tokens.RefreshToken != "" &amp;&amp; tokens.RefreshToken != account.RefreshToken </span><span class="cov0" title="0">{
                        account.RefreshToken = tokens.RefreshToken
                        account.UpdatedAt = time.Now()
                        if _, err := s.repo.Update(ctx, account.Id, account); err != nil </span><span class="cov0" title="0">{
                                s.logger.Warn("failed to update refresh token", "error", err)
                        }</span>
                }
        }

        // Convert User to users.User for token generation
        <span class="cov0" title="0">usersUser := &amp;users.User{
                Id:            user.Id,
                Email:         user.Email,
                Name:          user.Name,
                EmailVerified: user.EmailVerified,
                CreatedAt:     user.CreatedAt,
                UpdatedAt:     user.UpdatedAt,
        }

        // Generate JWT tokens using the service's internal method
        providerStr := providerID
        jwtTokens, err := s.service.generateTokensWithContext(
                usersUser,
                uuid.Nil,     // activeOrgID
                "",           // orgName
                "",           // orgRole
                nil,          // organizations
                nil,          // permissions
                &amp;providerStr, // provider
                s.service.config,
        )
        if err != nil </span><span class="cov0" title="0">{
                return nil, nil, fmt.Errorf("failed to generate tokens: %w", err)
        }</span>

        // Clean up OAuth state
        <span class="cov0" title="0">_ = s.DeleteOAuthState(ctx, state)

        return user, jwtTokens, nil</span>
}

// createOAuthUser creates a new user from OAuth provider info
func (s *OAuthService) createOAuthUser(ctx context.Context, providerID string, userInfo *OAuthUserInfo, tokens *OAuthTokens) (*User, error) <span class="cov0" title="0">{
        now := time.Now()

        // Create user entity
        userEntity := &amp;users.User{
                Id:            uuid.New(),
                Email:         users.Email(userInfo.Email),
                Name:          userInfo.Name,
                Image:         userInfo.Picture,
                EmailVerified: userInfo.EmailVerified,
                CreatedAt:     now,
                UpdatedAt:     now,
        }

        // Save user to database
        createdUser, err := s.usersRepo.Create(ctx, userEntity)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to create user: %w", err)
        }</span>

        // Create OAuth account
        <span class="cov0" title="0">account := &amp;accounts.Account{
                Id:           uuid.New(),
                UserId:       createdUser.Id,
                ProviderId:   accounts.AccountProviderId(providerID),
                AccountId:    userInfo.ProviderAccountID,
                RefreshToken: tokens.RefreshToken,
                CreatedAt:    now,
                UpdatedAt:    now,
        }

        if _, err = s.repo.Create(ctx, account); err != nil </span><span class="cov0" title="0">{
                // Rollback user creation
                _ = s.usersRepo.Delete(ctx, createdUser.Id)
                return nil, fmt.Errorf("failed to create account: %w", err)
        }</span>

        // Convert to auth.User
        <span class="cov0" title="0">return &amp;User{
                Id:            createdUser.Id,
                Email:         createdUser.Email,
                Name:          createdUser.Name,
                Image:         createdUser.Image,
                EmailVerified: createdUser.EmailVerified,
                CreatedAt:     createdUser.CreatedAt,
                UpdatedAt:     createdUser.UpdatedAt,
        }, nil</span>
}

// RefreshOAuthToken refreshes an OAuth access token
func (s *OAuthService) RefreshOAuthToken(ctx context.Context, userID uuid.UUID, providerID string) (*OAuthTokens, error) <span class="cov0" title="0">{
        // Get the user's OAuth account
        accounts, _, err := s.repo.List(ctx, accounts.ListAccountsParams{
                UserID:     &amp;userID,
                ProviderID: &amp;providerID,
                Limit:      1,
        })
        if err != nil || len(accounts) == 0 </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("OAuth account not found")
        }</span>

        <span class="cov0" title="0">account := accounts[0]
        if account.RefreshToken == "" </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("no refresh token available")
        }</span>

        <span class="cov0" title="0">provider, ok := s.providers[providerID]
        if !ok </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("provider %s not found", providerID)
        }</span>

        // Refresh the token
        <span class="cov0" title="0">tokens, err := provider.RefreshToken(ctx, account.RefreshToken)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to refresh token: %w", err)
        }</span>

        // Update the account with new tokens
        <span class="cov0" title="0">account.RefreshToken = tokens.RefreshToken
        account.UpdatedAt = time.Now()

        if _, err := s.repo.Update(ctx, account.Id, account); err != nil </span><span class="cov0" title="0">{
                s.logger.Warn("failed to update account tokens", "error", err)
        }</span>

        <span class="cov0" title="0">return tokens, nil</span>
}

// generateState generates a secure random state parameter
func generateState() (string, error) <span class="cov0" title="0">{
        b := make([]byte, 32)
        if _, err := rand.Read(b); err != nil </span><span class="cov0" title="0">{
                return "", err
        }</span>
        <span class="cov0" title="0">return base64.URLEncoding.EncodeToString(b), nil</span>
}

// OAuth state storage using a simple in-memory map
// In production, this should use Redis or another distributed cache
var oauthStateStore = struct {
        sync.RWMutex
        states map[string]oauthState
}{
        states: make(map[string]oauthState),
}

type oauthState struct {
        Provider    string
        RedirectURI string
        ExpiresAt   time.Time
}

// StoreOAuthState stores OAuth state data temporarily
func (s *OAuthService) StoreOAuthState(_ context.Context, state, provider, redirectURI string, ttl time.Duration) error <span class="cov0" title="0">{
        oauthStateStore.Lock()
        defer oauthStateStore.Unlock()

        // Clean up expired states
        now := time.Now()
        for k, v := range oauthStateStore.states </span><span class="cov0" title="0">{
                if v.ExpiresAt.Before(now) </span><span class="cov0" title="0">{
                        delete(oauthStateStore.states, k)
                }</span>
        }

        <span class="cov0" title="0">oauthStateStore.states[state] = oauthState{
                Provider:    provider,
                RedirectURI: redirectURI,
                ExpiresAt:   now.Add(ttl),
        }

        return nil</span>
}

// GetOAuthRedirectURI retrieves the redirect URI for a state
func (s *OAuthService) GetOAuthRedirectURI(_ context.Context, state string) (string, error) <span class="cov0" title="0">{
        oauthStateStore.RLock()
        defer oauthStateStore.RUnlock()

        if s, ok := oauthStateStore.states[state]; ok </span><span class="cov0" title="0">{
                if s.ExpiresAt.After(time.Now()) </span><span class="cov0" title="0">{
                        return s.RedirectURI, nil
                }</span>
        }

        <span class="cov0" title="0">return "", fmt.Errorf("state not found or expired")</span>
}

// DeleteOAuthState removes OAuth state data
func (s *OAuthService) DeleteOAuthState(_ context.Context, state string) error <span class="cov0" title="0">{
        oauthStateStore.Lock()
        defer oauthStateStore.Unlock()

        delete(oauthStateStore.states, state)
        return nil
}</span>
</pre>
		
		<pre class="file" id="file29" style="display: none">package auth

import (
        "context"
        "crypto/rand"
        "encoding/hex"
        "fmt"
        "strings"
        "time"
        "unicode"

        "golang.org/x/crypto/bcrypt"
)

// validatePassword validates password strength requirements
func (s *Service) validatePassword(password string) error <span class="cov5" title="12">{
        if len(password) &lt; 8 </span><span class="cov1" title="1">{
                return fmt.Errorf("password must be at least 8 characters long")
        }</span>

        <span class="cov5" title="11">if len(password) &gt; 128 </span><span class="cov1" title="1">{
                return fmt.Errorf("password must not exceed 128 characters")
        }</span>

        <span class="cov5" title="10">var (
                hasUpper   bool
                hasLower   bool
                hasNumber  bool
                hasSpecial bool
        )

        for _, char := range password </span><span class="cov10" title="124">{
                switch </span>{
                case unicode.IsUpper(char):<span class="cov6" title="21">
                        hasUpper = true</span>
                case unicode.IsLower(char):<span class="cov8" title="71">
                        hasLower = true</span>
                case unicode.IsNumber(char):<span class="cov6" title="24">
                        hasNumber = true</span>
                case unicode.IsPunct(char) || unicode.IsSymbol(char):<span class="cov4" title="8">
                        hasSpecial = true</span>
                }
        }

        <span class="cov5" title="10">var missing []string
        if !hasUpper </span><span class="cov2" title="2">{
                missing = append(missing, "uppercase letter")
        }</span>
        <span class="cov5" title="10">if !hasLower </span><span class="cov1" title="1">{
                missing = append(missing, "lowercase letter")
        }</span>
        <span class="cov5" title="10">if !hasNumber </span><span class="cov2" title="2">{
                missing = append(missing, "number")
        }</span>
        <span class="cov5" title="10">if !hasSpecial </span><span class="cov2" title="2">{
                missing = append(missing, "special character")
        }</span>

        <span class="cov5" title="10">if len(missing) &gt; 0 </span><span class="cov4" title="5">{
                return fmt.Errorf("password must contain at least one %s", strings.Join(missing, ", "))
        }</span>

        <span class="cov4" title="5">return nil</span>
}

// hashPassword creates a bcrypt hash of the password
func (s *Service) hashPassword(password string) (string, error) <span class="cov3" title="4">{
        hashedBytes, err := bcrypt.GenerateFromPassword([]byte(password), s.config.BCryptCost)
        return string(hashedBytes), err
}</span>

// verifyPassword checks if the provided password matches the hash
func (s *Service) verifyPassword(password, hash string) error <span class="cov3" title="3">{
        return bcrypt.CompareHashAndPassword([]byte(hash), []byte(password))
}</span>

// generateVerificationToken generates a secure random token for email verification
func (s *Service) generateVerificationToken() (string, error) <span class="cov0" title="0">{
        // Generate 32 bytes of random data
        bytes := make([]byte, 32)
        if _, err := rand.Read(bytes); err != nil </span><span class="cov0" title="0">{
                return "", fmt.Errorf("failed to generate random bytes: %w", err)
        }</span>

        // Convert to hex string
        <span class="cov0" title="0">return hex.EncodeToString(bytes), nil</span>
}

// RequestPasswordReset initiates a password reset process
func (s *Service) RequestPasswordReset(ctx context.Context, email string) error <span class="cov0" title="0">{
        // Check if email service is configured
        if s.emailService == nil || s.dbQueries == nil </span><span class="cov0" title="0">{
                return fmt.Errorf("password reset service not configured")
        }</span>

        // Get user by email
        <span class="cov0" title="0">user, err := s.usersRepo.GetByEmail(ctx, email)
        if err != nil </span><span class="cov0" title="0">{
                // Don't reveal if user exists or not
                s.logger.Warn("password reset requested for non-existent user", "email", email)
                // Return success anyway to prevent user enumeration
                return nil
        }</span>

        // Generate reset token
        <span class="cov0" title="0">resetToken, err := s.generateVerificationToken()
        if err != nil </span><span class="cov0" title="0">{
                s.logger.Error("failed to generate reset token", "error", err)
                return fmt.Errorf("failed to generate reset token: %w", err)
        }</span>

        // TODO: Implement password reset token storage once database migration is added
        // For now, just log the token (DO NOT DO THIS IN PRODUCTION)
        <span class="cov0" title="0">s.logger.Info("password reset token generated", "email", email, "token", resetToken)

        // Send password reset email
        err = s.emailService.SendPasswordResetEmail(ctx, email, user.Name, resetToken)
        if err != nil </span><span class="cov0" title="0">{
                s.logger.Error("failed to send password reset email", "error", err)
                return fmt.Errorf("failed to send password reset email: %w", err)
        }</span>

        <span class="cov0" title="0">s.logger.Info("password reset requested", "user_id", user.Id.String())
        return nil</span>
}

// ConfirmPasswordReset completes the password reset process
func (s *Service) ConfirmPasswordReset(_ context.Context, _, _ string) error <span class="cov0" title="0">{
        // TODO: Implement password reset confirmation once database migration is added
        // For now, return not implemented error
        return fmt.Errorf("password reset confirmation not yet implemented")
}</span>

// trackFailedLoginAttempt tracks failed login attempts for rate limiting
func (s *Service) trackFailedLoginAttempt(_ context.Context, ipAddress, email string) <span class="cov3" title="4">{
        // TODO: Implement proper rate limiting with Redis or database
        // For now, just log the attempt
        s.logger.Warn("failed login attempt",
                "ip", ipAddress,
                "email", email,
                "timestamp", time.Now().Unix())
}</span>

// isIPLockedOut checks if an IP address is locked out due to too many failed attempts
func (s *Service) isIPLockedOut(_ context.Context, _ string) bool <span class="cov0" title="0">{ // nolint:unparam
        // TODO: Implement proper rate limiting with Redis or database
        // For now, always return false (no lockout)
        // In production, this should:
        // 1. Check failed attempt count for the IP in a time window
        // 2. Return true if count exceeds MaxLoginAttempts
        // 3. Consider using exponential backoff for repeat offenders
        return false
}</span>

// clearFailedAttempts clears failed login attempts after successful authentication
func (s *Service) clearFailedAttempts(_ context.Context, ipAddress, email string) <span class="cov2" title="2">{
        // TODO: Implement proper rate limiting with Redis or database
        // For now, just log the clear
        s.logger.Info("clearing failed login attempts",
                "ip", ipAddress,
                "email", email)
}</span>
</pre>
		
		<pre class="file" id="file30" style="display: none">package auth

// Role represents a user role in the system
type Role string

const (
        // RoleSuperAdmin has full system access
        RoleSuperAdmin Role = "super_admin"
        // RoleSystemAdmin can manage system settings
        RoleSystemAdmin Role = "system_admin"
        // RoleSupport provides support access
        RoleSupport Role = "support"

        // RoleOrgOwner has full control over an organization
        RoleOrgOwner Role = "org_owner"
        // RoleOrgAdmin can administer an organization
        RoleOrgAdmin Role = "org_admin"
        // RoleOrgMember is a regular organization member
        RoleOrgMember Role = "org_member"
        // RoleOrgViewer can only view organization resources
        RoleOrgViewer Role = "org_viewer"
        // RoleOrgGuest has limited guest access
        RoleOrgGuest Role = "org_guest"

        // RoleAPIUser represents API-only access
        RoleAPIUser Role = "api_user"
        // RoleServiceAccount is for service accounts
        RoleServiceAccount Role = "service_account"
)

// Permission represents a specific permission in the system
type Permission string

const (
        // PermSystemManage allows full system management
        PermSystemManage Permission = "system:manage"
        // PermSystemViewMetrics allows viewing system metrics
        PermSystemViewMetrics Permission = "system:view_metrics"
        // PermSystemViewLogs allows viewing system logs
        PermSystemViewLogs Permission = "system:view_logs"
        // PermSystemManageUsers allows managing system users
        PermSystemManageUsers Permission = "system:manage_users"

        // PermOrgCreate allows creating new organizations
        PermOrgCreate Permission = "org:create"
        // PermOrgRead allows reading organization data
        PermOrgRead Permission = "org:read"
        // PermOrgUpdate allows updating organization settings
        PermOrgUpdate Permission = "org:update"
        // PermOrgDelete allows deleting organizations
        PermOrgDelete Permission = "org:delete"
        // PermOrgManageMembers allows managing organization members
        PermOrgManageMembers Permission = "org:manage_members"
        // PermOrgManageBilling allows managing billing
        PermOrgManageBilling Permission = "org:manage_billing"
        // PermOrgManageSettings allows managing organization settings
        PermOrgManageSettings Permission = "org:manage_settings"
        // PermOrgInviteMembers allows inviting new members
        PermOrgInviteMembers Permission = "org:invite_members"
        // PermOrgViewAuditLog allows viewing audit logs
        PermOrgViewAuditLog Permission = "org:view_audit_log"

        // PermWorkflowCreate allows creating workflows
        PermWorkflowCreate Permission = "workflow:create"
        // PermWorkflowRead allows reading workflows
        PermWorkflowRead Permission = "workflow:read"
        // PermWorkflowUpdate allows updating workflows
        PermWorkflowUpdate Permission = "workflow:update"
        // PermWorkflowDelete allows deleting workflows
        PermWorkflowDelete Permission = "workflow:delete"
        // PermWorkflowExecute allows executing workflows
        PermWorkflowExecute Permission = "workflow:execute"
        // PermWorkflowViewRuns allows viewing workflow runs
        PermWorkflowViewRuns Permission = "workflow:view_runs"
        // PermWorkflowManageRuns allows managing workflow runs
        PermWorkflowManageRuns Permission = "workflow:manage_runs"

        // PermContentCreate allows creating content
        PermContentCreate Permission = "content:create"
        // PermContentRead allows reading content
        PermContentRead Permission = "content:read"
        // PermContentUpdate allows updating content
        PermContentUpdate Permission = "content:update"
        // PermContentDelete allows deleting content
        PermContentDelete Permission = "content:delete"
        // PermContentShare allows sharing content
        PermContentShare Permission = "content:share"
        // PermContentPublish allows publishing content
        PermContentPublish Permission = "content:publish"

        // PermAIUseBasic allows basic AI usage
        PermAIUseBasic Permission = "ai:use_basic"
        // PermAIUsePremium allows premium AI usage
        PermAIUsePremium Permission = "ai:use_premium"
        // PermAIManageKeys allows managing AI keys
        PermAIManageKeys Permission = "ai:manage_keys"
        // PermAIViewUsage allows viewing AI usage
        PermAIViewUsage Permission = "ai:view_usage"
        // PermAIManagePrompts allows managing AI prompts
        PermAIManagePrompts Permission = "ai:manage_prompts"

        // PermUserUpdateProfile allows updating user profile
        PermUserUpdateProfile Permission = "user:update_profile"
        // PermUserManageTokens allows managing user tokens
        PermUserManageTokens Permission = "user:manage_tokens"
        // PermUserManageSessions allows managing user sessions
        PermUserManageSessions Permission = "user:manage_sessions"
        // PermUserViewActivity allows viewing user activity
        PermUserViewActivity Permission = "user:view_activity"

        // PermAPICreateKeys allows creating API keys
        PermAPICreateKeys Permission = "api:create_keys"
        // PermAPIManageKeys allows managing API keys
        PermAPIManageKeys Permission = "api:manage_keys"
        // PermAPIViewUsage allows viewing API usage
        PermAPIViewUsage Permission = "api:view_usage"
)

// Scope represents API access scopes
type Scope string

const (
        // ScopeOpenID is the OpenID Connect scope
        ScopeOpenID Scope = "openid"
        // ScopeEmail allows reading email address
        ScopeEmail Scope = "email"
        // ScopeProfile allows reading basic profile info
        ScopeProfile Scope = "profile"

        // ScopeReadProfile allows reading user profile
        ScopeReadProfile Scope = "read:profile"
        // ScopeReadOrganizations allows reading organization data
        ScopeReadOrganizations Scope = "read:organizations"
        // ScopeReadWorkflows allows reading workflows
        ScopeReadWorkflows Scope = "read:workflows"
        // ScopeReadContent allows reading content
        ScopeReadContent Scope = "read:content"
        // ScopeReadMetrics allows reading metrics
        ScopeReadMetrics Scope = "read:metrics"

        // ScopeWriteProfile allows writing to user profile
        ScopeWriteProfile Scope = "write:profile"
        // ScopeWriteOrganizations allows writing to organizations
        ScopeWriteOrganizations Scope = "write:organizations"
        // ScopeWriteWorkflows allows writing to workflows
        ScopeWriteWorkflows Scope = "write:workflows"
        // ScopeWriteContent allows writing content
        ScopeWriteContent Scope = "write:content"

        // ScopeExecuteWorkflows allows executing workflows
        ScopeExecuteWorkflows Scope = "execute:workflows"
        // ScopeExecuteCommands allows executing commands
        ScopeExecuteCommands Scope = "execute:commands"
        // ScopeExecuteAI allows executing AI operations
        ScopeExecuteAI Scope = "execute:ai"
)

// RolePermissions maps roles to their associated permissions
var RolePermissions = map[Role][]Permission{
        RoleSuperAdmin: {
                PermSystemManage,
                PermSystemViewMetrics,
                PermSystemViewLogs,
                PermSystemManageUsers,
                PermOrgCreate,
                PermOrgRead,
                PermOrgUpdate,
                PermOrgDelete,
                PermOrgManageMembers,
                PermOrgManageBilling,
                PermOrgManageSettings,
                PermOrgInviteMembers,
                PermOrgViewAuditLog,
                PermWorkflowCreate,
                PermWorkflowRead,
                PermWorkflowUpdate,
                PermWorkflowDelete,
                PermWorkflowExecute,
                PermContentCreate,
                PermContentRead,
                PermContentUpdate,
                PermContentDelete,
                PermContentShare,
                PermContentPublish,
                PermAIUsePremium,
                PermAIManageKeys,
                PermAPICreateKeys,
                PermAPIManageKeys,
        },
        RoleOrgOwner: {
                PermOrgRead,
                PermOrgUpdate,
                PermOrgDelete,
                PermOrgManageMembers,
                PermOrgManageBilling,
                PermOrgManageSettings,
                PermOrgInviteMembers,
                PermOrgViewAuditLog,
                PermWorkflowCreate,
                PermWorkflowRead,
                PermWorkflowUpdate,
                PermWorkflowDelete,
                PermWorkflowExecute,
                PermContentCreate,
                PermContentRead,
                PermContentUpdate,
                PermContentDelete,
                PermContentShare,
                PermContentPublish,
                PermAIUsePremium,
                PermAPICreateKeys,
        },
        RoleOrgAdmin: {
                PermOrgRead,
                PermOrgUpdate,
                PermOrgManageMembers,
                PermOrgInviteMembers,
                PermWorkflowCreate,
                PermWorkflowRead,
                PermWorkflowUpdate,
                PermWorkflowExecute,
                PermContentCreate,
                PermContentRead,
                PermContentUpdate,
                PermContentShare,
                PermAIUseBasic,
        },
        RoleOrgMember: {
                PermOrgRead,
                PermWorkflowCreate,
                PermWorkflowRead,
                PermWorkflowExecute,
                PermContentCreate,
                PermContentRead,
                PermContentUpdate,
                PermAIUseBasic,
        },
        RoleOrgViewer: {
                PermOrgRead,
                PermWorkflowRead,
                PermContentRead,
        },
        RoleOrgGuest: {
                PermOrgRead,
                PermContentRead,
        },
}

// HasPermission checks if a role has a specific permission
func HasPermission(role Role, permission Permission) bool <span class="cov5" title="5">{
        permissions, exists := RolePermissions[role]
        if !exists </span><span class="cov0" title="0">{
                return false
        }</span>

        <span class="cov5" title="5">for _, p := range permissions </span><span class="cov9" title="18">{
                if p == permission </span><span class="cov4" title="3">{
                        return true
                }</span>
        }
        <span class="cov2" title="2">return false</span>
}

// GetRolePermissions returns all permissions for a given role
func GetRolePermissions(role Role) []Permission <span class="cov10" title="23">{
        return RolePermissions[role]
}</span>

// GetDefaultScopes returns the default OAuth scopes
func GetDefaultScopes() []Scope <span class="cov1" title="1">{
        return []Scope{
                ScopeOpenID,
                ScopeEmail,
                ScopeProfile,
                ScopeReadProfile,
                ScopeReadOrganizations,
        }
}</span>

// GetAPIKeyScopes returns scopes available for API keys
func GetAPIKeyScopes() []Scope <span class="cov1" title="1">{
        return []Scope{
                ScopeReadWorkflows,
                ScopeWriteWorkflows,
                ScopeExecuteWorkflows,
                ScopeReadContent,
                ScopeWriteContent,
                ScopeExecuteAI,
        }
}</span>

// ValidateScopes checks if permissions satisfy required scopes
func ValidateScopes(_ []Permission, requiredScopes []Scope) bool <span class="cov0" title="0">{
        // TODO: Implement proper scope validation logic
        // For now, return true if no scopes required
        return len(requiredScopes) == 0
}</span>
</pre>
		
		<pre class="file" id="file31" style="display: none">package auth

import (
        "context"
        "net/url"

        "golang.org/x/oauth2"
)

// OAuthProvider defines the interface for OAuth2 providers
type OAuthProvider interface {
        // GetAuthURL returns the authorization URL for the provider
        GetAuthURL(state string, redirectURI string) string

        // ExchangeCode exchanges an authorization code for tokens
        ExchangeCode(ctx context.Context, code string, redirectURI string) (*OAuthTokens, error)

        // RefreshToken refreshes an access token using a refresh token
        RefreshToken(ctx context.Context, refreshToken string) (*OAuthTokens, error)

        // GetUserInfo retrieves user information from the provider
        GetUserInfo(ctx context.Context, accessToken string) (*OAuthUserInfo, error)

        // GetProviderID returns the provider identifier (e.g., "google", "github")
        GetProviderID() string
}

// OAuthTokens represents OAuth2 tokens returned by a provider
type OAuthTokens struct {
        AccessToken  string
        RefreshToken string
        IDToken      string // OpenID Connect ID token (optional)
        ExpiresIn    int    // Seconds until expiration
        Scope        string
}

// OAuthUserInfo represents user information from an OAuth provider
type OAuthUserInfo struct {
        ProviderAccountID string // Unique ID from the provider
        Email             string
        EmailVerified     bool
        Name              string
        Picture           string
        Locale            string
        // Provider-specific additional data
        Raw map[string]interface{}
}

// OAuthConfig holds common OAuth2 configuration
type OAuthConfig struct {
        ClientID     string
        ClientSecret string
        Scopes       []string
        AuthURL      string
        TokenURL     string
}

// BaseOAuthProvider provides common OAuth2 functionality
type BaseOAuthProvider struct {
        Config *oauth2.Config
}

// GetAuthURL returns the authorization URL with the provided state
func (p *BaseOAuthProvider) GetAuthURL(state string, redirectURI string) string <span class="cov0" title="0">{
        p.Config.RedirectURL = redirectURI

        // Add access_type=offline for providers that support refresh tokens
        authURL, _ := url.Parse(p.Config.AuthCodeURL(state))
        q := authURL.Query()
        q.Set("access_type", "offline")
        q.Set("prompt", "consent") // Force consent to get refresh token
        authURL.RawQuery = q.Encode()

        return authURL.String()
}</span>

// ExchangeCode exchanges an authorization code for tokens
func (p *BaseOAuthProvider) ExchangeCode(ctx context.Context, code string, redirectURI string) (*oauth2.Token, error) <span class="cov0" title="0">{
        p.Config.RedirectURL = redirectURI
        return p.Config.Exchange(ctx, code)
}</span>

// RefreshToken refreshes an access token using a refresh token
func (p *BaseOAuthProvider) RefreshToken(ctx context.Context, refreshToken string) (*oauth2.Token, error) <span class="cov0" title="0">{
        tokenSource := p.Config.TokenSource(ctx, &amp;oauth2.Token{
                RefreshToken: refreshToken,
        })
        return tokenSource.Token()
}</span>
</pre>
		
		<pre class="file" id="file32" style="display: none">package auth

import (
        "context"
        "fmt"
        "strings"
        "time"

        "github.com/archesai/archesai/internal/users"
        "github.com/golang-jwt/jwt/v5"
        "github.com/google/uuid"
)

// ValidateToken validates and parses a JWT token using enhanced claims
func (s *Service) ValidateToken(tokenString string) (*EnhancedClaims, error) <span class="cov10" title="5">{
        // Remove Bearer prefix if present
        tokenString = strings.TrimPrefix(tokenString, "Bearer ")
        tokenString = strings.TrimSpace(tokenString)

        // Parse and validate the token with enhanced claims
        token, err := jwt.ParseWithClaims(tokenString, &amp;EnhancedClaims{}, func(token *jwt.Token) (interface{}, error) </span><span class="cov8" title="4">{
                // Validate the signing method
                if _, ok := token.Method.(*jwt.SigningMethodHMAC); !ok </span><span class="cov0" title="0">{
                        return nil, fmt.Errorf("unexpected signing method: %v", token.Header["alg"])
                }</span>
                <span class="cov8" title="4">return s.jwtSecret, nil</span>
        })

        <span class="cov10" title="5">if err != nil </span><span class="cov4" title="2">{
                return nil, fmt.Errorf("failed to parse token: %w", err)
        }</span>

        <span class="cov7" title="3">claims, ok := token.Claims.(*EnhancedClaims)
        if !ok || !token.Valid </span><span class="cov0" title="0">{
                return nil, ErrInvalidToken
        }</span>

        // Additional validation for token type
        <span class="cov7" title="3">if claims.TokenType != AccessTokenType </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("invalid token type: expected access token")
        }</span>

        <span class="cov7" title="3">return claims, nil</span>
}

// ValidateAPIKey validates an API key
func (s *Service) ValidateAPIKey(ctx context.Context, apiKey string) (*APIKey, error) <span class="cov4" title="2">{
        if s.apiKeyService == nil </span><span class="cov4" title="2">{
                return nil, fmt.Errorf("API key service not configured")
        }</span>

        // Delegate to API key service
        <span class="cov0" title="0">return s.apiKeyService.ValidateAPIKey(ctx, apiKey)</span>
}

// RefreshToken refreshes an access token using a refresh token
func (s *Service) RefreshToken(ctx context.Context, refreshToken string) (*TokenResponse, error) <span class="cov0" title="0">{
        // Parse the refresh token with enhanced claims
        token, err := jwt.ParseWithClaims(refreshToken, &amp;RefreshClaims{}, func(token *jwt.Token) (interface{}, error) </span><span class="cov0" title="0">{
                // Validate the signing method
                if _, ok := token.Method.(*jwt.SigningMethodHMAC); !ok </span><span class="cov0" title="0">{
                        return nil, fmt.Errorf("unexpected signing method: %v", token.Header["alg"])
                }</span>
                <span class="cov0" title="0">return s.jwtSecret, nil</span>
        })

        <span class="cov0" title="0">if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("invalid refresh token: %w", err)
        }</span>

        <span class="cov0" title="0">claims, ok := token.Claims.(*RefreshClaims)
        if !ok || !token.Valid </span><span class="cov0" title="0">{
                return nil, ErrInvalidToken
        }</span>

        // Verify token type
        <span class="cov0" title="0">if claims.TokenType != RefreshTokenType </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("invalid token type: expected refresh token")
        }</span>

        // Get the user
        <span class="cov0" title="0">user, err := s.usersRepo.Get(ctx, claims.UserID)
        if err != nil </span><span class="cov0" title="0">{
                s.logger.Error("failed to get user for refresh", "user_id", claims.UserID, "error", err)
                return nil, ErrUserNotFound
        }</span>

        // Verify session is still valid if sessionID is present
        <span class="cov0" title="0">if claims.SessionID != "" </span><span class="cov0" title="0">{
                sessionID, err := uuid.Parse(claims.SessionID)
                if err == nil </span><span class="cov0" title="0">{
                        session, err := s.sessionsRepo.Get(ctx, sessionID)
                        if err != nil || session == nil </span><span class="cov0" title="0">{
                                s.logger.Warn("session not found for refresh", "session_id", claims.SessionID)
                                return nil, ErrSessionNotFound
                        }</span>

                        // Check if session is expired
                        <span class="cov0" title="0">if session.ExpiresAt != "" </span><span class="cov0" title="0">{
                                expiresAt, err := time.Parse(time.RFC3339, session.ExpiresAt)
                                if err == nil &amp;&amp; time.Now().After(expiresAt) </span><span class="cov0" title="0">{
                                        s.logger.Warn("session expired for refresh", "session_id", claims.SessionID)
                                        return nil, ErrSessionExpired
                                }</span>
                        }
                }
        }

        // Generate new tokens
        <span class="cov0" title="0">newTokens, err := s.generateTokens(user)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to generate new tokens: %w", err)
        }</span>

        <span class="cov0" title="0">s.logger.Info("tokens refreshed successfully", "user_id", claims.UserID)
        return newTokens, nil</span>
}

// generateTokens generates access and refresh tokens for a user
func (s *Service) generateTokens(user *users.User) (*TokenResponse, error) <span class="cov8" title="4">{
        return s.generateTokensWithConfig(user, s.config)
}</span>

// generateTokensWithConfig generates tokens with a specific configuration
func (s *Service) generateTokensWithConfig(user *users.User, config Config) (*TokenResponse, error) <span class="cov8" title="4">{
        // TODO: Fetch user's organizations and permissions
        // For now, use empty slices
        var organizations []OrganizationClaim
        var permissions []string

        return s.generateTokensWithContext(
                user,
                uuid.Nil, // No active organization for now
                "",       // No organization name
                "",       // No organization role
                organizations,
                permissions,
                nil, // No provider for local auth
                config,
        )
}</span>

// generateTokensWithContext generates tokens with full context
func (s *Service) generateTokensWithContext(
        user *users.User,
        activeOrgID uuid.UUID,
        orgName string,
        orgRole string,
        organizations []OrganizationClaim,
        permissions []string,
        provider *string,
        config Config,
) (*TokenResponse, error) <span class="cov8" title="4">{
        now := time.Now()

        // Create enhanced claims for access token
        accessClaims := &amp;EnhancedClaims{
                RegisteredClaims: jwt.RegisteredClaims{
                        ExpiresAt: jwt.NewNumericDate(now.Add(config.AccessTokenExpiry)),
                        IssuedAt:  jwt.NewNumericDate(now),
                        NotBefore: jwt.NewNumericDate(now),
                        Subject:   user.Id.String(),
                },
                UserID:           user.Id,
                Email:            string(user.Email),
                Name:             user.Name,
                OrganizationID:   activeOrgID,
                OrganizationName: orgName,
                OrganizationRole: orgRole,
                Organizations:    organizations,
                Permissions:      permissions,
                TokenType:        AccessTokenType,
                AuthMethod:       AuthMethodPassword,
                EmailVerified:    user.EmailVerified,
        }

        // Add provider info if OAuth
        if provider != nil &amp;&amp; *provider != "" </span><span class="cov0" title="0">{
                accessClaims.Provider = *provider
                accessClaims.AuthMethod = AuthMethodOAuth
        }</span>

        // Create access token
        <span class="cov8" title="4">accessToken := jwt.NewWithClaims(jwt.SigningMethodHS256, accessClaims)
        accessTokenString, err := accessToken.SignedString(s.jwtSecret)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to generate access token: %w", err)
        }</span>

        // Create refresh token with minimal claims
        <span class="cov8" title="4">refreshClaims := &amp;RefreshClaims{
                RegisteredClaims: jwt.RegisteredClaims{
                        ExpiresAt: jwt.NewNumericDate(now.Add(config.RefreshTokenExpiry)),
                        IssuedAt:  jwt.NewNumericDate(now),
                        NotBefore: jwt.NewNumericDate(now),
                        Subject:   user.Id.String(),
                },
                UserID:     user.Id,
                TokenType:  RefreshTokenType,
                AuthMethod: accessClaims.AuthMethod,
        }

        // Create refresh token
        refreshToken := jwt.NewWithClaims(jwt.SigningMethodHS256, refreshClaims)
        refreshTokenString, err := refreshToken.SignedString(s.jwtSecret)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to generate refresh token: %w", err)
        }</span>

        <span class="cov8" title="4">return &amp;TokenResponse{
                AccessToken:  accessTokenString,
                RefreshToken: refreshTokenString,
                ExpiresIn:    int64(config.AccessTokenExpiry.Seconds()),
                TokenType:    "Bearer",
        }, nil</span>
}
</pre>
		
		<pre class="file" id="file33" style="display: none">// Package auth provides primitives to interact with the openapi HTTP API.
//
// Code generated by github.com/oapi-codegen/oapi-codegen/v2 version v2.5.0 DO NOT EDIT.
package auth

import (
        "encoding/json"
        "time"

        "github.com/google/uuid"
        "github.com/oapi-codegen/runtime"
        openapi_types "github.com/oapi-codegen/runtime/types"
)

const (
        BearerAuthScopes    = "bearerAuth.Scopes"
        SessionCookieScopes = "sessionCookie.Scopes"
)

// Defines values for AccountProviderId.
const (
        Apple     AccountProviderId = "apple"
        Github    AccountProviderId = "github"
        Google    AccountProviderId = "google"
        Local     AccountProviderId = "local"
        Microsoft AccountProviderId = "microsoft"
)

// Defines values for AccountsFindManyParamsSortField.
const (
        AccountsFindManyParamsSortFieldAccessToken           AccountsFindManyParamsSortField = "accessToken"
        AccountsFindManyParamsSortFieldAccessTokenExpiresAt  AccountsFindManyParamsSortField = "accessTokenExpiresAt"
        AccountsFindManyParamsSortFieldAccountId             AccountsFindManyParamsSortField = "accountId"
        AccountsFindManyParamsSortFieldCreatedAt             AccountsFindManyParamsSortField = "createdAt"
        AccountsFindManyParamsSortFieldId                    AccountsFindManyParamsSortField = "id"
        AccountsFindManyParamsSortFieldIdToken               AccountsFindManyParamsSortField = "idToken"
        AccountsFindManyParamsSortFieldPassword              AccountsFindManyParamsSortField = "password"
        AccountsFindManyParamsSortFieldProviderId            AccountsFindManyParamsSortField = "providerId"
        AccountsFindManyParamsSortFieldRefreshToken          AccountsFindManyParamsSortField = "refreshToken"
        AccountsFindManyParamsSortFieldRefreshTokenExpiresAt AccountsFindManyParamsSortField = "refreshTokenExpiresAt"
        AccountsFindManyParamsSortFieldScope                 AccountsFindManyParamsSortField = "scope"
        AccountsFindManyParamsSortFieldUpdatedAt             AccountsFindManyParamsSortField = "updatedAt"
        AccountsFindManyParamsSortFieldUserId                AccountsFindManyParamsSortField = "userId"
)

// Defines values for AccountsFindManyParamsSortOrder.
const (
        AccountsFindManyParamsSortOrderAsc  AccountsFindManyParamsSortOrder = "asc"
        AccountsFindManyParamsSortOrderDesc AccountsFindManyParamsSortOrder = "desc"
)

// Defines values for FindManySessionsParamsSortField.
const (
        FindManySessionsParamsSortFieldActiveOrganizationId FindManySessionsParamsSortField = "activeOrganizationId"
        FindManySessionsParamsSortFieldCreatedAt            FindManySessionsParamsSortField = "createdAt"
        FindManySessionsParamsSortFieldExpiresAt            FindManySessionsParamsSortField = "expiresAt"
        FindManySessionsParamsSortFieldId                   FindManySessionsParamsSortField = "id"
        FindManySessionsParamsSortFieldIpAddress            FindManySessionsParamsSortField = "ipAddress"
        FindManySessionsParamsSortFieldToken                FindManySessionsParamsSortField = "token"
        FindManySessionsParamsSortFieldUpdatedAt            FindManySessionsParamsSortField = "updatedAt"
        FindManySessionsParamsSortFieldUserAgent            FindManySessionsParamsSortField = "userAgent"
        FindManySessionsParamsSortFieldUserId               FindManySessionsParamsSortField = "userId"
)

// Defines values for FindManySessionsParamsSortOrder.
const (
        FindManySessionsParamsSortOrderAsc  FindManySessionsParamsSortOrder = "asc"
        FindManySessionsParamsSortOrderDesc FindManySessionsParamsSortOrder = "desc"
)

// Account defines model for Account.
type Account struct {
        // AccessToken The OAuth access token
        AccessToken string `json:"accessToken,omitempty,omitzero" yaml:"accessToken,omitempty"`

        // AccessTokenExpiresAt The access token expiration timestamp
        AccessTokenExpiresAt time.Time `json:"accessTokenExpiresAt,omitempty,omitzero" yaml:"accessTokenExpiresAt,omitempty"`

        // AccountId The unique identifier for the account from the provider
        AccountId string `json:"accountId" yaml:"accountId"`

        // CreatedAt The date and time when the resource was created
        CreatedAt time.Time `json:"createdAt" yaml:"createdAt"`

        // Id Universally Unique Identifier
        Id UUID `json:"id" yaml:"id"`

        // IdToken The OpenID Connect ID token
        IdToken string `json:"idToken,omitempty,omitzero" yaml:"idToken,omitempty"`

        // Password The hashed password (only for local authentication)
        Password string `json:"password,omitempty,omitzero" yaml:"password,omitempty"`

        // ProviderId The authentication provider identifier
        ProviderId AccountProviderId `json:"providerId" yaml:"providerId"`

        // RefreshToken The OAuth refresh token
        RefreshToken string `json:"refreshToken,omitempty,omitzero" yaml:"refreshToken,omitempty"`

        // RefreshTokenExpiresAt The refresh token expiration timestamp
        RefreshTokenExpiresAt time.Time `json:"refreshTokenExpiresAt,omitempty,omitzero" yaml:"refreshTokenExpiresAt,omitempty"`

        // Scope The OAuth scope granted
        Scope string `json:"scope,omitempty,omitzero" yaml:"scope,omitempty"`

        // UpdatedAt The date and time when the resource was last updated
        UpdatedAt time.Time `json:"updatedAt" yaml:"updatedAt"`

        // UserId The user ID this account belongs to
        UserId UUID `json:"userId" yaml:"userId"`
}

// AccountProviderId The authentication provider identifier
type AccountProviderId string

// Base defines model for Base.
type Base struct {
        // CreatedAt The date and time when the resource was created
        CreatedAt time.Time `json:"createdAt" yaml:"createdAt"`

        // Id Universally Unique Identifier
        Id UUID `json:"id" yaml:"id"`

        // UpdatedAt The date and time when the resource was last updated
        UpdatedAt time.Time `json:"updatedAt" yaml:"updatedAt"`
}

// Email defines model for Email.
type Email = openapi_types.Email

// FilterNode A recursive filter node that can be a condition or group
type FilterNode = interface{}

// Page Pagination (page number &amp; size)
type Page struct {
        Number int `json:"number,omitempty,omitzero" yaml:"number,omitempty"`
        Size   int `json:"size,omitempty,omitzero" yaml:"size,omitempty"`
}

// Problem RFC 7807 (Problem Details) compliant error response
type Problem struct {
        // Detail Human-readable explanation specific to this occurrence
        Detail string `json:"detail" yaml:"detail"`

        // Errors Additional validation errors for specific fields
        Errors []ValidationError `json:"errors,omitempty,omitzero" yaml:"errors,omitempty"`

        // Instance URI identifying the specific occurrence
        Instance string `json:"instance,omitempty,omitzero" yaml:"instance,omitempty"`

        // Status HTTP status code
        Status int `json:"status" yaml:"status"`

        // Title Short, human-readable summary
        Title string `json:"title" yaml:"title"`

        // Type URI identifying the problem type
        Type string `json:"type" yaml:"type"`
}

// Session Schema for Session entity
type Session struct {
        // ActiveOrganizationId The active organization ID
        ActiveOrganizationId openapi_types.UUID `json:"activeOrganizationId" yaml:"activeOrganizationId"`

        // CreatedAt The date this item was created
        CreatedAt time.Time `json:"createdAt" yaml:"createdAt"`

        // ExpiresAt The expiration date of the session
        ExpiresAt string `json:"expiresAt" yaml:"expiresAt"`

        // Id The ID of the item
        Id openapi_types.UUID `json:"id" yaml:"id"`

        // IpAddress The IP address of the session
        IpAddress string `json:"ipAddress" yaml:"ipAddress"`

        // Token The session token
        Token string `json:"token" yaml:"token"`

        // UpdatedAt The date this item was last updated
        UpdatedAt time.Time `json:"updatedAt" yaml:"updatedAt"`

        // UserAgent The user agent of the session
        UserAgent string `json:"userAgent" yaml:"userAgent"`

        // UserId The ID of the user associated with the session
        UserId openapi_types.UUID `json:"userId" yaml:"userId"`
}

// TokenResponse defines model for TokenResponse.
type TokenResponse struct {
        // AccessToken JWT access token for API authentication
        AccessToken string `json:"access_token" yaml:"access_token"`

        // ExpiresIn Access token expiration time in seconds
        ExpiresIn int64 `json:"expires_in" yaml:"expires_in"`

        // RefreshToken Refresh token for obtaining new access tokens
        RefreshToken string `json:"refresh_token" yaml:"refresh_token"`

        // TokenType Type of token (always "Bearer")
        TokenType string `json:"token_type" yaml:"token_type"`
}

// UUID Universally Unique Identifier
type UUID = uuid.UUID

// User defines model for User.
type User struct {
        // CreatedAt The date and time when the resource was created
        CreatedAt time.Time `json:"createdAt" yaml:"createdAt"`

        // Email The user's email address
        Email Email `json:"email" yaml:"email"`

        // EmailVerified Whether the user's email has been verified
        EmailVerified bool `json:"emailVerified" yaml:"emailVerified"`

        // Id Universally Unique Identifier
        Id UUID `json:"id" yaml:"id"`

        // Image The user's avatar image URL
        Image string `json:"image,omitempty,omitzero" yaml:"image,omitempty"`

        // Name The user's display name
        Name string `json:"name" yaml:"name"`

        // UpdatedAt The date and time when the resource was last updated
        UpdatedAt time.Time `json:"updatedAt" yaml:"updatedAt"`
}

// ValidationError Individual field validation error
type ValidationError struct {
        // Field The field path that failed validation
        Field string `json:"field" yaml:"field"`

        // Message Human-readable error message
        Message string `json:"message" yaml:"message"`

        // Value The invalid value that was provided
        Value ValidationError_Value `json:"value,omitempty,omitzero" yaml:"value,omitempty"`
}

// ValidationErrorValue0 defines model for .
type ValidationErrorValue0 = string

// ValidationErrorValue1 defines model for .
type ValidationErrorValue1 = float32

// ValidationErrorValue2 defines model for .
type ValidationErrorValue2 = bool

// ValidationError_Value The invalid value that was provided
type ValidationError_Value struct {
        union json.RawMessage
}

// AccountsFilter A recursive filter node that can be a condition or group
type AccountsFilter = FilterNode

// AccountsSort defines model for AccountsSort.
type AccountsSort = []struct {
        Field string `json:"field" yaml:"field"`
        Order string `json:"order" yaml:"order"`
}

// PageQuery Pagination (page number &amp; size)
type PageQuery = Page

// SessionsFilter A recursive filter node that can be a condition or group
type SessionsFilter = FilterNode

// SessionsSort defines model for SessionsSort.
type SessionsSort = []struct {
        Field string `json:"field" yaml:"field"`
        Order string `json:"order" yaml:"order"`
}

// BadRequest RFC 7807 (Problem Details) compliant error response
type BadRequest = Problem

// NotFound RFC 7807 (Problem Details) compliant error response
type NotFound = Problem

// Unauthorized RFC 7807 (Problem Details) compliant error response
type Unauthorized = Problem

// AccountsFindManyParams defines parameters for AccountsFindMany.
type AccountsFindManyParams struct {
        // Filter Filter accounts by field values. Supported fields:
        // - createdAt, id, updatedAt, accessToken, accessTokenExpiresAt
        // - accountId, idToken, password, providerId, refreshToken
        // - refreshTokenExpiresAt, scope, userId
        Filter AccountsFilter `json:"filter,omitempty,omitzero" yaml:"filter,omitempty"`

        // Page The page parameter
        Page PageQuery `form:"page,omitempty" json:"page,omitempty,omitzero" yaml:"page,omitempty"`

        // Sort The sort parameter
        Sort AccountsSort `form:"sort,omitempty" json:"sort,omitempty,omitzero" yaml:"sort,omitempty"`
}

// AccountsFindManyParamsSortField defines parameters for AccountsFindMany.
type AccountsFindManyParamsSortField string

// AccountsFindManyParamsSortOrder defines parameters for AccountsFindMany.
type AccountsFindManyParamsSortOrder string

// RequestEmailChangeJSONBody defines parameters for RequestEmailChange.
type RequestEmailChangeJSONBody struct {
        // NewEmail The e-mail to send the confirmation token to
        NewEmail openapi_types.Email `json:"newEmail" yaml:"newEmail"`

        // UserId The user ID of the user requesting the email change
        UserId openapi_types.UUID `json:"userId" yaml:"userId"`
}

// ConfirmEmailChangeJSONBody defines parameters for ConfirmEmailChange.
type ConfirmEmailChangeJSONBody struct {
        // NewEmail The e-mail to send the confirmation token to
        NewEmail openapi_types.Email `json:"newEmail" yaml:"newEmail"`

        // Token The password reset token
        Token string `json:"token" yaml:"token"`

        // UserId The user ID of the user requesting the email change
        UserId openapi_types.UUID `json:"userId" yaml:"userId"`
}

// ConfirmEmailVerificationJSONBody defines parameters for ConfirmEmailVerification.
type ConfirmEmailVerificationJSONBody struct {
        // Token The password reset token
        Token string `json:"token" yaml:"token"`
}

// LoginJSONBody defines parameters for Login.
type LoginJSONBody struct {
        // Email The email address associated with the account
        Email openapi_types.Email `json:"email" yaml:"email"`

        // Password The password for the account
        Password string `json:"password" yaml:"password"`

        // RememberMe Whether to create a long-lived session
        RememberMe bool `json:"rememberMe,omitempty,omitzero" yaml:"rememberMe,omitempty"`
}

// RequestPasswordResetJSONBody defines parameters for RequestPasswordReset.
type RequestPasswordResetJSONBody struct {
        // Email The e-mail to send the password reset token to
        Email string `json:"email" yaml:"email"`
}

// ConfirmPasswordResetJSONBody defines parameters for ConfirmPasswordReset.
type ConfirmPasswordResetJSONBody struct {
        // NewPassword The new password
        NewPassword string `json:"newPassword" yaml:"newPassword"`

        // Token The password reset token
        Token string `json:"token" yaml:"token"`
}

// RegisterJSONBody defines parameters for Register.
type RegisterJSONBody struct {
        // Email The email address associated with the account
        Email openapi_types.Email `json:"email" yaml:"email"`

        // Name The name of the user creating the account
        Name string `json:"name" yaml:"name"`

        // Password The password for the account
        Password string `json:"password" yaml:"password"`
}

// FindManySessionsParams defines parameters for FindManySessions.
type FindManySessionsParams struct {
        // Filter Filter sessions by field values. Supported fields:
        // - createdAt, id, updatedAt, activeOrganizationId, expiresAt
        // - ipAddress, token, userAgent, userId
        Filter SessionsFilter `json:"filter,omitempty,omitzero" yaml:"filter,omitempty"`

        // Page The page parameter
        Page PageQuery `form:"page,omitempty" json:"page,omitempty,omitzero" yaml:"page,omitempty"`

        // Sort The sort parameter
        Sort SessionsSort `form:"sort,omitempty" json:"sort,omitempty,omitzero" yaml:"sort,omitempty"`
}

// FindManySessionsParamsSortField defines parameters for FindManySessions.
type FindManySessionsParamsSortField string

// FindManySessionsParamsSortOrder defines parameters for FindManySessions.
type FindManySessionsParamsSortOrder string

// UpdateSessionJSONBody defines parameters for UpdateSession.
type UpdateSessionJSONBody struct {
        // ActiveOrganizationId The active organization ID
        ActiveOrganizationId string `json:"activeOrganizationId" yaml:"activeOrganizationId"`
}

// RequestEmailChangeJSONRequestBody defines body for RequestEmailChange for application/json ContentType.
type RequestEmailChangeJSONRequestBody RequestEmailChangeJSONBody

// ConfirmEmailChangeJSONRequestBody defines body for ConfirmEmailChange for application/json ContentType.
type ConfirmEmailChangeJSONRequestBody ConfirmEmailChangeJSONBody

// ConfirmEmailVerificationJSONRequestBody defines body for ConfirmEmailVerification for application/json ContentType.
type ConfirmEmailVerificationJSONRequestBody ConfirmEmailVerificationJSONBody

// LoginJSONRequestBody defines body for Login for application/json ContentType.
type LoginJSONRequestBody LoginJSONBody

// RequestPasswordResetJSONRequestBody defines body for RequestPasswordReset for application/json ContentType.
type RequestPasswordResetJSONRequestBody RequestPasswordResetJSONBody

// ConfirmPasswordResetJSONRequestBody defines body for ConfirmPasswordReset for application/json ContentType.
type ConfirmPasswordResetJSONRequestBody ConfirmPasswordResetJSONBody

// RegisterJSONRequestBody defines body for Register for application/json ContentType.
type RegisterJSONRequestBody RegisterJSONBody

// UpdateSessionJSONRequestBody defines body for UpdateSession for application/json ContentType.
type UpdateSessionJSONRequestBody UpdateSessionJSONBody

// AsValidationErrorValue0 returns the union data inside the ValidationError_Value as a ValidationErrorValue0
func (t ValidationError_Value) AsValidationErrorValue0() (ValidationErrorValue0, error) <span class="cov0" title="0">{
        var body ValidationErrorValue0
        err := json.Unmarshal(t.union, &amp;body)
        return body, err
}</span>

// FromValidationErrorValue0 overwrites any union data inside the ValidationError_Value as the provided ValidationErrorValue0
func (t *ValidationError_Value) FromValidationErrorValue0(v ValidationErrorValue0) error <span class="cov0" title="0">{
        b, err := json.Marshal(v)
        t.union = b
        return err
}</span>

// MergeValidationErrorValue0 performs a merge with any union data inside the ValidationError_Value, using the provided ValidationErrorValue0
func (t *ValidationError_Value) MergeValidationErrorValue0(v ValidationErrorValue0) error <span class="cov0" title="0">{
        b, err := json.Marshal(v)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov0" title="0">merged, err := runtime.JSONMerge(t.union, b)
        t.union = merged
        return err</span>
}

// AsValidationErrorValue1 returns the union data inside the ValidationError_Value as a ValidationErrorValue1
func (t ValidationError_Value) AsValidationErrorValue1() (ValidationErrorValue1, error) <span class="cov0" title="0">{
        var body ValidationErrorValue1
        err := json.Unmarshal(t.union, &amp;body)
        return body, err
}</span>

// FromValidationErrorValue1 overwrites any union data inside the ValidationError_Value as the provided ValidationErrorValue1
func (t *ValidationError_Value) FromValidationErrorValue1(v ValidationErrorValue1) error <span class="cov0" title="0">{
        b, err := json.Marshal(v)
        t.union = b
        return err
}</span>

// MergeValidationErrorValue1 performs a merge with any union data inside the ValidationError_Value, using the provided ValidationErrorValue1
func (t *ValidationError_Value) MergeValidationErrorValue1(v ValidationErrorValue1) error <span class="cov0" title="0">{
        b, err := json.Marshal(v)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov0" title="0">merged, err := runtime.JSONMerge(t.union, b)
        t.union = merged
        return err</span>
}

// AsValidationErrorValue2 returns the union data inside the ValidationError_Value as a ValidationErrorValue2
func (t ValidationError_Value) AsValidationErrorValue2() (ValidationErrorValue2, error) <span class="cov0" title="0">{
        var body ValidationErrorValue2
        err := json.Unmarshal(t.union, &amp;body)
        return body, err
}</span>

// FromValidationErrorValue2 overwrites any union data inside the ValidationError_Value as the provided ValidationErrorValue2
func (t *ValidationError_Value) FromValidationErrorValue2(v ValidationErrorValue2) error <span class="cov0" title="0">{
        b, err := json.Marshal(v)
        t.union = b
        return err
}</span>

// MergeValidationErrorValue2 performs a merge with any union data inside the ValidationError_Value, using the provided ValidationErrorValue2
func (t *ValidationError_Value) MergeValidationErrorValue2(v ValidationErrorValue2) error <span class="cov0" title="0">{
        b, err := json.Marshal(v)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov0" title="0">merged, err := runtime.JSONMerge(t.union, b)
        t.union = merged
        return err</span>
}

func (t ValidationError_Value) MarshalJSON() ([]byte, error) <span class="cov0" title="0">{
        b, err := t.union.MarshalJSON()
        return b, err
}</span>

func (t *ValidationError_Value) UnmarshalJSON(b []byte) error <span class="cov0" title="0">{
        err := t.union.UnmarshalJSON(b)
        return err
}</span>
</pre>
		
		<pre class="file" id="file34" style="display: none">package auth

import (
        "context"
        "fmt"
)

// VerifyEmail verifies a user's email address using a verification token
func (s *Service) VerifyEmail(_ context.Context, _ string) error <span class="cov0" title="0">{
        // TODO: Implement email verification once database migration is added
        // For now, return not implemented error
        return fmt.Errorf("email verification not yet implemented")
}</span>

// ResendVerificationEmail resends the email verification email
func (s *Service) ResendVerificationEmail(_ context.Context, _ string) error <span class="cov0" title="0">{
        // TODO: Implement email verification resend once database migration is added
        // For now, return not implemented error
        return fmt.Errorf("email verification resend not yet implemented")
}</span>
</pre>
		
		<pre class="file" id="file35" style="display: none">package cache

import (
        "context"
        "sync"
        "time"
)

// MemoryCache implements Cache using in-memory storage (for testing)
type MemoryCache[T any] struct {
        mu    sync.RWMutex
        items map[string]*memoryItem[T]
}

type memoryItem[T any] struct {
        value     *T
        expiresAt time.Time
}

// NewMemoryCache creates a new in-memory cache
func NewMemoryCache[T any]() *MemoryCache[T] <span class="cov0" title="0">{
        return &amp;MemoryCache[T]{
                items: make(map[string]*memoryItem[T]),
        }
}</span>

// Get retrieves an item from cache by key
func (c *MemoryCache[T]) Get(_ context.Context, key string) (*T, error) <span class="cov0" title="0">{
        c.mu.RLock()
        defer c.mu.RUnlock()

        item, exists := c.items[key]
        if !exists </span><span class="cov0" title="0">{
                return nil, nil
        }</span>

        // Check expiration
        <span class="cov0" title="0">if !item.expiresAt.IsZero() &amp;&amp; time.Now().After(item.expiresAt) </span><span class="cov0" title="0">{
                return nil, nil
        }</span>

        <span class="cov0" title="0">return item.value, nil</span>
}

// Set stores an item in cache with TTL
func (c *MemoryCache[T]) Set(_ context.Context, key string, value *T, ttl time.Duration) error <span class="cov0" title="0">{
        c.mu.Lock()
        defer c.mu.Unlock()

        var expiresAt time.Time
        if ttl &gt; 0 </span><span class="cov0" title="0">{
                expiresAt = time.Now().Add(ttl)
        }</span>

        <span class="cov0" title="0">c.items[key] = &amp;memoryItem[T]{
                value:     value,
                expiresAt: expiresAt,
        }

        return nil</span>
}

// Delete removes an item from cache
func (c *MemoryCache[T]) Delete(_ context.Context, key string) error <span class="cov0" title="0">{
        c.mu.Lock()
        defer c.mu.Unlock()

        delete(c.items, key)
        return nil
}</span>

// Exists checks if a key exists in cache
func (c *MemoryCache[T]) Exists(_ context.Context, key string) (bool, error) <span class="cov0" title="0">{
        c.mu.RLock()
        defer c.mu.RUnlock()

        item, exists := c.items[key]
        if !exists </span><span class="cov0" title="0">{
                return false, nil
        }</span>

        // Check expiration
        <span class="cov0" title="0">if !item.expiresAt.IsZero() &amp;&amp; time.Now().After(item.expiresAt) </span><span class="cov0" title="0">{
                return false, nil
        }</span>

        <span class="cov0" title="0">return true, nil</span>
}

// Clear removes all items from cache
func (c *MemoryCache[T]) Clear(_ context.Context) error <span class="cov0" title="0">{
        c.mu.Lock()
        defer c.mu.Unlock()

        c.items = make(map[string]*memoryItem[T])
        return nil
}</span>

// GetMany retrieves multiple items from cache
func (c *MemoryCache[T]) GetMany(_ context.Context, keys []string) (map[string]*T, error) <span class="cov0" title="0">{
        c.mu.RLock()
        defer c.mu.RUnlock()

        result := make(map[string]*T)
        now := time.Now()

        for _, key := range keys </span><span class="cov0" title="0">{
                item, exists := c.items[key]
                if !exists </span><span class="cov0" title="0">{
                        continue</span>
                }

                // Check expiration
                <span class="cov0" title="0">if !item.expiresAt.IsZero() &amp;&amp; now.After(item.expiresAt) </span><span class="cov0" title="0">{
                        continue</span>
                }

                <span class="cov0" title="0">result[key] = item.value</span>
        }

        <span class="cov0" title="0">return result, nil</span>
}

// SetMany stores multiple items in cache
func (c *MemoryCache[T]) SetMany(_ context.Context, items map[string]*T, ttl time.Duration) error <span class="cov0" title="0">{
        c.mu.Lock()
        defer c.mu.Unlock()

        var expiresAt time.Time
        if ttl &gt; 0 </span><span class="cov0" title="0">{
                expiresAt = time.Now().Add(ttl)
        }</span>

        <span class="cov0" title="0">for key, value := range items </span><span class="cov0" title="0">{
                c.items[key] = &amp;memoryItem[T]{
                        value:     value,
                        expiresAt: expiresAt,
                }
        }</span>

        <span class="cov0" title="0">return nil</span>
}

// DeleteMany removes multiple items from cache
func (c *MemoryCache[T]) DeleteMany(_ context.Context, keys []string) error <span class="cov0" title="0">{
        c.mu.Lock()
        defer c.mu.Unlock()

        for _, key := range keys </span><span class="cov0" title="0">{
                delete(c.items, key)
        }</span>

        <span class="cov0" title="0">return nil</span>
}

// Ensure MemoryCache implements MultiCache
var _ MultiCache[any] = (*MemoryCache[any])(nil)
</pre>
		
		<pre class="file" id="file36" style="display: none">package cache

import (
        "context"
        "errors"
        "time"
)

// ErrCacheMiss indicates a cache miss
var ErrCacheMiss = errors.New("cache miss")

// NoOpCache implements Cache but does nothing (always returns cache miss)
type NoOpCache[T any] struct{}

// NewNoOpCache creates a new no-op cache
func NewNoOpCache[T any]() *NoOpCache[T] <span class="cov0" title="0">{
        return &amp;NoOpCache[T]{}
}</span>

// Get always returns cache miss
func (c *NoOpCache[T]) Get(_ context.Context, _ string) (*T, error) <span class="cov0" title="0">{
        return nil, ErrCacheMiss
}</span>

// Set does nothing
func (c *NoOpCache[T]) Set(_ context.Context, _ string, _ *T, _ time.Duration) error <span class="cov0" title="0">{
        return nil
}</span>

// Delete does nothing
func (c *NoOpCache[T]) Delete(_ context.Context, _ string) error <span class="cov0" title="0">{
        return nil
}</span>

// Exists always returns false
func (c *NoOpCache[T]) Exists(_ context.Context, _ string) (bool, error) <span class="cov0" title="0">{
        return false, nil
}</span>

// Clear does nothing
func (c *NoOpCache[T]) Clear(_ context.Context) error <span class="cov0" title="0">{
        return nil
}</span>

// Ensure NoOpCache implements Cache interface
var _ Cache[any] = (*NoOpCache[any])(nil)
</pre>
		
		<pre class="file" id="file37" style="display: none">package cache

import (
        "context"
        "encoding/json"
        "errors"
        "fmt"
        "time"

        "github.com/redis/go-redis/v9"
)

// RedisCache implements Cache using Redis as the backend
type RedisCache[T any] struct {
        client    *redis.Client
        keyPrefix string
}

// NewRedisCache creates a new Redis-backed cache with an optional key prefix
func NewRedisCache[T any](client *redis.Client, keyPrefix string) *RedisCache[T] <span class="cov0" title="0">{
        return &amp;RedisCache[T]{
                client:    client,
                keyPrefix: keyPrefix,
        }
}</span>

// formatKey adds the prefix to a cache key
func (c *RedisCache[T]) formatKey(key string) string <span class="cov0" title="0">{
        if c.keyPrefix != "" </span><span class="cov0" title="0">{
                return fmt.Sprintf("%s:%s", c.keyPrefix, key)
        }</span>
        <span class="cov0" title="0">return key</span>
}

// Get retrieves an item from cache by key
func (c *RedisCache[T]) Get(ctx context.Context, key string) (*T, error) <span class="cov0" title="0">{
        data, err := c.client.Get(ctx, c.formatKey(key)).Bytes()
        if err != nil </span><span class="cov0" title="0">{
                if errors.Is(err, redis.Nil) </span><span class="cov0" title="0">{
                        return nil, nil // Key doesn't exist
                }</span>
                <span class="cov0" title="0">return nil, fmt.Errorf("redis get: %w", err)</span>
        }

        <span class="cov0" title="0">var value T
        if err := json.Unmarshal(data, &amp;value); err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("unmarshal: %w", err)
        }</span>

        <span class="cov0" title="0">return &amp;value, nil</span>
}

// Set stores an item in cache with TTL
func (c *RedisCache[T]) Set(ctx context.Context, key string, value *T, ttl time.Duration) error <span class="cov0" title="0">{
        if value == nil </span><span class="cov0" title="0">{
                return errors.New("cannot cache nil value")
        }</span>

        <span class="cov0" title="0">data, err := json.Marshal(value)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("marshal: %w", err)
        }</span>

        <span class="cov0" title="0">if err := c.client.Set(ctx, c.formatKey(key), data, ttl).Err(); err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("redis set: %w", err)
        }</span>

        <span class="cov0" title="0">return nil</span>
}

// Delete removes an item from cache
func (c *RedisCache[T]) Delete(ctx context.Context, key string) error <span class="cov0" title="0">{
        if err := c.client.Del(ctx, c.formatKey(key)).Err(); err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("redis del: %w", err)
        }</span>
        <span class="cov0" title="0">return nil</span>
}

// Exists checks if a key exists in cache
func (c *RedisCache[T]) Exists(ctx context.Context, key string) (bool, error) <span class="cov0" title="0">{
        count, err := c.client.Exists(ctx, c.formatKey(key)).Result()
        if err != nil </span><span class="cov0" title="0">{
                return false, fmt.Errorf("redis exists: %w", err)
        }</span>
        <span class="cov0" title="0">return count &gt; 0, nil</span>
}

// Clear removes all items from cache (use with caution)
func (c *RedisCache[T]) Clear(ctx context.Context) error <span class="cov0" title="0">{
        if c.keyPrefix == "" </span><span class="cov0" title="0">{
                return errors.New("cannot clear cache without key prefix")
        }</span>

        <span class="cov0" title="0">pattern := fmt.Sprintf("%s:*", c.keyPrefix)
        iter := c.client.Scan(ctx, 0, pattern, 0).Iterator()

        var keys []string
        for iter.Next(ctx) </span><span class="cov0" title="0">{
                keys = append(keys, iter.Val())
        }</span>

        <span class="cov0" title="0">if err := iter.Err(); err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("redis scan: %w", err)
        }</span>

        <span class="cov0" title="0">if len(keys) &gt; 0 </span><span class="cov0" title="0">{
                if err := c.client.Del(ctx, keys...).Err(); err != nil </span><span class="cov0" title="0">{
                        return fmt.Errorf("redis del: %w", err)
                }</span>
        }

        <span class="cov0" title="0">return nil</span>
}

// GetMany retrieves multiple items from cache
func (c *RedisCache[T]) GetMany(ctx context.Context, keys []string) (map[string]*T, error) <span class="cov0" title="0">{
        if len(keys) == 0 </span><span class="cov0" title="0">{
                return make(map[string]*T), nil
        }</span>

        // Format keys with prefix
        <span class="cov0" title="0">formattedKeys := make([]string, len(keys))
        for i, key := range keys </span><span class="cov0" title="0">{
                formattedKeys[i] = c.formatKey(key)
        }</span>

        // Get values from Redis
        <span class="cov0" title="0">values, err := c.client.MGet(ctx, formattedKeys...).Result()
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("redis mget: %w", err)
        }</span>

        // Parse results
        <span class="cov0" title="0">result := make(map[string]*T)
        for i, val := range values </span><span class="cov0" title="0">{
                if val == nil </span><span class="cov0" title="0">{
                        continue</span> // Key doesn't exist
                }

                <span class="cov0" title="0">data, ok := val.(string)
                if !ok </span><span class="cov0" title="0">{
                        continue</span>
                }

                <span class="cov0" title="0">var value T
                if err := json.Unmarshal([]byte(data), &amp;value); err != nil </span><span class="cov0" title="0">{
                        continue</span> // Skip invalid entries
                }

                <span class="cov0" title="0">result[keys[i]] = &amp;value</span>
        }

        <span class="cov0" title="0">return result, nil</span>
}

// SetMany stores multiple items in cache
func (c *RedisCache[T]) SetMany(ctx context.Context, items map[string]*T, ttl time.Duration) error <span class="cov0" title="0">{
        if len(items) == 0 </span><span class="cov0" title="0">{
                return nil
        }</span>

        <span class="cov0" title="0">pipe := c.client.Pipeline()

        for key, value := range items </span><span class="cov0" title="0">{
                if value == nil </span><span class="cov0" title="0">{
                        continue</span>
                }

                <span class="cov0" title="0">data, err := json.Marshal(value)
                if err != nil </span><span class="cov0" title="0">{
                        continue</span> // Skip items that can't be marshaled
                }

                <span class="cov0" title="0">pipe.Set(ctx, c.formatKey(key), data, ttl)</span>
        }

        <span class="cov0" title="0">_, err := pipe.Exec(ctx)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("redis pipeline exec: %w", err)
        }</span>

        <span class="cov0" title="0">return nil</span>
}

// DeleteMany removes multiple items from cache
func (c *RedisCache[T]) DeleteMany(ctx context.Context, keys []string) error <span class="cov0" title="0">{
        if len(keys) == 0 </span><span class="cov0" title="0">{
                return nil
        }</span>

        <span class="cov0" title="0">formattedKeys := make([]string, len(keys))
        for i, key := range keys </span><span class="cov0" title="0">{
                formattedKeys[i] = c.formatKey(key)
        }</span>

        <span class="cov0" title="0">if err := c.client.Del(ctx, formattedKeys...).Err(); err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("redis del: %w", err)
        }</span>

        <span class="cov0" title="0">return nil</span>
}

// Ensure RedisCache implements MultiCache
var _ MultiCache[any] = (*RedisCache[any])(nil)
</pre>
		
		<pre class="file" id="file38" style="display: none">// Package cli provides command-line interface functionality
package cli

import (
        "context"
        "fmt"
        "log"
        "log/slog"
        "net/http"
        "os"
        "os/signal"
        "sync"
        "syscall"
        "time"

        "github.com/archesai/archesai/internal/app"
        "github.com/archesai/archesai/internal/config"
        "github.com/spf13/cobra"
        "github.com/spf13/viper"
)

// allCmd represents the all command
var allCmd = &amp;cobra.Command{
        Use:     "all",
        Aliases: []string{"dev"},
        Short:   "Run all services (API, web, worker) for development",
        Long: `Start all ArchesAI services in a single process for development.

This command runs the API server, web server, and background worker
together, making it convenient for local development.

Note: This mode is NOT recommended for production. In production,
run each service separately for better scaling and isolation.`,
        Example: `  archesai all
  archesai dev  # Using alias`,
        RunE: runAll,
}

func init() <span class="cov0" title="0">{
        rootCmd.AddCommand(allCmd)

        // Reuse flags from individual commands with dev defaults
        allCmd.Flags().String("api-host", "localhost", "API server host")
        allCmd.Flags().Int("api-port", 8080, "API server port")
        allCmd.Flags().Int("web-port", 3000, "Web server port")

        // Bind to viper with prefixes
        if err := viper.BindPFlag("server.host", allCmd.Flags().Lookup("api-host")); err != nil </span><span class="cov0" title="0">{
                log.Fatalf("Failed to bind api-host flag: %v", err)
        }</span>
        <span class="cov0" title="0">if err := viper.BindPFlag("server.port", allCmd.Flags().Lookup("api-port")); err != nil </span><span class="cov0" title="0">{
                log.Fatalf("Failed to bind api-port flag: %v", err)
        }</span>
        <span class="cov0" title="0">if err := viper.BindPFlag("web.port", allCmd.Flags().Lookup("web-port")); err != nil </span><span class="cov0" title="0">{
                log.Fatalf("Failed to bind web-port flag: %v", err)
        }</span>
}

func runAll(_ *cobra.Command, _ []string) error <span class="cov0" title="0">{
        log.Println("🚀 Starting all services in development mode...")

        // Load configuration
        cfg, err := config.Load()
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to load configuration: %w", err)
        }</span>

        // Override with viper values if set
        <span class="cov0" title="0">if viper.IsSet("server.host") </span><span class="cov0" title="0">{
                cfg.Api.Host = viper.GetString("server.host")
        }</span>
        <span class="cov0" title="0">if viper.IsSet("server.port") </span><span class="cov0" title="0">{
                cfg.Api.Port = float32(viper.GetInt("server.port"))
        }</span>

        // Create application container
        <span class="cov0" title="0">appContainer, err := app.NewApp(cfg)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to create application: %w", err)
        }</span>
        <span class="cov0" title="0">defer func() </span><span class="cov0" title="0">{
                if err := appContainer.Close(); err != nil </span><span class="cov0" title="0">{
                        slog.Error("Failed to close container: %v", "error", err)
                }</span>
        }()

        // Create wait group for services
        <span class="cov0" title="0">var wg sync.WaitGroup

        // Channel to collect errors
        errChan := make(chan error, 3)

        // Start API server
        wg.Add(1)
        go func() </span><span class="cov0" title="0">{
                defer wg.Done()
                log.Printf("🚀 API server starting on %s:%d", cfg.Api.Host, int(cfg.Api.Port))
                if err := appContainer.Server.ListenAndServe(); err != nil &amp;&amp; err != http.ErrServerClosed </span><span class="cov0" title="0">{
                        errChan &lt;- fmt.Errorf("api server: %w", err)
                }</span>
        }()

        // Give API server time to start
        <span class="cov0" title="0">time.Sleep(1 * time.Second)

        // Start web server (when implemented)
        wg.Add(1)
        go func() </span><span class="cov0" title="0">{
                defer wg.Done()
                webPort := viper.GetInt("web.port")
                log.Printf("🌐 Web server would start on port %d", webPort)
                // TODO: Implement web server
        }</span>()

        // Start worker (when implemented)
        <span class="cov0" title="0">wg.Add(1)
        go func() </span><span class="cov0" title="0">{
                defer wg.Done()
                log.Printf("⚙️  Worker would start processing jobs")
                // TODO: Implement worker
        }</span>()

        // Wait for interrupt signal
        <span class="cov0" title="0">quit := make(chan os.Signal, 1)
        signal.Notify(quit, os.Interrupt, syscall.SIGTERM)

        // Wait for either error or interrupt
        select </span>{
        case err := &lt;-errChan:<span class="cov0" title="0">
                log.Printf("Error starting services: %v", err)
                return err</span>
        case &lt;-quit:<span class="cov0" title="0">
                log.Println("\nShutting down all services...")
                // Graceful shutdown
                shutdownCtx, shutdownCancel := context.WithTimeout(context.Background(), 10*time.Second)
                defer shutdownCancel()
                if err := appContainer.Server.Shutdown(shutdownCtx); err != nil </span><span class="cov0" title="0">{
                        log.Printf("API server forced to shutdown: %v", err)
                }</span>
        }

        // Wait for all services to stop
        <span class="cov0" title="0">wg.Wait()
        log.Println("All services stopped")
        return nil</span>
}
</pre>
		
		<pre class="file" id="file39" style="display: none">package cli

import (
        "context"
        "fmt"
        "log"
        "log/slog"
        "net/http"
        "os"
        "os/signal"
        "syscall"
        "time"

        "github.com/archesai/archesai/internal/app"
        "github.com/archesai/archesai/internal/config"
        "github.com/spf13/cobra"
        "github.com/spf13/viper"
)

// apiCmd represents the api command
var apiCmd = &amp;cobra.Command{
        Use:   "api",
        Short: "Run the API server",
        Long: `Start the ArchesAI API server which provides REST endpoints
for all platform functionality.

The API server handles authentication, organizations, workflows,
content management, and more.`,
        Example: `  archesai api --port=8080
  archesai api --host=0.0.0.0 --port=3000
  archesai api --config=production.yaml`,
        RunE: runAPI,
}

var (
        apiHost string
        apiPort int
)

func init() <span class="cov0" title="0">{
        rootCmd.AddCommand(apiCmd)

        // Local flags for API server
        apiCmd.Flags().StringVar(&amp;apiHost, "host", "0.0.0.0", "Host to bind the server to")
        apiCmd.Flags().IntVar(&amp;apiPort, "port", 8080, "Port to bind the server to")

        // Bind to viper
        if err := viper.BindPFlag("server.host", apiCmd.Flags().Lookup("host")); err != nil </span><span class="cov0" title="0">{
                log.Fatalf("Failed to bind host flag: %v", err)
        }</span>
        <span class="cov0" title="0">if err := viper.BindPFlag("server.port", apiCmd.Flags().Lookup("port")); err != nil </span><span class="cov0" title="0">{
                log.Fatalf("Failed to bind port flag: %v", err)
        }</span>
}

func runAPI(cmd *cobra.Command, _ []string) error <span class="cov0" title="0">{
        // Load configuration
        cfg, err := config.Load()
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to load configuration: %w", err)
        }</span>

        // Override with command line flags
        <span class="cov0" title="0">if cmd.Flags().Changed("host") </span><span class="cov0" title="0">{
                cfg.Api.Host = viper.GetString("server.host")
        }</span>
        <span class="cov0" title="0">if cmd.Flags().Changed("port") </span><span class="cov0" title="0">{
                cfg.Api.Port = float32(viper.GetInt("server.port"))
        }</span>

        // Create application container
        <span class="cov0" title="0">appContainer, err := app.NewApp(cfg)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to create application: %w", err)
        }</span>
        <span class="cov0" title="0">defer func() </span><span class="cov0" title="0">{
                if err := appContainer.Close(); err != nil </span><span class="cov0" title="0">{
                        slog.Error("Failed to close container: %v", "error", err)
                }</span>
        }()

        // Channel to listen for interrupt signals
        <span class="cov0" title="0">quit := make(chan os.Signal, 1)
        signal.Notify(quit, os.Interrupt, syscall.SIGTERM)

        // Run server in goroutine
        go func() </span><span class="cov0" title="0">{
                log.Printf("🚀 API server starting on %s:%d", cfg.Api.Host, int(cfg.Api.Port))
                if err := appContainer.Server.ListenAndServe(); err != nil &amp;&amp; err != http.ErrServerClosed </span><span class="cov0" title="0">{
                        log.Fatalf("Failed to start server: %v", err)
                }</span>
        }()

        // Wait for interrupt signal
        <span class="cov0" title="0">&lt;-quit
        log.Println("Shutting down server...")

        // Graceful shutdown with timeout
        ctx, cancel := context.WithTimeout(context.Background(), 30*time.Second)
        defer cancel()

        if err := appContainer.Server.Shutdown(ctx); err != nil </span><span class="cov0" title="0">{
                log.Printf("Server forced to shutdown: %v", err)
                return err
        }</span>

        <span class="cov0" title="0">log.Println("Server gracefully stopped")
        return nil</span>
}
</pre>
		
		<pre class="file" id="file40" style="display: none">package cli

import (
        "os"

        "github.com/spf13/cobra"
)

// completionCmd represents the completion command
var completionCmd = &amp;cobra.Command{
        Use:   "completion [bash|zsh|fish|powershell]",
        Short: "Generate shell completion script",
        Long: `To load completions:

Bash:
  $ source &lt;(archesai completion bash)
  # To load completions for each session, execute once:
  # Linux:
  $ archesai completion bash &gt; /etc/bash_completion.d/archesai
  # macOS:
  $ archesai completion bash &gt; $(brew --prefix)/etc/bash_completion.d/archesai

Zsh:
  $ source &lt;(archesai completion zsh)
  # To load completions for each session, execute once:
  $ archesai completion zsh &gt; "${fpath[1]}/_archesai"

Fish:
  $ archesai completion fish | source
  # To load completions for each session, execute once:
  $ archesai completion fish &gt; ~/.config/fish/completions/archesai.fish

PowerShell:
  PS&gt; archesai completion powershell | Out-String | Invoke-Expression
  # To load completions for every new session, run:
  PS&gt; archesai completion powershell &gt; archesai.ps1
  # and source this file from your PowerShell profile.
`,
        DisableFlagsInUseLine: true,
        ValidArgs:             []string{"bash", "zsh", "fish", "powershell"},
        Args:                  cobra.MatchAll(cobra.ExactArgs(1), cobra.OnlyValidArgs),
        Run: func(cmd *cobra.Command, args []string) <span class="cov0" title="0">{
                switch args[0] </span>{
                case "bash":<span class="cov0" title="0">
                        _ = cmd.Root().GenBashCompletion(os.Stdout)</span>
                case "zsh":<span class="cov0" title="0">
                        _ = cmd.Root().GenZshCompletion(os.Stdout)</span>
                case "fish":<span class="cov0" title="0">
                        _ = cmd.Root().GenFishCompletion(os.Stdout, true)</span>
                case "powershell":<span class="cov0" title="0">
                        _ = cmd.Root().GenPowerShellCompletionWithDesc(os.Stdout)</span>
                }
        },
}

func init() <span class="cov0" title="0">{
        rootCmd.AddCommand(completionCmd)
}</span>
</pre>
		
		<pre class="file" id="file41" style="display: none">package cli

import (
        "fmt"
        "log"
        "os"

        "github.com/spf13/cobra"
        "github.com/spf13/viper"
)

var (
        cfgFile string
        verbose bool
)

// rootCmd represents the base command when called without any subcommands
var rootCmd = &amp;cobra.Command{
        Use:   "archesai",
        Short: "ArchesAI server and utilities",
        Long: `ArchesAI is a comprehensive data processing platform.

This command provides various modes to run the ArchesAI server:
- API server for REST endpoints
- Web server for the UI (future)
- Worker for background job processing
- All mode for development`,
}

// Execute adds all child commands to the root command and sets flags appropriately.
func Execute() <span class="cov0" title="0">{
        if err := rootCmd.Execute(); err != nil </span><span class="cov0" title="0">{
                fmt.Fprintln(os.Stderr, err)
                os.Exit(1)
        }</span>
}

func init() <span class="cov0" title="0">{
        cobra.OnInitialize(initConfig)

        // Global flags
        rootCmd.PersistentFlags().StringVar(&amp;cfgFile, "config", "", "config file (default is .archesai.yaml)")
        rootCmd.PersistentFlags().BoolVarP(&amp;verbose, "verbose", "v", false, "verbose output")

        // Bind flags to viper
        if err := viper.BindPFlag("verbose", rootCmd.PersistentFlags().Lookup("verbose")); err != nil </span><span class="cov0" title="0">{
                log.Fatalf("Failed to bind verbose flag: %v", err)
        }</span>
}

// initConfig reads in config file and ENV variables if set.
func initConfig() <span class="cov0" title="0">{
        if cfgFile != "" </span><span class="cov0" title="0">{
                // Use config file from the flag.
                viper.SetConfigFile(cfgFile)
        }</span> else<span class="cov0" title="0"> {
                // Search for config in current directory and home directory
                viper.AddConfigPath(".")
                viper.AddConfigPath("$HOME")
                viper.SetConfigType("yaml")
                viper.SetConfigName(".archesai")
        }</span>

        // Read in environment variables
        <span class="cov0" title="0">viper.SetEnvPrefix("ARCHESAI")
        viper.AutomaticEnv()

        // If a config file is found, read it in.
        if err := viper.ReadInConfig(); err == nil &amp;&amp; verbose </span><span class="cov0" title="0">{
                fmt.Fprintln(os.Stderr, "Using config file:", viper.ConfigFileUsed())
        }</span>
}
</pre>
		
		<pre class="file" id="file42" style="display: none">package cli

import (
        "fmt"
        "os"

        "github.com/archesai/archesai/internal/llm"
        "github.com/archesai/archesai/internal/tui"
        tea "github.com/charmbracelet/bubbletea"
        "github.com/spf13/cobra"
)

// tuiCmd represents the tui command
var tuiCmd = &amp;cobra.Command{
        Use:   "tui",
        Short: "Launch the interactive TUI for configuration and AI agents",
        Long: `Launch an interactive terminal user interface (TUI) for viewing
configuration and optionally interacting with AI agents.

The TUI provides:
- Configuration viewer for all settings
- Database, server, and auth configuration display
- AI provider status and configuration
- Optional chat interface with AI agents`,
        Example: `  archesai tui                  # Launch config viewer
  archesai tui --chat            # Launch AI chat interface
  archesai tui --chat --provider=openai --model=gpt-4`,
        RunE: runTUI,
}

const (
        providerOllama = "ollama"
)

var (
        tuiProvider string
        tuiModel    string
        tuiAPIKey   string
        tuiChatMode bool
)

func init() <span class="cov0" title="0">{
        rootCmd.AddCommand(tuiCmd)

        // TUI specific flags
        tuiCmd.Flags().BoolVar(&amp;tuiChatMode, "chat", false, "Launch AI chat interface instead of config viewer")
        tuiCmd.Flags().StringVar(&amp;tuiProvider, "provider", "openai", "LLM provider (openai, claude, gemini, ollama)")
        tuiCmd.Flags().StringVar(&amp;tuiModel, "model", "gpt-4", "Model to use")
        tuiCmd.Flags().StringVar(&amp;tuiAPIKey, "api-key", "", "API key for the provider (or use environment variable)")
}</span>

func runTUI(_ *cobra.Command, _ []string) error <span class="cov0" title="0">{
        // If not in chat mode, launch the config viewer
        if !tuiChatMode </span><span class="cov0" title="0">{
                model := tui.NewConfigModel()
                program := tea.NewProgram(model, tea.WithAltScreen())

                if _, err := program.Run(); err != nil </span><span class="cov0" title="0">{
                        return fmt.Errorf("error running config TUI: %w", err)
                }</span>
                <span class="cov0" title="0">return nil</span>
        }

        // Chat mode - get API key from environment if not provided
        <span class="cov0" title="0">if tuiAPIKey == "" </span><span class="cov0" title="0">{
                switch tuiProvider </span>{
                case "openai":<span class="cov0" title="0">
                        tuiAPIKey = os.Getenv("OPENAI_API_KEY")</span>
                case "claude":<span class="cov0" title="0">
                        tuiAPIKey = os.Getenv("ANTHROPIC_API_KEY")</span>
                case "gemini":<span class="cov0" title="0">
                        tuiAPIKey = os.Getenv("GEMINI_API_KEY")</span>
                case providerOllama:<span class="cov0" title="0">
                        // Ollama doesn't need an API key
                        tuiAPIKey = "not-required"</span>
                }

                <span class="cov0" title="0">if tuiAPIKey == "" &amp;&amp; tuiProvider != providerOllama </span><span class="cov0" title="0">{
                        return fmt.Errorf("API key required for chat mode. Set --api-key flag or appropriate environment variable")
                }</span>
        }

        // Convert provider string to LLMProvider
        <span class="cov0" title="0">var provider llm.Provider
        switch tuiProvider </span>{
        case "openai":<span class="cov0" title="0">
                provider = llm.OpenAI</span>
        case "claude":<span class="cov0" title="0">
                provider = llm.Claude</span>
        case "gemini":<span class="cov0" title="0">
                provider = llm.Gemini</span>
        case providerOllama:<span class="cov0" title="0">
                provider = llm.Ollama</span>
        case "deepseek":<span class="cov0" title="0">
                provider = llm.DeepSeek</span>
        default:<span class="cov0" title="0">
                return fmt.Errorf("unsupported provider: %s", tuiProvider)</span>
        }

        // Initialize LLM client
        <span class="cov0" title="0">var llmClient llm.LLM
        switch provider </span>{
        case llm.OpenAI:<span class="cov0" title="0">
                llmClient = llm.NewOpenAILLM(tuiAPIKey)</span>
        case llm.Ollama:<span class="cov0" title="0">
                var err error
                llmClient, err = llm.NewOllamaLLM()
                if err != nil </span><span class="cov0" title="0">{
                        return fmt.Errorf("failed to create Ollama client: %w", err)
                }</span>
        default:<span class="cov0" title="0">
                return fmt.Errorf("provider %s not yet implemented in new chat interface", tuiProvider)</span>
        }

        <span class="cov0" title="0">if llmClient == nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to initialize LLM client")
        }</span>

        // Create chat client
        <span class="cov0" title="0">chatClient := llm.NewChatClient(llmClient)

        // Create sample personas with the specified model
        modelName := getModelForProvider(provider)
        personas := createSamplePersonas(modelName)

        // Create and run the TUI
        model := tui.New(chatClient, personas)
        program := tea.NewProgram(model, tea.WithAltScreen())

        if _, err := program.Run(); err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("error running TUI: %w", err)
        }</span>

        <span class="cov0" title="0">return nil</span>
}

func createSamplePersonas(model string) []*llm.ChatPersona <span class="cov0" title="0">{
        // Use the default personas but update the model
        personas := []*llm.ChatPersona{
                {
                        Name:         llm.DefaultPersonas.Assistant.Name,
                        SystemPrompt: llm.DefaultPersonas.Assistant.SystemPrompt,
                        Model:        model,
                        Temperature:  llm.DefaultPersonas.Assistant.Temperature,
                },
                {
                        Name:         llm.DefaultPersonas.CodeHelper.Name,
                        SystemPrompt: llm.DefaultPersonas.CodeHelper.SystemPrompt,
                        Model:        model,
                        Temperature:  llm.DefaultPersonas.CodeHelper.Temperature,
                },
                {
                        Name:         llm.DefaultPersonas.CreativeWriter.Name,
                        SystemPrompt: llm.DefaultPersonas.CreativeWriter.SystemPrompt,
                        Model:        model,
                        Temperature:  llm.DefaultPersonas.CreativeWriter.Temperature,
                },
                {
                        Name:         llm.DefaultPersonas.DataAnalyst.Name,
                        SystemPrompt: llm.DefaultPersonas.DataAnalyst.SystemPrompt,
                        Model:        model,
                        Temperature:  llm.DefaultPersonas.DataAnalyst.Temperature,
                },
                {
                        Name:         llm.DefaultPersonas.Researcher.Name,
                        SystemPrompt: llm.DefaultPersonas.Researcher.SystemPrompt,
                        Model:        model,
                        Temperature:  llm.DefaultPersonas.Researcher.Temperature,
                },
        }

        return personas
}</span>

func getModelForProvider(provider llm.Provider) string <span class="cov0" title="0">{
        switch provider </span>{
        case llm.Claude:<span class="cov0" title="0">
                return "claude-3-opus-20240229"</span>
        case llm.Gemini:<span class="cov0" title="0">
                return "gemini-pro"</span>
        case llm.Ollama:<span class="cov0" title="0">
                return "llama2"</span>
        case llm.DeepSeek:<span class="cov0" title="0">
                return "deepseek-chat"</span>
        default:<span class="cov0" title="0">
                return "gpt-4"</span>
        }
}
</pre>
		
		<pre class="file" id="file43" style="display: none">package cli

import (
        "fmt"

        "github.com/spf13/cobra"
)

var (
        // These will be set by ldflags during build
        version   = "dev"
        commit    = "none"
        buildDate = "unknown"
)

// versionCmd represents the version command
var versionCmd = &amp;cobra.Command{
        Use:   "version",
        Short: "Print version information",
        Long:  `Display version, commit hash, and build date of the ArchesAI server.`,
        Run: func(_ *cobra.Command, _ []string) <span class="cov0" title="0">{
                fmt.Printf("ArchesAI version %s\n", version)
                fmt.Printf("  commit: %s\n", commit)
                fmt.Printf("  built:  %s\n", buildDate)
        }</span>,
}

func init() <span class="cov0" title="0">{
        rootCmd.AddCommand(versionCmd)
}</span>
</pre>
		
		<pre class="file" id="file44" style="display: none">package cli

import (
        "fmt"
        "log"

        "github.com/spf13/cobra"
        "github.com/spf13/viper"
)

// webCmd represents the web command
var webCmd = &amp;cobra.Command{
        Use:   "web",
        Short: "Run the web UI server",
        Long: `Start the ArchesAI web UI server which serves the frontend
application for the platform.

This command will serve the built frontend assets and proxy API
requests to the configured API server.`,
        Example: `  archesai web --port=3000
  archesai web --api-url=http://localhost:8080`,
        RunE: runWeb,
}

var (
        webPort   int
        webAPIURL string
)

func init() <span class="cov0" title="0">{
        rootCmd.AddCommand(webCmd)

        // Local flags for web server
        webCmd.Flags().IntVar(&amp;webPort, "port", 3000, "Port to bind the web server to")
        webCmd.Flags().StringVar(&amp;webAPIURL, "api-url", "http://localhost:8080", "URL of the API server to proxy requests to")

        // Bind to viper
        if err := viper.BindPFlag("web.port", webCmd.Flags().Lookup("port")); err != nil </span><span class="cov0" title="0">{
                log.Fatalf("Failed to bind port flag: %v", err)
        }</span>
        <span class="cov0" title="0">if err := viper.BindPFlag("web.api_url", webCmd.Flags().Lookup("api-url")); err != nil </span><span class="cov0" title="0">{
                log.Fatalf("Failed to bind api-url flag: %v", err)
        }</span>
}

func runWeb(_ *cobra.Command, _ []string) error <span class="cov0" title="0">{
        port := viper.GetInt("web.port")
        apiURL := viper.GetString("web.api_url")

        log.Printf("🌐 Web server would start on port %d", port)
        log.Printf("   Proxying API requests to %s", apiURL)

        // TODO: Implement web server
        // This would:
        // 1. Serve static files from web/platform/dist
        // 2. Proxy /api/* requests to the API server
        // 3. Handle client-side routing for SPA

        return fmt.Errorf("web server not yet implemented")
}</span>
</pre>
		
		<pre class="file" id="file45" style="display: none">package cli

import (
        "fmt"
        "log"

        "github.com/spf13/cobra"
        "github.com/spf13/viper"
)

// workerCmd represents the worker command
var workerCmd = &amp;cobra.Command{
        Use:   "worker",
        Short: "Run background job worker",
        Long: `Start the ArchesAI background job worker which processes
asynchronous tasks like email sending, webhook delivery, and
long-running data processing jobs.`,
        Example: `  archesai worker
  archesai worker --queues=default,email,webhook
  archesai worker --concurrency=10`,
        RunE: runWorker,
}

var (
        workerQueues      []string
        workerConcurrency int
)

func init() <span class="cov0" title="0">{
        rootCmd.AddCommand(workerCmd)

        // Local flags for worker
        workerCmd.Flags().StringSliceVar(&amp;workerQueues, "queues", []string{"default"}, "Queues to process")
        workerCmd.Flags().IntVar(&amp;workerConcurrency, "concurrency", 10, "Number of concurrent workers")

        // Bind to viper
        if err := viper.BindPFlag("worker.queues", workerCmd.Flags().Lookup("queues")); err != nil </span><span class="cov0" title="0">{
                log.Fatalf("Failed to bind queues flag: %v", err)
        }</span>
        <span class="cov0" title="0">if err := viper.BindPFlag("worker.concurrency", workerCmd.Flags().Lookup("concurrency")); err != nil </span><span class="cov0" title="0">{
                log.Fatalf("Failed to bind concurrency flag: %v", err)
        }</span>
}

func runWorker(_ *cobra.Command, _ []string) error <span class="cov0" title="0">{
        queues := viper.GetStringSlice("worker.queues")
        concurrency := viper.GetInt("worker.concurrency")

        log.Printf("⚙️  Worker would start processing queues: %v", queues)
        log.Printf("   Concurrency: %d workers", concurrency)

        // TODO: Implement worker
        // This would:
        // 1. Connect to Redis or other job queue
        // 2. Process jobs from specified queues
        // 3. Handle graceful shutdown

        return fmt.Errorf("worker not yet implemented")
}</span>
</pre>
		
		<pre class="file" id="file46" style="display: none">// Package codegen provides unified code generation from OpenAPI schemas with x-codegen extensions.
//
// This package generates repository interfaces, cache implementations, event publishers,
// and other boilerplate code from OpenAPI specifications annotated with x-codegen metadata.
//
// The generator reads codegen.yaml configuration and processes OpenAPI schemas to produce:
//   - Repository interfaces and database implementations
//   - Cache interfaces and memory/redis implementations
//   - Event publisher interfaces and NATS/Redis implementations
//   - HTTP handlers and adapters
//   - Configuration defaults
//
// All generated files follow the pattern *.gen.go and should not be edited manually.
package codegen

import (
        "fmt"
        "log/slog"
        "os"
        "path/filepath"
        "sort"
        "text/template"

        "github.com/archesai/archesai/internal/logger"
        "gopkg.in/yaml.v3"
)

// Config represents the unified codegen configuration.
type Config struct {
        // OpenAPI spec file
        OpenAPI string `yaml:"openapi"`

        // Output directory
        OutputDir string `yaml:"output"`

        // Domains to generate
        Domains map[string]DomainConfig `yaml:"domains"`

        // Generators configuration
        Generators *GeneratorConfig `yaml:"generators,omitempty"`

        // Global settings
        Settings GlobalSettings `yaml:"settings"`
}

// DomainConfig configures generation for a specific domain.
type DomainConfig struct {
        Tags    []string `yaml:"tags"`
        Schemas []string `yaml:"schemas"`
}

// GeneratorConfig controls generator output paths.
// If a path is specified, the generator is enabled for that output.
// Paths are relative to the domain directory.
type GeneratorConfig struct {
        Repository *RepositoryGeneratorConfig `yaml:"repository,omitempty"`
        Cache      *CacheGeneratorConfig      `yaml:"cache,omitempty"`
        Events     *EventsGeneratorConfig     `yaml:"events,omitempty"`
        Handlers   string                     `yaml:"handlers,omitempty"` // e.g., "handlers.gen.go"
        Adapters   string                     `yaml:"adapters,omitempty"` // e.g., "adapters.gen.go"
        Tests      *TestsGeneratorConfig      `yaml:"tests,omitempty"`
        Defaults   string                     `yaml:"defaults,omitempty"` // Global path for defaults
}

// RepositoryGeneratorConfig specifies repository generator outputs.
type RepositoryGeneratorConfig struct {
        Interface string `yaml:"interface,omitempty"` // e.g., "ports.gen.go"
        Postgres  string `yaml:"postgres,omitempty"`  // e.g., "postgres_repository.gen.go"
        SQLite    string `yaml:"sqlite,omitempty"`    // e.g., "sqlite_repository.gen.go"
}

// CacheGeneratorConfig specifies cache generator outputs.
type CacheGeneratorConfig struct {
        Interface string `yaml:"interface,omitempty"` // e.g., "cache.gen.go"
        Memory    string `yaml:"memory,omitempty"`    // e.g., "cache_memory.gen.go"
        Redis     string `yaml:"redis,omitempty"`     // e.g., "cache_redis.gen.go"
}

// EventsGeneratorConfig specifies event generator outputs.
type EventsGeneratorConfig struct {
        Interface string `yaml:"interface,omitempty"` // e.g., "events.gen.go"
        Redis     string `yaml:"redis,omitempty"`     // e.g., "events_redis.gen.go"
        NATS      string `yaml:"nats,omitempty"`      // e.g., "events_nats.gen.go"
}

// TestsGeneratorConfig specifies test generator outputs.
type TestsGeneratorConfig struct {
        Service    string `yaml:"service,omitempty"`    // e.g., "service_test.gen.go"
        Repository string `yaml:"repository,omitempty"` // e.g., "repository_test.gen.go"
        Handler    string `yaml:"handler,omitempty"`    // e.g., "handler_test.gen.go"
}

// GlobalSettings contains global generation settings.
type GlobalSettings struct {
        OverwriteExisting bool   `yaml:"overwrite"`
        GenerateTests     bool   `yaml:"generate_tests"`
        FileHeader        string `yaml:"header"`
}

// RunWithConfig executes the unified code generator with the given configuration.
func RunWithConfig(config *Config) error <span class="cov0" title="0">{
        // Create logger with error level by default (only show errors)
        // Set ARCHESAI_LOG_LEVEL=debug to see debug logs
        logLevel := os.Getenv("ARCHESAI_LOG_LEVEL")
        if logLevel == "" </span><span class="cov0" title="0">{
                logLevel = "error"
        }</span>
        <span class="cov0" title="0">log := logger.New(logger.Config{Level: logLevel, Pretty: true})

        // Create parser and file writer
        parser := NewParser("")
        fileWriter := NewFileWriter()

        // Configure file writer
        fileWriter.WithOverwrite(true) // Always overwrite generated files
        if config.Settings.FileHeader != "" </span><span class="cov0" title="0">{
                fileWriter.WithHeader(config.Settings.FileHeader)
        }</span> else<span class="cov0" title="0"> {
                fileWriter.WithHeader(DefaultHeader())
        }</span>

        // Load templates
        <span class="cov0" title="0">templates, err := loadTemplates()
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to load templates: %w", err)
        }</span>

        <span class="cov0" title="0">log.Debug("Starting unified code generation...")

        // Parse OpenAPI spec
        schemas, err := parser.ParseOpenAPISpec(config.OpenAPI)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to parse OpenAPI spec: %w", err)
        }</span>

        <span class="cov0" title="0">log.Debug("Parsed schemas", slog.Int("count", len(schemas)), slog.String("spec", config.OpenAPI))

        // Auto-detect domains if not configured
        if len(config.Domains) == 0 </span><span class="cov0" title="0">{
                config.Domains = autoDetectDomains(schemas)
                log.Debug("Auto-detected domains", slog.Int("count", len(config.Domains)))
        }</span>

        // Filter schemas based on domain configuration
        <span class="cov0" title="0">filteredSchemas := filterSchemas(config, schemas)

        log.Debug("Filtered schemas with x-codegen", slog.Int("count", len(filteredSchemas)))

        // Run each enabled generator based on path configuration
        if config.Generators != nil &amp;&amp; config.Generators.Repository != nil </span><span class="cov0" title="0">{
                if err := generateRepository(config, filteredSchemas, templates, fileWriter, log); err != nil </span><span class="cov0" title="0">{
                        return fmt.Errorf("repository generator failed: %w", err)
                }</span>
                <span class="cov0" title="0">log.Debug("repository generator completed")</span>
        }

        <span class="cov0" title="0">if config.Generators != nil &amp;&amp; config.Generators.Cache != nil </span><span class="cov0" title="0">{
                if err := generateCache(config, filteredSchemas, templates, fileWriter, log); err != nil </span><span class="cov0" title="0">{
                        return fmt.Errorf("cache generator failed: %w", err)
                }</span>
                <span class="cov0" title="0">log.Debug("cache generator completed")</span>
        }

        <span class="cov0" title="0">if config.Generators != nil &amp;&amp; config.Generators.Events != nil </span><span class="cov0" title="0">{
                if err := generateEvents(config, filteredSchemas, templates, fileWriter, log); err != nil </span><span class="cov0" title="0">{
                        return fmt.Errorf("events generator failed: %w", err)
                }</span>
                <span class="cov0" title="0">log.Debug("events generator completed")</span>
        }

        <span class="cov0" title="0">if config.Generators != nil &amp;&amp; config.Generators.Handlers != "" </span><span class="cov0" title="0">{
                if err := generateHandlers(config, filteredSchemas, templates, fileWriter, log); err != nil </span><span class="cov0" title="0">{
                        return fmt.Errorf("handlers generator failed: %w", err)
                }</span>
                <span class="cov0" title="0">log.Debug("handlers generator completed")</span>
        }

        <span class="cov0" title="0">if config.Generators != nil &amp;&amp; config.Generators.Adapters != "" </span><span class="cov0" title="0">{
                if err := generateAdapters(config, filteredSchemas, templates, fileWriter, log); err != nil </span><span class="cov0" title="0">{
                        return fmt.Errorf("adapters generator failed: %w", err)
                }</span>
                <span class="cov0" title="0">log.Debug("adapters generator completed")</span>
        }

        <span class="cov0" title="0">if config.Generators != nil &amp;&amp; config.Generators.Defaults != "" </span><span class="cov0" title="0">{
                if err := generateDefaults(config, filteredSchemas, templates, fileWriter, log); err != nil </span><span class="cov0" title="0">{
                        return fmt.Errorf("defaults generator failed: %w", err)
                }</span>
                <span class="cov0" title="0">log.Debug("defaults generator completed")</span>
        }

        // Generate tests if enabled
        <span class="cov0" title="0">if config.Settings.GenerateTests </span><span class="cov0" title="0">{
                generateTests(config, filteredSchemas, templates, fileWriter, log)
                log.Debug("test generator completed")
        }</span>

        // Report warnings
        <span class="cov0" title="0">if warnings := parser.GetWarnings(); len(warnings) &gt; 0 </span><span class="cov0" title="0">{
                log.Warn("Parsing warnings found")
                for _, w := range warnings </span><span class="cov0" title="0">{
                        log.Debug("Warning", slog.String("message", w))
                }</span>
        }

        <span class="cov0" title="0">log.Debug("Code generation completed successfully")
        return nil</span>
}

// Run executes the unified code generator with the given configuration file.
func Run(configPath string) error <span class="cov0" title="0">{
        // Config path is required
        if configPath == "" </span><span class="cov0" title="0">{
                return fmt.Errorf("config file path is required")
        }</span>

        // Load configuration
        <span class="cov0" title="0">config, err := loadConfig(configPath)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to load config: %w", err)
        }</span>

        <span class="cov0" title="0">return RunWithConfig(config)</span>
}

// loadTemplates loads all template files.
func loadTemplates() (map[string]*template.Template, error) <span class="cov0" title="0">{
        templates := make(map[string]*template.Template)
        templateFiles := []string{
                "repository.go.tmpl",
                "repository_postgres.go.tmpl",
                "repository_sqlite.go.tmpl",
                "cache.go.tmpl",
                "cache_memory.go.tmpl",
                "cache_redis.go.tmpl",
                "events.go.tmpl",
                "events_nats.go.tmpl",
                "events_redis.go.tmpl",
                "adapters.go.tmpl",
                "config.go.tmpl",
        }

        for _, file := range templateFiles </span><span class="cov0" title="0">{
                content, err := GetTemplate(file)
                if err != nil </span><span class="cov0" title="0">{
                        return nil, fmt.Errorf("failed to read template %s: %w", file, err)
                }</span>

                <span class="cov0" title="0">tmpl, err := template.New(file).Funcs(TemplateFuncs()).Parse(content)
                if err != nil </span><span class="cov0" title="0">{
                        return nil, fmt.Errorf("failed to parse template %s: %w", file, err)
                }</span>

                <span class="cov0" title="0">templates[file] = tmpl</span>
        }

        <span class="cov0" title="0">return templates, nil</span>
}

// filterSchemas filters schemas based on domain configuration and x-codegen presence.
func filterSchemas(config *Config, allSchemas map[string]*ParsedSchema) map[string]*ParsedSchema <span class="cov0" title="0">{
        filtered := make(map[string]*ParsedSchema)

        for name, s := range allSchemas </span><span class="cov0" title="0">{
                // Check if schema has any x-codegen configuration
                if !HasXCodegen(s) </span><span class="cov0" title="0">{
                        continue</span>
                }

                // Check if schema matches domain filters
                <span class="cov0" title="0">if matchesDomainFilter(config, s) </span><span class="cov0" title="0">{
                        filtered[name] = s
                }</span>
        }

        <span class="cov0" title="0">return filtered</span>
}

// matchesDomainFilter checks if a schema matches the configured domain filters.
func matchesDomainFilter(config *Config, s *ParsedSchema) bool <span class="cov0" title="0">{
        // If no domain config, include all
        if len(config.Domains) == 0 </span><span class="cov0" title="0">{
                return true
        }</span>

        // Check if schema's domain is configured
        <span class="cov0" title="0">domainConfig, ok := config.Domains[s.Domain]
        if !ok </span><span class="cov0" title="0">{
                return false
        }</span>

        // If specific schemas are listed, check if this schema is included
        <span class="cov0" title="0">if len(domainConfig.Schemas) &gt; 0 </span><span class="cov0" title="0">{
                for _, schemaName := range domainConfig.Schemas </span><span class="cov0" title="0">{
                        if s.Name == schemaName </span><span class="cov0" title="0">{
                                return true
                        }</span>
                }
                <span class="cov0" title="0">return false</span>
        }

        // Include all schemas in the domain
        <span class="cov0" title="0">return true</span>
}

// loadConfig loads the codegen configuration from a YAML file.
func loadConfig(path string) (*Config, error) <span class="cov0" title="0">{
        data, err := os.ReadFile(path)
        if err != nil </span><span class="cov0" title="0">{
                // Try default locations
                defaultPaths := []string{
                        "archesai.codegen.yaml",
                        "codegen.yaml",
                        "codegen.yml",
                        ".codegen.yaml",
                        ".codegen.yml",
                }

                for _, defaultPath := range defaultPaths </span><span class="cov0" title="0">{
                        if data, err = os.ReadFile(defaultPath); err == nil </span><span class="cov0" title="0">{
                                break</span>
                        }
                }

                <span class="cov0" title="0">if err != nil </span><span class="cov0" title="0">{
                        return nil, fmt.Errorf("config file not found: %w", err)
                }</span>
        }

        <span class="cov0" title="0">var config Config
        if err := yaml.Unmarshal(data, &amp;config); err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to parse config: %w", err)
        }</span>

        // Set defaults
        <span class="cov0" title="0">if config.OutputDir == "" </span><span class="cov0" title="0">{
                config.OutputDir = "internal"
        }</span>

        // If no generators configured, use defaults
        <span class="cov0" title="0">if config.Generators == nil </span><span class="cov0" title="0">{
                config.Generators = &amp;GeneratorConfig{
                        Repository: &amp;RepositoryGeneratorConfig{
                                Interface: "ports.gen.go",
                                Postgres:  "postgres_repository.gen.go",
                                SQLite:    "sqlite_repository.gen.go",
                        },
                        Cache: &amp;CacheGeneratorConfig{
                                Interface: "cache.gen.go",
                                Memory:    "cache_memory.gen.go",
                                Redis:     "cache_redis.gen.go",
                        },
                        Events: &amp;EventsGeneratorConfig{
                                Interface: "events.gen.go",
                                Redis:     "events_redis.gen.go",
                        },
                        Handlers: "handlers.gen.go",
                        Adapters: "adapters.gen.go",
                        Defaults: "./internal/config/defaults.gen.go",
                }
        }</span>

        <span class="cov0" title="0">return &amp;config, nil</span>
}

// runGeneratorWithPaths runs generators using path-based configuration
func runGeneratorWithPaths(generatorType string, config *Config, schemas map[string]*ParsedSchema, templates map[string]*template.Template, fileWriter *FileWriter, filterFunc func(*ParsedSchema) bool, log *slog.Logger) error <span class="cov0" title="0">{
        log.Debug("Running generator", slog.String("type", generatorType))

        // Group schemas by domain
        domainSchemas := make(map[string][]*ParsedSchema)
        for _, s := range schemas </span><span class="cov0" title="0">{
                if filterFunc(s) </span><span class="cov0" title="0">{
                        domainSchemas[s.Domain] = append(domainSchemas[s.Domain], s)
                }</span>
        }

        // Sort domains for consistent output
        <span class="cov0" title="0">domains := make([]string, 0, len(domainSchemas))
        for domain := range domainSchemas </span><span class="cov0" title="0">{
                domains = append(domains, domain)
        }</span>
        <span class="cov0" title="0">sort.Strings(domains)

        // Generate for each domain
        for _, domain := range domains </span><span class="cov0" title="0">{
                schemas := domainSchemas[domain]

                // Sort schemas by name for consistent output
                sort.Slice(schemas, func(i, j int) bool </span><span class="cov0" title="0">{
                        return schemas[i].Name &lt; schemas[j].Name
                }</span>)

                <span class="cov0" title="0">log.Debug("Generating for domain",
                        slog.String("generator", generatorType),
                        slog.String("domain", domain),
                        slog.Int("entities", len(schemas)))

                // Prepare template data and output files based on generator type and config
                var templateData interface{}
                var outputFiles []struct{ path, template string }

                switch generatorType </span>{
                case "repository":<span class="cov0" title="0">
                        if config.Generators.Repository == nil </span><span class="cov0" title="0">{
                                continue</span>
                        }
                        <span class="cov0" title="0">templateData = prepareRepositoryData(domain, schemas)
                        outputFiles = []struct{ path, template string }{}
                        if config.Generators.Repository.Interface != "" </span><span class="cov0" title="0">{
                                outputFiles = append(outputFiles, struct{ path, template string }{
                                        filepath.Join(config.OutputDir, domain, config.Generators.Repository.Interface), "repository.go.tmpl",
                                })
                        }</span>
                        <span class="cov0" title="0">if config.Generators.Repository.Postgres != "" </span><span class="cov0" title="0">{
                                outputFiles = append(outputFiles, struct{ path, template string }{
                                        filepath.Join(config.OutputDir, domain, config.Generators.Repository.Postgres), "repository_postgres.go.tmpl",
                                })
                        }</span>
                        <span class="cov0" title="0">if config.Generators.Repository.SQLite != "" </span><span class="cov0" title="0">{
                                outputFiles = append(outputFiles, struct{ path, template string }{
                                        filepath.Join(config.OutputDir, domain, config.Generators.Repository.SQLite), "repository_sqlite.go.tmpl",
                                })
                        }</span>
                case "cache":<span class="cov0" title="0">
                        if config.Generators.Cache == nil </span><span class="cov0" title="0">{
                                continue</span>
                        }
                        <span class="cov0" title="0">templateData = prepareCacheData(domain, schemas)
                        outputFiles = []struct{ path, template string }{}
                        if config.Generators.Cache.Interface != "" </span><span class="cov0" title="0">{
                                outputFiles = append(outputFiles, struct{ path, template string }{
                                        filepath.Join(config.OutputDir, domain, config.Generators.Cache.Interface), "cache.go.tmpl",
                                })
                        }</span>
                        <span class="cov0" title="0">if config.Generators.Cache.Memory != "" </span><span class="cov0" title="0">{
                                outputFiles = append(outputFiles, struct{ path, template string }{
                                        filepath.Join(config.OutputDir, domain, config.Generators.Cache.Memory), "cache_memory.go.tmpl",
                                })
                        }</span>
                        <span class="cov0" title="0">if config.Generators.Cache.Redis != "" </span><span class="cov0" title="0">{
                                outputFiles = append(outputFiles, struct{ path, template string }{
                                        filepath.Join(config.OutputDir, domain, config.Generators.Cache.Redis), "cache_redis.go.tmpl",
                                })
                        }</span>
                case "events":<span class="cov0" title="0">
                        if config.Generators.Events == nil </span><span class="cov0" title="0">{
                                continue</span>
                        }
                        <span class="cov0" title="0">templateData = prepareEventsData(domain, schemas)
                        outputFiles = []struct{ path, template string }{}
                        if config.Generators.Events.Interface != "" </span><span class="cov0" title="0">{
                                outputFiles = append(outputFiles, struct{ path, template string }{
                                        filepath.Join(config.OutputDir, domain, config.Generators.Events.Interface), "events.go.tmpl",
                                })
                        }</span>
                        <span class="cov0" title="0">if config.Generators.Events.Redis != "" </span><span class="cov0" title="0">{
                                outputFiles = append(outputFiles, struct{ path, template string }{
                                        filepath.Join(config.OutputDir, domain, config.Generators.Events.Redis), "events_redis.go.tmpl",
                                })
                        }</span>
                        <span class="cov0" title="0">if config.Generators.Events.NATS != "" </span><span class="cov0" title="0">{
                                outputFiles = append(outputFiles, struct{ path, template string }{
                                        filepath.Join(config.OutputDir, domain, config.Generators.Events.NATS), "events_nats.go.tmpl",
                                })
                        }</span>
                case "adapters":<span class="cov0" title="0">
                        if config.Generators.Adapters == "" </span><span class="cov0" title="0">{
                                continue</span>
                        }
                        <span class="cov0" title="0">templateData = prepareAdaptersData(domain, schemas)
                        outputFiles = []struct{ path, template string }{
                                {filepath.Join(config.OutputDir, domain, config.Generators.Adapters), "adapters.go.tmpl"},
                        }</span>
                case "handlers":<span class="cov0" title="0">
                        if config.Generators.Handlers == "" </span><span class="cov0" title="0">{
                                continue</span>
                        }
                        <span class="cov0" title="0">templateData = prepareHandlersData(domain, schemas)
                        outputFiles = []struct{ path, template string }{
                                {filepath.Join(config.OutputDir, domain, config.Generators.Handlers), "handlers.go.tmpl"},
                        }</span>
                }

                // Write all template files
                <span class="cov0" title="0">for _, file := range outputFiles </span><span class="cov0" title="0">{
                        if err := fileWriter.WriteTemplate(file.path, templates[file.template], templateData); err != nil </span><span class="cov0" title="0">{
                                return fmt.Errorf("failed to write %s for %s: %w", generatorType, domain, err)
                        }</span>
                }
        }

        <span class="cov0" title="0">return nil</span>
}

// Helper functions to prepare data for each generator type
func prepareRepositoryData(domain string, schemas []*ParsedSchema) interface{} <span class="cov0" title="0">{
        var entities []struct {
                Name              string
                Type              string
                Operations        []string
                AdditionalMethods []interface{}
        }
        for _, schema := range schemas </span><span class="cov0" title="0">{
                ops := []string{}
                if schema.XCodegen.Repository.Operations != nil </span><span class="cov0" title="0">{
                        for _, op := range schema.XCodegen.Repository.Operations </span><span class="cov0" title="0">{
                                ops = append(ops, string(op))
                        }</span>
                }

                // Extract additional methods from x-codegen
                <span class="cov0" title="0">var additionalMethods []interface{}
                if schema.XCodegen != nil &amp;&amp; schema.XCodegen.Repository.AdditionalMethods != nil </span><span class="cov0" title="0">{
                        for _, method := range schema.XCodegen.Repository.AdditionalMethods </span><span class="cov0" title="0">{
                                additionalMethods = append(additionalMethods, struct {
                                        Name    string
                                        Params  []string
                                        Returns string
                                }{
                                        Name:    method.Name,
                                        Params:  method.Params,
                                        Returns: string(method.Returns),
                                })
                        }</span>
                }

                <span class="cov0" title="0">entities = append(entities, struct {
                        Name              string
                        Type              string
                        Operations        []string
                        AdditionalMethods []interface{}
                }{
                        Name:              schema.Name,
                        Type:              schema.Name,
                        Operations:        ops,
                        AdditionalMethods: additionalMethods,
                })</span>
        }

        <span class="cov0" title="0">return struct {
                Domain   string
                Package  string
                Entities []struct {
                        Name              string
                        Type              string
                        Operations        []string
                        AdditionalMethods []interface{}
                }
                Imports []string
        }{
                Domain:   domain,
                Package:  domain,
                Entities: entities,
                Imports:  []string{"github.com/google/uuid"},
        }</span>
}

func prepareCacheData(domain string, schemas []*ParsedSchema) interface{} <span class="cov0" title="0">{
        var entities []interface{}
        for _, schema := range schemas </span><span class="cov0" title="0">{
                ops := []string{}
                if schema.XCodegen.Cache.Enabled </span><span class="cov0" title="0">{
                        ops = append(ops, "get", "set", "delete")
                }</span>

                // Extract additional methods from x-codegen repository config
                <span class="cov0" title="0">var additionalMethods []interface{}
                if schema.XCodegen != nil &amp;&amp; schema.XCodegen.Repository.AdditionalMethods != nil </span><span class="cov0" title="0">{
                        for _, method := range schema.XCodegen.Repository.AdditionalMethods </span><span class="cov0" title="0">{
                                additionalMethods = append(additionalMethods, struct {
                                        Name    string
                                        Params  []string
                                        Returns string
                                }{
                                        Name:    method.Name,
                                        Params:  method.Params,
                                        Returns: string(method.Returns),
                                })
                        }</span>
                }

                <span class="cov0" title="0">entities = append(entities, struct {
                        Name              string
                        Type              string
                        Operations        []string
                        AdditionalMethods []interface{}
                        XCodegen          *XCodegen
                }{
                        Name:              schema.Name,
                        Type:              schema.Name, // Type is same as Name for cache
                        Operations:        ops,
                        AdditionalMethods: additionalMethods,
                        XCodegen:          schema.XCodegen,
                })</span>
        }

        <span class="cov0" title="0">return struct {
                Domain   string
                Package  string
                Entities []interface{}
                Imports  []string
        }{
                Domain:   domain,
                Package:  domain,
                Entities: entities,
                Imports:  []string{"github.com/google/uuid"},
        }</span>
}

func prepareEventsData(domain string, schemas []*ParsedSchema) interface{} <span class="cov0" title="0">{
        return struct {
                Domain   string
                Package  string
                Schemas  []*ParsedSchema
                Entities []*ParsedSchema // Alias for compatibility with templates
                Imports  []string
        }{
                Domain:   domain,
                Package:  domain,
                Schemas:  schemas,
                Entities: schemas, // Same data, different field name for template compatibility
                Imports:  []string{"github.com/google/uuid"},
        }
}</span>

func prepareAdaptersData(domain string, schemas []*ParsedSchema) interface{} <span class="cov0" title="0">{
        return struct {
                Domain  string
                Package string
                Schemas []*ParsedSchema
                Imports []string
        }{
                Domain:  domain,
                Package: domain,
                Schemas: schemas,
                Imports: []string{"github.com/google/uuid"},
        }
}</span>

func prepareHandlersData(domain string, schemas []*ParsedSchema) interface{} <span class="cov0" title="0">{
        return struct {
                Domain   string
                Package  string
                Entities []*ParsedSchema
                Imports  []string
        }{
                Domain:   domain,
                Package:  domain,
                Entities: schemas,
                Imports:  []string{"github.com/google/uuid", "github.com/labstack/echo/v4"},
        }
}</span>

// generateRepository generates repository interfaces and implementations.
func generateRepository(config *Config, schemas map[string]*ParsedSchema, templates map[string]*template.Template, fileWriter *FileWriter, log *slog.Logger) error <span class="cov0" title="0">{
        return runGeneratorWithPaths("repository", config, schemas, templates, fileWriter, NeedsRepository, log)
}</span>

// generateCache generates cache interfaces and implementations.
func generateCache(config *Config, schemas map[string]*ParsedSchema, templates map[string]*template.Template, fileWriter *FileWriter, log *slog.Logger) error <span class="cov0" title="0">{
        return runGeneratorWithPaths("cache", config, schemas, templates, fileWriter, NeedsCache, log)
}</span>

// generateEvents generates event interfaces and implementations.
func generateEvents(config *Config, schemas map[string]*ParsedSchema, templates map[string]*template.Template, fileWriter *FileWriter, log *slog.Logger) error <span class="cov0" title="0">{
        return runGeneratorWithPaths("events", config, schemas, templates, fileWriter, NeedsEvents, log)
}</span>

// generateHandlers generates HTTP handler stubs.
func generateHandlers(_ *Config, _ map[string]*ParsedSchema, _ map[string]*template.Template, _ *FileWriter, log *slog.Logger) error <span class="cov0" title="0">{
        // For now, return without generating since handlers are complex
        // and typically generated by oapi-codegen
        log.Debug("Running handlers generator")
        log.Debug("Handler generation delegated to oapi-codegen")
        return nil
}</span>

// generateAdapters generates type adapters/mappers.
func generateAdapters(config *Config, schemas map[string]*ParsedSchema, templates map[string]*template.Template, fileWriter *FileWriter, log *slog.Logger) error <span class="cov0" title="0">{
        // Check if there are any schemas that need adapters first
        hasAdapters := false
        for _, s := range schemas </span><span class="cov0" title="0">{
                if NeedsAdapter(s) </span><span class="cov0" title="0">{
                        hasAdapters = true
                        break</span>
                }
        }

        <span class="cov0" title="0">if !hasAdapters </span><span class="cov0" title="0">{
                log.Debug("Running adapters generator")
                log.Debug("No schemas configured for adapter generation")
                return nil
        }</span>

        <span class="cov0" title="0">return runGeneratorWithPaths("adapters", config, schemas, templates, fileWriter, NeedsAdapter, log)</span>
}

// generateDefaults generates configuration defaults.
func generateDefaults(config *Config, _ map[string]*ParsedSchema, _ map[string]*template.Template, fileWriter *FileWriter, log *slog.Logger) error <span class="cov0" title="0">{
        log.Debug("Running defaults generator")

        // Create parser
        parser := NewParser(filepath.Dir(config.OpenAPI))

        // Parse OpenAPI spec
        _, err := parser.ParseOpenAPISpec(config.OpenAPI)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to parse spec: %w", err)
        }</span>

        // Get complete defaults
        <span class="cov0" title="0">defaults, err := parser.GetCompleteConfigDefaults()
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to get defaults: %w", err)
        }</span>

        // Generate Go code
        <span class="cov0" title="0">code := GenerateDefaultsCode(defaults)

        // Write to file
        outputPath := "./internal/config/defaults.gen.go"
        if err := fileWriter.WriteFile(outputPath, []byte(code)); err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to write defaults file: %w", err)
        }</span>

        <span class="cov0" title="0">log.Debug("Generated defaults",
                slog.String("path", outputPath),
                slog.Int("count", len(parser.FlattenConfigDefaults(defaults))))

        return nil</span>
}

// generateTests generates test boilerplate for all domains
func generateTests(_ *Config, schemas map[string]*ParsedSchema, _ map[string]*template.Template, _ *FileWriter, log *slog.Logger) <span class="cov0" title="0">{
        log.Debug("Running test generator")

        // Group schemas by domain
        domainSchemas := make(map[string][]*ParsedSchema)
        for _, s := range schemas </span><span class="cov0" title="0">{
                domainSchemas[s.Domain] = append(domainSchemas[s.Domain], s)
        }</span>

        // Sort domains for consistent output
        <span class="cov0" title="0">domains := make([]string, 0, len(domainSchemas))
        for domain := range domainSchemas </span><span class="cov0" title="0">{
                domains = append(domains, domain)
        }</span>
        <span class="cov0" title="0">sort.Strings(domains)

        // Generate tests for each domain
        for _, domain := range domains </span><span class="cov0" title="0">{
                schemas := domainSchemas[domain]

                // Sort schemas by name for consistent output
                sort.Slice(schemas, func(i, j int) bool </span><span class="cov0" title="0">{
                        return schemas[i].Name &lt; schemas[j].Name
                }</span>)

                <span class="cov0" title="0">log.Debug("Generating tests for domain",
                        slog.String("domain", domain),
                        slog.Int("entities", len(schemas)))

                // TODO: Implement test generation with templates
                // For now, we'll skip the actual generation
                log.Debug("Test generation not yet implemented", slog.String("domain", domain))</span>
        }
}

// autoDetectDomains analyzes schemas and auto-detects domain configuration
func autoDetectDomains(schemas map[string]*ParsedSchema) map[string]DomainConfig <span class="cov0" title="0">{
        domains := make(map[string]DomainConfig)

        // Collect unique domains from schemas
        domainSchemas := make(map[string][]string)
        for name, schema := range schemas </span><span class="cov0" title="0">{
                if schema.Domain == "" </span><span class="cov0" title="0">{
                        continue</span>
                }

                <span class="cov0" title="0">domainSchemas[schema.Domain] = append(domainSchemas[schema.Domain], name)</span>
        }

        // Convert to DomainConfig
        <span class="cov0" title="0">for domain, schemaNames := range domainSchemas </span><span class="cov0" title="0">{
                // For now, we don't have tags in ParsedSchema, so we'll use domain names
                // In the future, this could be enhanced to extract tags from the OpenAPI spec
                domains[domain] = DomainConfig{
                        Schemas: schemaNames,
                }
        }</span>

        <span class="cov0" title="0">return domains</span>
}
</pre>
		
		<pre class="file" id="file47" style="display: none">package codegen

import (
        "bytes"
        "fmt"
        "go/format"
        "sort"
        "strings"
)

const developmentKey = "development"

// GenerateDefaultsCode generates Go code for configuration defaults.
func GenerateDefaultsCode(defaults map[string]interface{}) string <span class="cov0" title="0">{
        var buf bytes.Buffer

        // Header
        buf.WriteString(`// Code generated by codegen; DO NOT EDIT.
// This file contains default configuration values extracted from OpenAPI schemas.

package config

// GetDefaultConfig returns a complete default configuration with all values from OpenAPI schemas.
func GetDefaultConfig() *ArchesConfig {
        return &amp;ArchesConfig{
`)

        // Generate each top-level config
        generateStruct(&amp;buf, defaults, 2)

        buf.WriteString("\t}\n}\n")

        // Format the code
        code := buf.String()
        formatted, err := format.Source([]byte(code))
        if err != nil </span><span class="cov0" title="0">{
                // Return unformatted code if formatting fails
                return code
        }</span>
        <span class="cov0" title="0">return string(formatted)</span>
}

func generateStruct(buf *bytes.Buffer, data map[string]interface{}, indent int) <span class="cov0" title="0">{
        // Sort keys for consistent output
        keys := make([]string, 0, len(data))
        for k := range data </span><span class="cov0" title="0">{
                keys = append(keys, k)
        }</span>
        <span class="cov0" title="0">sort.Strings(keys)

        for _, key := range keys </span><span class="cov0" title="0">{
                value := data[key]

                // Skip fields that don't exist in generated types
                if key == "oauth" </span><span class="cov0" title="0">{
                        continue</span>
                }

                // Skip development if it only has enabled field (incorrect parsing)
                <span class="cov0" title="0">if key == developmentKey </span><span class="cov0" title="0">{
                        if m, ok := value.(map[string]interface{}); ok </span><span class="cov0" title="0">{
                                if len(m) == 1 </span><span class="cov0" title="0">{
                                        if _, hasEnabled := m["enabled"]; hasEnabled </span><span class="cov0" title="0">{
                                                continue</span> // Skip incorrect development config
                                        }
                                }
                        }
                }

                <span class="cov0" title="0">fieldName := toPascalCase(key)
                tabs := strings.Repeat("\t", indent)

                switch v := value.(type) </span>{
                case map[string]interface{}:<span class="cov0" title="0">
                        // Get the correct type name for the nested config
                        typeName := getConfigTypeName(key)
                        if len(v) == 0 </span><span class="cov0" title="0">{
                                // Empty struct, skip or use empty initializer
                                fmt.Fprintf(buf, "%s%s: %s{},\n", tabs, fieldName, typeName)
                        }</span> else<span class="cov0" title="0"> {
                                // Nested struct
                                fmt.Fprintf(buf, "%s%s: %s{\n", tabs, fieldName, typeName)
                                generateStruct(buf, v, indent+1)
                                fmt.Fprintf(buf, "%s},\n", tabs)
                        }</span>
                case string:<span class="cov0" title="0">
                        // Check if it's an enum value that needs a constant
                        constValue := getEnumConstant(key, v)
                        if constValue != "" </span><span class="cov0" title="0">{
                                fmt.Fprintf(buf, "%s%s: %s,\n", tabs, fieldName, constValue)
                        }</span> else<span class="cov0" title="0"> {
                                fmt.Fprintf(buf, "%s%s: %q,\n", tabs, fieldName, v)
                        }</span>
                case bool:<span class="cov0" title="0">
                        fmt.Fprintf(buf, "%s%s: %t,\n", tabs, fieldName, v)</span>
                case float64:<span class="cov0" title="0">
                        if v == float64(int(v)) </span><span class="cov0" title="0">{
                                fmt.Fprintf(buf, "%s%s: %d,\n", tabs, fieldName, int(v))
                        }</span> else<span class="cov0" title="0"> {
                                fmt.Fprintf(buf, "%s%s: %f,\n", tabs, fieldName, v)
                        }</span>
                default:<span class="cov0" title="0">
                        fmt.Fprintf(buf, "%s%s: %v,\n", tabs, fieldName, v)</span>
                }
        }
}

func getConfigTypeName(key string) string <span class="cov0" title="0">{
        // Map field names to their config type names
        switch key </span>{
        case "api":<span class="cov0" title="0">
                return "APIConfig"</span>
        case "cors":<span class="cov0" title="0">
                return "CORSConfig"</span>
        case "email":<span class="cov0" title="0">
                return "EmailConfig"</span>
        case "image":<span class="cov0" title="0">
                return "ImageConfig"</span>
        case "resources":<span class="cov0" title="0">
                return "ResourceConfig"</span>
        case "auth":<span class="cov0" title="0">
                return "AuthConfig"</span>
        case "local":<span class="cov0" title="0">
                return "LocalAuth"</span>
        case "twitter":<span class="cov0" title="0">
                return "TwitterAuth"</span>
        case "firebase":<span class="cov0" title="0">
                return "FirebaseAuth"</span>
        case "database":<span class="cov0" title="0">
                return "DatabaseConfig"</span>
        case "logging":<span class="cov0" title="0">
                return "LoggingConfig"</span>
        case "redis":<span class="cov0" title="0">
                return "RedisConfig"</span>
        case "storage":<span class="cov0" title="0">
                return "StorageConfig"</span>
        case "infrastructure":<span class="cov0" title="0">
                return "InfrastructureConfig"</span>
        case developmentKey:<span class="cov0" title="0">
                return "DevelopmentConfig"</span>
        case "platform":<span class="cov0" title="0">
                return "PlatformConfig"</span>
        case "ingress":<span class="cov0" title="0">
                return "IngressConfig"</span>
        case "intelligence":<span class="cov0" title="0">
                return "IntelligenceConfig"</span>
        case "llm":<span class="cov0" title="0">
                return "LLMConfig"</span>
        case "embedding":<span class="cov0" title="0">
                return "EmbeddingConfig"</span>
        case "monitoring":<span class="cov0" title="0">
                return "MonitoringConfig"</span>
        case "grafana":<span class="cov0" title="0">
                return "GrafanaConfig"</span>
        case "loki":<span class="cov0" title="0">
                return "LokiConfig"</span>
        case "billing":<span class="cov0" title="0">
                return "BillingConfig"</span>
        case "stripe":<span class="cov0" title="0">
                return "StripeConfig"</span>
        default:<span class="cov0" title="0">
                // Fallback to PascalCase + Config
                return toPascalCase(key) + "Config"</span>
        }
}

var pascalCaseMap = map[string]string{
        "api":            "Api",
        "cors":           "Cors",
        "auth":           "Auth",
        "database":       "Database",
        "infrastructure": "Infrastructure",
        "ingress":        "Ingress",
        "intelligence":   "Intelligence",
        "logging":        "Logging",
        "monitoring":     "Monitoring",
        "platform":       "Platform",
        "redis":          "Redis",
        "storage":        "Storage",
        "billing":        "Billing",
        "llm":            "Llm",
        "embedding":      "Embedding",
        "grafana":        "Grafana",
        "loki":           "Loki",
        "stripe":         "Stripe",
        "oauth":          "Oauth",
        "local":          "Local",
        "twitter":        "Twitter",
        "firebase":       "Firebase",
        developmentKey:   "Development",
        "url":            "Url",
        "maxConns":       "MaxConns",
        "minConns":       "MinConns",
        "runMigrations":  "RunMigrations",
        "pullPolicy":     "PullPolicy",
        "accesskey":      "Accesskey",
        "secretkey":      "Secretkey",
        "email":          "Email",
        "image":          "Image",
        "resources":      "Resources",
}

func toPascalCase(s string) string <span class="cov0" title="0">{
        // Handle special cases for field names
        if pascal, ok := pascalCaseMap[s]; ok </span><span class="cov0" title="0">{
                return pascal
        }</span>

        // General case: capitalize first letter
        <span class="cov0" title="0">if len(s) == 0 </span><span class="cov0" title="0">{
                return s
        }</span>
        <span class="cov0" title="0">return strings.ToUpper(s[:1]) + s[1:]</span>
}

func getEnumConstant(key, value string) string <span class="cov0" title="0">{
        // Map known enum values to their Go constants
        switch key </span>{
        case "environment":<span class="cov0" title="0">
                switch value </span>{
                case developmentKey:<span class="cov0" title="0">
                        return "Development"</span>
                case "staging":<span class="cov0" title="0">
                        return "Staging"</span>
                case "production":<span class="cov0" title="0">
                        return "Production"</span>
                }
        case "type":<span class="cov0" title="0">
                switch value </span>{
                case "postgresql":<span class="cov0" title="0">
                        return "Postgresql"</span>
                case "sqlite":<span class="cov0" title="0">
                        return "Sqlite"</span>
                case "ollama":<span class="cov0" title="0">
                        // Return empty to use the quoted string
                        return ""</span>
                }
        case "level":<span class="cov0" title="0">
                switch value </span>{
                case "debug":<span class="cov0" title="0">
                        return "Debug"</span>
                case "info":<span class="cov0" title="0">
                        return "Info"</span>
                case "warn":<span class="cov0" title="0">
                        return "Warn"</span>
                case "error":<span class="cov0" title="0">
                        return "Error"</span>
                }
        case "pullPolicy":<span class="cov0" title="0">
                switch value </span>{
                case "Always":<span class="cov0" title="0">
                        return "Always"</span>
                case "IfNotPresent":<span class="cov0" title="0">
                        return "IfNotPresent"</span>
                case "Never":<span class="cov0" title="0">
                        return "Never"</span>
                }
        }
        <span class="cov0" title="0">return ""</span>
}

// GetCompleteConfigDefaults safely extracts ALL configuration defaults from the ArchesConfig structure.
// This includes all nested config schemas (APIConfig, DatabaseConfig, etc.) and their sub-configs.
// Returns a complete hierarchical map of all defaults that can be used for code generation.
func (p *Parser) GetCompleteConfigDefaults() (map[string]interface{}, error) <span class="cov0" title="0">{
        if p.doc == nil || p.doc.Components == nil || p.doc.Components.Schemas == nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("no OpenAPI document loaded - call ParseOpenAPISpec first")
        }</span>

        // Build complete config structure matching ArchesConfig
        // Each top-level key corresponds to a field in ArchesConfig
        <span class="cov0" title="0">completeDefaults := make(map[string]interface{})

        // Helper function to safely get defaults for a schema
        safeGetDefaults := func(schemaName string) map[string]interface{} </span><span class="cov0" title="0">{
                defaults, err := p.GetDefaultValues(schemaName)
                if err != nil </span><span class="cov0" title="0">{
                        // Schema might not exist or have no defaults
                        return make(map[string]interface{})
                }</span>
                <span class="cov0" title="0">return defaults</span>
        }

        // Top-level configs in ArchesConfig
        <span class="cov0" title="0">configs := map[string]string{
                "api":            "APIConfig",
                "auth":           "AuthConfig",
                "billing":        "BillingConfig",
                "database":       "DatabaseConfig",
                "infrastructure": "InfrastructureConfig",
                "ingress":        "IngressConfig",
                "intelligence":   "IntelligenceConfig",
                "logging":        "LoggingConfig",
                "monitoring":     "MonitoringConfig",
                "platform":       "PlatformConfig",
                "redis":          "RedisConfig",
                "storage":        "StorageConfig",
        }

        // Get defaults for each top-level config
        for key, schemaName := range configs </span><span class="cov0" title="0">{
                completeDefaults[key] = safeGetDefaults(schemaName)
        }</span>

        // Handle nested configs within each top-level config
        // APIConfig has nested: cors, email, image, resources
        <span class="cov0" title="0">if apiDefaults, ok := completeDefaults["api"].(map[string]interface{}); ok </span><span class="cov0" title="0">{
                apiDefaults["cors"] = safeGetDefaults("CORSConfig")
                apiDefaults["email"] = safeGetDefaults("EmailConfig")
                apiDefaults["image"] = safeGetDefaults("ImageConfig")
                apiDefaults["resources"] = safeGetDefaults("ResourceConfig")
        }</span>

        // AuthConfig has nested: local, oauth
        <span class="cov0" title="0">if authDefaults, ok := completeDefaults["auth"].(map[string]interface{}); ok </span><span class="cov0" title="0">{
                authDefaults["local"] = safeGetDefaults("LocalAuthConfig")
                authDefaults["oauth"] = safeGetDefaults("OAuthConfig")
        }</span>

        // IntelligenceConfig has nested: llm, embedding
        <span class="cov0" title="0">if intellDefaults, ok := completeDefaults["intelligence"].(map[string]interface{}); ok </span><span class="cov0" title="0">{
                intellDefaults["llm"] = safeGetDefaults("LLMConfig")
                intellDefaults["embedding"] = safeGetDefaults("EmbeddingConfig")
        }</span>

        // MonitoringConfig has nested: grafana, loki
        <span class="cov0" title="0">if monDefaults, ok := completeDefaults["monitoring"].(map[string]interface{}); ok </span><span class="cov0" title="0">{
                monDefaults["grafana"] = safeGetDefaults("GrafanaConfig")
                monDefaults["loki"] = safeGetDefaults("LokiConfig")
        }</span>

        // BillingConfig has nested: stripe
        <span class="cov0" title="0">if billDefaults, ok := completeDefaults["billing"].(map[string]interface{}); ok </span><span class="cov0" title="0">{
                billDefaults["stripe"] = safeGetDefaults("StripeConfig")
        }</span>

        // InfrastructureConfig has nested: development
        <span class="cov0" title="0">if infraDefaults, ok := completeDefaults["infrastructure"].(map[string]interface{}); ok </span><span class="cov0" title="0">{
                infraDefaults["development"] = safeGetDefaults("DevServiceConfig")
        }</span>

        <span class="cov0" title="0">return completeDefaults, nil</span>
}

// FlattenConfigDefaults converts nested config defaults to a flat map with dot notation keys.
// For example: {"api": {"host": "0.0.0.0"}} becomes {"api.host": "0.0.0.0"}
// This is useful for environment variable generation or flat config files.
func (p *Parser) FlattenConfigDefaults(defaults map[string]interface{}) map[string]interface{} <span class="cov0" title="0">{
        result := make(map[string]interface{})
        p.flattenRecursive("", defaults, result)
        return result
}</span>

// flattenRecursive is a helper to recursively flatten nested maps
func (p *Parser) flattenRecursive(prefix string, nested map[string]interface{}, result map[string]interface{}) <span class="cov0" title="0">{
        for key, value := range nested </span><span class="cov0" title="0">{
                fullKey := key
                if prefix != "" </span><span class="cov0" title="0">{
                        fullKey = prefix + "." + key
                }</span>

                <span class="cov0" title="0">switch v := value.(type) </span>{
                case map[string]interface{}:<span class="cov0" title="0">
                        // Recursively flatten nested maps
                        p.flattenRecursive(fullKey, v, result)</span>
                default:<span class="cov0" title="0">
                        // Store the value with its full path
                        result[fullKey] = value</span>
                }
        }
}

// CountConfigDefaults counts the total number of default values in a nested config map.
// This includes all nested defaults at any depth.
func (p *Parser) CountConfigDefaults(defaults map[string]interface{}) int <span class="cov0" title="0">{
        count := 0
        for _, value := range defaults </span><span class="cov0" title="0">{
                switch v := value.(type) </span>{
                case map[string]interface{}:<span class="cov0" title="0">
                        // Recursively count nested defaults
                        count += p.CountConfigDefaults(v)</span>
                default:<span class="cov0" title="0">
                        // This is a leaf value (actual default)
                        count++</span>
                }
        }
        <span class="cov0" title="0">return count</span>
}
</pre>
		
		<pre class="file" id="file48" style="display: none">// Package codegen provides file writing utilities for code generation.
package codegen

import (
        "bytes"
        "fmt"
        "go/format"
        "os"
        "path/filepath"
        "strings"
        "text/template"
)

// FileWriter handles writing generated files with proper formatting and headers.
type FileWriter struct {
        // Header to prepend to all generated files
        header string

        // Whether to overwrite existing files
        overwrite bool

        // Whether to format Go code
        formatCode bool
}

// NewFileWriter creates a new file writer with default settings.
func NewFileWriter() *FileWriter <span class="cov0" title="0">{
        return &amp;FileWriter{
                header:     DefaultHeader(),
                overwrite:  true,
                formatCode: true,
        }
}</span>

// WithHeader sets a custom header for generated files.
func (fw *FileWriter) WithHeader(header string) *FileWriter <span class="cov0" title="0">{
        fw.header = header
        return fw
}</span>

// WithOverwrite sets whether to overwrite existing files.
func (fw *FileWriter) WithOverwrite(overwrite bool) *FileWriter <span class="cov0" title="0">{
        fw.overwrite = overwrite
        return fw
}</span>

// WithFormatting sets whether to format Go code.
func (fw *FileWriter) WithFormatting(format bool) *FileWriter <span class="cov0" title="0">{
        fw.formatCode = format
        return fw
}</span>

// WriteFile writes content to a file with proper headers and formatting.
func (fw *FileWriter) WriteFile(path string, content []byte) error <span class="cov0" title="0">{
        // Check if file exists and overwrite is disabled
        if !fw.overwrite </span><span class="cov0" title="0">{
                if _, err := os.Stat(path); err == nil </span><span class="cov0" title="0">{
                        return fmt.Errorf("file already exists and overwrite is disabled: %s", path)
                }</span>
        }

        // Ensure the file has .gen.go suffix if it's a Go file
        <span class="cov0" title="0">if strings.HasSuffix(path, ".go") &amp;&amp; !strings.HasSuffix(path, ".gen.go") </span><span class="cov0" title="0">{
                // Only enforce for generated files in internal/
                if strings.Contains(path, "internal/") &amp;&amp; !strings.Contains(path, "_manual.go") </span><span class="cov0" title="0">{
                        base := strings.TrimSuffix(path, ".go")
                        path = base + ".gen.go"
                }</span>
        }

        // Add header if it's a Go file
        <span class="cov0" title="0">if strings.HasSuffix(path, ".go") &amp;&amp; fw.header != "" </span><span class="cov0" title="0">{
                content = fw.addHeader(content)
        }</span>

        // Format Go code if enabled
        <span class="cov0" title="0">if fw.formatCode &amp;&amp; strings.HasSuffix(path, ".go") </span><span class="cov0" title="0">{
                formatted, err := format.Source(content)
                if err != nil </span><span class="cov0" title="0">{
                        // If formatting fails, write unformatted with a warning comment
                        warning := []byte("// WARNING: This file could not be formatted automatically\n")
                        content = append(warning, content...)
                }</span> else<span class="cov0" title="0"> {
                        content = formatted
                }</span>
        }

        // Ensure directory exists
        <span class="cov0" title="0">dir := filepath.Dir(path)
        if err := os.MkdirAll(dir, 0755); err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to create directory %s: %w", dir, err)
        }</span>

        // Write the file
        <span class="cov0" title="0">if err := os.WriteFile(path, content, 0644); err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to write file %s: %w", path, err)
        }</span>

        <span class="cov0" title="0">return nil</span>
}

// WriteTemplate executes a template and writes the result to a file.
func (fw *FileWriter) WriteTemplate(path string, tmpl *template.Template, data interface{}) error <span class="cov0" title="0">{
        var buf bytes.Buffer
        if err := tmpl.Execute(&amp;buf, data); err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to execute template: %w", err)
        }</span>

        <span class="cov0" title="0">return fw.WriteFile(path, buf.Bytes())</span>
}

// WriteTemplateString parses a template string and writes the result to a file.
func (fw *FileWriter) WriteTemplateString(path, tmplStr string, data interface{}) error <span class="cov0" title="0">{
        tmpl, err := template.New(filepath.Base(path)).Funcs(TemplateFuncs()).Parse(tmplStr)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to parse template: %w", err)
        }</span>

        <span class="cov0" title="0">return fw.WriteTemplate(path, tmpl, data)</span>
}

// addHeader prepends the header to content.
func (fw *FileWriter) addHeader(content []byte) []byte <span class="cov0" title="0">{
        // Skip if content already has a header
        contentStr := string(content)
        if strings.HasPrefix(contentStr, "// Code generated") ||
                strings.HasPrefix(contentStr, "// Package") </span><span class="cov0" title="0">{
                // Check if it already has our header
                if strings.Contains(contentStr, "DO NOT EDIT") </span><span class="cov0" title="0">{
                        return content
                }</span>
        }

        // Find the package declaration
        <span class="cov0" title="0">lines := strings.Split(contentStr, "\n")
        var headerLines []string
        packageIndex := -1

        for i, line := range lines </span><span class="cov0" title="0">{
                if strings.HasPrefix(strings.TrimSpace(line), "package ") </span><span class="cov0" title="0">{
                        packageIndex = i
                        break</span>
                }
        }

        // Add header before package declaration
        <span class="cov0" title="0">if packageIndex &gt;= 0 </span><span class="cov0" title="0">{
                headerLines = append(headerLines, fw.header)
                if !strings.HasSuffix(fw.header, "\n") </span><span class="cov0" title="0">{
                        headerLines = append(headerLines, "")
                }</span>
                <span class="cov0" title="0">headerLines = append(headerLines, lines[packageIndex:]...)
                return []byte(strings.Join(headerLines, "\n"))</span>
        }

        // No package declaration found, prepend header
        <span class="cov0" title="0">return []byte(fw.header + "\n" + contentStr)</span>
}

// DefaultHeader returns the default header for generated files.
func DefaultHeader() string <span class="cov0" title="0">{
        return `// Code generated by archesai-codegen. DO NOT EDIT.`
}</span>

// HeaderWithSource returns a header that includes the source file.
func HeaderWithSource(source string) string <span class="cov0" title="0">{
        return fmt.Sprintf(`// Code generated by archesai-codegen. DO NOT EDIT.
// Source: %s`, source)
}</span>

// HeaderWithDetails returns a detailed header for generated files.
func HeaderWithDetails(generator, source string) string <span class="cov0" title="0">{
        return fmt.Sprintf(`// Code generated by archesai-codegen. DO NOT EDIT.
// Generator: %s
// Source: %s`, generator, source)
}</span>

// EnsureGenSuffix ensures a file path has the .gen.go suffix.
func EnsureGenSuffix(path string) string <span class="cov0" title="0">{
        if !strings.HasSuffix(path, ".go") </span><span class="cov0" title="0">{
                return path
        }</span>

        <span class="cov0" title="0">if strings.HasSuffix(path, ".gen.go") </span><span class="cov0" title="0">{
                return path
        }</span>

        // Don't change manual files
        <span class="cov0" title="0">if strings.Contains(path, "_manual") || strings.Contains(path, "manual_") </span><span class="cov0" title="0">{
                return path
        }</span>

        <span class="cov0" title="0">base := strings.TrimSuffix(path, ".go")
        return base + ".gen.go"</span>
}

// IsGeneratedFile checks if a file is a generated file.
func IsGeneratedFile(path string) bool <span class="cov0" title="0">{
        // Check by suffix
        if strings.HasSuffix(path, ".gen.go") </span><span class="cov0" title="0">{
                return true
        }</span>

        // Check by reading the file header
        <span class="cov0" title="0">content, err := os.ReadFile(path)
        if err != nil </span><span class="cov0" title="0">{
                return false
        }</span>

        <span class="cov0" title="0">contentStr := string(content)
        return strings.Contains(contentStr, "Code generated") &amp;&amp;
                strings.Contains(contentStr, "DO NOT EDIT")</span>
}

// BackupFile creates a backup of an existing file before overwriting.
func BackupFile(path string) error <span class="cov0" title="0">{
        // Check if file exists
        if _, err := os.Stat(path); os.IsNotExist(err) </span><span class="cov0" title="0">{
                return nil // No file to backup
        }</span>

        // Create backup path
        <span class="cov0" title="0">backupPath := path + ".backup"

        // Read original file
        content, err := os.ReadFile(path)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to read original file: %w", err)
        }</span>

        // Write backup
        <span class="cov0" title="0">if err := os.WriteFile(backupPath, content, 0644); err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to write backup: %w", err)
        }</span>

        <span class="cov0" title="0">return nil</span>
}

// CleanGeneratedFiles removes all generated files in a directory.
func CleanGeneratedFiles(dir string) error <span class="cov0" title="0">{
        return filepath.Walk(dir, func(path string, info os.FileInfo, err error) error </span><span class="cov0" title="0">{
                if err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>

                // Skip directories
                <span class="cov0" title="0">if info.IsDir() </span><span class="cov0" title="0">{
                        return nil
                }</span>

                // Remove generated files
                <span class="cov0" title="0">if IsGeneratedFile(path) </span><span class="cov0" title="0">{
                        if err := os.Remove(path); err != nil </span><span class="cov0" title="0">{
                                return fmt.Errorf("failed to remove %s: %w", path, err)
                        }</span>
                }

                <span class="cov0" title="0">return nil</span>
        })
}

// OutputPath generates the output path for a generated file.
func OutputPath(baseDir, domain, fileName string) string <span class="cov0" title="0">{
        return filepath.Join(baseDir, domain, EnsureGenSuffix(fileName))
}</span>

// DomainPath generates the base path for a domain.
func DomainPath(baseDir, domain string) string <span class="cov0" title="0">{
        return filepath.Join(baseDir, domain)
}</span>

// AdapterPath generates the path for adapter implementations.
func AdapterPath(baseDir, domain, adapter, fileName string) string <span class="cov0" title="0">{
        return filepath.Join(baseDir, domain, "adapters", adapter, EnsureGenSuffix(fileName))
}</span>
</pre>
		
		<pre class="file" id="file49" style="display: none">// Package codegen provides shared utilities for all code generators.
package codegen

import (
        "bytes"
        "embed"
        "fmt"
        "go/ast"
        "go/format"
        "go/parser"
        "go/token"
        "os"
        "reflect"
        "sort"
        "strings"
        "text/template"
)

//go:embed templates/*.tmpl
var templatesFS embed.FS

// GetTemplate loads a template by name from the central templates directory.
func GetTemplate(name string) (string, error) <span class="cov0" title="0">{
        content, err := templatesFS.ReadFile("templates/" + name)
        if err != nil </span><span class="cov0" title="0">{
                return "", fmt.Errorf("failed to read template %s: %w", name, err)
        }</span>
        <span class="cov0" title="0">return string(content), nil</span>
}

// GetTemplateFS returns the embedded template filesystem for direct access.
func GetTemplateFS() embed.FS <span class="cov0" title="0">{
        return templatesFS
}</span>

// ParseTemplate loads and parses a template with common functions.
func ParseTemplate(name string) (*template.Template, error) <span class="cov0" title="0">{
        content, err := GetTemplate(name)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov0" title="0">tmpl, err := template.New(name).Funcs(TemplateFuncs()).Parse(content)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to parse template %s: %w", name, err)
        }</span>

        <span class="cov0" title="0">return tmpl, nil</span>
}

// GetSortedPropertyKeys returns sorted property names from a map of properties.
// This ensures consistent ordering when iterating over schema properties.
func GetSortedPropertyKeys(properties map[string]Property) []string <span class="cov0" title="0">{
        keys := make([]string, 0, len(properties))
        for k := range properties </span><span class="cov0" title="0">{
                keys = append(keys, k)
        }</span>
        <span class="cov0" title="0">sort.Strings(keys)
        return keys</span>
}

// AddYamlTags adds YAML tags to Go struct fields that have JSON tags but no YAML tags.
// This functionality was moved from tools/codegen/add_yaml_tags.go to consolidate codegen utilities.
func AddYamlTags(filename string) error <span class="cov0" title="0">{
        fset := token.NewFileSet()
        node, err := parser.ParseFile(fset, filename, nil, parser.ParseComments)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("error parsing file: %w", err)
        }</span>

        // Walk through all struct fields and add yaml tags
        <span class="cov0" title="0">ast.Inspect(node, func(n ast.Node) bool </span><span class="cov0" title="0">{
                switch x := n.(type) </span>{
                case *ast.Field:<span class="cov0" title="0">
                        if x.Tag != nil </span><span class="cov0" title="0">{
                                // Parse existing tag
                                tag := reflect.StructTag(strings.Trim(x.Tag.Value, "`"))
                                jsonTag := tag.Get("json")

                                if jsonTag != "" &amp;&amp; tag.Get("yaml") == "" </span><span class="cov0" title="0">{
                                        // Add yaml tag with same value as json tag
                                        newTag := fmt.Sprintf("`json:\"%s\" yaml:\"%s\"`", jsonTag, jsonTag)
                                        x.Tag.Value = newTag
                                }</span>
                        }
                }
                <span class="cov0" title="0">return true</span>
        })

        // Format and write the modified file
        <span class="cov0" title="0">var buf bytes.Buffer
        if err := format.Node(&amp;buf, fset, node); err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("error formatting code: %w", err)
        }</span>

        <span class="cov0" title="0">if err := os.WriteFile(filename, buf.Bytes(), 0644); err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("error writing file: %w", err)
        }</span>

        <span class="cov0" title="0">return nil</span>
}
</pre>
		
		<pre class="file" id="file50" style="display: none">// Package codegen provides schema parsing using the Speakeasy OpenAPI library.
// This parser offers better OpenAPI 3.1.1 support and improved x-codegen extraction.
package codegen

import (
        "context"
        "encoding/json"
        "fmt"
        "os"
        "strings"
        "time"

        "github.com/speakeasy-api/openapi/extensions"
        "github.com/speakeasy-api/openapi/jsonschema/oas3"
        "github.com/speakeasy-api/openapi/openapi"
)

// ParsedSchema represents a fully parsed and analyzed schema with x-codegen metadata.
type ParsedSchema struct {
        Schema

        // Domain this schema belongs to (e.g., "auth", "organizations")
        Domain string

        // File path where schema was defined
        SourceFile string

        // Timestamp when parsed
        ParsedAt time.Time

        // Any parsing warnings
        Warnings []string

        // Primary key field name (typically "ID" or "Id")
        PrimaryKey string

        // Type is the entity type name (same as Name, for template compatibility)
        Type string

        // Events extracted and formatted from XCodegen.Events
        Events []Event
}

// Event represents a domain event for code generation.
type Event struct {
        Type        string // e.g., "UserCreated"
        Description string // e.g., "User created event"
}

// Schema represents a parsed OpenAPI schema with x-codegen extensions.
type Schema struct {
        // Schema name (e.g., "User", "Organization")
        Name string

        // OpenAPI schema type
        Type string `yaml:"type" json:"type"`

        // Schema description
        Description string `yaml:"description,omitempty" json:"description,omitempty"`

        // Required fields
        Required []string `yaml:"required,omitempty" json:"required,omitempty"`

        // Schema properties
        Properties map[string]Property `yaml:"properties,omitempty" json:"properties,omitempty"`

        // x-codegen extension at schema level
        XCodegen *XCodegen `yaml:"x-codegen,omitempty" json:"x-codegen,omitempty"`

        // AllOf references (for composition) - using interface{} to handle both refs and inline schemas
        AllOf []interface{} `yaml:"allOf,omitempty" json:"allOf,omitempty"`

        // Default value for the entire object
        Default interface{} `yaml:"default,omitempty" json:"default,omitempty"`

        // Enum values if applicable
        Enum []interface{} `yaml:"enum,omitempty" json:"enum,omitempty"`
}

// Property represents a schema property with potential x-codegen extensions.
type Property struct {
        // Property type
        Type string `yaml:"type" json:"type"`

        // Format hint (e.g., "uuid", "email", "date-time")
        Format string `yaml:"format,omitempty" json:"format,omitempty"`

        // Property description
        Description string `yaml:"description,omitempty" json:"description,omitempty"`

        // Default value
        Default interface{} `yaml:"default,omitempty" json:"default,omitempty"`

        // Enum values
        Enum []interface{} `yaml:"enum,omitempty" json:"enum,omitempty"`

        // Reference to another schema
        Ref string `yaml:"$ref,omitempty" json:"$ref,omitempty"`

        // Array items type
        Items *Property `yaml:"items,omitempty" json:"items,omitempty"`

        // Nested object properties
        Properties map[string]Property `yaml:"properties,omitempty" json:"properties,omitempty"`

        // x-codegen extension at property level
        XCodegen *PropertyXCodegen `yaml:"x-codegen,omitempty" json:"x-codegen,omitempty"`

        // Required fields for object types
        Required []string `yaml:"required,omitempty" json:"required,omitempty"`
}

// PropertyXCodegen represents x-codegen at the property level.
type PropertyXCodegen struct {
        // Create unique constraint
        Unique *bool `yaml:"unique,omitempty" json:"unique,omitempty"`

        // Create database index
        Index *bool `yaml:"index,omitempty" json:"index,omitempty"`

        // Field is searchable (full-text search)
        Searchable *bool `yaml:"searchable,omitempty" json:"searchable,omitempty"`

        // Custom validation rule
        Validation *XCodegenValidation `yaml:"validation,omitempty" json:"validation,omitempty"`

        // Mark as primary key (legacy field)
        PrimaryKey bool `yaml:"primary-key,omitempty" json:"primary-key,omitempty"`

        // Field is immutable after creation
        Immutable bool `yaml:"immutable,omitempty" json:"immutable,omitempty"`

        // Database column name (if different from property name)
        ColumnName string `yaml:"column-name,omitempty" json:"column-name,omitempty"`

        // Default value expression
        DefaultValue string `yaml:"default-value,omitempty" json:"default-value,omitempty"`

        // Auto-generate value (e.g., "uuid", "timestamp")
        AutoGenerate string `yaml:"auto-generate,omitempty" json:"auto-generate,omitempty"`
}

// Parser handles parsing of OpenAPI schemas with x-codegen extensions.
// This implementation uses the Speakeasy OpenAPI library for better OpenAPI 3.1.1 support.
type Parser struct {
        // Parsed schemas cache
        schemas map[string]*ParsedSchema

        // Base directory for relative paths
        baseDir string

        // Warnings accumulated during parsing
        warnings []string

        // OpenAPI document
        doc *openapi.OpenAPI
}

// NewParser creates a new schema parser using the Speakeasy OpenAPI library.
func NewParser(baseDir string) *Parser <span class="cov0" title="0">{
        return &amp;Parser{
                schemas:  make(map[string]*ParsedSchema),
                baseDir:  baseDir,
                warnings: []string{},
        }
}</span>

// ParseOpenAPISpec parses a complete OpenAPI specification file using Speakeasy.
func (p *Parser) ParseOpenAPISpec(specPath string) (map[string]*ParsedSchema, error) <span class="cov0" title="0">{
        ctx := context.Background()

        // Open the spec file
        f, err := os.Open(specPath)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to open spec file: %w", err)
        }</span>
        <span class="cov0" title="0">defer func() </span><span class="cov0" title="0">{ _ = f.Close() }</span>()

        // Parse and validate the OpenAPI document
        <span class="cov0" title="0">doc, validationErrs, err := openapi.Unmarshal(ctx, f)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to unmarshal OpenAPI spec: %w", err)
        }</span>

        // Store document for reference
        <span class="cov0" title="0">p.doc = doc

        // Collect validation warnings
        for _, validErr := range validationErrs </span><span class="cov0" title="0">{
                p.warnings = append(p.warnings, validErr.Error())
        }</span>

        // Check if we have components and schemas
        <span class="cov0" title="0">if doc.Components == nil || doc.Components.Schemas == nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("no components.schemas found in spec")
        }</span>

        // Parse all schemas in components
        <span class="cov0" title="0">schemas := make(map[string]*ParsedSchema)
        for schemaName := range doc.Components.Schemas.Keys() </span><span class="cov0" title="0">{
                schemaRef := doc.Components.Schemas.GetOrZero(schemaName)
                if schemaRef != nil &amp;&amp; schemaRef.IsLeft() </span><span class="cov0" title="0">{
                        schema := schemaRef.GetLeft()
                        parsed := p.parseSchema(schemaName, schema)
                        if parsed != nil </span><span class="cov0" title="0">{
                                schemas[schemaName] = parsed
                        }</span>
                }
        }

        // Cache the parsed schemas
        <span class="cov0" title="0">p.schemas = schemas

        return schemas, nil</span>
}

// parseSchema converts a Speakeasy schema to our ParsedSchema format.
func (p *Parser) parseSchema(name string, schema *oas3.Schema) *ParsedSchema <span class="cov0" title="0">{
        // Create base parsed schema
        parsed := &amp;ParsedSchema{
                Schema: Schema{
                        Name: name,
                },
                Domain:     p.inferDomain("", name),
                SourceFile: "openapi.yaml", // Since it's from the bundled spec
                ParsedAt:   time.Now(),
                Warnings:   []string{},
                PrimaryKey: "Id", // Default primary key field
                Type:       name, // For template compatibility
        }

        // Extract basic schema info
        if schema.Type != nil </span><span class="cov0" title="0">{
                types := schema.GetType()
                if len(types) &gt; 0 </span><span class="cov0" title="0">{
                        parsed.Schema.Type = string(types[0])
                }</span>
        }

        <span class="cov0" title="0">if schema.Description != nil </span><span class="cov0" title="0">{
                parsed.Description = *schema.Description
        }</span>

        <span class="cov0" title="0">parsed.Required = schema.Required

        // Extract x-codegen extension
        if schema.Extensions != nil </span><span class="cov0" title="0">{
                xcodegen := p.extractXCodegen(schema.Extensions)
                if xcodegen != nil </span><span class="cov0" title="0">{
                        parsed.XCodegen = xcodegen

                        // Extract events if present
                        if len(xcodegen.Events) &gt; 0 </span><span class="cov0" title="0">{
                                parsed.Events = make([]Event, 0, len(xcodegen.Events))
                                for _, eventName := range xcodegen.Events </span><span class="cov0" title="0">{
                                        parsed.Events = append(parsed.Events, Event{
                                                Type:        eventName,
                                                Description: fmt.Sprintf("%s event", eventName),
                                        })
                                }</span>
                        }
                }
        }

        // Parse properties
        <span class="cov0" title="0">if schema.Properties != nil </span><span class="cov0" title="0">{
                parsed.Properties = make(map[string]Property)
                for propName := range schema.Properties.Keys() </span><span class="cov0" title="0">{
                        propRef := schema.Properties.GetOrZero(propName)
                        if propRef != nil &amp;&amp; propRef.IsLeft() </span><span class="cov0" title="0">{
                                prop := propRef.GetLeft()
                                parsed.Properties[propName] = p.parseProperty(propName, prop)
                        }</span>
                }

                // Properties are already stored at top level
        }

        // Extract default values if present
        <span class="cov0" title="0">if schema.Default != nil </span><span class="cov0" title="0">{
                var defaultValue interface{}
                if err := schema.Default.Decode(&amp;defaultValue); err == nil </span><span class="cov0" title="0">{
                        parsed.Default = defaultValue
                }</span>
        }

        // Extract enum values if present
        <span class="cov0" title="0">if len(schema.Enum) &gt; 0 </span><span class="cov0" title="0">{
                parsed.Enum = make([]interface{}, len(schema.Enum))
                for i, enumVal := range schema.Enum </span><span class="cov0" title="0">{
                        var value interface{}
                        if err := enumVal.Decode(&amp;value); err == nil </span><span class="cov0" title="0">{
                                parsed.Enum[i] = value
                        }</span> else<span class="cov0" title="0"> {
                                parsed.Enum[i] = enumVal
                        }</span>
                }
        }

        <span class="cov0" title="0">return parsed</span>
}

// parseProperty converts a Speakeasy property to our Property format.
func (p *Parser) parseProperty(_ string, prop *oas3.Schema) Property <span class="cov0" title="0">{
        result := Property{}

        // Extract type
        if prop.Type != nil </span><span class="cov0" title="0">{
                types := prop.GetType()
                if len(types) &gt; 0 </span><span class="cov0" title="0">{
                        result.Type = string(types[0])
                }</span>
        }

        // Extract format
        <span class="cov0" title="0">if prop.Format != nil </span><span class="cov0" title="0">{
                result.Format = *prop.Format
        }</span>

        // Extract description
        <span class="cov0" title="0">if prop.Description != nil </span><span class="cov0" title="0">{
                result.Description = *prop.Description
        }</span>

        // Extract default value
        <span class="cov0" title="0">if prop.Default != nil </span><span class="cov0" title="0">{
                var defaultValue interface{}
                if err := prop.Default.Decode(&amp;defaultValue); err == nil </span><span class="cov0" title="0">{
                        result.Default = defaultValue
                }</span>
        }

        // Extract enum values
        <span class="cov0" title="0">if len(prop.Enum) &gt; 0 </span><span class="cov0" title="0">{
                result.Enum = make([]interface{}, len(prop.Enum))
                for i, enumVal := range prop.Enum </span><span class="cov0" title="0">{
                        var value interface{}
                        if err := enumVal.Decode(&amp;value); err == nil </span><span class="cov0" title="0">{
                                result.Enum[i] = value
                        }</span>
                }
        }

        // Extract x-codegen extension at property level
        <span class="cov0" title="0">if prop.Extensions != nil </span><span class="cov0" title="0">{
                xcodegen := p.extractPropertyXCodegen(prop.Extensions)
                if xcodegen != nil </span><span class="cov0" title="0">{
                        result.XCodegen = xcodegen
                }</span>
        }

        // Handle array items
        <span class="cov0" title="0">if result.Type == "array" &amp;&amp; prop.Items != nil &amp;&amp; prop.Items.IsLeft() </span><span class="cov0" title="0">{
                itemSchema := prop.Items.GetLeft()
                itemProp := p.parseProperty("item", itemSchema)
                result.Items = &amp;itemProp
        }</span>

        // Handle nested object properties
        <span class="cov0" title="0">if result.Type == "object" &amp;&amp; prop.Properties != nil </span><span class="cov0" title="0">{
                result.Properties = make(map[string]Property)
                for subPropName := range prop.Properties.Keys() </span><span class="cov0" title="0">{
                        subPropRef := prop.Properties.GetOrZero(subPropName)
                        if subPropRef != nil &amp;&amp; subPropRef.IsLeft() </span><span class="cov0" title="0">{
                                subProp := subPropRef.GetLeft()
                                result.Properties[subPropName] = p.parseProperty(subPropName, subProp)
                        }</span>
                }
        }

        <span class="cov0" title="0">return result</span>
}

// extractXCodegen extracts the x-codegen extension from schema extensions.
func (p *Parser) extractXCodegen(ext *extensions.Extensions) *XCodegen <span class="cov0" title="0">{
        raw, err := extensions.GetExtensionValue[interface{}](ext, "x-codegen")
        if err != nil || raw == nil </span><span class="cov0" title="0">{
                return nil
        }</span>

        // Marshal to JSON then unmarshal to our type
        <span class="cov0" title="0">jsonBytes, err := json.Marshal(raw)
        if err != nil </span><span class="cov0" title="0">{
                p.warnings = append(p.warnings, fmt.Sprintf("failed to marshal x-codegen: %v", err))
                return nil
        }</span>

        <span class="cov0" title="0">var xcodegen XCodegen
        if err := json.Unmarshal(jsonBytes, &amp;xcodegen); err != nil </span><span class="cov0" title="0">{
                p.warnings = append(p.warnings, fmt.Sprintf("failed to unmarshal x-codegen: %v", err))
                return nil
        }</span>

        <span class="cov0" title="0">return &amp;xcodegen</span>
}

// extractPropertyXCodegen extracts property-level x-codegen extension.
func (p *Parser) extractPropertyXCodegen(ext *extensions.Extensions) *PropertyXCodegen <span class="cov0" title="0">{
        raw, err := extensions.GetExtensionValue[interface{}](ext, "x-codegen")
        if err != nil || raw == nil </span><span class="cov0" title="0">{
                return nil
        }</span>

        // Marshal to JSON then unmarshal to our type
        <span class="cov0" title="0">jsonBytes, err := json.Marshal(raw)
        if err != nil </span><span class="cov0" title="0">{
                return nil
        }</span>

        <span class="cov0" title="0">var xcodegen PropertyXCodegen
        if err := json.Unmarshal(jsonBytes, &amp;xcodegen); err != nil </span><span class="cov0" title="0">{
                return nil
        }</span>

        <span class="cov0" title="0">return &amp;xcodegen</span>
}

// ParseWithTags parses schemas associated with specific OpenAPI tags.
func (p *Parser) ParseWithTags(specPath string, tags []string) (map[string]*ParsedSchema, error) <span class="cov0" title="0">{
        // First parse the entire spec
        allSchemas, err := p.ParseOpenAPISpec(specPath)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        // If no tags specified, return all schemas
        <span class="cov0" title="0">if len(tags) == 0 </span><span class="cov0" title="0">{
                return allSchemas, nil
        }</span>

        // Filter schemas by tags
        // Note: This would need to be enhanced to actually check which schemas
        // are used by operations with the specified tags
        <span class="cov0" title="0">filtered := make(map[string]*ParsedSchema)
        for name, schema := range allSchemas </span><span class="cov0" title="0">{
                // For now, use domain inference as a proxy for tags
                for _, tag := range tags </span><span class="cov0" title="0">{
                        if strings.EqualFold(schema.Domain, tag) </span><span class="cov0" title="0">{
                                filtered[name] = schema
                                break</span>
                        }
                }
        }

        <span class="cov0" title="0">return filtered, nil</span>
}

// GetWarnings returns any warnings accumulated during parsing.
func (p *Parser) GetWarnings() []string <span class="cov0" title="0">{
        return p.warnings
}</span>

// inferDomain attempts to infer the domain from schema name.
func (p *Parser) inferDomain(_, schemaName string) string <span class="cov0" title="0">{
        // Simple rule: use lowercase plural form of the entity name
        // This creates a one-to-one mapping between entities and packages

        // Convert schema name to lowercase
        lower := strings.ToLower(schemaName)

        // Simple pluralization rules
        if strings.HasSuffix(lower, "s") </span><span class="cov0" title="0">{
                // Already plural (e.g., "sessions" stays "sessions")
                return lower
        }</span>
        <span class="cov0" title="0">if strings.HasSuffix(lower, "y") </span><span class="cov0" title="0">{
                // Change y to ies (e.g., "entity" -&gt; "entities")
                return lower[:len(lower)-1] + "ies"
        }</span>
        // Just add s (e.g., "user" -&gt; "users", "artifact" -&gt; "artifacts")
        <span class="cov0" title="0">return lower + "s"</span>
}

// WalkAllSchemas walks through all schemas including nested ones.
func (p *Parser) WalkAllSchemas(callback func(name string, schema *ParsedSchema) error) error <span class="cov0" title="0">{
        if p.doc == nil </span><span class="cov0" title="0">{
                return fmt.Errorf("no document loaded")
        }</span>

        <span class="cov0" title="0">ctx := context.Background()
        for item := range openapi.Walk(ctx, p.doc) </span><span class="cov0" title="0">{
                err := item.Match(openapi.Matcher{
                        Schema: func(schema *oas3.JSONSchema[oas3.Referenceable]) error </span><span class="cov0" title="0">{
                                if schema.IsLeft() </span><span class="cov0" title="0">{
                                        // Process the schema
                                        // Note: We don't have the name here, would need to track context
                                        return nil
                                }</span>
                                <span class="cov0" title="0">return nil</span>
                        },
                })
                <span class="cov0" title="0">if err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>
        }

        // Also walk our cached schemas
        <span class="cov0" title="0">for name, schema := range p.schemas </span><span class="cov0" title="0">{
                if err := callback(name, schema); err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>
        }

        <span class="cov0" title="0">return nil</span>
}

// GetDefaultValues extracts all default values from a schema.
func (p *Parser) GetDefaultValues(schemaName string) (map[string]interface{}, error) <span class="cov0" title="0">{
        schema, exists := p.schemas[schemaName]
        if !exists </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("schema %s not found", schemaName)
        }</span>

        <span class="cov0" title="0">defaults := make(map[string]interface{})

        // Extract defaults from properties
        for propName, prop := range schema.Properties </span><span class="cov0" title="0">{
                if prop.Default != nil </span><span class="cov0" title="0">{
                        defaults[propName] = prop.Default
                }</span>
        }

        <span class="cov0" title="0">return defaults, nil</span>
}

// GetAllConfigDefaults recursively extracts all defaults including from nested schemas.
// This is especially useful for ArchesConfig which references other config schemas.
func (p *Parser) GetAllConfigDefaults(schemaName string) (map[string]interface{}, error) <span class="cov0" title="0">{
        if p.doc == nil || p.doc.Components == nil || p.doc.Components.Schemas == nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("no document loaded")
        }</span>

        <span class="cov0" title="0">schemaRef := p.doc.Components.Schemas.GetOrZero(schemaName)
        if schemaRef == nil || !schemaRef.IsLeft() </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("schema %s not found", schemaName)
        }</span>

        <span class="cov0" title="0">schema := schemaRef.GetLeft()
        return p.extractDefaultsRecursive(schema, schemaName)</span>
}

// extractDefaultsRecursive recursively extracts defaults from a schema and its references.
func (p *Parser) extractDefaultsRecursive(schema *oas3.Schema, path string) (map[string]interface{}, error) <span class="cov0" title="0">{
        result := make(map[string]interface{})

        if schema.Properties != nil </span><span class="cov0" title="0">{
                for propName := range schema.Properties.Keys() </span><span class="cov0" title="0">{
                        propRef := schema.Properties.GetOrZero(propName)
                        if propRef == nil </span><span class="cov0" title="0">{
                                continue</span>
                        }

                        <span class="cov0" title="0">if propRef.IsLeft() </span><span class="cov0" title="0">{
                                // Direct schema
                                prop := propRef.GetLeft()

                                // Check for default value
                                if prop.Default != nil </span><span class="cov0" title="0">{
                                        var defaultValue interface{}
                                        if err := prop.Default.Decode(&amp;defaultValue); err == nil </span><span class="cov0" title="0">{
                                                result[propName] = defaultValue
                                        }</span>
                                }

                                // If it's an object with properties, recurse
                                <span class="cov0" title="0">if prop.Type != nil </span><span class="cov0" title="0">{
                                        types := prop.GetType()
                                        if len(types) &gt; 0 &amp;&amp; types[0] == "object" &amp;&amp; prop.Properties != nil </span><span class="cov0" title="0">{
                                                // Recursively get defaults from nested object
                                                nested, err := p.extractDefaultsRecursive(prop, path+"."+propName)
                                                if err == nil &amp;&amp; len(nested) &gt; 0 </span><span class="cov0" title="0">{
                                                        // Store nested defaults as a map
                                                        result[propName] = nested
                                                }</span>
                                        }
                                }
                        }
                        // TODO: Handle references (IsRight) with Speakeasy's API
                        // For now, we're only handling direct schemas
                }
        }

        <span class="cov0" title="0">return result, nil</span>
}

// Helper functions for code generation compatibility

// HasXCodegen checks if a schema has x-codegen extensions.
func HasXCodegen(schema *ParsedSchema) bool <span class="cov0" title="0">{
        return schema != nil &amp;&amp; schema.XCodegen != nil
}</span>

// NeedsRepository checks if a schema needs repository generation.
func NeedsRepository(schema *ParsedSchema) bool <span class="cov0" title="0">{
        if schema == nil || schema.XCodegen == nil </span><span class="cov0" title="0">{
                return false
        }</span>
        // Check if repository operations are defined
        <span class="cov0" title="0">return len(schema.XCodegen.Repository.Operations) &gt; 0</span>
}

// NeedsCache checks if a schema needs cache generation.
func NeedsCache(schema *ParsedSchema) bool <span class="cov0" title="0">{
        if schema == nil || schema.XCodegen == nil </span><span class="cov0" title="0">{
                return false
        }</span>
        <span class="cov0" title="0">return schema.XCodegen.Cache.Enabled</span>
}

// NeedsEvents checks if a schema needs event generation.
func NeedsEvents(schema *ParsedSchema) bool <span class="cov0" title="0">{
        if schema == nil || schema.XCodegen == nil </span><span class="cov0" title="0">{
                return false
        }</span>
        <span class="cov0" title="0">return len(schema.XCodegen.Events) &gt; 0 || len(schema.Events) &gt; 0</span>
}

// NeedsAdapter checks if a schema needs adapter generation.
func NeedsAdapter(schema *ParsedSchema) bool <span class="cov0" title="0">{
        if schema == nil || schema.XCodegen == nil </span><span class="cov0" title="0">{
                return false
        }</span>
        // Check if adapter is configured (has mappers or custom mappings)
        <span class="cov0" title="0">return schema.XCodegen.Adapter.GenerateMappers ||
                len(schema.XCodegen.Adapter.CustomMappings) &gt; 0</span>
}
</pre>
		
		<pre class="file" id="file51" style="display: none">// Package codegen provides template functions for code generation.
package codegen

import (
        "bytes"
        "strings"
        "text/template"
        "unicode"
)

// TemplateFuncs returns common template functions used across all generators.
func TemplateFuncs() template.FuncMap <span class="cov0" title="0">{
        return template.FuncMap{
                "title":       Title,
                "lower":       strings.ToLower,
                "upper":       strings.ToUpper,
                "camelCase":   CamelCase,
                "pascalCase":  PascalCase,
                "snakeCase":   SnakeCase,
                "kebabCase":   KebabCase,
                "pluralize":   Pluralize,
                "singularize": Singularize,
                "join":        strings.Join,
                "contains":    Contains,
                "hasPrefix":   strings.HasPrefix,
                "hasSuffix":   strings.HasSuffix,
                "trimPrefix":  strings.TrimPrefix,
                "trimSuffix":  strings.TrimSuffix,
                "replace":     strings.ReplaceAll,
                "quote":       Quote,
                "indent":      Indent,
                "comment":     Comment,
                "paramType":   ParamType,
                "isUUIDParam": IsUUIDParam,
        }
}</span>

// Title capitalizes the first letter of a string.
func Title(s string) string <span class="cov0" title="0">{
        if s == "" </span><span class="cov0" title="0">{
                return s
        }</span>
        <span class="cov0" title="0">r := []rune(s)
        r[0] = unicode.ToUpper(r[0])
        return string(r)</span>
}

// CamelCase converts a string to camelCase.
func CamelCase(s string) string <span class="cov0" title="0">{
        s = strings.TrimSpace(s)
        if s == "" </span><span class="cov0" title="0">{
                return s
        }</span>

        // Handle snake_case, kebab-case, and space-separated
        <span class="cov0" title="0">parts := splitWords(s)
        if len(parts) == 0 </span><span class="cov0" title="0">{
                return s
        }</span>

        // First part is lowercase
        <span class="cov0" title="0">result := strings.ToLower(parts[0])

        // Remaining parts are title case
        for i := 1; i &lt; len(parts); i++ </span><span class="cov0" title="0">{
                if parts[i] != "" </span><span class="cov0" title="0">{
                        result += Title(strings.ToLower(parts[i]))
                }</span>
        }

        <span class="cov0" title="0">return result</span>
}

// PascalCase converts a string to PascalCase.
func PascalCase(s string) string <span class="cov0" title="0">{
        s = strings.TrimSpace(s)
        if s == "" </span><span class="cov0" title="0">{
                return s
        }</span>

        <span class="cov0" title="0">parts := splitWords(s)
        result := ""

        for _, part := range parts </span><span class="cov0" title="0">{
                if part != "" </span><span class="cov0" title="0">{
                        result += Title(strings.ToLower(part))
                }</span>
        }

        <span class="cov0" title="0">return result</span>
}

// SnakeCase converts a string to snake_case.
func SnakeCase(s string) string <span class="cov0" title="0">{
        s = strings.TrimSpace(s)
        if s == "" </span><span class="cov0" title="0">{
                return s
        }</span>

        <span class="cov0" title="0">var result bytes.Buffer
        for i, r := range s </span><span class="cov0" title="0">{
                if i &gt; 0 &amp;&amp; unicode.IsUpper(r) </span><span class="cov0" title="0">{
                        // Add underscore before uppercase letters (except at the start)
                        if i &gt; 0 &amp;&amp; s[i-1] != '_' &amp;&amp; s[i-1] != '-' &amp;&amp; s[i-1] != ' ' </span><span class="cov0" title="0">{
                                result.WriteRune('_')
                        }</span>
                }
                <span class="cov0" title="0">if r == '-' || r == ' ' </span><span class="cov0" title="0">{
                        result.WriteRune('_')
                }</span> else<span class="cov0" title="0"> {
                        result.WriteRune(unicode.ToLower(r))
                }</span>
        }

        <span class="cov0" title="0">return result.String()</span>
}

// KebabCase converts a string to kebab-case.
func KebabCase(s string) string <span class="cov0" title="0">{
        s = strings.TrimSpace(s)
        if s == "" </span><span class="cov0" title="0">{
                return s
        }</span>

        <span class="cov0" title="0">var result bytes.Buffer
        for i, r := range s </span><span class="cov0" title="0">{
                if i &gt; 0 &amp;&amp; unicode.IsUpper(r) </span><span class="cov0" title="0">{
                        // Add hyphen before uppercase letters (except at the start)
                        if i &gt; 0 &amp;&amp; s[i-1] != '-' &amp;&amp; s[i-1] != '_' &amp;&amp; s[i-1] != ' ' </span><span class="cov0" title="0">{
                                result.WriteRune('-')
                        }</span>
                }
                <span class="cov0" title="0">if r == '_' || r == ' ' </span><span class="cov0" title="0">{
                        result.WriteRune('-')
                }</span> else<span class="cov0" title="0"> {
                        result.WriteRune(unicode.ToLower(r))
                }</span>
        }

        <span class="cov0" title="0">return result.String()</span>
}

// Pluralize converts a singular word to plural using simple rules.
func Pluralize(word string) string <span class="cov0" title="0">{
        if word == "" </span><span class="cov0" title="0">{
                return word
        }</span>

        // Special cases
        <span class="cov0" title="0">special := map[string]string{
                "person": "people",
                "child":  "children",
                "mouse":  "mice",
                "tooth":  "teeth",
                "foot":   "feet",
                "goose":  "geese",
                "man":    "men",
                "woman":  "women",
        }

        lower := strings.ToLower(word)
        if plural, ok := special[lower]; ok </span><span class="cov0" title="0">{
                // Preserve original case
                if unicode.IsUpper(rune(word[0])) </span><span class="cov0" title="0">{
                        return Title(plural)
                }</span>
                <span class="cov0" title="0">return plural</span>
        }

        // Words ending in 'y' preceded by a consonant
        <span class="cov0" title="0">if strings.HasSuffix(word, "y") &amp;&amp; len(word) &gt; 1 </span><span class="cov0" title="0">{
                beforeY := word[len(word)-2]
                if !isVowel(beforeY) </span><span class="cov0" title="0">{
                        return word[:len(word)-1] + "ies"
                }</span>
                <span class="cov0" title="0">return word + "s"</span>
        }

        // Words ending in 's', 'x', 'z', 'ch', 'sh'
        <span class="cov0" title="0">if strings.HasSuffix(word, "s") || strings.HasSuffix(word, "x") ||
                strings.HasSuffix(word, "z") || strings.HasSuffix(word, "ch") ||
                strings.HasSuffix(word, "sh") </span><span class="cov0" title="0">{
                return word + "es"
        }</span>

        // Words ending in 'f' or 'fe'
        <span class="cov0" title="0">if strings.HasSuffix(word, "f") </span><span class="cov0" title="0">{
                return word[:len(word)-1] + "ves"
        }</span>
        <span class="cov0" title="0">if strings.HasSuffix(word, "fe") </span><span class="cov0" title="0">{
                return word[:len(word)-2] + "ves"
        }</span>

        // Default: add 's'
        <span class="cov0" title="0">return word + "s"</span>
}

// Singularize converts a plural word to singular using simple rules.
func Singularize(word string) string <span class="cov0" title="0">{
        if word == "" </span><span class="cov0" title="0">{
                return word
        }</span>

        // Special cases
        <span class="cov0" title="0">special := map[string]string{
                "people":   "person",
                "children": "child",
                "mice":     "mouse",
                "teeth":    "tooth",
                "feet":     "foot",
                "geese":    "goose",
                "men":      "man",
                "women":    "woman",
        }

        lower := strings.ToLower(word)
        if singular, ok := special[lower]; ok </span><span class="cov0" title="0">{
                // Preserve original case
                if unicode.IsUpper(rune(word[0])) </span><span class="cov0" title="0">{
                        return Title(singular)
                }</span>
                <span class="cov0" title="0">return singular</span>
        }

        // Words ending in 'ies'
        <span class="cov0" title="0">if strings.HasSuffix(word, "ies") </span><span class="cov0" title="0">{
                return word[:len(word)-3] + "y"
        }</span>

        // Words ending in 'ves'
        <span class="cov0" title="0">if strings.HasSuffix(word, "ves") </span><span class="cov0" title="0">{
                return word[:len(word)-3] + "f"
        }</span>

        // Words ending in 'es'
        <span class="cov0" title="0">if strings.HasSuffix(word, "es") </span><span class="cov0" title="0">{
                // Check if it's 'ses', 'xes', 'zes', 'ches', 'shes'
                if len(word) &gt; 3 </span><span class="cov0" title="0">{
                        beforeES := word[len(word)-3]
                        if beforeES == 's' || beforeES == 'x' || beforeES == 'z' </span><span class="cov0" title="0">{
                                return word[:len(word)-2]
                        }</span>
                }
                <span class="cov0" title="0">if strings.HasSuffix(word, "ches") || strings.HasSuffix(word, "shes") </span><span class="cov0" title="0">{
                        return word[:len(word)-2]
                }</span>
                <span class="cov0" title="0">return word[:len(word)-1]</span> // Remove just 's'
        }

        // Words ending in 's'
        <span class="cov0" title="0">if strings.HasSuffix(word, "s") &amp;&amp; !strings.HasSuffix(word, "ss") </span><span class="cov0" title="0">{
                return word[:len(word)-1]
        }</span>

        // Already singular or unknown pattern
        <span class="cov0" title="0">return word</span>
}

// Contains checks if a slice contains a string.
func Contains(slice []string, item string) bool <span class="cov0" title="0">{
        for _, s := range slice </span><span class="cov0" title="0">{
                if s == item </span><span class="cov0" title="0">{
                        return true
                }</span>
        }
        <span class="cov0" title="0">return false</span>
}

// Quote wraps a string in quotes.
func Quote(s string) string <span class="cov0" title="0">{
        return `"` + s + `"`
}</span>

// Indent indents each line of a string by the specified number of tabs.
func Indent(n int, s string) string <span class="cov0" title="0">{
        if s == "" </span><span class="cov0" title="0">{
                return s
        }</span>

        <span class="cov0" title="0">indent := strings.Repeat("\t", n)
        lines := strings.Split(s, "\n")
        for i, line := range lines </span><span class="cov0" title="0">{
                if line != "" </span><span class="cov0" title="0">{
                        lines[i] = indent + line
                }</span>
        }
        <span class="cov0" title="0">return strings.Join(lines, "\n")</span>
}

// Comment formats a string as a Go comment.
func Comment(s string) string <span class="cov0" title="0">{
        if s == "" </span><span class="cov0" title="0">{
                return ""
        }</span>

        <span class="cov0" title="0">lines := strings.Split(s, "\n")
        for i, line := range lines </span><span class="cov0" title="0">{
                if line != "" </span><span class="cov0" title="0">{
                        lines[i] = "// " + line
                }</span> else<span class="cov0" title="0"> {
                        lines[i] = "//"
                }</span>
        }
        <span class="cov0" title="0">return strings.Join(lines, "\n")</span>
}

// splitWords splits a string into words based on various delimiters.
func splitWords(s string) []string <span class="cov0" title="0">{
        var words []string
        var current bytes.Buffer

        for i, r := range s </span><span class="cov0" title="0">{
                if r == '_' || r == '-' || r == ' ' </span><span class="cov0" title="0">{
                        if current.Len() &gt; 0 </span><span class="cov0" title="0">{
                                words = append(words, current.String())
                                current.Reset()
                        }</span>
                } else<span class="cov0" title="0"> if i &gt; 0 &amp;&amp; unicode.IsUpper(r) &amp;&amp; !unicode.IsUpper(rune(s[i-1])) </span><span class="cov0" title="0">{
                        // Start of new word (camelCase boundary)
                        if current.Len() &gt; 0 </span><span class="cov0" title="0">{
                                words = append(words, current.String())
                                current.Reset()
                        }</span>
                        <span class="cov0" title="0">current.WriteRune(r)</span>
                } else<span class="cov0" title="0"> {
                        current.WriteRune(r)
                }</span>
        }

        <span class="cov0" title="0">if current.Len() &gt; 0 </span><span class="cov0" title="0">{
                words = append(words, current.String())
        }</span>

        <span class="cov0" title="0">return words</span>
}

// isVowel checks if a byte represents a vowel.
func isVowel(b byte) bool <span class="cov0" title="0">{
        return b == 'a' || b == 'e' || b == 'i' || b == 'o' || b == 'u' ||
                b == 'A' || b == 'E' || b == 'I' || b == 'O' || b == 'U'
}</span>

// ParamType returns the Go type for a parameter name based on naming conventions.
func ParamType(paramName string) string <span class="cov0" title="0">{
        switch paramName </span>{
        case "id", "userId":<span class="cov0" title="0">
                return "uuid.UUID"</span>
        case "organizationId", "name", "email", "token", "provider", "providerAccountId", "slug", "stripeCustomerId", "pipelineId", "inviterId", "toolId":<span class="cov0" title="0">
                return "string"</span>
        default:<span class="cov0" title="0">
                return "string"</span>
        }
}

// IsUUIDParam checks if a parameter should be treated as a UUID type.
func IsUUIDParam(paramName string) bool <span class="cov0" title="0">{
        return paramName == "id" || paramName == "userId"
}</span>
</pre>
		
		<pre class="file" id="file52" style="display: none">// Code generated by codegen; DO NOT EDIT.
// This file contains default configuration values extracted from OpenAPI schemas.

package config

// GetDefaultConfig returns a complete default configuration with all values from OpenAPI schemas.
func GetDefaultConfig() *ArchesConfig <span class="cov10" title="3">{
        return &amp;ArchesConfig{
                Api: APIConfig{
                        Cors: CORSConfig{
                                Origins: "https://platform.archesai.dev",
                        },
                        Docs: true,
                        Email: EmailConfig{
                                Enabled: false,
                        },
                        Environment: Development,
                        Host:        "0.0.0.0",
                        Image: ImageConfig{
                                PullPolicy: IfNotPresent,
                                Tag:        "latest",
                        },
                        Port:      3001,
                        Resources: ResourceConfig{},
                        Validate:  true,
                },
                Auth: AuthConfig{
                        Enabled: true,
                        Local:   LocalAuth{},
                },
                Billing: BillingConfig{
                        Enabled: false,
                        Stripe:  StripeConfig{},
                },
                Database: DatabaseConfig{
                        Enabled:       true,
                        Managed:       false,
                        MaxConns:      25,
                        MinConns:      5,
                        RunMigrations: false,
                        Type:          Postgresql,
                        Url:           "postgresql://admin:password@127.0.0.1:5432/archesai",
                },
                Infrastructure: InfrastructureConfig{
                        Namespace: "arches-system",
                },
                Ingress: IngressConfig{
                        Domain:  "archesai.dev",
                        Enabled: false,
                },
                Intelligence: IntelligenceConfig{
                        Embedding: EmbeddingConfig{
                                Type: "ollama",
                        },
                        Llm: LLMConfig{
                                Type: "ollama",
                        },
                },
                Logging: LoggingConfig{
                        Level:  Info,
                        Pretty: false,
                },
                Monitoring: MonitoringConfig{
                        Grafana: GrafanaConfig{
                                Enabled: false,
                                Managed: false,
                        },
                        Loki: LokiConfig{
                                Enabled: false,
                                Host:    "http://localhost:3100",
                                Managed: false,
                        },
                },
                Platform: PlatformConfig{
                        Enabled: false,
                        Host:    "localhost",
                        Managed: false,
                },
                Redis: RedisConfig{
                        Auth:    "password",
                        Enabled: false,
                        Host:    "localhost",
                        Managed: false,
                        Port:    6379,
                },
                Storage: StorageConfig{
                        Accesskey: "minioadmin",
                        Bucket:    "archesai",
                        Enabled:   false,
                        Endpoint:  "http://localhost:9000",
                        Managed:   false,
                        Secretkey: "minioadmin",
                },
        }
}</span>
</pre>
		
		<pre class="file" id="file53" style="display: none">// Package config provides primitives to interact with the openapi HTTP API.
//
// Code generated by github.com/oapi-codegen/oapi-codegen/v2 version v2.5.0 DO NOT EDIT.
package config

import (
        "context"
        "encoding/json"
        "fmt"
        "net/http"

        "github.com/labstack/echo/v4"
        strictecho "github.com/oapi-codegen/runtime/strictmiddleware/echo"
)

// ServerInterface represents all server handlers.
type ServerInterface interface {
        // Get the configuration
        // (GET /config)
        GetConfig(ctx echo.Context) error
}

// ServerInterfaceWrapper converts echo contexts to parameters.
type ServerInterfaceWrapper struct {
        Handler ServerInterface
}

// GetConfig converts echo context to params.
func (w *ServerInterfaceWrapper) GetConfig(ctx echo.Context) error <span class="cov0" title="0">{
        var err error

        ctx.Set(BearerAuthScopes, []string{})

        ctx.Set(SessionCookieScopes, []string{})

        // Invoke the callback with all the unmarshaled arguments
        err = w.Handler.GetConfig(ctx)
        return err
}</span>

// This is a simple interface which specifies echo.Route addition functions which
// are present on both echo.Echo and echo.Group, since we want to allow using
// either of them for path registration
type EchoRouter interface {
        CONNECT(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
        DELETE(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
        GET(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
        HEAD(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
        OPTIONS(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
        PATCH(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
        POST(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
        PUT(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
        TRACE(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
}

// RegisterHandlers adds each server route to the EchoRouter.
func RegisterHandlers(router EchoRouter, si ServerInterface) <span class="cov0" title="0">{
        RegisterHandlersWithBaseURL(router, si, "")
}</span>

// Registers handlers, and prepends BaseURL to the paths, so that the paths
// can be served under a prefix.
func RegisterHandlersWithBaseURL(router EchoRouter, si ServerInterface, baseURL string) <span class="cov0" title="0">{

        wrapper := ServerInterfaceWrapper{
                Handler: si,
        }

        router.GET(baseURL+"/config", wrapper.GetConfig)

}</span>

type BadRequestApplicationProblemPlusJSONResponse Problem

type GetConfigRequestObject struct {
}

type GetConfigResponseObject interface {
        VisitGetConfigResponse(w http.ResponseWriter) error
}

type GetConfig200JSONResponse ArchesConfig

func (response GetConfig200JSONResponse) VisitGetConfigResponse(w http.ResponseWriter) error <span class="cov0" title="0">{
        w.Header().Set("Content-Type", "application/json")
        w.WriteHeader(200)

        return json.NewEncoder(w).Encode(response)
}</span>

type GetConfig400ApplicationProblemPlusJSONResponse struct {
        BadRequestApplicationProblemPlusJSONResponse
}

func (response GetConfig400ApplicationProblemPlusJSONResponse) VisitGetConfigResponse(w http.ResponseWriter) error <span class="cov0" title="0">{
        w.Header().Set("Content-Type", "application/problem+json")
        w.WriteHeader(400)

        return json.NewEncoder(w).Encode(response)
}</span>

// StrictServerInterface represents all server handlers.
type StrictServerInterface interface {
        // Get the configuration
        // (GET /config)
        GetConfig(ctx context.Context, request GetConfigRequestObject) (GetConfigResponseObject, error)
}

type StrictHandlerFunc = strictecho.StrictEchoHandlerFunc
type StrictMiddlewareFunc = strictecho.StrictEchoMiddlewareFunc

func NewStrictHandler(ssi StrictServerInterface, middlewares []StrictMiddlewareFunc) ServerInterface <span class="cov0" title="0">{
        return &amp;strictHandler{ssi: ssi, middlewares: middlewares}
}</span>

type strictHandler struct {
        ssi         StrictServerInterface
        middlewares []StrictMiddlewareFunc
}

// GetConfig operation middleware
func (sh *strictHandler) GetConfig(ctx echo.Context) error <span class="cov0" title="0">{
        var request GetConfigRequestObject

        handler := func(ctx echo.Context, request interface{}) (interface{}, error) </span><span class="cov0" title="0">{
                return sh.ssi.GetConfig(ctx.Request().Context(), request.(GetConfigRequestObject))
        }</span>
        <span class="cov0" title="0">for _, middleware := range sh.middlewares </span><span class="cov0" title="0">{
                handler = middleware(handler, "GetConfig")
        }</span>

        <span class="cov0" title="0">response, err := handler(ctx, request)

        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span> else<span class="cov0" title="0"> if validResponse, ok := response.(GetConfigResponseObject); ok </span><span class="cov0" title="0">{
                return validResponse.VisitGetConfigResponse(ctx.Response())
        }</span> else<span class="cov0" title="0"> if response != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("unexpected response type: %T", response)
        }</span>
        <span class="cov0" title="0">return nil</span>
}
</pre>
		
		<pre class="file" id="file54" style="display: none">package config

import (
        "fmt"
        "strings"
        "time"

        "github.com/spf13/viper"
)

// Config wraps the generated ArchesConfig for easy access
type Config struct {
        *ArchesConfig
        v *viper.Viper
}

// Load reads configuration from environment variables and returns a Config.
func Load() (*Config, error) <span class="cov4" title="3">{
        // Start with defaults from generated code
        config := GetDefaultConfig()

        // Setup Viper for environment and file overrides
        v := viper.New()
        setupViper(v)

        // Read config file if exists
        if err := v.ReadInConfig(); err != nil </span><span class="cov3" title="2">{
                if _, ok := err.(viper.ConfigFileNotFoundError); !ok </span><span class="cov0" title="0">{
                        return nil, fmt.Errorf("failed to read config: %w", err)
                }</span>
        }

        // Apply overrides from environment/config to the default config
        <span class="cov4" title="3">applyViperOverrides(config, v)

        return &amp;Config{
                ArchesConfig: config,
                v:            v,
        }, nil</span>
}

// setupViper configures viper for reading config
func setupViper(v *viper.Viper) <span class="cov6" title="4">{
        v.SetConfigName(DefaultConfigName)
        v.SetConfigType(DefaultConfigType)
        for _, path := range ConfigPaths </span><span class="cov10" title="12">{
                v.AddConfigPath(path)
        }</span>

        <span class="cov6" title="4">v.SetEnvPrefix(EnvPrefix)
        v.SetEnvKeyReplacer(strings.NewReplacer(".", "_", "-", "_"))
        v.AutomaticEnv()</span>
}

// applyViperOverrides applies configuration overrides from Viper to the config struct
func applyViperOverrides(config *ArchesConfig, v *viper.Viper) <span class="cov4" title="3">{
        applyAPIOverrides(config, v)
        applyAuthOverrides(config, v)
        applyDatabaseOverrides(config, v)
        applyLoggingOverrides(config, v)
        applyRedisOverrides(config, v)
        applyStorageOverrides(config, v)
        applyInfrastructureOverrides(config, v)
        applyPlatformOverrides(config, v)
        applyIngressOverrides(config, v)
        applyIntelligenceOverrides(config, v)
        applyMonitoringOverrides(config, v)
        applyBillingOverrides(config, v)
}</span>

func applyAPIOverrides(config *ArchesConfig, v *viper.Viper) <span class="cov6" title="4">{
        if v.IsSet("api.host") </span><span class="cov4" title="3">{
                config.Api.Host = v.GetString("api.host")
        }</span>
        <span class="cov6" title="4">if v.IsSet("api.port") </span><span class="cov4" title="3">{
                config.Api.Port = float32(v.GetInt("api.port"))
        }</span>
        <span class="cov6" title="4">if v.IsSet("api.docs") </span><span class="cov1" title="1">{
                config.Api.Docs = v.GetBool("api.docs")
        }</span>
        <span class="cov6" title="4">if v.IsSet("api.validate") </span><span class="cov1" title="1">{
                config.Api.Validate = v.GetBool("api.validate")
        }</span>
        <span class="cov6" title="4">if v.IsSet("api.environment") </span><span class="cov3" title="2">{
                config.Api.Environment = APIConfigEnvironment(v.GetString("api.environment"))
        }</span>
        <span class="cov6" title="4">if v.IsSet("api.cors.origins") </span><span class="cov1" title="1">{
                config.Api.Cors.Origins = v.GetString("api.cors.origins")
        }</span>
}

func applyAuthOverrides(config *ArchesConfig, v *viper.Viper) <span class="cov6" title="4">{
        if v.IsSet("auth.enabled") </span><span class="cov3" title="2">{
                config.Auth.Enabled = v.GetBool("auth.enabled")
        }</span>
        <span class="cov6" title="4">if v.IsSet("auth.local.enabled") </span><span class="cov1" title="1">{
                config.Auth.Local.Enabled = v.GetBool("auth.local.enabled")
        }</span>
        <span class="cov6" title="4">if v.IsSet("auth.local.jwt_secret") </span><span class="cov1" title="1">{
                config.Auth.Local.JwtSecret = v.GetString("auth.local.jwt_secret")
        }</span>
        <span class="cov6" title="4">if v.IsSet("auth.local.access_token_ttl") </span><span class="cov1" title="1">{
                config.Auth.Local.AccessTokenTtl = v.GetString("auth.local.access_token_ttl")
        }</span>
        <span class="cov6" title="4">if v.IsSet("auth.local.refresh_token_ttl") </span><span class="cov1" title="1">{
                config.Auth.Local.RefreshTokenTtl = v.GetString("auth.local.refresh_token_ttl")
        }</span>
}

func applyDatabaseOverrides(config *ArchesConfig, v *viper.Viper) <span class="cov6" title="4">{
        if v.IsSet("database.enabled") </span><span class="cov1" title="1">{
                config.Database.Enabled = v.GetBool("database.enabled")
        }</span>
        <span class="cov6" title="4">if v.IsSet("database.url") </span><span class="cov3" title="2">{
                config.Database.Url = v.GetString("database.url")
        }</span>
        <span class="cov6" title="4">if v.IsSet("database.type") </span><span class="cov3" title="2">{
                config.Database.Type = DatabaseConfigType(v.GetString("database.type"))
        }</span>
        <span class="cov6" title="4">if v.IsSet("database.max_conns") </span><span class="cov3" title="2">{
                config.Database.MaxConns = v.GetInt("database.max_conns")
        }</span>
        <span class="cov6" title="4">if v.IsSet("database.min_conns") </span><span class="cov1" title="1">{
                config.Database.MinConns = v.GetInt("database.min_conns")
        }</span>
        <span class="cov6" title="4">if v.IsSet("database.conn_max_lifetime") </span><span class="cov1" title="1">{
                config.Database.ConnMaxLifetime = v.GetString("database.conn_max_lifetime")
        }</span>
        <span class="cov6" title="4">if v.IsSet("database.conn_max_idle_time") </span><span class="cov1" title="1">{
                config.Database.ConnMaxIdleTime = v.GetString("database.conn_max_idle_time")
        }</span>
        <span class="cov6" title="4">if v.IsSet("database.health_check_period") </span><span class="cov1" title="1">{
                config.Database.HealthCheckPeriod = v.GetString("database.health_check_period")
        }</span>
        <span class="cov6" title="4">if v.IsSet("database.run_migrations") </span><span class="cov1" title="1">{
                config.Database.RunMigrations = v.GetBool("database.run_migrations")
        }</span>
}

func applyLoggingOverrides(config *ArchesConfig, v *viper.Viper) <span class="cov6" title="4">{
        if v.IsSet("logging.level") </span><span class="cov3" title="2">{
                config.Logging.Level = LoggingConfigLevel(v.GetString("logging.level"))
        }</span>
        <span class="cov6" title="4">if v.IsSet("logging.pretty") </span><span class="cov3" title="2">{
                config.Logging.Pretty = v.GetBool("logging.pretty")
        }</span>
}

func applyRedisOverrides(config *ArchesConfig, v *viper.Viper) <span class="cov4" title="3">{
        if v.IsSet("redis.enabled") </span><span class="cov0" title="0">{
                config.Redis.Enabled = v.GetBool("redis.enabled")
        }</span>
        <span class="cov4" title="3">if v.IsSet("redis.host") </span><span class="cov0" title="0">{
                config.Redis.Host = v.GetString("redis.host")
        }</span>
        <span class="cov4" title="3">if v.IsSet("redis.port") </span><span class="cov0" title="0">{
                config.Redis.Port = float32(v.GetInt("redis.port"))
        }</span>
        <span class="cov4" title="3">if v.IsSet("redis.auth") </span><span class="cov0" title="0">{
                config.Redis.Auth = v.GetString("redis.auth")
        }</span>
}

func applyStorageOverrides(config *ArchesConfig, v *viper.Viper) <span class="cov4" title="3">{
        if v.IsSet("storage.enabled") </span><span class="cov0" title="0">{
                config.Storage.Enabled = v.GetBool("storage.enabled")
        }</span>
        <span class="cov4" title="3">if v.IsSet("storage.endpoint") </span><span class="cov0" title="0">{
                config.Storage.Endpoint = v.GetString("storage.endpoint")
        }</span>
        <span class="cov4" title="3">if v.IsSet("storage.bucket") </span><span class="cov0" title="0">{
                config.Storage.Bucket = v.GetString("storage.bucket")
        }</span>
        <span class="cov4" title="3">if v.IsSet("storage.access_key") </span><span class="cov0" title="0">{
                config.Storage.Accesskey = v.GetString("storage.access_key")
        }</span>
        <span class="cov4" title="3">if v.IsSet("storage.secret_key") </span><span class="cov0" title="0">{
                config.Storage.Secretkey = v.GetString("storage.secret_key")
        }</span>
}

func applyInfrastructureOverrides(config *ArchesConfig, v *viper.Viper) <span class="cov4" title="3">{
        if v.IsSet("infrastructure.namespace") </span><span class="cov0" title="0">{
                config.Infrastructure.Namespace = v.GetString("infrastructure.namespace")
        }</span>
        <span class="cov4" title="3">if v.IsSet("infrastructure.development.host_ip") </span><span class="cov0" title="0">{
                config.Infrastructure.Development.HostIP = v.GetString("infrastructure.development.host_ip")
        }</span>
}

func applyPlatformOverrides(config *ArchesConfig, v *viper.Viper) <span class="cov4" title="3">{
        if v.IsSet("platform.enabled") </span><span class="cov0" title="0">{
                config.Platform.Enabled = v.GetBool("platform.enabled")
        }</span>
}

func applyIngressOverrides(config *ArchesConfig, v *viper.Viper) <span class="cov4" title="3">{
        if v.IsSet("ingress.enabled") </span><span class="cov0" title="0">{
                config.Ingress.Enabled = v.GetBool("ingress.enabled")
        }</span>
        <span class="cov4" title="3">if v.IsSet("ingress.domain") </span><span class="cov0" title="0">{
                config.Ingress.Domain = v.GetString("ingress.domain")
        }</span>
}

func applyIntelligenceOverrides(config *ArchesConfig, v *viper.Viper) <span class="cov4" title="3">{
        if v.IsSet("intelligence.llm.type") </span><span class="cov0" title="0">{
                config.Intelligence.Llm.Type = LLMConfigType(v.GetString("intelligence.llm.type"))
        }</span>
        <span class="cov4" title="3">if v.IsSet("intelligence.llm.endpoint") </span><span class="cov0" title="0">{
                config.Intelligence.Llm.Endpoint = v.GetString("intelligence.llm.endpoint")
        }</span>
        <span class="cov4" title="3">if v.IsSet("intelligence.llm.token") </span><span class="cov0" title="0">{
                config.Intelligence.Llm.Token = v.GetString("intelligence.llm.token")
        }</span>
        <span class="cov4" title="3">if v.IsSet("intelligence.embedding.type") </span><span class="cov0" title="0">{
                config.Intelligence.Embedding.Type = EmbeddingConfigType(v.GetString("intelligence.embedding.type"))
        }</span>
}

func applyMonitoringOverrides(config *ArchesConfig, v *viper.Viper) <span class="cov4" title="3">{
        if v.IsSet("monitoring.grafana.enabled") </span><span class="cov0" title="0">{
                config.Monitoring.Grafana.Enabled = v.GetBool("monitoring.grafana.enabled")
        }</span>
        <span class="cov4" title="3">if v.IsSet("monitoring.loki.enabled") </span><span class="cov0" title="0">{
                config.Monitoring.Loki.Enabled = v.GetBool("monitoring.loki.enabled")
        }</span>
}

func applyBillingOverrides(config *ArchesConfig, v *viper.Viper) <span class="cov4" title="3">{
        if v.IsSet("billing.enabled") </span><span class="cov0" title="0">{
                config.Billing.Enabled = v.GetBool("billing.enabled")
        }</span>
        <span class="cov4" title="3">if v.IsSet("billing.stripe.token") </span><span class="cov0" title="0">{
                config.Billing.Stripe.Token = v.GetString("billing.stripe.token")
        }</span>
        <span class="cov4" title="3">if v.IsSet("billing.stripe.whsec") </span><span class="cov0" title="0">{
                config.Billing.Stripe.Whsec = v.GetString("billing.stripe.whsec")
        }</span>
}

// Helper methods for backward compatibility and convenience

// GetAllowedOrigins returns CORS allowed origins as a slice
func (c *Config) GetAllowedOrigins() []string <span class="cov0" title="0">{
        origins := c.Api.Cors.Origins
        if origins == "" </span><span class="cov0" title="0">{
                return []string{}
        }</span>
        <span class="cov0" title="0">return strings.Split(origins, ",")</span>
}

// GetServerAddress returns the formatted server address
func (c *Config) GetServerAddress() string <span class="cov0" title="0">{
        return fmt.Sprintf("%s:%d", c.Api.Host, int(c.Api.Port))
}</span>

// ParseDuration parses a duration string and returns time.Duration
func ParseDuration(s string) (time.Duration, error) <span class="cov0" title="0">{
        return time.ParseDuration(s)
}</span>

// GetJWTSecret returns the JWT secret for authentication
func (c *Config) GetJWTSecret() string <span class="cov0" title="0">{
        return c.Auth.Local.JwtSecret
}</span>

// GetAccessTokenTTL returns the access token TTL as a Duration
func (c *Config) GetAccessTokenTTL() (time.Duration, error) <span class="cov0" title="0">{
        if c.Auth.Local.AccessTokenTtl != "" </span><span class="cov0" title="0">{
                return ParseDuration(c.Auth.Local.AccessTokenTtl)
        }</span>
        <span class="cov0" title="0">return 15 * time.Minute, nil</span> // default
}

// GetRefreshTokenTTL returns the refresh token TTL as a Duration
func (c *Config) GetRefreshTokenTTL() (time.Duration, error) <span class="cov0" title="0">{
        if c.Auth.Local.RefreshTokenTtl != "" </span><span class="cov0" title="0">{
                return ParseDuration(c.Auth.Local.RefreshTokenTtl)
        }</span>
        <span class="cov0" title="0">return 168 * time.Hour, nil</span> // default 7 days
}
</pre>
		
		<pre class="file" id="file55" style="display: none">// Package config provides primitives to interact with the openapi HTTP API.
//
// Code generated by github.com/oapi-codegen/oapi-codegen/v2 version v2.5.0 DO NOT EDIT.
package config

import (
        "encoding/json"

        "github.com/oapi-codegen/runtime"
)

const (
        BearerAuthScopes    = "bearerAuth.Scopes"
        SessionCookieScopes = "sessionCookie.Scopes"
)

// Defines values for APIConfigEnvironment.
const (
        Development APIConfigEnvironment = "development"
        Production  APIConfigEnvironment = "production"
        Staging     APIConfigEnvironment = "staging"
)

// Defines values for DatabaseConfigType.
const (
        Postgresql DatabaseConfigType = "postgresql"
        Sqlite     DatabaseConfigType = "sqlite"
)

// Defines values for EmbeddingConfigType.
const (
        EmbeddingConfigTypeOllama EmbeddingConfigType = "ollama"
        EmbeddingConfigTypeOpenai EmbeddingConfigType = "openai"
)

// Defines values for ImageConfigPullPolicy.
const (
        Always       ImageConfigPullPolicy = "Always"
        IfNotPresent ImageConfigPullPolicy = "IfNotPresent"
        Never        ImageConfigPullPolicy = "Never"
)

// Defines values for LLMConfigType.
const (
        LLMConfigTypeOllama LLMConfigType = "ollama"
        LLMConfigTypeOpenai LLMConfigType = "openai"
)

// Defines values for LoggingConfigLevel.
const (
        Debug  LoggingConfigLevel = "debug"
        Error  LoggingConfigLevel = "error"
        Fatal  LoggingConfigLevel = "fatal"
        Info   LoggingConfigLevel = "info"
        Silent LoggingConfigLevel = "silent"
        Trace  LoggingConfigLevel = "trace"
        Warn   LoggingConfigLevel = "warn"
)

// APIConfig Configuration schema for the API server
type APIConfig struct {
        // Cors CORS configuration for the API server
        Cors CORSConfig `json:"cors" yaml:"cors"`

        // Docs Enable or disable API documentation
        Docs bool `json:"docs" yaml:"docs"`

        // Email Email configuration for sending emails
        Email EmailConfig `json:"email" yaml:"email"`

        // Environment Deployment environment (development, staging, production)
        Environment APIConfigEnvironment `json:"environment,omitempty,omitzero" yaml:"environment,omitempty"`

        // Host The host address on which the API server will listen
        Host string `json:"host" yaml:"host"`

        // Image Container image configuration
        Image ImageConfig `json:"image" yaml:"image"`

        // Port The port on which the API server will listen
        Port float32 `json:"port" yaml:"port"`

        // Resources Kubernetes resource configuration
        Resources ResourceConfig `json:"resources" yaml:"resources"`

        // Validate Enable or disable request validation
        Validate bool `json:"validate" yaml:"validate"`
}

// APIConfigEnvironment Deployment environment (development, staging, production)
type APIConfigEnvironment string

// ArchesConfig Arches AI configuration schema
type ArchesConfig struct {
        // Api Configuration schema for the API server
        Api APIConfig `json:"api" yaml:"api"`

        // Auth Authentication configuration for the API server
        Auth AuthConfig `json:"auth" yaml:"auth"`

        // Billing Billing configuration for Stripe
        Billing BillingConfig `json:"billing" yaml:"billing"`

        // Database Database configuration for PostgreSQL
        Database DatabaseConfig `json:"database" yaml:"database"`

        // Infrastructure Infrastructure configuration for Kubernetes deployments
        Infrastructure InfrastructureConfig `json:"infrastructure" yaml:"infrastructure"`

        // Ingress Ingress configuration
        Ingress IngressConfig `json:"ingress" yaml:"ingress"`

        // Intelligence Intelligence configuration (LLMs, embeddings, scraper, speech, etc.)
        Intelligence IntelligenceConfig `json:"intelligence" yaml:"intelligence"`

        // Logging Logging configuration
        Logging LoggingConfig `json:"logging" yaml:"logging"`

        // Monitoring Monitoring configuration for Grafana and Loki
        Monitoring MonitoringConfig `json:"monitoring" yaml:"monitoring"`

        // Platform Platform configuration (host, image, resources)
        Platform PlatformConfig `json:"platform" yaml:"platform"`

        // Redis Redis configuration
        Redis RedisConfig `json:"redis" yaml:"redis"`

        // Storage Object storage configuration for MinIO or S3-compatible services
        Storage StorageConfig `json:"storage" yaml:"storage"`
}

// AuthConfig Authentication configuration for the API server
type AuthConfig struct {
        // Enabled Enable authentication
        Enabled bool `json:"enabled" yaml:"enabled"`

        // Firebase Firebase authentication configuration
        Firebase FirebaseAuth `json:"firebase,omitempty,omitzero" yaml:"firebase,omitempty"`

        // Local Local username/password authentication
        Local LocalAuth `json:"local,omitempty,omitzero" yaml:"local,omitempty"`

        // Twitter Twitter OAuth configuration
        Twitter TwitterAuth `json:"twitter,omitempty,omitzero" yaml:"twitter,omitempty"`
}

// BillingConfig Billing configuration for Stripe
type BillingConfig struct {
        // Enabled Enable billing functionality
        Enabled bool `json:"enabled" yaml:"enabled"`

        // Stripe Stripe payment configuration
        Stripe StripeConfig `json:"stripe,omitempty,omitzero" yaml:"stripe,omitempty"`
}

// CORSConfig CORS configuration for the API server
type CORSConfig struct {
        // Origins A comma-separated list of allowed origins for CORS requests
        Origins string `json:"origins" yaml:"origins"`
}

// DatabaseAuth Database authentication credentials
type DatabaseAuth struct {
        // Database Database name
        Database string `json:"database" yaml:"database"`

        // Password Database user password
        Password string `json:"password" yaml:"password"`
}

// DatabaseConfig Database configuration for PostgreSQL
type DatabaseConfig struct {
        // Auth Database authentication credentials
        Auth DatabaseAuth `json:"auth,omitempty,omitzero" yaml:"auth,omitempty"`

        // ConnMaxIdleTime Maximum connection idle time (e.g., "5m")
        ConnMaxIdleTime string `json:"connMaxIdleTime,omitempty,omitzero" yaml:"connMaxIdleTime,omitempty"`

        // ConnMaxLifetime Maximum connection lifetime (e.g., "30m")
        ConnMaxLifetime string `json:"connMaxLifetime,omitempty,omitzero" yaml:"connMaxLifetime,omitempty"`

        // Enabled Enable database
        Enabled bool `json:"enabled" yaml:"enabled"`

        // HealthCheckPeriod Health check period for connections (PostgreSQL)
        HealthCheckPeriod string `json:"healthCheckPeriod,omitempty,omitzero" yaml:"healthCheckPeriod,omitempty"`

        // Image Container image configuration
        Image ImageConfig `json:"image,omitempty,omitzero" yaml:"image,omitempty"`

        // Managed Use managed database deployment
        Managed bool `json:"managed,omitempty,omitzero" yaml:"managed,omitempty"`

        // MaxConns Maximum number of connections in pool (PostgreSQL)
        MaxConns int `json:"maxConns,omitempty,omitzero" yaml:"maxConns,omitempty"`

        // MinConns Minimum number of connections in pool (PostgreSQL)
        MinConns int `json:"minConns,omitempty,omitzero" yaml:"minConns,omitempty"`

        // Persistence Persistent storage configuration
        Persistence PersistenceConfig `json:"persistence,omitempty,omitzero" yaml:"persistence,omitempty"`

        // Resources Kubernetes resource configuration
        Resources ResourceConfig `json:"resources,omitempty,omitzero" yaml:"resources,omitempty"`

        // RunMigrations Automatically run database migrations on startup
        RunMigrations bool `json:"runMigrations,omitempty,omitzero" yaml:"runMigrations,omitempty"`

        // Type Database type (postgresql or sqlite)
        Type DatabaseConfigType `json:"type,omitempty,omitzero" yaml:"type,omitempty"`

        // Url Database connection URL/string
        Url string `json:"url" yaml:"url"`
}

// DatabaseConfigType Database type (postgresql or sqlite)
type DatabaseConfigType string

// DevServiceConfig Development service port forwarding configuration
type DevServiceConfig struct {
        // Enabled Enable dev port forwarding
        Enabled bool `json:"enabled" yaml:"enabled"`

        // Port Local port for forwarding
        Port float32 `json:"port" yaml:"port"`
}

// DevelopmentConfig Development environment configuration
type DevelopmentConfig struct {
        // Api Development service port forwarding configuration
        Api DevServiceConfig `json:"api" yaml:"api"`

        // HostIP Host IP address for dev port forwarding
        HostIP string `json:"hostIP" yaml:"hostIP"`

        // Loki Development service port forwarding configuration
        Loki DevServiceConfig `json:"loki" yaml:"loki"`

        // Platform Development service port forwarding configuration
        Platform DevServiceConfig `json:"platform" yaml:"platform"`

        // Postgres Development service port forwarding configuration
        Postgres DevServiceConfig `json:"postgres" yaml:"postgres"`

        // Redis Development service port forwarding configuration
        Redis DevServiceConfig `json:"redis" yaml:"redis"`
}

// EmailConfig Email configuration for sending emails
type EmailConfig struct {
        // Enabled Enable email functionality
        Enabled bool `json:"enabled" yaml:"enabled"`

        // Password Password for the email service
        Password string `json:"password,omitempty,omitzero" yaml:"password,omitempty"`

        // Service Email service provider (e.g., "gmail", "sendgrid", etc.)
        Service string `json:"service,omitempty,omitzero" yaml:"service,omitempty"`

        // User Username for the email service
        User string `json:"user,omitempty,omitzero" yaml:"user,omitempty"`
}

// EmbeddingConfig Configuration for text embedding generation
type EmbeddingConfig struct {
        // Type The embedding provider to use for vector embeddings
        Type EmbeddingConfigType `json:"type" yaml:"type"`
}

// EmbeddingConfigType The embedding provider to use for vector embeddings
type EmbeddingConfigType string

// FirebaseAuth Firebase authentication configuration
type FirebaseAuth struct {
        // ClientEmail Firebase service account client email address
        ClientEmail string `json:"clientEmail,omitempty,omitzero" yaml:"clientEmail,omitempty"`

        // Enabled Enable Firebase authentication
        Enabled bool `json:"enabled" yaml:"enabled"`

        // PrivateKey Firebase service account private key (PEM format)
        PrivateKey string `json:"privateKey,omitempty,omitzero" yaml:"privateKey,omitempty"`

        // ProjectId Firebase project ID for authentication
        ProjectId string `json:"projectId,omitempty,omitzero" yaml:"projectId,omitempty"`
}

// GrafanaConfig Grafana monitoring dashboard configuration
type GrafanaConfig struct {
        // Enabled Enable Grafana
        Enabled bool `json:"enabled" yaml:"enabled"`

        // Image Container image configuration
        Image ImageConfig `json:"image,omitempty,omitzero" yaml:"image,omitempty"`

        // Managed Use managed Grafana deployment
        Managed bool `json:"managed,omitempty,omitzero" yaml:"managed,omitempty"`

        // Resources Kubernetes resource configuration
        Resources ResourceConfig `json:"resources,omitempty,omitzero" yaml:"resources,omitempty"`
}

// ImageConfig Container image configuration
type ImageConfig struct {
        // PullPolicy Kubernetes image pull policy
        PullPolicy ImageConfigPullPolicy `json:"pullPolicy" yaml:"pullPolicy"`

        // Repository Container image repository
        Repository string `json:"repository" yaml:"repository"`

        // Tag Container image tag
        Tag string `json:"tag" yaml:"tag"`
}

// ImageConfigPullPolicy Kubernetes image pull policy
type ImageConfigPullPolicy string

// ImagesConfig Container image configuration
type ImagesConfig struct {
        // ImagePullSecrets List of Kubernetes secrets for pulling private images
        ImagePullSecrets []string `json:"imagePullSecrets" yaml:"imagePullSecrets"`

        // ImageRegistry Custom container registry URL (leave empty for Docker Hub)
        ImageRegistry string `json:"imageRegistry" yaml:"imageRegistry"`
}

// InfrastructureConfig Infrastructure configuration for Kubernetes deployments
type InfrastructureConfig struct {
        // Development Development environment configuration
        Development DevelopmentConfig `json:"development" yaml:"development"`

        // Images Container image configuration
        Images ImagesConfig `json:"images" yaml:"images"`

        // Migrations Database migration configuration
        Migrations MigrationsConfig `json:"migrations" yaml:"migrations"`

        // Namespace Kubernetes namespace where all resources will be deployed
        Namespace string `json:"namespace" yaml:"namespace"`

        // ServiceAccount Kubernetes service account configuration
        ServiceAccount ServiceAccountConfig `json:"serviceAccount" yaml:"serviceAccount"`
}

// IngressConfig Ingress configuration
type IngressConfig struct {
        // Domain Primary domain name for ingress routing
        Domain string `json:"domain,omitempty,omitzero" yaml:"domain,omitempty"`

        // Enabled Enable ingress
        Enabled bool `json:"enabled" yaml:"enabled"`

        // Tls TLS configuration
        Tls TLSConfig `json:"tls,omitempty,omitzero" yaml:"tls,omitempty"`
}

// IntelligenceConfig Intelligence configuration (LLMs, embeddings, scraper, speech, etc.)
type IntelligenceConfig struct {
        // Embedding Configuration for text embedding generation
        Embedding EmbeddingConfig `json:"embedding" yaml:"embedding"`

        // Llm Large Language Model configuration
        Llm LLMConfig `json:"llm" yaml:"llm"`

        // Runpod RunPod serverless GPU configuration
        Runpod RunPodConfig `json:"runpod" yaml:"runpod"`

        // Scraper Web scraping service configuration
        Scraper ScraperConfig `json:"scraper" yaml:"scraper"`

        // Speech Speech recognition and TTS services
        Speech SpeechConfig `json:"speech" yaml:"speech"`

        // Unstructured Unstructured.io service for document parsing
        Unstructured UnstructuredConfig `json:"unstructured" yaml:"unstructured"`
}

// LLMConfig Large Language Model configuration
type LLMConfig struct {
        // Endpoint LLM service endpoint URL
        Endpoint string `json:"endpoint,omitempty,omitzero" yaml:"endpoint,omitempty"`

        // Token Authentication token for LLM service
        Token string `json:"token,omitempty,omitzero" yaml:"token,omitempty"`

        // Type LLM provider type
        Type LLMConfigType `json:"type" yaml:"type"`
}

// LLMConfigType LLM provider type
type LLMConfigType string

// LocalAuth Local username/password authentication
type LocalAuth struct {
        // AccessTokenTtl Access token time-to-live duration (e.g., "15m", "1h")
        AccessTokenTtl string `json:"accessTokenTtl" yaml:"accessTokenTtl"`

        // Enabled Enable local authentication
        Enabled bool `json:"enabled" yaml:"enabled"`

        // JwtSecret Secret key for JWT token signing
        JwtSecret string `json:"jwtSecret" yaml:"jwtSecret"`

        // RefreshTokenTtl Refresh token time-to-live duration (e.g., "7d", "168h")
        RefreshTokenTtl string `json:"refreshTokenTtl" yaml:"refreshTokenTtl"`
}

// LoggingConfig Logging configuration
type LoggingConfig struct {
        // Level Minimum log level to output
        Level LoggingConfigLevel `json:"level" yaml:"level"`

        // Pretty Enable pretty-printed logs for development
        Pretty bool `json:"pretty" yaml:"pretty"`
}

// LoggingConfigLevel Minimum log level to output
type LoggingConfigLevel string

// LokiConfig Loki log aggregation service configuration
type LokiConfig struct {
        // Enabled Enable Loki
        Enabled bool `json:"enabled" yaml:"enabled"`

        // Host Loki host URL
        Host string `json:"host,omitempty,omitzero" yaml:"host,omitempty"`

        // Image Container image configuration
        Image ImageConfig `json:"image,omitempty,omitzero" yaml:"image,omitempty"`

        // Managed Use managed Loki deployment
        Managed bool `json:"managed,omitempty,omitzero" yaml:"managed,omitempty"`

        // Resources Kubernetes resource configuration
        Resources ResourceConfig `json:"resources,omitempty,omitzero" yaml:"resources,omitempty"`
}

// MigrationsConfig Database migration configuration
type MigrationsConfig struct {
        // Enabled Enable automatic DB migrations
        Enabled bool `json:"enabled" yaml:"enabled"`
}

// MonitoringConfig Monitoring configuration for Grafana and Loki
type MonitoringConfig struct {
        // Grafana Grafana monitoring dashboard configuration
        Grafana GrafanaConfig `json:"grafana" yaml:"grafana"`

        // Loki Loki log aggregation service configuration
        Loki LokiConfig `json:"loki" yaml:"loki"`
}

// PersistenceConfig Persistent storage configuration
type PersistenceConfig struct {
        // Enabled Enable persistent storage
        Enabled bool `json:"enabled" yaml:"enabled"`

        // Size Size of persistent volume
        Size string `json:"size" yaml:"size"`
}

// PlatformConfig Platform configuration (host, image, resources)
type PlatformConfig struct {
        // Enabled Enable platform service
        Enabled bool `json:"enabled" yaml:"enabled"`

        // Host Host address where the platform service will be accessible
        Host string `json:"host,omitempty,omitzero" yaml:"host,omitempty"`

        // Image Container image configuration
        Image ImageConfig `json:"image,omitempty,omitzero" yaml:"image,omitempty"`

        // Managed Use managed platform deployment
        Managed bool `json:"managed,omitempty,omitzero" yaml:"managed,omitempty"`

        // Resources Kubernetes resource configuration
        Resources ResourceConfig `json:"resources,omitempty,omitzero" yaml:"resources,omitempty"`
}

// Problem RFC 7807 (Problem Details) compliant error response
type Problem struct {
        // Detail Human-readable explanation specific to this occurrence
        Detail string `json:"detail" yaml:"detail"`

        // Errors Additional validation errors for specific fields
        Errors []ValidationError `json:"errors,omitempty,omitzero" yaml:"errors,omitempty"`

        // Instance URI identifying the specific occurrence
        Instance string `json:"instance,omitempty,omitzero" yaml:"instance,omitempty"`

        // Status HTTP status code
        Status int `json:"status" yaml:"status"`

        // Title Short, human-readable summary
        Title string `json:"title" yaml:"title"`

        // Type URI identifying the problem type
        Type string `json:"type" yaml:"type"`
}

// RedisConfig Redis configuration
type RedisConfig struct {
        // Auth Redis authentication password
        Auth string `json:"auth" yaml:"auth"`

        // Ca Certificate Authority for TLS (optional)
        Ca string `json:"ca,omitempty,omitzero" yaml:"ca,omitempty"`

        // Enabled Enable Redis
        Enabled bool `json:"enabled" yaml:"enabled"`

        // Host Redis hostname or IP
        Host string `json:"host" yaml:"host"`

        // Image Container image configuration
        Image ImageConfig `json:"image,omitempty,omitzero" yaml:"image,omitempty"`

        // Managed Use managed Redis deployment
        Managed bool `json:"managed,omitempty,omitzero" yaml:"managed,omitempty"`

        // Persistence Persistent storage configuration
        Persistence PersistenceConfig `json:"persistence,omitempty,omitzero" yaml:"persistence,omitempty"`

        // Port Redis port number
        Port float32 `json:"port" yaml:"port"`

        // Resources Kubernetes resource configuration
        Resources ResourceConfig `json:"resources,omitempty,omitzero" yaml:"resources,omitempty"`
}

// ResourceConfig Kubernetes resource configuration
type ResourceConfig struct {
        // Limits Resource limits
        Limits ResourceLimits `json:"limits" yaml:"limits"`

        // Requests Resource requests
        Requests ResourceRequests `json:"requests" yaml:"requests"`
}

// ResourceLimits Resource limits
type ResourceLimits struct {
        // Cpu Maximum CPU allocation
        Cpu string `json:"cpu" yaml:"cpu"`

        // Memory Maximum memory allocation
        Memory string `json:"memory" yaml:"memory"`
}

// ResourceRequests Resource requests
type ResourceRequests struct {
        // Cpu Requested CPU allocation
        Cpu string `json:"cpu" yaml:"cpu"`

        // Memory Requested memory allocation
        Memory string `json:"memory" yaml:"memory"`
}

// RunPodConfig RunPod serverless GPU configuration
type RunPodConfig struct {
        // Enabled Enable RunPod integration
        Enabled bool `json:"enabled" yaml:"enabled"`

        // Token RunPod API token
        Token string `json:"token,omitempty,omitzero" yaml:"token,omitempty"`
}

// ScraperConfig Web scraping service configuration
type ScraperConfig struct {
        // Enabled Enable scraper service
        Enabled bool `json:"enabled" yaml:"enabled"`

        // Endpoint Web scraper service endpoint URL
        Endpoint string `json:"endpoint,omitempty,omitzero" yaml:"endpoint,omitempty"`

        // Image Container image configuration
        Image ImageConfig `json:"image,omitempty,omitzero" yaml:"image,omitempty"`

        // Managed Use managed scraper deployment
        Managed bool `json:"managed,omitempty,omitzero" yaml:"managed,omitempty"`

        // Resources Kubernetes resource configuration
        Resources ResourceConfig `json:"resources,omitempty,omitzero" yaml:"resources,omitempty"`
}

// ServiceAccountConfig Kubernetes service account configuration
type ServiceAccountConfig struct {
        // Create Create dedicated service account
        Create bool `json:"create" yaml:"create"`

        // Name Custom service account name
        Name string `json:"name" yaml:"name"`
}

// SpeechConfig Speech recognition and TTS services
type SpeechConfig struct {
        // Enabled Enable speech services
        Enabled bool `json:"enabled" yaml:"enabled"`

        // Token Speech-to-text service API token
        Token string `json:"token,omitempty,omitzero" yaml:"token,omitempty"`
}

// StorageConfig Object storage configuration for MinIO or S3-compatible services
type StorageConfig struct {
        // Accesskey MinIO/S3 access key ID
        Accesskey string `json:"accesskey" yaml:"accesskey"`

        // Bucket S3 bucket name
        Bucket string `json:"bucket" yaml:"bucket"`

        // Enabled Enable object storage
        Enabled bool `json:"enabled" yaml:"enabled"`

        // Endpoint MinIO server endpoint URL
        Endpoint string `json:"endpoint" yaml:"endpoint"`

        // Image Container image configuration
        Image ImageConfig `json:"image,omitempty,omitzero" yaml:"image,omitempty"`

        // Managed Use managed storage deployment
        Managed bool `json:"managed,omitempty,omitzero" yaml:"managed,omitempty"`

        // Persistence Persistent storage configuration
        Persistence PersistenceConfig `json:"persistence,omitempty,omitzero" yaml:"persistence,omitempty"`

        // Resources Kubernetes resource configuration
        Resources ResourceConfig `json:"resources,omitempty,omitzero" yaml:"resources,omitempty"`

        // Secretkey MinIO/S3 secret access key
        Secretkey string `json:"secretkey" yaml:"secretkey"`
}

// StripeConfig Stripe payment configuration
type StripeConfig struct {
        // Token Stripe secret API key
        Token string `json:"token" yaml:"token"`

        // Whsec Stripe webhook endpoint secret
        Whsec string `json:"whsec" yaml:"whsec"`
}

// TLSConfig TLS configuration
type TLSConfig struct {
        // Enabled Enable TLS/SSL
        Enabled bool `json:"enabled" yaml:"enabled"`

        // Issuer Cert-manager ClusterIssuer
        Issuer string `json:"issuer,omitempty,omitzero" yaml:"issuer,omitempty"`

        // SecretName Kubernetes secret name for TLS certificates
        SecretName string `json:"secretName" yaml:"secretName"`
}

// TwitterAuth Twitter OAuth configuration
type TwitterAuth struct {
        // CallbackURL OAuth callback URL
        CallbackURL string `json:"callbackURL,omitempty,omitzero" yaml:"callbackURL,omitempty"`

        // ConsumerKey Twitter API consumer key
        ConsumerKey string `json:"consumerKey,omitempty,omitzero" yaml:"consumerKey,omitempty"`

        // ConsumerSecret Twitter API consumer secret
        ConsumerSecret string `json:"consumerSecret,omitempty,omitzero" yaml:"consumerSecret,omitempty"`

        // Enabled Enable Twitter OAuth
        Enabled bool `json:"enabled" yaml:"enabled"`
}

// UnstructuredConfig Unstructured.io service for document parsing
type UnstructuredConfig struct {
        // Enabled Enable unstructured document parsing
        Enabled bool `json:"enabled" yaml:"enabled"`

        // Image Container image configuration
        Image ImageConfig `json:"image,omitempty,omitzero" yaml:"image,omitempty"`

        // Managed Use managed unstructured deployment
        Managed bool `json:"managed,omitempty,omitzero" yaml:"managed,omitempty"`

        // Resources Kubernetes resource configuration
        Resources ResourceConfig `json:"resources,omitempty,omitzero" yaml:"resources,omitempty"`
}

// ValidationError Individual field validation error
type ValidationError struct {
        // Field The field path that failed validation
        Field string `json:"field" yaml:"field"`

        // Message Human-readable error message
        Message string `json:"message" yaml:"message"`

        // Value The invalid value that was provided
        Value ValidationError_Value `json:"value,omitempty,omitzero" yaml:"value,omitempty"`
}

// ValidationErrorValue0 defines model for .
type ValidationErrorValue0 = string

// ValidationErrorValue1 defines model for .
type ValidationErrorValue1 = float32

// ValidationErrorValue2 defines model for .
type ValidationErrorValue2 = bool

// ValidationError_Value The invalid value that was provided
type ValidationError_Value struct {
        union json.RawMessage
}

// BadRequest RFC 7807 (Problem Details) compliant error response
type BadRequest = Problem

// AsValidationErrorValue0 returns the union data inside the ValidationError_Value as a ValidationErrorValue0
func (t ValidationError_Value) AsValidationErrorValue0() (ValidationErrorValue0, error) <span class="cov0" title="0">{
        var body ValidationErrorValue0
        err := json.Unmarshal(t.union, &amp;body)
        return body, err
}</span>

// FromValidationErrorValue0 overwrites any union data inside the ValidationError_Value as the provided ValidationErrorValue0
func (t *ValidationError_Value) FromValidationErrorValue0(v ValidationErrorValue0) error <span class="cov0" title="0">{
        b, err := json.Marshal(v)
        t.union = b
        return err
}</span>

// MergeValidationErrorValue0 performs a merge with any union data inside the ValidationError_Value, using the provided ValidationErrorValue0
func (t *ValidationError_Value) MergeValidationErrorValue0(v ValidationErrorValue0) error <span class="cov0" title="0">{
        b, err := json.Marshal(v)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov0" title="0">merged, err := runtime.JSONMerge(t.union, b)
        t.union = merged
        return err</span>
}

// AsValidationErrorValue1 returns the union data inside the ValidationError_Value as a ValidationErrorValue1
func (t ValidationError_Value) AsValidationErrorValue1() (ValidationErrorValue1, error) <span class="cov0" title="0">{
        var body ValidationErrorValue1
        err := json.Unmarshal(t.union, &amp;body)
        return body, err
}</span>

// FromValidationErrorValue1 overwrites any union data inside the ValidationError_Value as the provided ValidationErrorValue1
func (t *ValidationError_Value) FromValidationErrorValue1(v ValidationErrorValue1) error <span class="cov0" title="0">{
        b, err := json.Marshal(v)
        t.union = b
        return err
}</span>

// MergeValidationErrorValue1 performs a merge with any union data inside the ValidationError_Value, using the provided ValidationErrorValue1
func (t *ValidationError_Value) MergeValidationErrorValue1(v ValidationErrorValue1) error <span class="cov0" title="0">{
        b, err := json.Marshal(v)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov0" title="0">merged, err := runtime.JSONMerge(t.union, b)
        t.union = merged
        return err</span>
}

// AsValidationErrorValue2 returns the union data inside the ValidationError_Value as a ValidationErrorValue2
func (t ValidationError_Value) AsValidationErrorValue2() (ValidationErrorValue2, error) <span class="cov0" title="0">{
        var body ValidationErrorValue2
        err := json.Unmarshal(t.union, &amp;body)
        return body, err
}</span>

// FromValidationErrorValue2 overwrites any union data inside the ValidationError_Value as the provided ValidationErrorValue2
func (t *ValidationError_Value) FromValidationErrorValue2(v ValidationErrorValue2) error <span class="cov0" title="0">{
        b, err := json.Marshal(v)
        t.union = b
        return err
}</span>

// MergeValidationErrorValue2 performs a merge with any union data inside the ValidationError_Value, using the provided ValidationErrorValue2
func (t *ValidationError_Value) MergeValidationErrorValue2(v ValidationErrorValue2) error <span class="cov0" title="0">{
        b, err := json.Marshal(v)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov0" title="0">merged, err := runtime.JSONMerge(t.union, b)
        t.union = merged
        return err</span>
}

func (t ValidationError_Value) MarshalJSON() ([]byte, error) <span class="cov0" title="0">{
        b, err := t.union.MarshalJSON()
        return b, err
}</span>

func (t *ValidationError_Value) UnmarshalJSON(b []byte) error <span class="cov0" title="0">{
        err := t.union.UnmarshalJSON(b)
        return err
}</span>
</pre>
		
		<pre class="file" id="file56" style="display: none">// Package database provides data persistence infrastructure including
// database connections, query generation, and migrations.
//
// The package includes:
// - Database abstraction layer supporting PostgreSQL and SQLite
// - Type-safe query generation using sqlc
// - Database migrations using goose
// - Connection pooling and health checks
// - Transaction management
package database

import (
        "context"
        "database/sql"
        "strings"
)

// Type represents the database type
type Type string

// Database type constants
const (
        TypePostgreSQL Type = "postgresql" // PostgreSQL database
        TypeSQLite     Type = "sqlite"     // SQLite database
)

// String converts Type to string
func (t Type) String() string <span class="cov0" title="0">{
        switch t </span>{
        case TypePostgreSQL:<span class="cov0" title="0">
                return "postgresql"</span>
        case TypeSQLite:<span class="cov0" title="0">
                return "sqlite"</span>
        default:<span class="cov0" title="0">
                return "unknown"</span>
        }
}

// Database defines the common interface for all database implementations
type Database interface {
        // Core operations
        Query(ctx context.Context, query string, args ...interface{}) (Rows, error)
        QueryRow(ctx context.Context, query string, args ...interface{}) Row
        Exec(ctx context.Context, query string, args ...interface{}) (Result, error)

        // Transaction support
        Begin(ctx context.Context) (Transaction, error)
        BeginTx(ctx context.Context, opts *sql.TxOptions) (Transaction, error)

        // Connection management
        Ping(ctx context.Context) error
        Close() error
        Stats() Stats

        // Database type identification
        Type() Type

        // Get underlying connection for driver-specific operations
        // Returns *sql.DB for SQLite, *pgxpool.Pool for PostgreSQL
        Underlying() interface{}
}

// Transaction defines the interface for database transactions
type Transaction interface {
        Query(ctx context.Context, query string, args ...interface{}) (Rows, error)
        QueryRow(ctx context.Context, query string, args ...interface{}) Row
        Exec(ctx context.Context, query string, args ...interface{}) (Result, error)
        Commit() error
        Rollback() error
}

// Rows defines the interface for query result rows
type Rows interface {
        Next() bool
        Scan(dest ...interface{}) error
        Close() error
        Err() error
}

// Row defines the interface for a single query result row
type Row interface {
        Scan(dest ...interface{}) error
}

// Result defines the interface for exec results
type Result interface {
        LastInsertId() (int64, error)
        RowsAffected() (int64, error)
}

// Stats represents database connection pool statistics
type Stats struct {
        OpenConnections   int
        InUse             int
        Idle              int
        WaitCount         int64
        WaitDuration      string
        MaxIdleClosed     int64
        MaxLifetimeClosed int64
}

// ParseTypeFromString converts a string to database Type
func ParseTypeFromString(s string) Type <span class="cov0" title="0">{
        switch s </span>{
        case "postgresql", "postgres", "pg":<span class="cov0" title="0">
                return TypePostgreSQL</span>
        case "sqlite", "sqlite3":<span class="cov0" title="0">
                return TypeSQLite</span>
        default:<span class="cov0" title="0">
                return TypePostgreSQL</span> // Default to PostgreSQL
        }
}

// DetectTypeFromURL auto-detects database type from connection URL
func DetectTypeFromURL(url string) Type <span class="cov0" title="0">{
        if strings.HasPrefix(url, "postgresql://") || strings.HasPrefix(url, "postgres://") </span><span class="cov0" title="0">{
                return TypePostgreSQL
        }</span>
        <span class="cov0" title="0">if strings.HasPrefix(url, "sqlite://") || strings.Contains(url, ".db") || url == ":memory:" </span><span class="cov0" title="0">{
                return TypeSQLite
        }</span>
        <span class="cov0" title="0">return TypePostgreSQL</span> // Default to PostgreSQL
}
</pre>
		
		<pre class="file" id="file57" style="display: none">package database

import (
        "fmt"
        "log/slog"

        "github.com/archesai/archesai/internal/config"
)

// Factory creates database instances based on configuration
type Factory struct {
        logger *slog.Logger
}

// NewFactory creates a new database factory
func NewFactory(logger *slog.Logger) *Factory <span class="cov0" title="0">{
        return &amp;Factory{
                logger: logger,
        }
}</span>

// Create creates a new database connection based on the provided configuration
func (f *Factory) Create(cfg *config.DatabaseConfig) (Database, error) <span class="cov0" title="0">{
        if cfg == nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("database config is nil")
        }</span>

        // Determine database type from config or URL
        <span class="cov0" title="0">var dbType Type
        if cfg.Type != "" </span><span class="cov0" title="0">{
                dbType = ParseTypeFromString(string(cfg.Type))
        }</span> else<span class="cov0" title="0"> {
                dbType = DetectTypeFromURL(cfg.Url)
        }</span>

        <span class="cov0" title="0">switch dbType </span>{
        case TypePostgreSQL:<span class="cov0" title="0">
                return NewPostgreSQL(cfg, f.logger)</span>
        case TypeSQLite:<span class="cov0" title="0">
                return NewSQLite(cfg, f.logger)</span>
        default:<span class="cov0" title="0">
                return nil, fmt.Errorf("unsupported database type: %s", dbType)</span>
        }
}

// CreateFromURL creates a database connection from a connection URL
// It auto-detects the database type from the URL scheme
func (f *Factory) CreateFromURL(url string) (Database, error) <span class="cov0" title="0">{
        dbType := DetectTypeFromURL(url)
        cfg := &amp;config.DatabaseConfig{
                Enabled: true,
                Url:     url,
                Type:    config.DatabaseConfigType(dbType),
        }
        return f.Create(cfg)
}</span>
</pre>
		
		<pre class="file" id="file58" style="display: none">package database

import (
        "context"
        "database/sql"
        "fmt"
        "log/slog"
        "time"

        "github.com/archesai/archesai/internal/config"
        "github.com/jackc/pgx/v5"
        "github.com/jackc/pgx/v5/pgconn"
        "github.com/jackc/pgx/v5/pgxpool"
        _ "github.com/jackc/pgx/v5/stdlib" // PostgreSQL driver for database/sql compatibility
)

// PGDatabase implements the Database interface for PostgreSQL
type PGDatabase struct {
        pool   *pgxpool.Pool
        sqlDB  *sql.DB // For stdlib compatibility when needed
        logger *slog.Logger
}

// NewPostgreSQL creates a new PostgreSQL database connection
func NewPostgreSQL(cfg *config.DatabaseConfig, logger *slog.Logger) (Database, error) <span class="cov0" title="0">{
        ctx := context.Background()

        // Parse the connection string
        poolConfig, err := pgxpool.ParseConfig(cfg.Url)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to parse database URL: %w", err)
        }</span>

        // Configure connection pool with defaults
        <span class="cov0" title="0">if cfg.MaxConns &gt; 0 </span><span class="cov0" title="0">{
                poolConfig.MaxConns = int32(cfg.MaxConns)
        }</span> else<span class="cov0" title="0"> {
                poolConfig.MaxConns = 25
        }</span>

        <span class="cov0" title="0">if cfg.MinConns &gt; 0 </span><span class="cov0" title="0">{
                poolConfig.MinConns = int32(cfg.MinConns)
        }</span> else<span class="cov0" title="0"> {
                poolConfig.MinConns = 5
        }</span>

        <span class="cov0" title="0">if cfg.ConnMaxLifetime != "" </span><span class="cov0" title="0">{
                duration, err := time.ParseDuration(cfg.ConnMaxLifetime)
                if err == nil </span><span class="cov0" title="0">{
                        poolConfig.MaxConnLifetime = duration
                }</span>
        }

        <span class="cov0" title="0">if cfg.ConnMaxIdleTime != "" </span><span class="cov0" title="0">{
                duration, err := time.ParseDuration(cfg.ConnMaxIdleTime)
                if err == nil </span><span class="cov0" title="0">{
                        poolConfig.MaxConnIdleTime = duration
                }</span>
        }

        <span class="cov0" title="0">if cfg.HealthCheckPeriod != "" </span><span class="cov0" title="0">{
                duration, err := time.ParseDuration(cfg.HealthCheckPeriod)
                if err == nil </span><span class="cov0" title="0">{
                        poolConfig.HealthCheckPeriod = duration
                }</span>
        }

        // Create connection pool
        <span class="cov0" title="0">pool, err := pgxpool.NewWithConfig(ctx, poolConfig)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to create connection pool: %w", err)
        }</span>

        // Test the connection
        <span class="cov0" title="0">if err := pool.Ping(ctx); err != nil </span><span class="cov0" title="0">{
                pool.Close()
                return nil, fmt.Errorf("failed to ping database: %w", err)
        }</span>

        // Create stdlib connection for compatibility
        <span class="cov0" title="0">sqlDB, err := sql.Open("pgx", cfg.Url)
        if err != nil </span><span class="cov0" title="0">{
                pool.Close()
                return nil, fmt.Errorf("failed to create stdlib connection: %w", err)
        }</span>

        <span class="cov0" title="0">logger.Info("PostgreSQL connection established",
                "max_connections", poolConfig.MaxConns,
                "min_connections", poolConfig.MinConns,
        )

        return &amp;PGDatabase{
                pool:   pool,
                sqlDB:  sqlDB,
                logger: logger,
        }, nil</span>
}

// Query executes a query that returns rows
func (db *PGDatabase) Query(ctx context.Context, query string, args ...interface{}) (Rows, error) <span class="cov0" title="0">{
        rows, err := db.pool.Query(ctx, query, args...)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">return &amp;pgRows{rows: rows}, nil</span>
}

// QueryRow executes a query that returns at most one row
func (db *PGDatabase) QueryRow(ctx context.Context, query string, args ...interface{}) Row <span class="cov0" title="0">{
        return &amp;pgRow{row: db.pool.QueryRow(ctx, query, args...)}
}</span>

// Exec executes a query without returning any rows
func (db *PGDatabase) Exec(ctx context.Context, query string, args ...interface{}) (Result, error) <span class="cov0" title="0">{
        result, err := db.pool.Exec(ctx, query, args...)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">return &amp;pgResult{result: result}, nil</span>
}

// Begin starts a transaction
func (db *PGDatabase) Begin(ctx context.Context) (Transaction, error) <span class="cov0" title="0">{
        tx, err := db.pool.Begin(ctx)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">return &amp;pgTransaction{tx: tx}, nil</span>
}

// BeginTx starts a transaction with options
func (db *PGDatabase) BeginTx(ctx context.Context, opts *sql.TxOptions) (Transaction, error) <span class="cov0" title="0">{
        // Map SQL isolation levels to pgx string values
        var isoLevel pgx.TxIsoLevel
        switch opts.Isolation </span>{
        case sql.LevelDefault:<span class="cov0" title="0">
                isoLevel = pgx.ReadCommitted</span> // PostgreSQL default
        case sql.LevelReadUncommitted:<span class="cov0" title="0">
                isoLevel = pgx.ReadUncommitted</span>
        case sql.LevelReadCommitted:<span class="cov0" title="0">
                isoLevel = pgx.ReadCommitted</span>
        case sql.LevelRepeatableRead:<span class="cov0" title="0">
                isoLevel = pgx.RepeatableRead</span>
        case sql.LevelSerializable:<span class="cov0" title="0">
                isoLevel = pgx.Serializable</span>
        default:<span class="cov0" title="0">
                isoLevel = pgx.ReadCommitted</span>
        }

        <span class="cov0" title="0">tx, err := db.pool.BeginTx(ctx, pgx.TxOptions{
                IsoLevel:       isoLevel,
                AccessMode:     pgx.ReadWrite,
                DeferrableMode: pgx.NotDeferrable,
        })
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">return &amp;pgTransaction{tx: tx}, nil</span>
}

// Ping verifies the connection to the database
func (db *PGDatabase) Ping(ctx context.Context) error <span class="cov0" title="0">{
        return db.pool.Ping(ctx)
}</span>

// Close closes the database connection
func (db *PGDatabase) Close() error <span class="cov0" title="0">{
        db.logger.Info("Closing PostgreSQL connection")
        db.pool.Close()
        if db.sqlDB != nil </span><span class="cov0" title="0">{
                return db.sqlDB.Close()
        }</span>
        <span class="cov0" title="0">return nil</span>
}

// Stats returns database statistics
func (db *PGDatabase) Stats() Stats <span class="cov0" title="0">{
        stats := db.pool.Stat()
        return Stats{
                OpenConnections:   int(stats.TotalConns()),
                InUse:             int(stats.AcquiredConns()),
                Idle:              int(stats.IdleConns()),
                WaitCount:         stats.EmptyAcquireCount(),
                WaitDuration:      stats.AcquireDuration().String(),
                MaxIdleClosed:     stats.CanceledAcquireCount(),
                MaxLifetimeClosed: 0, // Not directly available in pgxpool
        }
}</span>

// Type returns the database type
func (db *PGDatabase) Type() Type <span class="cov0" title="0">{
        return TypePostgreSQL
}</span>

// Underlying returns the underlying connection pool
func (db *PGDatabase) Underlying() interface{} <span class="cov0" title="0">{
        return db.pool
}</span>

// GetSQLDB returns the stdlib SQL database connection for migrations
func (db *PGDatabase) GetSQLDB() *sql.DB <span class="cov0" title="0">{
        return db.sqlDB
}</span>

// Adapter types for pgx compatibility

type pgRows struct {
        rows pgx.Rows
}

func (r *pgRows) Next() bool <span class="cov0" title="0">{
        return r.rows.Next()
}</span>

func (r *pgRows) Scan(dest ...interface{}) error <span class="cov0" title="0">{
        return r.rows.Scan(dest...)
}</span>

func (r *pgRows) Close() error <span class="cov0" title="0">{
        r.rows.Close()
        return nil
}</span>

func (r *pgRows) Err() error <span class="cov0" title="0">{
        return r.rows.Err()
}</span>

type pgRow struct {
        row pgx.Row
}

func (r *pgRow) Scan(dest ...interface{}) error <span class="cov0" title="0">{
        return r.row.Scan(dest...)
}</span>

type pgResult struct {
        result pgconn.CommandTag
}

func (r *pgResult) LastInsertId() (int64, error) <span class="cov0" title="0">{
        return 0, fmt.Errorf("LastInsertId not supported in PostgreSQL")
}</span>

func (r *pgResult) RowsAffected() (int64, error) <span class="cov0" title="0">{
        return r.result.RowsAffected(), nil
}</span>

type pgTransaction struct {
        tx pgx.Tx
}

func (t *pgTransaction) Query(ctx context.Context, query string, args ...interface{}) (Rows, error) <span class="cov0" title="0">{
        rows, err := t.tx.Query(ctx, query, args...)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">return &amp;pgRows{rows: rows}, nil</span>
}

func (t *pgTransaction) QueryRow(ctx context.Context, query string, args ...interface{}) Row <span class="cov0" title="0">{
        return &amp;pgRow{row: t.tx.QueryRow(ctx, query, args...)}
}</span>

func (t *pgTransaction) Exec(ctx context.Context, query string, args ...interface{}) (Result, error) <span class="cov0" title="0">{
        result, err := t.tx.Exec(ctx, query, args...)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">return &amp;pgResult{result: result}, nil</span>
}

func (t *pgTransaction) Commit() error <span class="cov0" title="0">{
        return t.tx.Commit(context.Background())
}</span>

func (t *pgTransaction) Rollback() error <span class="cov0" title="0">{
        return t.tx.Rollback(context.Background())
}</span>
</pre>
		
		<pre class="file" id="file59" style="display: none">// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.30.0
// source: accounts.sql

package postgresql

import (
        "context"
        "time"

        "github.com/google/uuid"
)

const createAccount = `-- name: CreateAccount :one
INSERT INTO account (
    id,
    user_id,
    provider_id,
    account_id,
    access_token,
    refresh_token,
    access_token_expires_at,
    refresh_token_expires_at,
    scope,
    id_token,
    password
) VALUES (
    $1, $2, $3, $4, $5, $6, 
    $7, $8, 
    $9, $10, $11
)
RETURNING id, created_at, updated_at, access_token, access_token_expires_at, account_id, id_token, password, provider_id, refresh_token, refresh_token_expires_at, scope, user_id
`

type CreateAccountParams struct {
        Id                    uuid.UUID
        UserId                uuid.UUID
        ProviderId            string
        AccountId             string
        AccessToken           *string
        RefreshToken          *string
        AccessTokenExpiresAt  *time.Time
        RefreshTokenExpiresAt *time.Time
        Scope                 *string
        IdToken               *string
        Password              *string
}

func (q *Queries) CreateAccount(ctx context.Context, arg CreateAccountParams) (Account, error) <span class="cov0" title="0">{
        row := q.db.QueryRow(ctx, createAccount,
                arg.Id,
                arg.UserId,
                arg.ProviderId,
                arg.AccountId,
                arg.AccessToken,
                arg.RefreshToken,
                arg.AccessTokenExpiresAt,
                arg.RefreshTokenExpiresAt,
                arg.Scope,
                arg.IdToken,
                arg.Password,
        )
        var i Account
        err := row.Scan(
                &amp;i.Id,
                &amp;i.CreatedAt,
                &amp;i.UpdatedAt,
                &amp;i.AccessToken,
                &amp;i.AccessTokenExpiresAt,
                &amp;i.AccountId,
                &amp;i.IdToken,
                &amp;i.Password,
                &amp;i.ProviderId,
                &amp;i.RefreshToken,
                &amp;i.RefreshTokenExpiresAt,
                &amp;i.Scope,
                &amp;i.UserId,
        )
        return i, err
}</span>

const deleteAccount = `-- name: DeleteAccount :exec
DELETE FROM account
WHERE id = $1
`

func (q *Queries) DeleteAccount(ctx context.Context, id uuid.UUID) error <span class="cov0" title="0">{
        _, err := q.db.Exec(ctx, deleteAccount, id)
        return err
}</span>

const deleteAccountsByUser = `-- name: DeleteAccountsByUser :exec
DELETE FROM account
WHERE user_id = $1
`

func (q *Queries) DeleteAccountsByUser(ctx context.Context, userID uuid.UUID) error <span class="cov0" title="0">{
        _, err := q.db.Exec(ctx, deleteAccountsByUser, userID)
        return err
}</span>

const getAccount = `-- name: GetAccount :one
SELECT id, created_at, updated_at, access_token, access_token_expires_at, account_id, id_token, password, provider_id, refresh_token, refresh_token_expires_at, scope, user_id FROM account
WHERE id = $1 LIMIT 1
`

func (q *Queries) GetAccount(ctx context.Context, id uuid.UUID) (Account, error) <span class="cov0" title="0">{
        row := q.db.QueryRow(ctx, getAccount, id)
        var i Account
        err := row.Scan(
                &amp;i.Id,
                &amp;i.CreatedAt,
                &amp;i.UpdatedAt,
                &amp;i.AccessToken,
                &amp;i.AccessTokenExpiresAt,
                &amp;i.AccountId,
                &amp;i.IdToken,
                &amp;i.Password,
                &amp;i.ProviderId,
                &amp;i.RefreshToken,
                &amp;i.RefreshTokenExpiresAt,
                &amp;i.Scope,
                &amp;i.UserId,
        )
        return i, err
}</span>

const getAccountByUser = `-- name: GetAccountByUser :one
SELECT id, created_at, updated_at, access_token, access_token_expires_at, account_id, id_token, password, provider_id, refresh_token, refresh_token_expires_at, scope, user_id FROM account
WHERE user_id = $1 AND provider_id = $2
LIMIT 1
`

type GetAccountByUserParams struct {
        UserId     uuid.UUID
        ProviderId string
}

func (q *Queries) GetAccountByUser(ctx context.Context, arg GetAccountByUserParams) (Account, error) <span class="cov0" title="0">{
        row := q.db.QueryRow(ctx, getAccountByUser, arg.UserId, arg.ProviderId)
        var i Account
        err := row.Scan(
                &amp;i.Id,
                &amp;i.CreatedAt,
                &amp;i.UpdatedAt,
                &amp;i.AccessToken,
                &amp;i.AccessTokenExpiresAt,
                &amp;i.AccountId,
                &amp;i.IdToken,
                &amp;i.Password,
                &amp;i.ProviderId,
                &amp;i.RefreshToken,
                &amp;i.RefreshTokenExpiresAt,
                &amp;i.Scope,
                &amp;i.UserId,
        )
        return i, err
}</span>

const listAccounts = `-- name: ListAccounts :many
SELECT id, created_at, updated_at, access_token, access_token_expires_at, account_id, id_token, password, provider_id, refresh_token, refresh_token_expires_at, scope, user_id FROM account
ORDER BY created_at DESC
LIMIT $1 OFFSET $2
`

type ListAccountsParams struct {
        Limit  int32
        Offset int32
}

func (q *Queries) ListAccounts(ctx context.Context, arg ListAccountsParams) ([]Account, error) <span class="cov0" title="0">{
        rows, err := q.db.Query(ctx, listAccounts, arg.Limit, arg.Offset)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">defer rows.Close()
        var items []Account
        for rows.Next() </span><span class="cov0" title="0">{
                var i Account
                if err := rows.Scan(
                        &amp;i.Id,
                        &amp;i.CreatedAt,
                        &amp;i.UpdatedAt,
                        &amp;i.AccessToken,
                        &amp;i.AccessTokenExpiresAt,
                        &amp;i.AccountId,
                        &amp;i.IdToken,
                        &amp;i.Password,
                        &amp;i.ProviderId,
                        &amp;i.RefreshToken,
                        &amp;i.RefreshTokenExpiresAt,
                        &amp;i.Scope,
                        &amp;i.UserId,
                ); err != nil </span><span class="cov0" title="0">{
                        return nil, err
                }</span>
                <span class="cov0" title="0">items = append(items, i)</span>
        }
        <span class="cov0" title="0">if err := rows.Err(); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">return items, nil</span>
}

const listAccountsByUser = `-- name: ListAccountsByUser :many
SELECT id, created_at, updated_at, access_token, access_token_expires_at, account_id, id_token, password, provider_id, refresh_token, refresh_token_expires_at, scope, user_id FROM account
WHERE user_id = $1
ORDER BY created_at DESC
`

func (q *Queries) ListAccountsByUser(ctx context.Context, userID uuid.UUID) ([]Account, error) <span class="cov0" title="0">{
        rows, err := q.db.Query(ctx, listAccountsByUser, userID)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">defer rows.Close()
        var items []Account
        for rows.Next() </span><span class="cov0" title="0">{
                var i Account
                if err := rows.Scan(
                        &amp;i.Id,
                        &amp;i.CreatedAt,
                        &amp;i.UpdatedAt,
                        &amp;i.AccessToken,
                        &amp;i.AccessTokenExpiresAt,
                        &amp;i.AccountId,
                        &amp;i.IdToken,
                        &amp;i.Password,
                        &amp;i.ProviderId,
                        &amp;i.RefreshToken,
                        &amp;i.RefreshTokenExpiresAt,
                        &amp;i.Scope,
                        &amp;i.UserId,
                ); err != nil </span><span class="cov0" title="0">{
                        return nil, err
                }</span>
                <span class="cov0" title="0">items = append(items, i)</span>
        }
        <span class="cov0" title="0">if err := rows.Err(); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">return items, nil</span>
}

const updateAccount = `-- name: UpdateAccount :one
UPDATE account
SET 
    access_token = COALESCE($2, access_token),
    refresh_token = COALESCE($3, refresh_token),
    access_token_expires_at = COALESCE($4, access_token_expires_at),
    refresh_token_expires_at = COALESCE($5, refresh_token_expires_at),
    scope = COALESCE($6, scope),
    id_token = COALESCE($7, id_token),
    password = COALESCE($8, password),
    updated_at = NOW()
WHERE id = $1
RETURNING id, created_at, updated_at, access_token, access_token_expires_at, account_id, id_token, password, provider_id, refresh_token, refresh_token_expires_at, scope, user_id
`

type UpdateAccountParams struct {
        Id                    uuid.UUID
        AccessToken           *string
        RefreshToken          *string
        AccessTokenExpiresAt  *time.Time
        RefreshTokenExpiresAt *time.Time
        Scope                 *string
        IdToken               *string
        Password              *string
}

func (q *Queries) UpdateAccount(ctx context.Context, arg UpdateAccountParams) (Account, error) <span class="cov0" title="0">{
        row := q.db.QueryRow(ctx, updateAccount,
                arg.Id,
                arg.AccessToken,
                arg.RefreshToken,
                arg.AccessTokenExpiresAt,
                arg.RefreshTokenExpiresAt,
                arg.Scope,
                arg.IdToken,
                arg.Password,
        )
        var i Account
        err := row.Scan(
                &amp;i.Id,
                &amp;i.CreatedAt,
                &amp;i.UpdatedAt,
                &amp;i.AccessToken,
                &amp;i.AccessTokenExpiresAt,
                &amp;i.AccountId,
                &amp;i.IdToken,
                &amp;i.Password,
                &amp;i.ProviderId,
                &amp;i.RefreshToken,
                &amp;i.RefreshTokenExpiresAt,
                &amp;i.Scope,
                &amp;i.UserId,
        )
        return i, err
}</span>
</pre>
		
		<pre class="file" id="file60" style="display: none">// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.30.0
// source: api-tokens.sql

package postgresql

import (
        "context"
        "time"

        "github.com/google/uuid"
)

const createApiToken = `-- name: CreateApiToken :one
INSERT INTO api_token (
    id,
    user_id,
    name,
    key,
    prefix,
    enabled,
    expires_at,
    permissions,
    rate_limit_enabled,
    rate_limit_max,
    rate_limit_time_window,
    refill_amount,
    refill_interval,
    remaining,
    metadata
) VALUES (
    $1, $2, $3, $4, $5, $6, $7, $8, $9, $10, $11, $12, $13, $14, $15
)
RETURNING id, created_at, updated_at, enabled, expires_at, key, last_refill, last_request, metadata, name, permissions, prefix, rate_limit_enabled, rate_limit_max, rate_limit_time_window, refill_amount, refill_interval, remaining, request_count, start, user_id
`

type CreateApiTokenParams struct {
        Id                  uuid.UUID
        UserId              uuid.UUID
        Name                *string
        Key                 string
        Prefix              *string
        Enabled             bool
        ExpiresAt           *time.Time
        Permissions         *string
        RateLimitEnabled    bool
        RateLimitMax        *int32
        RateLimitTimeWindow *int32
        RefillAmount        *int32
        RefillInterval      *int32
        Remaining           *int32
        Metadata            *string
}

func (q *Queries) CreateApiToken(ctx context.Context, arg CreateApiTokenParams) (ApiToken, error) <span class="cov0" title="0">{
        row := q.db.QueryRow(ctx, createApiToken,
                arg.Id,
                arg.UserId,
                arg.Name,
                arg.Key,
                arg.Prefix,
                arg.Enabled,
                arg.ExpiresAt,
                arg.Permissions,
                arg.RateLimitEnabled,
                arg.RateLimitMax,
                arg.RateLimitTimeWindow,
                arg.RefillAmount,
                arg.RefillInterval,
                arg.Remaining,
                arg.Metadata,
        )
        var i ApiToken
        err := row.Scan(
                &amp;i.Id,
                &amp;i.CreatedAt,
                &amp;i.UpdatedAt,
                &amp;i.Enabled,
                &amp;i.ExpiresAt,
                &amp;i.Key,
                &amp;i.LastRefill,
                &amp;i.LastRequest,
                &amp;i.Metadata,
                &amp;i.Name,
                &amp;i.Permissions,
                &amp;i.Prefix,
                &amp;i.RateLimitEnabled,
                &amp;i.RateLimitMax,
                &amp;i.RateLimitTimeWindow,
                &amp;i.RefillAmount,
                &amp;i.RefillInterval,
                &amp;i.Remaining,
                &amp;i.RequestCount,
                &amp;i.Start,
                &amp;i.UserId,
        )
        return i, err
}</span>

const deleteApiToken = `-- name: DeleteApiToken :exec
DELETE FROM api_token
WHERE id = $1
`

func (q *Queries) DeleteApiToken(ctx context.Context, id uuid.UUID) error <span class="cov0" title="0">{
        _, err := q.db.Exec(ctx, deleteApiToken, id)
        return err
}</span>

const deleteApiTokensByUser = `-- name: DeleteApiTokensByUser :exec
DELETE FROM api_token
WHERE user_id = $1
`

func (q *Queries) DeleteApiTokensByUser(ctx context.Context, userID uuid.UUID) error <span class="cov0" title="0">{
        _, err := q.db.Exec(ctx, deleteApiTokensByUser, userID)
        return err
}</span>

const getApiToken = `-- name: GetApiToken :one
SELECT id, created_at, updated_at, enabled, expires_at, key, last_refill, last_request, metadata, name, permissions, prefix, rate_limit_enabled, rate_limit_max, rate_limit_time_window, refill_amount, refill_interval, remaining, request_count, start, user_id FROM api_token
WHERE id = $1 LIMIT 1
`

func (q *Queries) GetApiToken(ctx context.Context, id uuid.UUID) (ApiToken, error) <span class="cov0" title="0">{
        row := q.db.QueryRow(ctx, getApiToken, id)
        var i ApiToken
        err := row.Scan(
                &amp;i.Id,
                &amp;i.CreatedAt,
                &amp;i.UpdatedAt,
                &amp;i.Enabled,
                &amp;i.ExpiresAt,
                &amp;i.Key,
                &amp;i.LastRefill,
                &amp;i.LastRequest,
                &amp;i.Metadata,
                &amp;i.Name,
                &amp;i.Permissions,
                &amp;i.Prefix,
                &amp;i.RateLimitEnabled,
                &amp;i.RateLimitMax,
                &amp;i.RateLimitTimeWindow,
                &amp;i.RefillAmount,
                &amp;i.RefillInterval,
                &amp;i.Remaining,
                &amp;i.RequestCount,
                &amp;i.Start,
                &amp;i.UserId,
        )
        return i, err
}</span>

const getApiTokenByKey = `-- name: GetApiTokenByKey :one
SELECT id, created_at, updated_at, enabled, expires_at, key, last_refill, last_request, metadata, name, permissions, prefix, rate_limit_enabled, rate_limit_max, rate_limit_time_window, refill_amount, refill_interval, remaining, request_count, start, user_id FROM api_token
WHERE key = $1 LIMIT 1
`

func (q *Queries) GetApiTokenByKey(ctx context.Context, key string) (ApiToken, error) <span class="cov0" title="0">{
        row := q.db.QueryRow(ctx, getApiTokenByKey, key)
        var i ApiToken
        err := row.Scan(
                &amp;i.Id,
                &amp;i.CreatedAt,
                &amp;i.UpdatedAt,
                &amp;i.Enabled,
                &amp;i.ExpiresAt,
                &amp;i.Key,
                &amp;i.LastRefill,
                &amp;i.LastRequest,
                &amp;i.Metadata,
                &amp;i.Name,
                &amp;i.Permissions,
                &amp;i.Prefix,
                &amp;i.RateLimitEnabled,
                &amp;i.RateLimitMax,
                &amp;i.RateLimitTimeWindow,
                &amp;i.RefillAmount,
                &amp;i.RefillInterval,
                &amp;i.Remaining,
                &amp;i.RequestCount,
                &amp;i.Start,
                &amp;i.UserId,
        )
        return i, err
}</span>

const listApiTokens = `-- name: ListApiTokens :many
SELECT id, created_at, updated_at, enabled, expires_at, key, last_refill, last_request, metadata, name, permissions, prefix, rate_limit_enabled, rate_limit_max, rate_limit_time_window, refill_amount, refill_interval, remaining, request_count, start, user_id FROM api_token
ORDER BY created_at DESC
LIMIT $1 OFFSET $2
`

type ListApiTokensParams struct {
        Limit  int32
        Offset int32
}

func (q *Queries) ListApiTokens(ctx context.Context, arg ListApiTokensParams) ([]ApiToken, error) <span class="cov0" title="0">{
        rows, err := q.db.Query(ctx, listApiTokens, arg.Limit, arg.Offset)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">defer rows.Close()
        var items []ApiToken
        for rows.Next() </span><span class="cov0" title="0">{
                var i ApiToken
                if err := rows.Scan(
                        &amp;i.Id,
                        &amp;i.CreatedAt,
                        &amp;i.UpdatedAt,
                        &amp;i.Enabled,
                        &amp;i.ExpiresAt,
                        &amp;i.Key,
                        &amp;i.LastRefill,
                        &amp;i.LastRequest,
                        &amp;i.Metadata,
                        &amp;i.Name,
                        &amp;i.Permissions,
                        &amp;i.Prefix,
                        &amp;i.RateLimitEnabled,
                        &amp;i.RateLimitMax,
                        &amp;i.RateLimitTimeWindow,
                        &amp;i.RefillAmount,
                        &amp;i.RefillInterval,
                        &amp;i.Remaining,
                        &amp;i.RequestCount,
                        &amp;i.Start,
                        &amp;i.UserId,
                ); err != nil </span><span class="cov0" title="0">{
                        return nil, err
                }</span>
                <span class="cov0" title="0">items = append(items, i)</span>
        }
        <span class="cov0" title="0">if err := rows.Err(); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">return items, nil</span>
}

const listApiTokensByUser = `-- name: ListApiTokensByUser :many
SELECT id, created_at, updated_at, enabled, expires_at, key, last_refill, last_request, metadata, name, permissions, prefix, rate_limit_enabled, rate_limit_max, rate_limit_time_window, refill_amount, refill_interval, remaining, request_count, start, user_id FROM api_token
WHERE user_id = $1
ORDER BY created_at DESC
LIMIT $2 OFFSET $3
`

type ListApiTokensByUserParams struct {
        UserId uuid.UUID
        Limit  int32
        Offset int32
}

func (q *Queries) ListApiTokensByUser(ctx context.Context, arg ListApiTokensByUserParams) ([]ApiToken, error) <span class="cov0" title="0">{
        rows, err := q.db.Query(ctx, listApiTokensByUser, arg.UserId, arg.Limit, arg.Offset)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">defer rows.Close()
        var items []ApiToken
        for rows.Next() </span><span class="cov0" title="0">{
                var i ApiToken
                if err := rows.Scan(
                        &amp;i.Id,
                        &amp;i.CreatedAt,
                        &amp;i.UpdatedAt,
                        &amp;i.Enabled,
                        &amp;i.ExpiresAt,
                        &amp;i.Key,
                        &amp;i.LastRefill,
                        &amp;i.LastRequest,
                        &amp;i.Metadata,
                        &amp;i.Name,
                        &amp;i.Permissions,
                        &amp;i.Prefix,
                        &amp;i.RateLimitEnabled,
                        &amp;i.RateLimitMax,
                        &amp;i.RateLimitTimeWindow,
                        &amp;i.RefillAmount,
                        &amp;i.RefillInterval,
                        &amp;i.Remaining,
                        &amp;i.RequestCount,
                        &amp;i.Start,
                        &amp;i.UserId,
                ); err != nil </span><span class="cov0" title="0">{
                        return nil, err
                }</span>
                <span class="cov0" title="0">items = append(items, i)</span>
        }
        <span class="cov0" title="0">if err := rows.Err(); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">return items, nil</span>
}

const updateApiToken = `-- name: UpdateApiToken :one
UPDATE api_token
SET 
    name = COALESCE($2, name),
    enabled = COALESCE($3, enabled),
    expires_at = COALESCE($4, expires_at),
    permissions = COALESCE($5, permissions),
    rate_limit_enabled = COALESCE($6, rate_limit_enabled),
    rate_limit_max = COALESCE($7, rate_limit_max),
    rate_limit_time_window = COALESCE($8, rate_limit_time_window),
    metadata = COALESCE($9, metadata)
WHERE id = $1
RETURNING id, created_at, updated_at, enabled, expires_at, key, last_refill, last_request, metadata, name, permissions, prefix, rate_limit_enabled, rate_limit_max, rate_limit_time_window, refill_amount, refill_interval, remaining, request_count, start, user_id
`

type UpdateApiTokenParams struct {
        Id                  uuid.UUID
        Name                *string
        Enabled             *bool
        ExpiresAt           *time.Time
        Permissions         *string
        RateLimitEnabled    *bool
        RateLimitMax        *int32
        RateLimitTimeWindow *int32
        Metadata            *string
}

func (q *Queries) UpdateApiToken(ctx context.Context, arg UpdateApiTokenParams) (ApiToken, error) <span class="cov0" title="0">{
        row := q.db.QueryRow(ctx, updateApiToken,
                arg.Id,
                arg.Name,
                arg.Enabled,
                arg.ExpiresAt,
                arg.Permissions,
                arg.RateLimitEnabled,
                arg.RateLimitMax,
                arg.RateLimitTimeWindow,
                arg.Metadata,
        )
        var i ApiToken
        err := row.Scan(
                &amp;i.Id,
                &amp;i.CreatedAt,
                &amp;i.UpdatedAt,
                &amp;i.Enabled,
                &amp;i.ExpiresAt,
                &amp;i.Key,
                &amp;i.LastRefill,
                &amp;i.LastRequest,
                &amp;i.Metadata,
                &amp;i.Name,
                &amp;i.Permissions,
                &amp;i.Prefix,
                &amp;i.RateLimitEnabled,
                &amp;i.RateLimitMax,
                &amp;i.RateLimitTimeWindow,
                &amp;i.RefillAmount,
                &amp;i.RefillInterval,
                &amp;i.Remaining,
                &amp;i.RequestCount,
                &amp;i.Start,
                &amp;i.UserId,
        )
        return i, err
}</span>
</pre>
		
		<pre class="file" id="file61" style="display: none">// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.30.0
// source: artifacts.sql

package postgresql

import (
        "context"

        "github.com/google/uuid"
)

const createArtifact = `-- name: CreateArtifact :one
INSERT INTO artifact (
    id,
    organization_id,
    name,
    description,
    mime_type,
    url,
    credits,
    preview_image,
    producer_id,
    text
) VALUES (
    $1, $2, $3, $4, $5, $6, $7, $8, $9, $10
)
RETURNING id, created_at, updated_at, credits, description, mime_type, name, organization_id, preview_image, producer_id, text, url, embedding
`

type CreateArtifactParams struct {
        Id             uuid.UUID
        OrganizationId uuid.UUID
        Name           *string
        Description    *string
        MimeType       string
        Url            *string
        Credits        int32
        PreviewImage   *string
        ProducerId     *uuid.UUID
        Text           *string
}

func (q *Queries) CreateArtifact(ctx context.Context, arg CreateArtifactParams) (Artifact, error) <span class="cov0" title="0">{
        row := q.db.QueryRow(ctx, createArtifact,
                arg.Id,
                arg.OrganizationId,
                arg.Name,
                arg.Description,
                arg.MimeType,
                arg.Url,
                arg.Credits,
                arg.PreviewImage,
                arg.ProducerId,
                arg.Text,
        )
        var i Artifact
        err := row.Scan(
                &amp;i.Id,
                &amp;i.CreatedAt,
                &amp;i.UpdatedAt,
                &amp;i.Credits,
                &amp;i.Description,
                &amp;i.MimeType,
                &amp;i.Name,
                &amp;i.OrganizationId,
                &amp;i.PreviewImage,
                &amp;i.ProducerId,
                &amp;i.Text,
                &amp;i.Url,
                &amp;i.Embedding,
        )
        return i, err
}</span>

const deleteArtifact = `-- name: DeleteArtifact :exec
DELETE FROM artifact
WHERE id = $1
`

func (q *Queries) DeleteArtifact(ctx context.Context, id uuid.UUID) error <span class="cov0" title="0">{
        _, err := q.db.Exec(ctx, deleteArtifact, id)
        return err
}</span>

const deleteArtifactsByOrganization = `-- name: DeleteArtifactsByOrganization :exec
DELETE FROM artifact
WHERE organization_id = $1
`

func (q *Queries) DeleteArtifactsByOrganization(ctx context.Context, organizationID uuid.UUID) error <span class="cov0" title="0">{
        _, err := q.db.Exec(ctx, deleteArtifactsByOrganization, organizationID)
        return err
}</span>

const getArtifact = `-- name: GetArtifact :one
SELECT id, created_at, updated_at, credits, description, mime_type, name, organization_id, preview_image, producer_id, text, url, embedding FROM artifact
WHERE id = $1 LIMIT 1
`

func (q *Queries) GetArtifact(ctx context.Context, id uuid.UUID) (Artifact, error) <span class="cov0" title="0">{
        row := q.db.QueryRow(ctx, getArtifact, id)
        var i Artifact
        err := row.Scan(
                &amp;i.Id,
                &amp;i.CreatedAt,
                &amp;i.UpdatedAt,
                &amp;i.Credits,
                &amp;i.Description,
                &amp;i.MimeType,
                &amp;i.Name,
                &amp;i.OrganizationId,
                &amp;i.PreviewImage,
                &amp;i.ProducerId,
                &amp;i.Text,
                &amp;i.Url,
                &amp;i.Embedding,
        )
        return i, err
}</span>

const listArtifacts = `-- name: ListArtifacts :many
SELECT id, created_at, updated_at, credits, description, mime_type, name, organization_id, preview_image, producer_id, text, url, embedding FROM artifact
ORDER BY created_at DESC
LIMIT $1 OFFSET $2
`

type ListArtifactsParams struct {
        Limit  int32
        Offset int32
}

func (q *Queries) ListArtifacts(ctx context.Context, arg ListArtifactsParams) ([]Artifact, error) <span class="cov0" title="0">{
        rows, err := q.db.Query(ctx, listArtifacts, arg.Limit, arg.Offset)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">defer rows.Close()
        var items []Artifact
        for rows.Next() </span><span class="cov0" title="0">{
                var i Artifact
                if err := rows.Scan(
                        &amp;i.Id,
                        &amp;i.CreatedAt,
                        &amp;i.UpdatedAt,
                        &amp;i.Credits,
                        &amp;i.Description,
                        &amp;i.MimeType,
                        &amp;i.Name,
                        &amp;i.OrganizationId,
                        &amp;i.PreviewImage,
                        &amp;i.ProducerId,
                        &amp;i.Text,
                        &amp;i.Url,
                        &amp;i.Embedding,
                ); err != nil </span><span class="cov0" title="0">{
                        return nil, err
                }</span>
                <span class="cov0" title="0">items = append(items, i)</span>
        }
        <span class="cov0" title="0">if err := rows.Err(); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">return items, nil</span>
}

const listArtifactsByOrganization = `-- name: ListArtifactsByOrganization :many
SELECT id, created_at, updated_at, credits, description, mime_type, name, organization_id, preview_image, producer_id, text, url, embedding FROM artifact
WHERE organization_id = $1
ORDER BY created_at DESC
LIMIT $2 OFFSET $3
`

type ListArtifactsByOrganizationParams struct {
        OrganizationId uuid.UUID
        Limit          int32
        Offset         int32
}

func (q *Queries) ListArtifactsByOrganization(ctx context.Context, arg ListArtifactsByOrganizationParams) ([]Artifact, error) <span class="cov0" title="0">{
        rows, err := q.db.Query(ctx, listArtifactsByOrganization, arg.OrganizationId, arg.Limit, arg.Offset)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">defer rows.Close()
        var items []Artifact
        for rows.Next() </span><span class="cov0" title="0">{
                var i Artifact
                if err := rows.Scan(
                        &amp;i.Id,
                        &amp;i.CreatedAt,
                        &amp;i.UpdatedAt,
                        &amp;i.Credits,
                        &amp;i.Description,
                        &amp;i.MimeType,
                        &amp;i.Name,
                        &amp;i.OrganizationId,
                        &amp;i.PreviewImage,
                        &amp;i.ProducerId,
                        &amp;i.Text,
                        &amp;i.Url,
                        &amp;i.Embedding,
                ); err != nil </span><span class="cov0" title="0">{
                        return nil, err
                }</span>
                <span class="cov0" title="0">items = append(items, i)</span>
        }
        <span class="cov0" title="0">if err := rows.Err(); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">return items, nil</span>
}

const listArtifactsByProducer = `-- name: ListArtifactsByProducer :many
SELECT id, created_at, updated_at, credits, description, mime_type, name, organization_id, preview_image, producer_id, text, url, embedding FROM artifact
WHERE producer_id = $1
ORDER BY created_at DESC
LIMIT $2 OFFSET $3
`

type ListArtifactsByProducerParams struct {
        ProducerId *uuid.UUID
        Limit      int32
        Offset     int32
}

func (q *Queries) ListArtifactsByProducer(ctx context.Context, arg ListArtifactsByProducerParams) ([]Artifact, error) <span class="cov0" title="0">{
        rows, err := q.db.Query(ctx, listArtifactsByProducer, arg.ProducerId, arg.Limit, arg.Offset)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">defer rows.Close()
        var items []Artifact
        for rows.Next() </span><span class="cov0" title="0">{
                var i Artifact
                if err := rows.Scan(
                        &amp;i.Id,
                        &amp;i.CreatedAt,
                        &amp;i.UpdatedAt,
                        &amp;i.Credits,
                        &amp;i.Description,
                        &amp;i.MimeType,
                        &amp;i.Name,
                        &amp;i.OrganizationId,
                        &amp;i.PreviewImage,
                        &amp;i.ProducerId,
                        &amp;i.Text,
                        &amp;i.Url,
                        &amp;i.Embedding,
                ); err != nil </span><span class="cov0" title="0">{
                        return nil, err
                }</span>
                <span class="cov0" title="0">items = append(items, i)</span>
        }
        <span class="cov0" title="0">if err := rows.Err(); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">return items, nil</span>
}

const updateArtifact = `-- name: UpdateArtifact :one
UPDATE artifact
SET 
    name = COALESCE($2, name),
    description = COALESCE($3, description),
    mime_type = COALESCE($4, mime_type),
    url = COALESCE($5, url),
    credits = COALESCE($6, credits),
    preview_image = COALESCE($7, preview_image),
    text = COALESCE($8, text)
WHERE id = $1
RETURNING id, created_at, updated_at, credits, description, mime_type, name, organization_id, preview_image, producer_id, text, url, embedding
`

type UpdateArtifactParams struct {
        Id           uuid.UUID
        Name         *string
        Description  *string
        MimeType     *string
        Url          *string
        Credits      *int32
        PreviewImage *string
        Text         *string
}

func (q *Queries) UpdateArtifact(ctx context.Context, arg UpdateArtifactParams) (Artifact, error) <span class="cov0" title="0">{
        row := q.db.QueryRow(ctx, updateArtifact,
                arg.Id,
                arg.Name,
                arg.Description,
                arg.MimeType,
                arg.Url,
                arg.Credits,
                arg.PreviewImage,
                arg.Text,
        )
        var i Artifact
        err := row.Scan(
                &amp;i.Id,
                &amp;i.CreatedAt,
                &amp;i.UpdatedAt,
                &amp;i.Credits,
                &amp;i.Description,
                &amp;i.MimeType,
                &amp;i.Name,
                &amp;i.OrganizationId,
                &amp;i.PreviewImage,
                &amp;i.ProducerId,
                &amp;i.Text,
                &amp;i.Url,
                &amp;i.Embedding,
        )
        return i, err
}</span>
</pre>
		
		<pre class="file" id="file62" style="display: none">// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.30.0
// source: auth.sql

package postgresql

import (
        "context"
        "time"

        "github.com/google/uuid"
)

const createSession = `-- name: CreateSession :one
INSERT INTO session (
    id,
    user_id,
    token,
    expires_at,
    active_organization_id,
    ip_address,
    user_agent
) VALUES (
    $1, $2, $3, $4, $5, $6, $7
)
RETURNING id, created_at, updated_at, active_organization_id, expires_at, ip_address, token, user_agent, user_id
`

type CreateSessionParams struct {
        Id                   uuid.UUID
        UserId               uuid.UUID
        Token                string
        ExpiresAt            time.Time
        ActiveOrganizationId *uuid.UUID
        IpAddress            *string
        UserAgent            *string
}

func (q *Queries) CreateSession(ctx context.Context, arg CreateSessionParams) (Session, error) <span class="cov0" title="0">{
        row := q.db.QueryRow(ctx, createSession,
                arg.Id,
                arg.UserId,
                arg.Token,
                arg.ExpiresAt,
                arg.ActiveOrganizationId,
                arg.IpAddress,
                arg.UserAgent,
        )
        var i Session
        err := row.Scan(
                &amp;i.Id,
                &amp;i.CreatedAt,
                &amp;i.UpdatedAt,
                &amp;i.ActiveOrganizationId,
                &amp;i.ExpiresAt,
                &amp;i.IpAddress,
                &amp;i.Token,
                &amp;i.UserAgent,
                &amp;i.UserId,
        )
        return i, err
}</span>

const deleteSession = `-- name: DeleteSession :exec
DELETE FROM session
WHERE id = $1
`

func (q *Queries) DeleteSession(ctx context.Context, id uuid.UUID) error <span class="cov0" title="0">{
        _, err := q.db.Exec(ctx, deleteSession, id)
        return err
}</span>

const deleteSessionsByUser = `-- name: DeleteSessionsByUser :exec
DELETE FROM session
WHERE user_id = $1
`

func (q *Queries) DeleteSessionsByUser(ctx context.Context, userID uuid.UUID) error <span class="cov0" title="0">{
        _, err := q.db.Exec(ctx, deleteSessionsByUser, userID)
        return err
}</span>

const getSession = `-- name: GetSession :one
SELECT id, created_at, updated_at, active_organization_id, expires_at, ip_address, token, user_agent, user_id FROM session
WHERE id = $1 LIMIT 1
`

func (q *Queries) GetSession(ctx context.Context, id uuid.UUID) (Session, error) <span class="cov0" title="0">{
        row := q.db.QueryRow(ctx, getSession, id)
        var i Session
        err := row.Scan(
                &amp;i.Id,
                &amp;i.CreatedAt,
                &amp;i.UpdatedAt,
                &amp;i.ActiveOrganizationId,
                &amp;i.ExpiresAt,
                &amp;i.IpAddress,
                &amp;i.Token,
                &amp;i.UserAgent,
                &amp;i.UserId,
        )
        return i, err
}</span>

const getSessionByToken = `-- name: GetSessionByToken :one
SELECT id, created_at, updated_at, active_organization_id, expires_at, ip_address, token, user_agent, user_id FROM session
WHERE token = $1 LIMIT 1
`

func (q *Queries) GetSessionByToken(ctx context.Context, token string) (Session, error) <span class="cov0" title="0">{
        row := q.db.QueryRow(ctx, getSessionByToken, token)
        var i Session
        err := row.Scan(
                &amp;i.Id,
                &amp;i.CreatedAt,
                &amp;i.UpdatedAt,
                &amp;i.ActiveOrganizationId,
                &amp;i.ExpiresAt,
                &amp;i.IpAddress,
                &amp;i.Token,
                &amp;i.UserAgent,
                &amp;i.UserId,
        )
        return i, err
}</span>

const listSessions = `-- name: ListSessions :many
SELECT id, created_at, updated_at, active_organization_id, expires_at, ip_address, token, user_agent, user_id FROM session
ORDER BY created_at DESC
LIMIT $1 OFFSET $2
`

type ListSessionsParams struct {
        Limit  int32
        Offset int32
}

func (q *Queries) ListSessions(ctx context.Context, arg ListSessionsParams) ([]Session, error) <span class="cov0" title="0">{
        rows, err := q.db.Query(ctx, listSessions, arg.Limit, arg.Offset)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">defer rows.Close()
        var items []Session
        for rows.Next() </span><span class="cov0" title="0">{
                var i Session
                if err := rows.Scan(
                        &amp;i.Id,
                        &amp;i.CreatedAt,
                        &amp;i.UpdatedAt,
                        &amp;i.ActiveOrganizationId,
                        &amp;i.ExpiresAt,
                        &amp;i.IpAddress,
                        &amp;i.Token,
                        &amp;i.UserAgent,
                        &amp;i.UserId,
                ); err != nil </span><span class="cov0" title="0">{
                        return nil, err
                }</span>
                <span class="cov0" title="0">items = append(items, i)</span>
        }
        <span class="cov0" title="0">if err := rows.Err(); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">return items, nil</span>
}

const listSessionsByUser = `-- name: ListSessionsByUser :many
SELECT id, created_at, updated_at, active_organization_id, expires_at, ip_address, token, user_agent, user_id FROM session
WHERE user_id = $1
ORDER BY created_at DESC
LIMIT $2 OFFSET $3
`

type ListSessionsByUserParams struct {
        UserId uuid.UUID
        Limit  int32
        Offset int32
}

func (q *Queries) ListSessionsByUser(ctx context.Context, arg ListSessionsByUserParams) ([]Session, error) <span class="cov0" title="0">{
        rows, err := q.db.Query(ctx, listSessionsByUser, arg.UserId, arg.Limit, arg.Offset)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">defer rows.Close()
        var items []Session
        for rows.Next() </span><span class="cov0" title="0">{
                var i Session
                if err := rows.Scan(
                        &amp;i.Id,
                        &amp;i.CreatedAt,
                        &amp;i.UpdatedAt,
                        &amp;i.ActiveOrganizationId,
                        &amp;i.ExpiresAt,
                        &amp;i.IpAddress,
                        &amp;i.Token,
                        &amp;i.UserAgent,
                        &amp;i.UserId,
                ); err != nil </span><span class="cov0" title="0">{
                        return nil, err
                }</span>
                <span class="cov0" title="0">items = append(items, i)</span>
        }
        <span class="cov0" title="0">if err := rows.Err(); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">return items, nil</span>
}

const updateSession = `-- name: UpdateSession :one
UPDATE session
SET 
    expires_at = COALESCE($2, expires_at),
    active_organization_id = COALESCE($3, active_organization_id)
WHERE id = $1
RETURNING id, created_at, updated_at, active_organization_id, expires_at, ip_address, token, user_agent, user_id
`

type UpdateSessionParams struct {
        Id                   uuid.UUID
        ExpiresAt            *time.Time
        ActiveOrganizationId *uuid.UUID
}

func (q *Queries) UpdateSession(ctx context.Context, arg UpdateSessionParams) (Session, error) <span class="cov0" title="0">{
        row := q.db.QueryRow(ctx, updateSession, arg.Id, arg.ExpiresAt, arg.ActiveOrganizationId)
        var i Session
        err := row.Scan(
                &amp;i.Id,
                &amp;i.CreatedAt,
                &amp;i.UpdatedAt,
                &amp;i.ActiveOrganizationId,
                &amp;i.ExpiresAt,
                &amp;i.IpAddress,
                &amp;i.Token,
                &amp;i.UserAgent,
                &amp;i.UserId,
        )
        return i, err
}</span>
</pre>
		
		<pre class="file" id="file63" style="display: none">// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.30.0

package postgresql

import (
        "context"

        "github.com/jackc/pgx/v5"
        "github.com/jackc/pgx/v5/pgconn"
)

type DBTX interface {
        Exec(context.Context, string, ...interface{}) (pgconn.CommandTag, error)
        Query(context.Context, string, ...interface{}) (pgx.Rows, error)
        QueryRow(context.Context, string, ...interface{}) pgx.Row
}

func New(db DBTX) *Queries <span class="cov0" title="0">{
        return &amp;Queries{db: db}
}</span>

type Queries struct {
        db DBTX
}

func (q *Queries) WithTx(tx pgx.Tx) *Queries <span class="cov0" title="0">{
        return &amp;Queries{
                db: tx,
        }
}</span>
</pre>
		
		<pre class="file" id="file64" style="display: none">// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.30.0
// source: invitations.sql

package postgresql

import (
        "context"
        "time"

        "github.com/google/uuid"
)

const createInvitation = `-- name: CreateInvitation :one
INSERT INTO invitation (
    id,
    organization_id,
    inviter_id,
    email,
    role,
    expires_at,
    status
) VALUES (
    $1, $2, $3, $4, $5, $6, $7
)
RETURNING id, created_at, updated_at, email, expires_at, inviter_id, organization_id, role, status
`

type CreateInvitationParams struct {
        Id             uuid.UUID
        OrganizationId uuid.UUID
        InviterId      uuid.UUID
        Email          string
        Role           string
        ExpiresAt      time.Time
        Status         string
}

func (q *Queries) CreateInvitation(ctx context.Context, arg CreateInvitationParams) (Invitation, error) <span class="cov0" title="0">{
        row := q.db.QueryRow(ctx, createInvitation,
                arg.Id,
                arg.OrganizationId,
                arg.InviterId,
                arg.Email,
                arg.Role,
                arg.ExpiresAt,
                arg.Status,
        )
        var i Invitation
        err := row.Scan(
                &amp;i.Id,
                &amp;i.CreatedAt,
                &amp;i.UpdatedAt,
                &amp;i.Email,
                &amp;i.ExpiresAt,
                &amp;i.InviterId,
                &amp;i.OrganizationId,
                &amp;i.Role,
                &amp;i.Status,
        )
        return i, err
}</span>

const deleteInvitation = `-- name: DeleteInvitation :exec
DELETE FROM invitation
WHERE id = $1
`

func (q *Queries) DeleteInvitation(ctx context.Context, id uuid.UUID) error <span class="cov0" title="0">{
        _, err := q.db.Exec(ctx, deleteInvitation, id)
        return err
}</span>

const deleteInvitationsByOrganization = `-- name: DeleteInvitationsByOrganization :exec
DELETE FROM invitation
WHERE organization_id = $1
`

func (q *Queries) DeleteInvitationsByOrganization(ctx context.Context, organizationID uuid.UUID) error <span class="cov0" title="0">{
        _, err := q.db.Exec(ctx, deleteInvitationsByOrganization, organizationID)
        return err
}</span>

const getInvitation = `-- name: GetInvitation :one
SELECT id, created_at, updated_at, email, expires_at, inviter_id, organization_id, role, status FROM invitation
WHERE id = $1 LIMIT 1
`

func (q *Queries) GetInvitation(ctx context.Context, id uuid.UUID) (Invitation, error) <span class="cov0" title="0">{
        row := q.db.QueryRow(ctx, getInvitation, id)
        var i Invitation
        err := row.Scan(
                &amp;i.Id,
                &amp;i.CreatedAt,
                &amp;i.UpdatedAt,
                &amp;i.Email,
                &amp;i.ExpiresAt,
                &amp;i.InviterId,
                &amp;i.OrganizationId,
                &amp;i.Role,
                &amp;i.Status,
        )
        return i, err
}</span>

const getInvitationByEmail = `-- name: GetInvitationByEmail :one
SELECT id, created_at, updated_at, email, expires_at, inviter_id, organization_id, role, status FROM invitation
WHERE organization_id = $1 AND email = $2 LIMIT 1
`

type GetInvitationByEmailParams struct {
        OrganizationId uuid.UUID
        Email          string
}

func (q *Queries) GetInvitationByEmail(ctx context.Context, arg GetInvitationByEmailParams) (Invitation, error) <span class="cov0" title="0">{
        row := q.db.QueryRow(ctx, getInvitationByEmail, arg.OrganizationId, arg.Email)
        var i Invitation
        err := row.Scan(
                &amp;i.Id,
                &amp;i.CreatedAt,
                &amp;i.UpdatedAt,
                &amp;i.Email,
                &amp;i.ExpiresAt,
                &amp;i.InviterId,
                &amp;i.OrganizationId,
                &amp;i.Role,
                &amp;i.Status,
        )
        return i, err
}</span>

const listInvitations = `-- name: ListInvitations :many
SELECT id, created_at, updated_at, email, expires_at, inviter_id, organization_id, role, status FROM invitation
ORDER BY created_at DESC
LIMIT $1 OFFSET $2
`

type ListInvitationsParams struct {
        Limit  int32
        Offset int32
}

func (q *Queries) ListInvitations(ctx context.Context, arg ListInvitationsParams) ([]Invitation, error) <span class="cov0" title="0">{
        rows, err := q.db.Query(ctx, listInvitations, arg.Limit, arg.Offset)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">defer rows.Close()
        var items []Invitation
        for rows.Next() </span><span class="cov0" title="0">{
                var i Invitation
                if err := rows.Scan(
                        &amp;i.Id,
                        &amp;i.CreatedAt,
                        &amp;i.UpdatedAt,
                        &amp;i.Email,
                        &amp;i.ExpiresAt,
                        &amp;i.InviterId,
                        &amp;i.OrganizationId,
                        &amp;i.Role,
                        &amp;i.Status,
                ); err != nil </span><span class="cov0" title="0">{
                        return nil, err
                }</span>
                <span class="cov0" title="0">items = append(items, i)</span>
        }
        <span class="cov0" title="0">if err := rows.Err(); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">return items, nil</span>
}

const listInvitationsByInviter = `-- name: ListInvitationsByInviter :many
SELECT id, created_at, updated_at, email, expires_at, inviter_id, organization_id, role, status FROM invitation
WHERE inviter_id = $1
ORDER BY created_at DESC
LIMIT $2 OFFSET $3
`

type ListInvitationsByInviterParams struct {
        InviterId uuid.UUID
        Limit     int32
        Offset    int32
}

func (q *Queries) ListInvitationsByInviter(ctx context.Context, arg ListInvitationsByInviterParams) ([]Invitation, error) <span class="cov0" title="0">{
        rows, err := q.db.Query(ctx, listInvitationsByInviter, arg.InviterId, arg.Limit, arg.Offset)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">defer rows.Close()
        var items []Invitation
        for rows.Next() </span><span class="cov0" title="0">{
                var i Invitation
                if err := rows.Scan(
                        &amp;i.Id,
                        &amp;i.CreatedAt,
                        &amp;i.UpdatedAt,
                        &amp;i.Email,
                        &amp;i.ExpiresAt,
                        &amp;i.InviterId,
                        &amp;i.OrganizationId,
                        &amp;i.Role,
                        &amp;i.Status,
                ); err != nil </span><span class="cov0" title="0">{
                        return nil, err
                }</span>
                <span class="cov0" title="0">items = append(items, i)</span>
        }
        <span class="cov0" title="0">if err := rows.Err(); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">return items, nil</span>
}

const listInvitationsByOrganization = `-- name: ListInvitationsByOrganization :many
SELECT id, created_at, updated_at, email, expires_at, inviter_id, organization_id, role, status FROM invitation
WHERE organization_id = $1
ORDER BY created_at DESC
LIMIT $2 OFFSET $3
`

type ListInvitationsByOrganizationParams struct {
        OrganizationId uuid.UUID
        Limit          int32
        Offset         int32
}

func (q *Queries) ListInvitationsByOrganization(ctx context.Context, arg ListInvitationsByOrganizationParams) ([]Invitation, error) <span class="cov0" title="0">{
        rows, err := q.db.Query(ctx, listInvitationsByOrganization, arg.OrganizationId, arg.Limit, arg.Offset)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">defer rows.Close()
        var items []Invitation
        for rows.Next() </span><span class="cov0" title="0">{
                var i Invitation
                if err := rows.Scan(
                        &amp;i.Id,
                        &amp;i.CreatedAt,
                        &amp;i.UpdatedAt,
                        &amp;i.Email,
                        &amp;i.ExpiresAt,
                        &amp;i.InviterId,
                        &amp;i.OrganizationId,
                        &amp;i.Role,
                        &amp;i.Status,
                ); err != nil </span><span class="cov0" title="0">{
                        return nil, err
                }</span>
                <span class="cov0" title="0">items = append(items, i)</span>
        }
        <span class="cov0" title="0">if err := rows.Err(); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">return items, nil</span>
}

const updateInvitation = `-- name: UpdateInvitation :one
UPDATE invitation
SET 
    email = COALESCE($2, email),
    role = COALESCE($3, role),
    expires_at = COALESCE($4, expires_at),
    status = COALESCE($5, status),
    updated_at = NOW()
WHERE id = $1
RETURNING id, created_at, updated_at, email, expires_at, inviter_id, organization_id, role, status
`

type UpdateInvitationParams struct {
        Id        uuid.UUID
        Email     *string
        Role      *string
        ExpiresAt *time.Time
        Status    *string
}

func (q *Queries) UpdateInvitation(ctx context.Context, arg UpdateInvitationParams) (Invitation, error) <span class="cov0" title="0">{
        row := q.db.QueryRow(ctx, updateInvitation,
                arg.Id,
                arg.Email,
                arg.Role,
                arg.ExpiresAt,
                arg.Status,
        )
        var i Invitation
        err := row.Scan(
                &amp;i.Id,
                &amp;i.CreatedAt,
                &amp;i.UpdatedAt,
                &amp;i.Email,
                &amp;i.ExpiresAt,
                &amp;i.InviterId,
                &amp;i.OrganizationId,
                &amp;i.Role,
                &amp;i.Status,
        )
        return i, err
}</span>
</pre>
		
		<pre class="file" id="file65" style="display: none">// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.30.0
// source: labels.sql

package postgresql

import (
        "context"

        "github.com/google/uuid"
)

const createLabel = `-- name: CreateLabel :one
INSERT INTO label (
    id,
    organization_id,
    name
) VALUES (
    $1, $2, $3
)
RETURNING id, created_at, updated_at, name, organization_id
`

type CreateLabelParams struct {
        Id             uuid.UUID
        OrganizationId uuid.UUID
        Name           string
}

func (q *Queries) CreateLabel(ctx context.Context, arg CreateLabelParams) (Label, error) <span class="cov0" title="0">{
        row := q.db.QueryRow(ctx, createLabel, arg.Id, arg.OrganizationId, arg.Name)
        var i Label
        err := row.Scan(
                &amp;i.Id,
                &amp;i.CreatedAt,
                &amp;i.UpdatedAt,
                &amp;i.Name,
                &amp;i.OrganizationId,
        )
        return i, err
}</span>

const deleteLabel = `-- name: DeleteLabel :exec
DELETE FROM label
WHERE id = $1
`

func (q *Queries) DeleteLabel(ctx context.Context, id uuid.UUID) error <span class="cov0" title="0">{
        _, err := q.db.Exec(ctx, deleteLabel, id)
        return err
}</span>

const deleteLabelsByOrganization = `-- name: DeleteLabelsByOrganization :exec
DELETE FROM label
WHERE organization_id = $1
`

func (q *Queries) DeleteLabelsByOrganization(ctx context.Context, organizationID uuid.UUID) error <span class="cov0" title="0">{
        _, err := q.db.Exec(ctx, deleteLabelsByOrganization, organizationID)
        return err
}</span>

const getLabel = `-- name: GetLabel :one
SELECT id, created_at, updated_at, name, organization_id FROM label
WHERE id = $1 LIMIT 1
`

func (q *Queries) GetLabel(ctx context.Context, id uuid.UUID) (Label, error) <span class="cov0" title="0">{
        row := q.db.QueryRow(ctx, getLabel, id)
        var i Label
        err := row.Scan(
                &amp;i.Id,
                &amp;i.CreatedAt,
                &amp;i.UpdatedAt,
                &amp;i.Name,
                &amp;i.OrganizationId,
        )
        return i, err
}</span>

const getLabelByName = `-- name: GetLabelByName :one
SELECT id, created_at, updated_at, name, organization_id FROM label
WHERE organization_id = $1 AND name = $2 LIMIT 1
`

type GetLabelByNameParams struct {
        OrganizationId uuid.UUID
        Name           string
}

func (q *Queries) GetLabelByName(ctx context.Context, arg GetLabelByNameParams) (Label, error) <span class="cov0" title="0">{
        row := q.db.QueryRow(ctx, getLabelByName, arg.OrganizationId, arg.Name)
        var i Label
        err := row.Scan(
                &amp;i.Id,
                &amp;i.CreatedAt,
                &amp;i.UpdatedAt,
                &amp;i.Name,
                &amp;i.OrganizationId,
        )
        return i, err
}</span>

const listLabels = `-- name: ListLabels :many
SELECT id, created_at, updated_at, name, organization_id FROM label
ORDER BY created_at DESC
LIMIT $1 OFFSET $2
`

type ListLabelsParams struct {
        Limit  int32
        Offset int32
}

func (q *Queries) ListLabels(ctx context.Context, arg ListLabelsParams) ([]Label, error) <span class="cov0" title="0">{
        rows, err := q.db.Query(ctx, listLabels, arg.Limit, arg.Offset)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">defer rows.Close()
        var items []Label
        for rows.Next() </span><span class="cov0" title="0">{
                var i Label
                if err := rows.Scan(
                        &amp;i.Id,
                        &amp;i.CreatedAt,
                        &amp;i.UpdatedAt,
                        &amp;i.Name,
                        &amp;i.OrganizationId,
                ); err != nil </span><span class="cov0" title="0">{
                        return nil, err
                }</span>
                <span class="cov0" title="0">items = append(items, i)</span>
        }
        <span class="cov0" title="0">if err := rows.Err(); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">return items, nil</span>
}

const listLabelsByOrganization = `-- name: ListLabelsByOrganization :many
SELECT id, created_at, updated_at, name, organization_id FROM label
WHERE organization_id = $1
ORDER BY name ASC
LIMIT $2 OFFSET $3
`

type ListLabelsByOrganizationParams struct {
        OrganizationId uuid.UUID
        Limit          int32
        Offset         int32
}

func (q *Queries) ListLabelsByOrganization(ctx context.Context, arg ListLabelsByOrganizationParams) ([]Label, error) <span class="cov0" title="0">{
        rows, err := q.db.Query(ctx, listLabelsByOrganization, arg.OrganizationId, arg.Limit, arg.Offset)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">defer rows.Close()
        var items []Label
        for rows.Next() </span><span class="cov0" title="0">{
                var i Label
                if err := rows.Scan(
                        &amp;i.Id,
                        &amp;i.CreatedAt,
                        &amp;i.UpdatedAt,
                        &amp;i.Name,
                        &amp;i.OrganizationId,
                ); err != nil </span><span class="cov0" title="0">{
                        return nil, err
                }</span>
                <span class="cov0" title="0">items = append(items, i)</span>
        }
        <span class="cov0" title="0">if err := rows.Err(); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">return items, nil</span>
}

const updateLabel = `-- name: UpdateLabel :one
UPDATE label
SET 
    name = COALESCE($2, name)
WHERE id = $1
RETURNING id, created_at, updated_at, name, organization_id
`

type UpdateLabelParams struct {
        Id   uuid.UUID
        Name *string
}

func (q *Queries) UpdateLabel(ctx context.Context, arg UpdateLabelParams) (Label, error) <span class="cov0" title="0">{
        row := q.db.QueryRow(ctx, updateLabel, arg.Id, arg.Name)
        var i Label
        err := row.Scan(
                &amp;i.Id,
                &amp;i.CreatedAt,
                &amp;i.UpdatedAt,
                &amp;i.Name,
                &amp;i.OrganizationId,
        )
        return i, err
}</span>
</pre>
		
		<pre class="file" id="file66" style="display: none">// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.30.0
// source: members.sql

package postgresql

import (
        "context"

        "github.com/google/uuid"
)

const createMember = `-- name: CreateMember :one
INSERT INTO member (
    id,
    user_id,
    organization_id,
    role
) VALUES (
    $1, $2, $3, $4
)
RETURNING id, created_at, updated_at, organization_id, role, user_id
`

type CreateMemberParams struct {
        Id             uuid.UUID
        UserId         uuid.UUID
        OrganizationId uuid.UUID
        Role           string
}

func (q *Queries) CreateMember(ctx context.Context, arg CreateMemberParams) (Member, error) <span class="cov0" title="0">{
        row := q.db.QueryRow(ctx, createMember,
                arg.Id,
                arg.UserId,
                arg.OrganizationId,
                arg.Role,
        )
        var i Member
        err := row.Scan(
                &amp;i.Id,
                &amp;i.CreatedAt,
                &amp;i.UpdatedAt,
                &amp;i.OrganizationId,
                &amp;i.Role,
                &amp;i.UserId,
        )
        return i, err
}</span>

const deleteMember = `-- name: DeleteMember :exec
DELETE FROM member
WHERE id = $1
`

func (q *Queries) DeleteMember(ctx context.Context, id uuid.UUID) error <span class="cov0" title="0">{
        _, err := q.db.Exec(ctx, deleteMember, id)
        return err
}</span>

const deleteMembersByOrganization = `-- name: DeleteMembersByOrganization :exec
DELETE FROM member
WHERE organization_id = $1
`

func (q *Queries) DeleteMembersByOrganization(ctx context.Context, organizationID uuid.UUID) error <span class="cov0" title="0">{
        _, err := q.db.Exec(ctx, deleteMembersByOrganization, organizationID)
        return err
}</span>

const getMember = `-- name: GetMember :one
SELECT id, created_at, updated_at, organization_id, role, user_id FROM member
WHERE id = $1 LIMIT 1
`

func (q *Queries) GetMember(ctx context.Context, id uuid.UUID) (Member, error) <span class="cov0" title="0">{
        row := q.db.QueryRow(ctx, getMember, id)
        var i Member
        err := row.Scan(
                &amp;i.Id,
                &amp;i.CreatedAt,
                &amp;i.UpdatedAt,
                &amp;i.OrganizationId,
                &amp;i.Role,
                &amp;i.UserId,
        )
        return i, err
}</span>

const getMemberByUserAndOrg = `-- name: GetMemberByUserAndOrg :one
SELECT id, created_at, updated_at, organization_id, role, user_id FROM member
WHERE user_id = $1 AND organization_id = $2 LIMIT 1
`

type GetMemberByUserAndOrgParams struct {
        UserId         uuid.UUID
        OrganizationId uuid.UUID
}

func (q *Queries) GetMemberByUserAndOrg(ctx context.Context, arg GetMemberByUserAndOrgParams) (Member, error) <span class="cov0" title="0">{
        row := q.db.QueryRow(ctx, getMemberByUserAndOrg, arg.UserId, arg.OrganizationId)
        var i Member
        err := row.Scan(
                &amp;i.Id,
                &amp;i.CreatedAt,
                &amp;i.UpdatedAt,
                &amp;i.OrganizationId,
                &amp;i.Role,
                &amp;i.UserId,
        )
        return i, err
}</span>

const listMembers = `-- name: ListMembers :many
SELECT id, created_at, updated_at, organization_id, role, user_id FROM member
ORDER BY created_at DESC
LIMIT $1 OFFSET $2
`

type ListMembersParams struct {
        Limit  int32
        Offset int32
}

func (q *Queries) ListMembers(ctx context.Context, arg ListMembersParams) ([]Member, error) <span class="cov0" title="0">{
        rows, err := q.db.Query(ctx, listMembers, arg.Limit, arg.Offset)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">defer rows.Close()
        var items []Member
        for rows.Next() </span><span class="cov0" title="0">{
                var i Member
                if err := rows.Scan(
                        &amp;i.Id,
                        &amp;i.CreatedAt,
                        &amp;i.UpdatedAt,
                        &amp;i.OrganizationId,
                        &amp;i.Role,
                        &amp;i.UserId,
                ); err != nil </span><span class="cov0" title="0">{
                        return nil, err
                }</span>
                <span class="cov0" title="0">items = append(items, i)</span>
        }
        <span class="cov0" title="0">if err := rows.Err(); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">return items, nil</span>
}

const listMembersByOrganization = `-- name: ListMembersByOrganization :many
SELECT id, created_at, updated_at, organization_id, role, user_id FROM member
WHERE organization_id = $1
ORDER BY created_at DESC
LIMIT $2 OFFSET $3
`

type ListMembersByOrganizationParams struct {
        OrganizationId uuid.UUID
        Limit          int32
        Offset         int32
}

func (q *Queries) ListMembersByOrganization(ctx context.Context, arg ListMembersByOrganizationParams) ([]Member, error) <span class="cov0" title="0">{
        rows, err := q.db.Query(ctx, listMembersByOrganization, arg.OrganizationId, arg.Limit, arg.Offset)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">defer rows.Close()
        var items []Member
        for rows.Next() </span><span class="cov0" title="0">{
                var i Member
                if err := rows.Scan(
                        &amp;i.Id,
                        &amp;i.CreatedAt,
                        &amp;i.UpdatedAt,
                        &amp;i.OrganizationId,
                        &amp;i.Role,
                        &amp;i.UserId,
                ); err != nil </span><span class="cov0" title="0">{
                        return nil, err
                }</span>
                <span class="cov0" title="0">items = append(items, i)</span>
        }
        <span class="cov0" title="0">if err := rows.Err(); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">return items, nil</span>
}

const listMembersByUser = `-- name: ListMembersByUser :many
SELECT id, created_at, updated_at, organization_id, role, user_id FROM member
WHERE user_id = $1
ORDER BY created_at DESC
LIMIT $2 OFFSET $3
`

type ListMembersByUserParams struct {
        UserId uuid.UUID
        Limit  int32
        Offset int32
}

func (q *Queries) ListMembersByUser(ctx context.Context, arg ListMembersByUserParams) ([]Member, error) <span class="cov0" title="0">{
        rows, err := q.db.Query(ctx, listMembersByUser, arg.UserId, arg.Limit, arg.Offset)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">defer rows.Close()
        var items []Member
        for rows.Next() </span><span class="cov0" title="0">{
                var i Member
                if err := rows.Scan(
                        &amp;i.Id,
                        &amp;i.CreatedAt,
                        &amp;i.UpdatedAt,
                        &amp;i.OrganizationId,
                        &amp;i.Role,
                        &amp;i.UserId,
                ); err != nil </span><span class="cov0" title="0">{
                        return nil, err
                }</span>
                <span class="cov0" title="0">items = append(items, i)</span>
        }
        <span class="cov0" title="0">if err := rows.Err(); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">return items, nil</span>
}

const updateMember = `-- name: UpdateMember :one
UPDATE member
SET 
    role = COALESCE($2, role),
    updated_at = NOW()
WHERE id = $1
RETURNING id, created_at, updated_at, organization_id, role, user_id
`

type UpdateMemberParams struct {
        Id   uuid.UUID
        Role *string
}

func (q *Queries) UpdateMember(ctx context.Context, arg UpdateMemberParams) (Member, error) <span class="cov0" title="0">{
        row := q.db.QueryRow(ctx, updateMember, arg.Id, arg.Role)
        var i Member
        err := row.Scan(
                &amp;i.Id,
                &amp;i.CreatedAt,
                &amp;i.UpdatedAt,
                &amp;i.OrganizationId,
                &amp;i.Role,
                &amp;i.UserId,
        )
        return i, err
}</span>
</pre>
		
		<pre class="file" id="file67" style="display: none">// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.30.0
// source: organizations.sql

package postgresql

import (
        "context"

        "github.com/google/uuid"
)

const createOrganization = `-- name: CreateOrganization :one
INSERT INTO organization (
    id,
    name,
    billing_email,
    plan,
    credits,
    logo,
    metadata,
    stripe_customer_id
) VALUES (
    $1, $2, $3, $4, $5, $6, $7, $8
)
RETURNING id, created_at, updated_at, billing_email, credits, logo, metadata, name, plan, stripe_customer_id
`

type CreateOrganizationParams struct {
        Id               uuid.UUID
        Name             string
        BillingEmail     *string
        Plan             string
        Credits          int32
        Logo             *string
        Metadata         *string
        StripeCustomerId *string
}

func (q *Queries) CreateOrganization(ctx context.Context, arg CreateOrganizationParams) (Organization, error) <span class="cov0" title="0">{
        row := q.db.QueryRow(ctx, createOrganization,
                arg.Id,
                arg.Name,
                arg.BillingEmail,
                arg.Plan,
                arg.Credits,
                arg.Logo,
                arg.Metadata,
                arg.StripeCustomerId,
        )
        var i Organization
        err := row.Scan(
                &amp;i.Id,
                &amp;i.CreatedAt,
                &amp;i.UpdatedAt,
                &amp;i.BillingEmail,
                &amp;i.Credits,
                &amp;i.Logo,
                &amp;i.Metadata,
                &amp;i.Name,
                &amp;i.Plan,
                &amp;i.StripeCustomerId,
        )
        return i, err
}</span>

const deleteOrganization = `-- name: DeleteOrganization :exec
DELETE FROM organization
WHERE id = $1
`

func (q *Queries) DeleteOrganization(ctx context.Context, id uuid.UUID) error <span class="cov0" title="0">{
        _, err := q.db.Exec(ctx, deleteOrganization, id)
        return err
}</span>

const getOrganization = `-- name: GetOrganization :one
SELECT id, created_at, updated_at, billing_email, credits, logo, metadata, name, plan, stripe_customer_id FROM organization
WHERE id = $1 LIMIT 1
`

func (q *Queries) GetOrganization(ctx context.Context, id uuid.UUID) (Organization, error) <span class="cov0" title="0">{
        row := q.db.QueryRow(ctx, getOrganization, id)
        var i Organization
        err := row.Scan(
                &amp;i.Id,
                &amp;i.CreatedAt,
                &amp;i.UpdatedAt,
                &amp;i.BillingEmail,
                &amp;i.Credits,
                &amp;i.Logo,
                &amp;i.Metadata,
                &amp;i.Name,
                &amp;i.Plan,
                &amp;i.StripeCustomerId,
        )
        return i, err
}</span>

const listOrganizations = `-- name: ListOrganizations :many
SELECT id, created_at, updated_at, billing_email, credits, logo, metadata, name, plan, stripe_customer_id FROM organization
ORDER BY created_at DESC
LIMIT $1 OFFSET $2
`

type ListOrganizationsParams struct {
        Limit  int32
        Offset int32
}

func (q *Queries) ListOrganizations(ctx context.Context, arg ListOrganizationsParams) ([]Organization, error) <span class="cov0" title="0">{
        rows, err := q.db.Query(ctx, listOrganizations, arg.Limit, arg.Offset)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">defer rows.Close()
        var items []Organization
        for rows.Next() </span><span class="cov0" title="0">{
                var i Organization
                if err := rows.Scan(
                        &amp;i.Id,
                        &amp;i.CreatedAt,
                        &amp;i.UpdatedAt,
                        &amp;i.BillingEmail,
                        &amp;i.Credits,
                        &amp;i.Logo,
                        &amp;i.Metadata,
                        &amp;i.Name,
                        &amp;i.Plan,
                        &amp;i.StripeCustomerId,
                ); err != nil </span><span class="cov0" title="0">{
                        return nil, err
                }</span>
                <span class="cov0" title="0">items = append(items, i)</span>
        }
        <span class="cov0" title="0">if err := rows.Err(); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">return items, nil</span>
}

const updateOrganization = `-- name: UpdateOrganization :one
UPDATE organization
SET 
    name = COALESCE($2, name),
    billing_email = COALESCE($3, billing_email),
    plan = COALESCE($4, plan),
    credits = COALESCE($5, credits),
    logo = COALESCE($6, logo),
    metadata = COALESCE($7, metadata),
    stripe_customer_id = COALESCE($8, stripe_customer_id)
WHERE id = $1
RETURNING id, created_at, updated_at, billing_email, credits, logo, metadata, name, plan, stripe_customer_id
`

type UpdateOrganizationParams struct {
        Id               uuid.UUID
        Name             *string
        BillingEmail     *string
        Plan             *string
        Credits          *int32
        Logo             *string
        Metadata         *string
        StripeCustomerId *string
}

func (q *Queries) UpdateOrganization(ctx context.Context, arg UpdateOrganizationParams) (Organization, error) <span class="cov0" title="0">{
        row := q.db.QueryRow(ctx, updateOrganization,
                arg.Id,
                arg.Name,
                arg.BillingEmail,
                arg.Plan,
                arg.Credits,
                arg.Logo,
                arg.Metadata,
                arg.StripeCustomerId,
        )
        var i Organization
        err := row.Scan(
                &amp;i.Id,
                &amp;i.CreatedAt,
                &amp;i.UpdatedAt,
                &amp;i.BillingEmail,
                &amp;i.Credits,
                &amp;i.Logo,
                &amp;i.Metadata,
                &amp;i.Name,
                &amp;i.Plan,
                &amp;i.StripeCustomerId,
        )
        return i, err
}</span>
</pre>
		
		<pre class="file" id="file68" style="display: none">// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.30.0
// source: pipeline-step-dependencies.sql

package postgresql

import (
        "context"

        "github.com/google/uuid"
)

const checkDirectCircularDependency = `-- name: CheckDirectCircularDependency :one
SELECT EXISTS (
    SELECT 1 
    FROM pipeline_step_to_dependency 
    WHERE pipeline_step_id = $2 
    AND prerequisite_id = $1
) as would_create_cycle
`

type CheckDirectCircularDependencyParams struct {
        PrerequisiteId uuid.UUID
        PipelineStepId uuid.UUID
}

// Check if adding this dependency would create a direct cycle
func (q *Queries) CheckDirectCircularDependency(ctx context.Context, arg CheckDirectCircularDependencyParams) (bool, error) <span class="cov0" title="0">{
        row := q.db.QueryRow(ctx, checkDirectCircularDependency, arg.PrerequisiteId, arg.PipelineStepId)
        var would_create_cycle bool
        err := row.Scan(&amp;would_create_cycle)
        return would_create_cycle, err
}</span>

const createPipelineStepDependency = `-- name: CreatePipelineStepDependency :exec
INSERT INTO pipeline_step_to_dependency (
    pipeline_step_id,
    prerequisite_id
) VALUES (
    $1, $2
)
`

type CreatePipelineStepDependencyParams struct {
        PipelineStepId uuid.UUID
        PrerequisiteId uuid.UUID
}

func (q *Queries) CreatePipelineStepDependency(ctx context.Context, arg CreatePipelineStepDependencyParams) error <span class="cov0" title="0">{
        _, err := q.db.Exec(ctx, createPipelineStepDependency, arg.PipelineStepId, arg.PrerequisiteId)
        return err
}</span>

const deleteAllStepDependencies = `-- name: DeleteAllStepDependencies :exec
DELETE FROM pipeline_step_to_dependency
WHERE pipeline_step_id = $1 OR prerequisite_id = $1
`

func (q *Queries) DeleteAllStepDependencies(ctx context.Context, pipelineStepID uuid.UUID) error <span class="cov0" title="0">{
        _, err := q.db.Exec(ctx, deleteAllStepDependencies, pipelineStepID)
        return err
}</span>

const deletePipelineStepDependency = `-- name: DeletePipelineStepDependency :exec
DELETE FROM pipeline_step_to_dependency
WHERE pipeline_step_id = $1 AND prerequisite_id = $2
`

type DeletePipelineStepDependencyParams struct {
        PipelineStepId uuid.UUID
        PrerequisiteId uuid.UUID
}

func (q *Queries) DeletePipelineStepDependency(ctx context.Context, arg DeletePipelineStepDependencyParams) error <span class="cov0" title="0">{
        _, err := q.db.Exec(ctx, deletePipelineStepDependency, arg.PipelineStepId, arg.PrerequisiteId)
        return err
}</span>

const getPipelineStepDependencies = `-- name: GetPipelineStepDependencies :many
SELECT 
    psd.pipeline_step_id,
    psd.prerequisite_id,
    ps.pipeline_id
FROM pipeline_step_to_dependency psd
JOIN pipeline_step ps ON ps.id = psd.pipeline_step_id
WHERE ps.pipeline_id = $1
`

type GetPipelineStepDependenciesRow struct {
        PipelineStepId uuid.UUID
        PrerequisiteId uuid.UUID
        PipelineId     uuid.UUID
}

func (q *Queries) GetPipelineStepDependencies(ctx context.Context, pipelineID uuid.UUID) ([]GetPipelineStepDependenciesRow, error) <span class="cov0" title="0">{
        rows, err := q.db.Query(ctx, getPipelineStepDependencies, pipelineID)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">defer rows.Close()
        var items []GetPipelineStepDependenciesRow
        for rows.Next() </span><span class="cov0" title="0">{
                var i GetPipelineStepDependenciesRow
                if err := rows.Scan(&amp;i.PipelineStepId, &amp;i.PrerequisiteId, &amp;i.PipelineId); err != nil </span><span class="cov0" title="0">{
                        return nil, err
                }</span>
                <span class="cov0" title="0">items = append(items, i)</span>
        }
        <span class="cov0" title="0">if err := rows.Err(); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">return items, nil</span>
}

const getStepDependencies = `-- name: GetStepDependencies :many
SELECT prerequisite_id
FROM pipeline_step_to_dependency
WHERE pipeline_step_id = $1
`

func (q *Queries) GetStepDependencies(ctx context.Context, pipelineStepID uuid.UUID) ([]uuid.UUID, error) <span class="cov0" title="0">{
        rows, err := q.db.Query(ctx, getStepDependencies, pipelineStepID)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">defer rows.Close()
        var items []uuid.UUID
        for rows.Next() </span><span class="cov0" title="0">{
                var prerequisite_id uuid.UUID
                if err := rows.Scan(&amp;prerequisite_id); err != nil </span><span class="cov0" title="0">{
                        return nil, err
                }</span>
                <span class="cov0" title="0">items = append(items, prerequisite_id)</span>
        }
        <span class="cov0" title="0">if err := rows.Err(); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">return items, nil</span>
}

const getStepDependents = `-- name: GetStepDependents :many
SELECT pipeline_step_id
FROM pipeline_step_to_dependency
WHERE prerequisite_id = $1
`

func (q *Queries) GetStepDependents(ctx context.Context, prerequisiteID uuid.UUID) ([]uuid.UUID, error) <span class="cov0" title="0">{
        rows, err := q.db.Query(ctx, getStepDependents, prerequisiteID)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">defer rows.Close()
        var items []uuid.UUID
        for rows.Next() </span><span class="cov0" title="0">{
                var pipeline_step_id uuid.UUID
                if err := rows.Scan(&amp;pipeline_step_id); err != nil </span><span class="cov0" title="0">{
                        return nil, err
                }</span>
                <span class="cov0" title="0">items = append(items, pipeline_step_id)</span>
        }
        <span class="cov0" title="0">if err := rows.Err(); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">return items, nil</span>
}
</pre>
		
		<pre class="file" id="file69" style="display: none">// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.30.0
// source: pipeline-steps.sql

package postgresql

import (
        "context"
        "time"

        "github.com/google/uuid"
)

const countPipelineSteps = `-- name: CountPipelineSteps :one
SELECT COUNT(*) as count
FROM pipeline_step
WHERE pipeline_id = $1
`

func (q *Queries) CountPipelineSteps(ctx context.Context, pipelineID uuid.UUID) (int64, error) <span class="cov0" title="0">{
        row := q.db.QueryRow(ctx, countPipelineSteps, pipelineID)
        var count int64
        err := row.Scan(&amp;count)
        return count, err
}</span>

const createPipelineStep = `-- name: CreatePipelineStep :one
INSERT INTO pipeline_step (
    id,
    pipeline_id,
    tool_id
) VALUES (
    $1, $2, $3
)
RETURNING id, created_at, updated_at, pipeline_id, tool_id
`

type CreatePipelineStepParams struct {
        Id         uuid.UUID
        PipelineId uuid.UUID
        ToolId     uuid.UUID
}

func (q *Queries) CreatePipelineStep(ctx context.Context, arg CreatePipelineStepParams) (PipelineStep, error) <span class="cov0" title="0">{
        row := q.db.QueryRow(ctx, createPipelineStep, arg.Id, arg.PipelineId, arg.ToolId)
        var i PipelineStep
        err := row.Scan(
                &amp;i.Id,
                &amp;i.CreatedAt,
                &amp;i.UpdatedAt,
                &amp;i.PipelineId,
                &amp;i.ToolId,
        )
        return i, err
}</span>

const deletePipelineStep = `-- name: DeletePipelineStep :exec
DELETE FROM pipeline_step
WHERE id = $1
`

func (q *Queries) DeletePipelineStep(ctx context.Context, id uuid.UUID) error <span class="cov0" title="0">{
        _, err := q.db.Exec(ctx, deletePipelineStep, id)
        return err
}</span>

const deletePipelineStepsByPipeline = `-- name: DeletePipelineStepsByPipeline :exec
DELETE FROM pipeline_step
WHERE pipeline_id = $1
`

func (q *Queries) DeletePipelineStepsByPipeline(ctx context.Context, pipelineID uuid.UUID) error <span class="cov0" title="0">{
        _, err := q.db.Exec(ctx, deletePipelineStepsByPipeline, pipelineID)
        return err
}</span>

const getPipelineStep = `-- name: GetPipelineStep :one
SELECT id, created_at, updated_at, pipeline_id, tool_id FROM pipeline_step
WHERE id = $1 LIMIT 1
`

func (q *Queries) GetPipelineStep(ctx context.Context, id uuid.UUID) (PipelineStep, error) <span class="cov0" title="0">{
        row := q.db.QueryRow(ctx, getPipelineStep, id)
        var i PipelineStep
        err := row.Scan(
                &amp;i.Id,
                &amp;i.CreatedAt,
                &amp;i.UpdatedAt,
                &amp;i.PipelineId,
                &amp;i.ToolId,
        )
        return i, err
}</span>

const getPipelineStepsWithDependencies = `-- name: GetPipelineStepsWithDependencies :many
SELECT 
    ps.id,
    ps.pipeline_id,
    ps.tool_id,
    ps.created_at,
    ps.updated_at,
    COALESCE(
        ARRAY_AGG(
            DISTINCT psd.prerequisite_id
        ) FILTER (WHERE psd.prerequisite_id IS NOT NULL),
        ARRAY[]::UUID[]
    ) as dependencies
FROM pipeline_step ps
LEFT JOIN pipeline_step_to_dependency psd ON ps.id = psd.pipeline_step_id
WHERE ps.pipeline_id = $1
GROUP BY ps.id, ps.pipeline_id, ps.tool_id, ps.created_at, ps.updated_at
ORDER BY ps.created_at ASC
`

type GetPipelineStepsWithDependenciesRow struct {
        Id           uuid.UUID
        PipelineId   uuid.UUID
        ToolId       uuid.UUID
        CreatedAt    time.Time
        UpdatedAt    time.Time
        Dependencies interface{}
}

func (q *Queries) GetPipelineStepsWithDependencies(ctx context.Context, pipelineID uuid.UUID) ([]GetPipelineStepsWithDependenciesRow, error) <span class="cov0" title="0">{
        rows, err := q.db.Query(ctx, getPipelineStepsWithDependencies, pipelineID)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">defer rows.Close()
        var items []GetPipelineStepsWithDependenciesRow
        for rows.Next() </span><span class="cov0" title="0">{
                var i GetPipelineStepsWithDependenciesRow
                if err := rows.Scan(
                        &amp;i.Id,
                        &amp;i.PipelineId,
                        &amp;i.ToolId,
                        &amp;i.CreatedAt,
                        &amp;i.UpdatedAt,
                        &amp;i.Dependencies,
                ); err != nil </span><span class="cov0" title="0">{
                        return nil, err
                }</span>
                <span class="cov0" title="0">items = append(items, i)</span>
        }
        <span class="cov0" title="0">if err := rows.Err(); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">return items, nil</span>
}

const listPipelineSteps = `-- name: ListPipelineSteps :many
SELECT id, created_at, updated_at, pipeline_id, tool_id FROM pipeline_step
ORDER BY created_at DESC
LIMIT $1 OFFSET $2
`

type ListPipelineStepsParams struct {
        Limit  int32
        Offset int32
}

func (q *Queries) ListPipelineSteps(ctx context.Context, arg ListPipelineStepsParams) ([]PipelineStep, error) <span class="cov0" title="0">{
        rows, err := q.db.Query(ctx, listPipelineSteps, arg.Limit, arg.Offset)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">defer rows.Close()
        var items []PipelineStep
        for rows.Next() </span><span class="cov0" title="0">{
                var i PipelineStep
                if err := rows.Scan(
                        &amp;i.Id,
                        &amp;i.CreatedAt,
                        &amp;i.UpdatedAt,
                        &amp;i.PipelineId,
                        &amp;i.ToolId,
                ); err != nil </span><span class="cov0" title="0">{
                        return nil, err
                }</span>
                <span class="cov0" title="0">items = append(items, i)</span>
        }
        <span class="cov0" title="0">if err := rows.Err(); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">return items, nil</span>
}

const listPipelineStepsByPipeline = `-- name: ListPipelineStepsByPipeline :many
SELECT id, created_at, updated_at, pipeline_id, tool_id FROM pipeline_step
WHERE pipeline_id = $1
ORDER BY created_at ASC
LIMIT $2 OFFSET $3
`

type ListPipelineStepsByPipelineParams struct {
        PipelineId uuid.UUID
        Limit      int32
        Offset     int32
}

func (q *Queries) ListPipelineStepsByPipeline(ctx context.Context, arg ListPipelineStepsByPipelineParams) ([]PipelineStep, error) <span class="cov0" title="0">{
        rows, err := q.db.Query(ctx, listPipelineStepsByPipeline, arg.PipelineId, arg.Limit, arg.Offset)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">defer rows.Close()
        var items []PipelineStep
        for rows.Next() </span><span class="cov0" title="0">{
                var i PipelineStep
                if err := rows.Scan(
                        &amp;i.Id,
                        &amp;i.CreatedAt,
                        &amp;i.UpdatedAt,
                        &amp;i.PipelineId,
                        &amp;i.ToolId,
                ); err != nil </span><span class="cov0" title="0">{
                        return nil, err
                }</span>
                <span class="cov0" title="0">items = append(items, i)</span>
        }
        <span class="cov0" title="0">if err := rows.Err(); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">return items, nil</span>
}

const listPipelineStepsByTool = `-- name: ListPipelineStepsByTool :many
SELECT id, created_at, updated_at, pipeline_id, tool_id FROM pipeline_step
WHERE tool_id = $1
ORDER BY created_at DESC
LIMIT $2 OFFSET $3
`

type ListPipelineStepsByToolParams struct {
        ToolId uuid.UUID
        Limit  int32
        Offset int32
}

func (q *Queries) ListPipelineStepsByTool(ctx context.Context, arg ListPipelineStepsByToolParams) ([]PipelineStep, error) <span class="cov0" title="0">{
        rows, err := q.db.Query(ctx, listPipelineStepsByTool, arg.ToolId, arg.Limit, arg.Offset)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">defer rows.Close()
        var items []PipelineStep
        for rows.Next() </span><span class="cov0" title="0">{
                var i PipelineStep
                if err := rows.Scan(
                        &amp;i.Id,
                        &amp;i.CreatedAt,
                        &amp;i.UpdatedAt,
                        &amp;i.PipelineId,
                        &amp;i.ToolId,
                ); err != nil </span><span class="cov0" title="0">{
                        return nil, err
                }</span>
                <span class="cov0" title="0">items = append(items, i)</span>
        }
        <span class="cov0" title="0">if err := rows.Err(); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">return items, nil</span>
}

const updatePipelineStep = `-- name: UpdatePipelineStep :one
UPDATE pipeline_step
SET 
    tool_id = COALESCE($2, tool_id)
WHERE id = $1
RETURNING id, created_at, updated_at, pipeline_id, tool_id
`

type UpdatePipelineStepParams struct {
        Id     uuid.UUID
        ToolId *uuid.UUID
}

func (q *Queries) UpdatePipelineStep(ctx context.Context, arg UpdatePipelineStepParams) (PipelineStep, error) <span class="cov0" title="0">{
        row := q.db.QueryRow(ctx, updatePipelineStep, arg.Id, arg.ToolId)
        var i PipelineStep
        err := row.Scan(
                &amp;i.Id,
                &amp;i.CreatedAt,
                &amp;i.UpdatedAt,
                &amp;i.PipelineId,
                &amp;i.ToolId,
        )
        return i, err
}</span>
</pre>
		
		<pre class="file" id="file70" style="display: none">// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.30.0
// source: pipelines.sql

package postgresql

import (
        "context"

        "github.com/google/uuid"
)

const createPipeline = `-- name: CreatePipeline :one
INSERT INTO pipeline (
    id,
    organization_id,
    name,
    description
) VALUES (
    $1, $2, $3, $4
)
RETURNING id, created_at, updated_at, description, name, organization_id
`

type CreatePipelineParams struct {
        Id             uuid.UUID
        OrganizationId uuid.UUID
        Name           *string
        Description    *string
}

func (q *Queries) CreatePipeline(ctx context.Context, arg CreatePipelineParams) (Pipeline, error) <span class="cov0" title="0">{
        row := q.db.QueryRow(ctx, createPipeline,
                arg.Id,
                arg.OrganizationId,
                arg.Name,
                arg.Description,
        )
        var i Pipeline
        err := row.Scan(
                &amp;i.Id,
                &amp;i.CreatedAt,
                &amp;i.UpdatedAt,
                &amp;i.Description,
                &amp;i.Name,
                &amp;i.OrganizationId,
        )
        return i, err
}</span>

const deletePipeline = `-- name: DeletePipeline :exec
DELETE FROM pipeline
WHERE id = $1
`

func (q *Queries) DeletePipeline(ctx context.Context, id uuid.UUID) error <span class="cov0" title="0">{
        _, err := q.db.Exec(ctx, deletePipeline, id)
        return err
}</span>

const deletePipelinesByOrganization = `-- name: DeletePipelinesByOrganization :exec
DELETE FROM pipeline
WHERE organization_id = $1
`

func (q *Queries) DeletePipelinesByOrganization(ctx context.Context, organizationID uuid.UUID) error <span class="cov0" title="0">{
        _, err := q.db.Exec(ctx, deletePipelinesByOrganization, organizationID)
        return err
}</span>

const getPipeline = `-- name: GetPipeline :one
SELECT id, created_at, updated_at, description, name, organization_id FROM pipeline
WHERE id = $1 LIMIT 1
`

func (q *Queries) GetPipeline(ctx context.Context, id uuid.UUID) (Pipeline, error) <span class="cov0" title="0">{
        row := q.db.QueryRow(ctx, getPipeline, id)
        var i Pipeline
        err := row.Scan(
                &amp;i.Id,
                &amp;i.CreatedAt,
                &amp;i.UpdatedAt,
                &amp;i.Description,
                &amp;i.Name,
                &amp;i.OrganizationId,
        )
        return i, err
}</span>

const listPipelines = `-- name: ListPipelines :many
SELECT id, created_at, updated_at, description, name, organization_id FROM pipeline
ORDER BY created_at DESC
LIMIT $1 OFFSET $2
`

type ListPipelinesParams struct {
        Limit  int32
        Offset int32
}

func (q *Queries) ListPipelines(ctx context.Context, arg ListPipelinesParams) ([]Pipeline, error) <span class="cov0" title="0">{
        rows, err := q.db.Query(ctx, listPipelines, arg.Limit, arg.Offset)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">defer rows.Close()
        var items []Pipeline
        for rows.Next() </span><span class="cov0" title="0">{
                var i Pipeline
                if err := rows.Scan(
                        &amp;i.Id,
                        &amp;i.CreatedAt,
                        &amp;i.UpdatedAt,
                        &amp;i.Description,
                        &amp;i.Name,
                        &amp;i.OrganizationId,
                ); err != nil </span><span class="cov0" title="0">{
                        return nil, err
                }</span>
                <span class="cov0" title="0">items = append(items, i)</span>
        }
        <span class="cov0" title="0">if err := rows.Err(); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">return items, nil</span>
}

const listPipelinesByOrganization = `-- name: ListPipelinesByOrganization :many
SELECT id, created_at, updated_at, description, name, organization_id FROM pipeline
WHERE organization_id = $1
ORDER BY created_at DESC
LIMIT $2 OFFSET $3
`

type ListPipelinesByOrganizationParams struct {
        OrganizationId uuid.UUID
        Limit          int32
        Offset         int32
}

func (q *Queries) ListPipelinesByOrganization(ctx context.Context, arg ListPipelinesByOrganizationParams) ([]Pipeline, error) <span class="cov0" title="0">{
        rows, err := q.db.Query(ctx, listPipelinesByOrganization, arg.OrganizationId, arg.Limit, arg.Offset)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">defer rows.Close()
        var items []Pipeline
        for rows.Next() </span><span class="cov0" title="0">{
                var i Pipeline
                if err := rows.Scan(
                        &amp;i.Id,
                        &amp;i.CreatedAt,
                        &amp;i.UpdatedAt,
                        &amp;i.Description,
                        &amp;i.Name,
                        &amp;i.OrganizationId,
                ); err != nil </span><span class="cov0" title="0">{
                        return nil, err
                }</span>
                <span class="cov0" title="0">items = append(items, i)</span>
        }
        <span class="cov0" title="0">if err := rows.Err(); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">return items, nil</span>
}

const updatePipeline = `-- name: UpdatePipeline :one
UPDATE pipeline
SET 
    name = COALESCE($2, name),
    description = COALESCE($3, description)
WHERE id = $1
RETURNING id, created_at, updated_at, description, name, organization_id
`

type UpdatePipelineParams struct {
        Id          uuid.UUID
        Name        *string
        Description *string
}

func (q *Queries) UpdatePipeline(ctx context.Context, arg UpdatePipelineParams) (Pipeline, error) <span class="cov0" title="0">{
        row := q.db.QueryRow(ctx, updatePipeline, arg.Id, arg.Name, arg.Description)
        var i Pipeline
        err := row.Scan(
                &amp;i.Id,
                &amp;i.CreatedAt,
                &amp;i.UpdatedAt,
                &amp;i.Description,
                &amp;i.Name,
                &amp;i.OrganizationId,
        )
        return i, err
}</span>
</pre>
		
		<pre class="file" id="file71" style="display: none">// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.30.0
// source: runs.sql

package postgresql

import (
        "context"
        "time"

        "github.com/google/uuid"
)

const createRun = `-- name: CreateRun :one
INSERT INTO run (
    id,
    organization_id,
    pipeline_id,
    tool_id,
    status,
    progress
) VALUES (
    $1, $2, $3, $4, $5, $6
)
RETURNING id, created_at, updated_at, completed_at, error, organization_id, pipeline_id, progress, started_at, status, tool_id
`

type CreateRunParams struct {
        Id             uuid.UUID
        OrganizationId uuid.UUID
        PipelineId     *uuid.UUID
        ToolId         *uuid.UUID
        Status         string
        Progress       float64
}

func (q *Queries) CreateRun(ctx context.Context, arg CreateRunParams) (Run, error) <span class="cov0" title="0">{
        row := q.db.QueryRow(ctx, createRun,
                arg.Id,
                arg.OrganizationId,
                arg.PipelineId,
                arg.ToolId,
                arg.Status,
                arg.Progress,
        )
        var i Run
        err := row.Scan(
                &amp;i.Id,
                &amp;i.CreatedAt,
                &amp;i.UpdatedAt,
                &amp;i.CompletedAt,
                &amp;i.Error,
                &amp;i.OrganizationId,
                &amp;i.PipelineId,
                &amp;i.Progress,
                &amp;i.StartedAt,
                &amp;i.Status,
                &amp;i.ToolId,
        )
        return i, err
}</span>

const deleteRun = `-- name: DeleteRun :exec
DELETE FROM run
WHERE id = $1
`

func (q *Queries) DeleteRun(ctx context.Context, id uuid.UUID) error <span class="cov0" title="0">{
        _, err := q.db.Exec(ctx, deleteRun, id)
        return err
}</span>

const deleteRunsByPipeline = `-- name: DeleteRunsByPipeline :exec
DELETE FROM run
WHERE pipeline_id = $1
`

func (q *Queries) DeleteRunsByPipeline(ctx context.Context, pipelineID *uuid.UUID) error <span class="cov0" title="0">{
        _, err := q.db.Exec(ctx, deleteRunsByPipeline, pipelineID)
        return err
}</span>

const getRun = `-- name: GetRun :one
SELECT id, created_at, updated_at, completed_at, error, organization_id, pipeline_id, progress, started_at, status, tool_id FROM run
WHERE id = $1 LIMIT 1
`

func (q *Queries) GetRun(ctx context.Context, id uuid.UUID) (Run, error) <span class="cov0" title="0">{
        row := q.db.QueryRow(ctx, getRun, id)
        var i Run
        err := row.Scan(
                &amp;i.Id,
                &amp;i.CreatedAt,
                &amp;i.UpdatedAt,
                &amp;i.CompletedAt,
                &amp;i.Error,
                &amp;i.OrganizationId,
                &amp;i.PipelineId,
                &amp;i.Progress,
                &amp;i.StartedAt,
                &amp;i.Status,
                &amp;i.ToolId,
        )
        return i, err
}</span>

const listRuns = `-- name: ListRuns :many
SELECT id, created_at, updated_at, completed_at, error, organization_id, pipeline_id, progress, started_at, status, tool_id FROM run
ORDER BY created_at DESC
LIMIT $1 OFFSET $2
`

type ListRunsParams struct {
        Limit  int32
        Offset int32
}

func (q *Queries) ListRuns(ctx context.Context, arg ListRunsParams) ([]Run, error) <span class="cov0" title="0">{
        rows, err := q.db.Query(ctx, listRuns, arg.Limit, arg.Offset)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">defer rows.Close()
        var items []Run
        for rows.Next() </span><span class="cov0" title="0">{
                var i Run
                if err := rows.Scan(
                        &amp;i.Id,
                        &amp;i.CreatedAt,
                        &amp;i.UpdatedAt,
                        &amp;i.CompletedAt,
                        &amp;i.Error,
                        &amp;i.OrganizationId,
                        &amp;i.PipelineId,
                        &amp;i.Progress,
                        &amp;i.StartedAt,
                        &amp;i.Status,
                        &amp;i.ToolId,
                ); err != nil </span><span class="cov0" title="0">{
                        return nil, err
                }</span>
                <span class="cov0" title="0">items = append(items, i)</span>
        }
        <span class="cov0" title="0">if err := rows.Err(); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">return items, nil</span>
}

const listRunsByOrganization = `-- name: ListRunsByOrganization :many
SELECT id, created_at, updated_at, completed_at, error, organization_id, pipeline_id, progress, started_at, status, tool_id FROM run
WHERE organization_id = $1
ORDER BY created_at DESC
LIMIT $2 OFFSET $3
`

type ListRunsByOrganizationParams struct {
        OrganizationId uuid.UUID
        Limit          int32
        Offset         int32
}

func (q *Queries) ListRunsByOrganization(ctx context.Context, arg ListRunsByOrganizationParams) ([]Run, error) <span class="cov0" title="0">{
        rows, err := q.db.Query(ctx, listRunsByOrganization, arg.OrganizationId, arg.Limit, arg.Offset)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">defer rows.Close()
        var items []Run
        for rows.Next() </span><span class="cov0" title="0">{
                var i Run
                if err := rows.Scan(
                        &amp;i.Id,
                        &amp;i.CreatedAt,
                        &amp;i.UpdatedAt,
                        &amp;i.CompletedAt,
                        &amp;i.Error,
                        &amp;i.OrganizationId,
                        &amp;i.PipelineId,
                        &amp;i.Progress,
                        &amp;i.StartedAt,
                        &amp;i.Status,
                        &amp;i.ToolId,
                ); err != nil </span><span class="cov0" title="0">{
                        return nil, err
                }</span>
                <span class="cov0" title="0">items = append(items, i)</span>
        }
        <span class="cov0" title="0">if err := rows.Err(); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">return items, nil</span>
}

const listRunsByPipeline = `-- name: ListRunsByPipeline :many
SELECT id, created_at, updated_at, completed_at, error, organization_id, pipeline_id, progress, started_at, status, tool_id FROM run
WHERE pipeline_id = $1
ORDER BY created_at DESC
LIMIT $2 OFFSET $3
`

type ListRunsByPipelineParams struct {
        PipelineId *uuid.UUID
        Limit      int32
        Offset     int32
}

func (q *Queries) ListRunsByPipeline(ctx context.Context, arg ListRunsByPipelineParams) ([]Run, error) <span class="cov0" title="0">{
        rows, err := q.db.Query(ctx, listRunsByPipeline, arg.PipelineId, arg.Limit, arg.Offset)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">defer rows.Close()
        var items []Run
        for rows.Next() </span><span class="cov0" title="0">{
                var i Run
                if err := rows.Scan(
                        &amp;i.Id,
                        &amp;i.CreatedAt,
                        &amp;i.UpdatedAt,
                        &amp;i.CompletedAt,
                        &amp;i.Error,
                        &amp;i.OrganizationId,
                        &amp;i.PipelineId,
                        &amp;i.Progress,
                        &amp;i.StartedAt,
                        &amp;i.Status,
                        &amp;i.ToolId,
                ); err != nil </span><span class="cov0" title="0">{
                        return nil, err
                }</span>
                <span class="cov0" title="0">items = append(items, i)</span>
        }
        <span class="cov0" title="0">if err := rows.Err(); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">return items, nil</span>
}

const listRunsByTool = `-- name: ListRunsByTool :many
SELECT id, created_at, updated_at, completed_at, error, organization_id, pipeline_id, progress, started_at, status, tool_id FROM run
WHERE tool_id = $1
ORDER BY created_at DESC
LIMIT $2 OFFSET $3
`

type ListRunsByToolParams struct {
        ToolId *uuid.UUID
        Limit  int32
        Offset int32
}

func (q *Queries) ListRunsByTool(ctx context.Context, arg ListRunsByToolParams) ([]Run, error) <span class="cov0" title="0">{
        rows, err := q.db.Query(ctx, listRunsByTool, arg.ToolId, arg.Limit, arg.Offset)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">defer rows.Close()
        var items []Run
        for rows.Next() </span><span class="cov0" title="0">{
                var i Run
                if err := rows.Scan(
                        &amp;i.Id,
                        &amp;i.CreatedAt,
                        &amp;i.UpdatedAt,
                        &amp;i.CompletedAt,
                        &amp;i.Error,
                        &amp;i.OrganizationId,
                        &amp;i.PipelineId,
                        &amp;i.Progress,
                        &amp;i.StartedAt,
                        &amp;i.Status,
                        &amp;i.ToolId,
                ); err != nil </span><span class="cov0" title="0">{
                        return nil, err
                }</span>
                <span class="cov0" title="0">items = append(items, i)</span>
        }
        <span class="cov0" title="0">if err := rows.Err(); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">return items, nil</span>
}

const updateRun = `-- name: UpdateRun :one
UPDATE run
SET 
    pipeline_id = COALESCE($2, pipeline_id),
    tool_id = COALESCE($3, tool_id),
    status = COALESCE($4, status),
    progress = COALESCE($5, progress),
    error = COALESCE($6, error),
    started_at = COALESCE($7, started_at),
    completed_at = COALESCE($8, completed_at),
    updated_at = NOW()
WHERE id = $1
RETURNING id, created_at, updated_at, completed_at, error, organization_id, pipeline_id, progress, started_at, status, tool_id
`

type UpdateRunParams struct {
        Id          uuid.UUID
        PipelineId  *uuid.UUID
        ToolId      *uuid.UUID
        Status      *string
        Progress    *float64
        Error       *string
        StartedAt   *time.Time
        CompletedAt *time.Time
}

func (q *Queries) UpdateRun(ctx context.Context, arg UpdateRunParams) (Run, error) <span class="cov0" title="0">{
        row := q.db.QueryRow(ctx, updateRun,
                arg.Id,
                arg.PipelineId,
                arg.ToolId,
                arg.Status,
                arg.Progress,
                arg.Error,
                arg.StartedAt,
                arg.CompletedAt,
        )
        var i Run
        err := row.Scan(
                &amp;i.Id,
                &amp;i.CreatedAt,
                &amp;i.UpdatedAt,
                &amp;i.CompletedAt,
                &amp;i.Error,
                &amp;i.OrganizationId,
                &amp;i.PipelineId,
                &amp;i.Progress,
                &amp;i.StartedAt,
                &amp;i.Status,
                &amp;i.ToolId,
        )
        return i, err
}</span>
</pre>
		
		<pre class="file" id="file72" style="display: none">// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.30.0
// source: tools.sql

package postgresql

import (
        "context"

        "github.com/google/uuid"
)

const createTool = `-- name: CreateTool :one
INSERT INTO tool (
    id,
    organization_id,
    name,
    description,
    input_mime_type,
    output_mime_type
) VALUES (
    $1, $2, $3, $4, $5, $6
)
RETURNING id, created_at, updated_at, description, input_mime_type, name, organization_id, output_mime_type
`

type CreateToolParams struct {
        Id             uuid.UUID
        OrganizationId uuid.UUID
        Name           string
        Description    string
        InputMimeType  string
        OutputMimeType string
}

func (q *Queries) CreateTool(ctx context.Context, arg CreateToolParams) (Tool, error) <span class="cov0" title="0">{
        row := q.db.QueryRow(ctx, createTool,
                arg.Id,
                arg.OrganizationId,
                arg.Name,
                arg.Description,
                arg.InputMimeType,
                arg.OutputMimeType,
        )
        var i Tool
        err := row.Scan(
                &amp;i.Id,
                &amp;i.CreatedAt,
                &amp;i.UpdatedAt,
                &amp;i.Description,
                &amp;i.InputMimeType,
                &amp;i.Name,
                &amp;i.OrganizationId,
                &amp;i.OutputMimeType,
        )
        return i, err
}</span>

const deleteTool = `-- name: DeleteTool :exec
DELETE FROM tool
WHERE id = $1
`

func (q *Queries) DeleteTool(ctx context.Context, id uuid.UUID) error <span class="cov0" title="0">{
        _, err := q.db.Exec(ctx, deleteTool, id)
        return err
}</span>

const deleteToolsByOrganization = `-- name: DeleteToolsByOrganization :exec
DELETE FROM tool
WHERE organization_id = $1
`

func (q *Queries) DeleteToolsByOrganization(ctx context.Context, organizationID uuid.UUID) error <span class="cov0" title="0">{
        _, err := q.db.Exec(ctx, deleteToolsByOrganization, organizationID)
        return err
}</span>

const getTool = `-- name: GetTool :one
SELECT id, created_at, updated_at, description, input_mime_type, name, organization_id, output_mime_type FROM tool
WHERE id = $1 LIMIT 1
`

func (q *Queries) GetTool(ctx context.Context, id uuid.UUID) (Tool, error) <span class="cov0" title="0">{
        row := q.db.QueryRow(ctx, getTool, id)
        var i Tool
        err := row.Scan(
                &amp;i.Id,
                &amp;i.CreatedAt,
                &amp;i.UpdatedAt,
                &amp;i.Description,
                &amp;i.InputMimeType,
                &amp;i.Name,
                &amp;i.OrganizationId,
                &amp;i.OutputMimeType,
        )
        return i, err
}</span>

const listTools = `-- name: ListTools :many
SELECT id, created_at, updated_at, description, input_mime_type, name, organization_id, output_mime_type FROM tool
ORDER BY created_at DESC
LIMIT $1 OFFSET $2
`

type ListToolsParams struct {
        Limit  int32
        Offset int32
}

func (q *Queries) ListTools(ctx context.Context, arg ListToolsParams) ([]Tool, error) <span class="cov0" title="0">{
        rows, err := q.db.Query(ctx, listTools, arg.Limit, arg.Offset)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">defer rows.Close()
        var items []Tool
        for rows.Next() </span><span class="cov0" title="0">{
                var i Tool
                if err := rows.Scan(
                        &amp;i.Id,
                        &amp;i.CreatedAt,
                        &amp;i.UpdatedAt,
                        &amp;i.Description,
                        &amp;i.InputMimeType,
                        &amp;i.Name,
                        &amp;i.OrganizationId,
                        &amp;i.OutputMimeType,
                ); err != nil </span><span class="cov0" title="0">{
                        return nil, err
                }</span>
                <span class="cov0" title="0">items = append(items, i)</span>
        }
        <span class="cov0" title="0">if err := rows.Err(); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">return items, nil</span>
}

const listToolsByOrganization = `-- name: ListToolsByOrganization :many
SELECT id, created_at, updated_at, description, input_mime_type, name, organization_id, output_mime_type FROM tool
WHERE organization_id = $1
ORDER BY created_at DESC
LIMIT $2 OFFSET $3
`

type ListToolsByOrganizationParams struct {
        OrganizationId uuid.UUID
        Limit          int32
        Offset         int32
}

func (q *Queries) ListToolsByOrganization(ctx context.Context, arg ListToolsByOrganizationParams) ([]Tool, error) <span class="cov0" title="0">{
        rows, err := q.db.Query(ctx, listToolsByOrganization, arg.OrganizationId, arg.Limit, arg.Offset)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">defer rows.Close()
        var items []Tool
        for rows.Next() </span><span class="cov0" title="0">{
                var i Tool
                if err := rows.Scan(
                        &amp;i.Id,
                        &amp;i.CreatedAt,
                        &amp;i.UpdatedAt,
                        &amp;i.Description,
                        &amp;i.InputMimeType,
                        &amp;i.Name,
                        &amp;i.OrganizationId,
                        &amp;i.OutputMimeType,
                ); err != nil </span><span class="cov0" title="0">{
                        return nil, err
                }</span>
                <span class="cov0" title="0">items = append(items, i)</span>
        }
        <span class="cov0" title="0">if err := rows.Err(); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">return items, nil</span>
}

const updateTool = `-- name: UpdateTool :one
UPDATE tool
SET 
    name = COALESCE($2, name),
    description = COALESCE($3, description),
    input_mime_type = COALESCE($4, input_mime_type),
    output_mime_type = COALESCE($5, output_mime_type)
WHERE id = $1
RETURNING id, created_at, updated_at, description, input_mime_type, name, organization_id, output_mime_type
`

type UpdateToolParams struct {
        Id             uuid.UUID
        Name           *string
        Description    *string
        InputMimeType  *string
        OutputMimeType *string
}

func (q *Queries) UpdateTool(ctx context.Context, arg UpdateToolParams) (Tool, error) <span class="cov0" title="0">{
        row := q.db.QueryRow(ctx, updateTool,
                arg.Id,
                arg.Name,
                arg.Description,
                arg.InputMimeType,
                arg.OutputMimeType,
        )
        var i Tool
        err := row.Scan(
                &amp;i.Id,
                &amp;i.CreatedAt,
                &amp;i.UpdatedAt,
                &amp;i.Description,
                &amp;i.InputMimeType,
                &amp;i.Name,
                &amp;i.OrganizationId,
                &amp;i.OutputMimeType,
        )
        return i, err
}</span>
</pre>
		
		<pre class="file" id="file73" style="display: none">// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.30.0
// source: users.sql

package postgresql

import (
        "context"

        "github.com/google/uuid"
)

const countUsers = `-- name: CountUsers :one
SELECT COUNT(*) FROM "user"
`

func (q *Queries) CountUsers(ctx context.Context) (int64, error) <span class="cov0" title="0">{
        row := q.db.QueryRow(ctx, countUsers)
        var count int64
        err := row.Scan(&amp;count)
        return count, err
}</span>

const createUser = `-- name: CreateUser :one
INSERT INTO "user" (
    id,
    email,
    name,
    email_verified,
    image
) VALUES (
    $1, $2, $3, COALESCE($4, false), $5
)
RETURNING id, created_at, updated_at, email, email_verified, image, name
`

type CreateUserParams struct {
        Id            uuid.UUID
        Email         string
        Name          string
        EmailVerified interface{}
        Image         *string
}

func (q *Queries) CreateUser(ctx context.Context, arg CreateUserParams) (User, error) <span class="cov0" title="0">{
        row := q.db.QueryRow(ctx, createUser,
                arg.Id,
                arg.Email,
                arg.Name,
                arg.EmailVerified,
                arg.Image,
        )
        var i User
        err := row.Scan(
                &amp;i.Id,
                &amp;i.CreatedAt,
                &amp;i.UpdatedAt,
                &amp;i.Email,
                &amp;i.EmailVerified,
                &amp;i.Image,
                &amp;i.Name,
        )
        return i, err
}</span>

const deleteUser = `-- name: DeleteUser :exec
DELETE FROM "user"
WHERE id = $1
`

func (q *Queries) DeleteUser(ctx context.Context, id uuid.UUID) error <span class="cov0" title="0">{
        _, err := q.db.Exec(ctx, deleteUser, id)
        return err
}</span>

const getUser = `-- name: GetUser :one
SELECT id, created_at, updated_at, email, email_verified, image, name FROM "user"
WHERE id = $1 LIMIT 1
`

func (q *Queries) GetUser(ctx context.Context, id uuid.UUID) (User, error) <span class="cov0" title="0">{
        row := q.db.QueryRow(ctx, getUser, id)
        var i User
        err := row.Scan(
                &amp;i.Id,
                &amp;i.CreatedAt,
                &amp;i.UpdatedAt,
                &amp;i.Email,
                &amp;i.EmailVerified,
                &amp;i.Image,
                &amp;i.Name,
        )
        return i, err
}</span>

const getUserByEmail = `-- name: GetUserByEmail :one
SELECT id, created_at, updated_at, email, email_verified, image, name FROM "user"
WHERE email = $1 LIMIT 1
`

func (q *Queries) GetUserByEmail(ctx context.Context, email string) (User, error) <span class="cov0" title="0">{
        row := q.db.QueryRow(ctx, getUserByEmail, email)
        var i User
        err := row.Scan(
                &amp;i.Id,
                &amp;i.CreatedAt,
                &amp;i.UpdatedAt,
                &amp;i.Email,
                &amp;i.EmailVerified,
                &amp;i.Image,
                &amp;i.Name,
        )
        return i, err
}</span>

const listUsers = `-- name: ListUsers :many
SELECT id, created_at, updated_at, email, email_verified, image, name FROM "user"
ORDER BY created_at DESC
LIMIT $1 OFFSET $2
`

type ListUsersParams struct {
        Limit  int32
        Offset int32
}

func (q *Queries) ListUsers(ctx context.Context, arg ListUsersParams) ([]User, error) <span class="cov0" title="0">{
        rows, err := q.db.Query(ctx, listUsers, arg.Limit, arg.Offset)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">defer rows.Close()
        var items []User
        for rows.Next() </span><span class="cov0" title="0">{
                var i User
                if err := rows.Scan(
                        &amp;i.Id,
                        &amp;i.CreatedAt,
                        &amp;i.UpdatedAt,
                        &amp;i.Email,
                        &amp;i.EmailVerified,
                        &amp;i.Image,
                        &amp;i.Name,
                ); err != nil </span><span class="cov0" title="0">{
                        return nil, err
                }</span>
                <span class="cov0" title="0">items = append(items, i)</span>
        }
        <span class="cov0" title="0">if err := rows.Err(); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">return items, nil</span>
}

const updateUser = `-- name: UpdateUser :one
UPDATE "user"
SET 
    name = COALESCE($2, name),
    email = COALESCE($3, email),
    email_verified = COALESCE($4, email_verified),
    image = COALESCE($5, image)
WHERE id = $1
RETURNING id, created_at, updated_at, email, email_verified, image, name
`

type UpdateUserParams struct {
        Id            uuid.UUID
        Name          *string
        Email         *string
        EmailVerified *bool
        Image         *string
}

func (q *Queries) UpdateUser(ctx context.Context, arg UpdateUserParams) (User, error) <span class="cov0" title="0">{
        row := q.db.QueryRow(ctx, updateUser,
                arg.Id,
                arg.Name,
                arg.Email,
                arg.EmailVerified,
                arg.Image,
        )
        var i User
        err := row.Scan(
                &amp;i.Id,
                &amp;i.CreatedAt,
                &amp;i.UpdatedAt,
                &amp;i.Email,
                &amp;i.EmailVerified,
                &amp;i.Image,
                &amp;i.Name,
        )
        return i, err
}</span>
</pre>
		
		<pre class="file" id="file74" style="display: none">// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.30.0
// source: verification-tokens.sql

package postgresql

import (
        "context"
        "time"

        "github.com/google/uuid"
)

const createVerificationToken = `-- name: CreateVerificationToken :one
INSERT INTO verification_token (
    id,
    identifier,
    value,
    expires_at
) VALUES (
    $1, $2, $3, $4
)
RETURNING id, created_at, updated_at, expires_at, identifier, value
`

type CreateVerificationTokenParams struct {
        Id         uuid.UUID
        Identifier string
        Value      string
        ExpiresAt  time.Time
}

func (q *Queries) CreateVerificationToken(ctx context.Context, arg CreateVerificationTokenParams) (VerificationToken, error) <span class="cov0" title="0">{
        row := q.db.QueryRow(ctx, createVerificationToken,
                arg.Id,
                arg.Identifier,
                arg.Value,
                arg.ExpiresAt,
        )
        var i VerificationToken
        err := row.Scan(
                &amp;i.Id,
                &amp;i.CreatedAt,
                &amp;i.UpdatedAt,
                &amp;i.ExpiresAt,
                &amp;i.Identifier,
                &amp;i.Value,
        )
        return i, err
}</span>

const deleteVerificationToken = `-- name: DeleteVerificationToken :exec
DELETE FROM verification_token
WHERE id = $1
`

func (q *Queries) DeleteVerificationToken(ctx context.Context, id uuid.UUID) error <span class="cov0" title="0">{
        _, err := q.db.Exec(ctx, deleteVerificationToken, id)
        return err
}</span>

const deleteVerificationTokensByIdentifier = `-- name: DeleteVerificationTokensByIdentifier :exec
DELETE FROM verification_token
WHERE identifier = $1
`

func (q *Queries) DeleteVerificationTokensByIdentifier(ctx context.Context, identifier string) error <span class="cov0" title="0">{
        _, err := q.db.Exec(ctx, deleteVerificationTokensByIdentifier, identifier)
        return err
}</span>

const getVerificationToken = `-- name: GetVerificationToken :one
SELECT id, created_at, updated_at, expires_at, identifier, value FROM verification_token
WHERE id = $1 LIMIT 1
`

func (q *Queries) GetVerificationToken(ctx context.Context, id uuid.UUID) (VerificationToken, error) <span class="cov0" title="0">{
        row := q.db.QueryRow(ctx, getVerificationToken, id)
        var i VerificationToken
        err := row.Scan(
                &amp;i.Id,
                &amp;i.CreatedAt,
                &amp;i.UpdatedAt,
                &amp;i.ExpiresAt,
                &amp;i.Identifier,
                &amp;i.Value,
        )
        return i, err
}</span>

const getVerificationTokenByValue = `-- name: GetVerificationTokenByValue :one
SELECT id, created_at, updated_at, expires_at, identifier, value FROM verification_token
WHERE identifier = $1 AND value = $2 LIMIT 1
`

type GetVerificationTokenByValueParams struct {
        Identifier string
        Value      string
}

func (q *Queries) GetVerificationTokenByValue(ctx context.Context, arg GetVerificationTokenByValueParams) (VerificationToken, error) <span class="cov0" title="0">{
        row := q.db.QueryRow(ctx, getVerificationTokenByValue, arg.Identifier, arg.Value)
        var i VerificationToken
        err := row.Scan(
                &amp;i.Id,
                &amp;i.CreatedAt,
                &amp;i.UpdatedAt,
                &amp;i.ExpiresAt,
                &amp;i.Identifier,
                &amp;i.Value,
        )
        return i, err
}</span>

const listVerificationTokens = `-- name: ListVerificationTokens :many
SELECT id, created_at, updated_at, expires_at, identifier, value FROM verification_token
ORDER BY created_at DESC
LIMIT $1 OFFSET $2
`

type ListVerificationTokensParams struct {
        Limit  int32
        Offset int32
}

func (q *Queries) ListVerificationTokens(ctx context.Context, arg ListVerificationTokensParams) ([]VerificationToken, error) <span class="cov0" title="0">{
        rows, err := q.db.Query(ctx, listVerificationTokens, arg.Limit, arg.Offset)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">defer rows.Close()
        var items []VerificationToken
        for rows.Next() </span><span class="cov0" title="0">{
                var i VerificationToken
                if err := rows.Scan(
                        &amp;i.Id,
                        &amp;i.CreatedAt,
                        &amp;i.UpdatedAt,
                        &amp;i.ExpiresAt,
                        &amp;i.Identifier,
                        &amp;i.Value,
                ); err != nil </span><span class="cov0" title="0">{
                        return nil, err
                }</span>
                <span class="cov0" title="0">items = append(items, i)</span>
        }
        <span class="cov0" title="0">if err := rows.Err(); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">return items, nil</span>
}

const listVerificationTokensByIdentifier = `-- name: ListVerificationTokensByIdentifier :many
SELECT id, created_at, updated_at, expires_at, identifier, value FROM verification_token
WHERE identifier = $1
ORDER BY created_at DESC
LIMIT $2 OFFSET $3
`

type ListVerificationTokensByIdentifierParams struct {
        Identifier string
        Limit      int32
        Offset     int32
}

func (q *Queries) ListVerificationTokensByIdentifier(ctx context.Context, arg ListVerificationTokensByIdentifierParams) ([]VerificationToken, error) <span class="cov0" title="0">{
        rows, err := q.db.Query(ctx, listVerificationTokensByIdentifier, arg.Identifier, arg.Limit, arg.Offset)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">defer rows.Close()
        var items []VerificationToken
        for rows.Next() </span><span class="cov0" title="0">{
                var i VerificationToken
                if err := rows.Scan(
                        &amp;i.Id,
                        &amp;i.CreatedAt,
                        &amp;i.UpdatedAt,
                        &amp;i.ExpiresAt,
                        &amp;i.Identifier,
                        &amp;i.Value,
                ); err != nil </span><span class="cov0" title="0">{
                        return nil, err
                }</span>
                <span class="cov0" title="0">items = append(items, i)</span>
        }
        <span class="cov0" title="0">if err := rows.Err(); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">return items, nil</span>
}

const updateVerificationToken = `-- name: UpdateVerificationToken :one
UPDATE verification_token
SET 
    value = COALESCE($2, value),
    expires_at = COALESCE($3, expires_at),
    updated_at = NOW()
WHERE id = $1
RETURNING id, created_at, updated_at, expires_at, identifier, value
`

type UpdateVerificationTokenParams struct {
        Id        uuid.UUID
        Value     *string
        ExpiresAt *time.Time
}

func (q *Queries) UpdateVerificationToken(ctx context.Context, arg UpdateVerificationTokenParams) (VerificationToken, error) <span class="cov0" title="0">{
        row := q.db.QueryRow(ctx, updateVerificationToken, arg.Id, arg.Value, arg.ExpiresAt)
        var i VerificationToken
        err := row.Scan(
                &amp;i.Id,
                &amp;i.CreatedAt,
                &amp;i.UpdatedAt,
                &amp;i.ExpiresAt,
                &amp;i.Identifier,
                &amp;i.Value,
        )
        return i, err
}</span>
</pre>
		
		<pre class="file" id="file75" style="display: none">package database

import (
        "context"
        "database/sql"
        "fmt"
        "log/slog"
        "time"

        "github.com/archesai/archesai/internal/config"
        _ "modernc.org/sqlite" // Pure Go SQLite driver
)

// SQLite implements the Database interface for SQLite
type SQLite struct {
        db     *sql.DB
        logger *slog.Logger
}

// NewSQLite creates a new SQLite database connection
func NewSQLite(cfg *config.DatabaseConfig, logger *slog.Logger) (Database, error) <span class="cov0" title="0">{
        ctx := context.Background()

        // Parse connection URL
        connStr := cfg.Url
        if connStr == "" </span><span class="cov0" title="0">{
                connStr = ":memory:" // Default to in-memory database
        }</span>

        // Open database connection
        <span class="cov0" title="0">db, err := sql.Open("sqlite", connStr)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to open SQLite database: %w", err)
        }</span>

        // Configure connection pool
        // SQLite performs best with a single connection
        <span class="cov0" title="0">db.SetMaxOpenConns(1)
        db.SetMaxIdleConns(1)

        if cfg.ConnMaxLifetime != "" &amp;&amp; cfg.ConnMaxLifetime != "0" </span><span class="cov0" title="0">{
                duration, err := time.ParseDuration(cfg.ConnMaxLifetime)
                if err == nil </span><span class="cov0" title="0">{
                        db.SetConnMaxLifetime(duration)
                }</span>
        }

        <span class="cov0" title="0">if cfg.ConnMaxIdleTime != "" &amp;&amp; cfg.ConnMaxIdleTime != "0" </span><span class="cov0" title="0">{
                duration, err := time.ParseDuration(cfg.ConnMaxIdleTime)
                if err == nil </span><span class="cov0" title="0">{
                        db.SetConnMaxIdleTime(duration)
                }</span>
        }

        // Test connection
        <span class="cov0" title="0">if err := db.PingContext(ctx); err != nil </span><span class="cov0" title="0">{
                _ = db.Close()
                return nil, fmt.Errorf("failed to ping SQLite database: %w", err)
        }</span>

        // Configure SQLite pragmas
        <span class="cov0" title="0">if err := configureSQLitePragmas(db); err != nil </span><span class="cov0" title="0">{
                _ = db.Close()
                return nil, fmt.Errorf("failed to configure SQLite pragmas: %w", err)
        }</span>

        <span class="cov0" title="0">logger.Info("SQLite connection established",
                "database", connStr,
        )

        return &amp;SQLite{
                db:     db,
                logger: logger,
        }, nil</span>
}

// configureSQLitePragmas sets SQLite-specific pragmas for performance and reliability
func configureSQLitePragmas(db *sql.DB) error <span class="cov0" title="0">{
        pragmas := []string{
                "PRAGMA journal_mode = WAL",
                "PRAGMA synchronous = NORMAL",
                "PRAGMA cache_size = -2000", // 2MB cache
                "PRAGMA foreign_keys = ON",
                "PRAGMA busy_timeout = 5000",
        }

        for _, pragma := range pragmas </span><span class="cov0" title="0">{
                if _, err := db.Exec(pragma); err != nil </span><span class="cov0" title="0">{
                        return fmt.Errorf("failed to execute %s: %w", pragma, err)
                }</span>
        }

        <span class="cov0" title="0">return nil</span>
}

// Query executes a query that returns rows
func (db *SQLite) Query(ctx context.Context, query string, args ...interface{}) (Rows, error) <span class="cov0" title="0">{
        rows, err := db.db.QueryContext(ctx, query, args...)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">return &amp;sqlRows{rows: rows}, nil</span>
}

// QueryRow executes a query that returns at most one row
func (db *SQLite) QueryRow(ctx context.Context, query string, args ...interface{}) Row <span class="cov0" title="0">{
        return &amp;sqlRow{row: db.db.QueryRowContext(ctx, query, args...)}
}</span>

// Exec executes a query without returning any rows
func (db *SQLite) Exec(ctx context.Context, query string, args ...interface{}) (Result, error) <span class="cov0" title="0">{
        return db.db.ExecContext(ctx, query, args...)
}</span>

// Begin starts a transaction
func (db *SQLite) Begin(ctx context.Context) (Transaction, error) <span class="cov0" title="0">{
        tx, err := db.db.BeginTx(ctx, nil)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">return &amp;sqlTransaction{tx: tx}, nil</span>
}

// BeginTx starts a transaction with options
func (db *SQLite) BeginTx(ctx context.Context, opts *sql.TxOptions) (Transaction, error) <span class="cov0" title="0">{
        tx, err := db.db.BeginTx(ctx, opts)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">return &amp;sqlTransaction{tx: tx}, nil</span>
}

// Ping verifies the connection to the database
func (db *SQLite) Ping(ctx context.Context) error <span class="cov0" title="0">{
        return db.db.PingContext(ctx)
}</span>

// Close closes the database connection
func (db *SQLite) Close() error <span class="cov0" title="0">{
        db.logger.Info("Closing SQLite connection")
        return db.db.Close()
}</span>

// Stats returns database statistics
func (db *SQLite) Stats() Stats <span class="cov0" title="0">{
        stats := db.db.Stats()
        return Stats{
                OpenConnections:   stats.OpenConnections,
                InUse:             stats.InUse,
                Idle:              stats.Idle,
                WaitCount:         stats.WaitCount,
                WaitDuration:      stats.WaitDuration.String(),
                MaxIdleClosed:     stats.MaxIdleClosed,
                MaxLifetimeClosed: stats.MaxLifetimeClosed,
        }
}</span>

// Type returns the database type
func (db *SQLite) Type() Type <span class="cov0" title="0">{
        return TypeSQLite
}</span>

// Underlying returns the underlying database connection
func (db *SQLite) Underlying() interface{} <span class="cov0" title="0">{
        return db.db
}</span>

// Adapter types for database/sql compatibility

type sqlRows struct {
        rows *sql.Rows
}

func (r *sqlRows) Next() bool <span class="cov0" title="0">{
        return r.rows.Next()
}</span>

func (r *sqlRows) Scan(dest ...interface{}) error <span class="cov0" title="0">{
        return r.rows.Scan(dest...)
}</span>

func (r *sqlRows) Close() error <span class="cov0" title="0">{
        return r.rows.Close()
}</span>

func (r *sqlRows) Err() error <span class="cov0" title="0">{
        return r.rows.Err()
}</span>

type sqlRow struct {
        row *sql.Row
}

func (r *sqlRow) Scan(dest ...interface{}) error <span class="cov0" title="0">{
        return r.row.Scan(dest...)
}</span>

type sqlTransaction struct {
        tx *sql.Tx
}

func (t *sqlTransaction) Query(ctx context.Context, query string, args ...interface{}) (Rows, error) <span class="cov0" title="0">{
        rows, err := t.tx.QueryContext(ctx, query, args...)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">return &amp;sqlRows{rows: rows}, nil</span>
}

func (t *sqlTransaction) QueryRow(ctx context.Context, query string, args ...interface{}) Row <span class="cov0" title="0">{
        return &amp;sqlRow{row: t.tx.QueryRowContext(ctx, query, args...)}
}</span>

func (t *sqlTransaction) Exec(ctx context.Context, query string, args ...interface{}) (Result, error) <span class="cov0" title="0">{
        return t.tx.ExecContext(ctx, query, args...)
}</span>

func (t *sqlTransaction) Commit() error <span class="cov0" title="0">{
        return t.tx.Commit()
}</span>

func (t *sqlTransaction) Rollback() error <span class="cov0" title="0">{
        return t.tx.Rollback()
}</span>
</pre>
		
		<pre class="file" id="file76" style="display: none">// Package sqlite contains SQLite-specific database queries generated by sqlc.
// This is a stub file until SQLite-compatible queries are implemented.
package sqlite

import (
        "database/sql"
)

// Queries struct stub for SQLite
type Queries struct {
        db *sql.DB
}

// New creates a new Queries instance
func New(db *sql.DB) *Queries <span class="cov0" title="0">{
        return &amp;Queries{db: db}
}</span>
</pre>
		
		<pre class="file" id="file77" style="display: none">// Package email provides email sending functionality for the application
package email

import (
        "context"
        "crypto/tls"
        "fmt"
        "log/slog"
        "net/smtp"
        "strings"
)

// Service handles email operations
type Service struct {
        config Config
        logger *slog.Logger
}

// Config contains email service configuration
type Config struct {
        Enabled  bool
        Service  string // smtp service provider
        Host     string
        Port     int
        User     string
        Password string
        From     string // sender email address
        FromName string // sender name
}

// NewService creates a new email service
func NewService(config Config, logger *slog.Logger) *Service <span class="cov0" title="0">{
        // Set defaults based on service provider
        if config.Service == "gmail" &amp;&amp; config.Host == "" </span><span class="cov0" title="0">{
                config.Host = "smtp.gmail.com"
                config.Port = 587
        }</span> else<span class="cov0" title="0"> if config.Service == "sendgrid" &amp;&amp; config.Host == "" </span><span class="cov0" title="0">{
                config.Host = "smtp.sendgrid.net"
                config.Port = 587
        }</span>

        // Default from address if not set
        <span class="cov0" title="0">if config.From == "" </span><span class="cov0" title="0">{
                config.From = config.User
        }</span>

        <span class="cov0" title="0">if config.FromName == "" </span><span class="cov0" title="0">{
                config.FromName = "ArchesAI"
        }</span>

        <span class="cov0" title="0">return &amp;Service{
                config: config,
                logger: logger,
        }</span>
}

// Email represents an email message
type Email struct {
        To      string
        Subject string
        Body    string
        HTML    bool
}

// SendEmail sends an email message
func (s *Service) SendEmail(_ context.Context, email Email) error <span class="cov0" title="0">{
        if !s.config.Enabled </span><span class="cov0" title="0">{
                s.logger.Info("email service disabled, skipping email", "to", email.To, "subject", email.Subject)
                return nil
        }</span>

        // Build message
        <span class="cov0" title="0">msg := s.buildMessage(email)

        // Setup authentication
        auth := smtp.PlainAuth("", s.config.User, s.config.Password, s.config.Host)

        // Connect to server
        addr := fmt.Sprintf("%s:%d", s.config.Host, s.config.Port)

        // Send email with TLS
        err := s.sendEmailWithTLS(addr, auth, s.config.From, []string{email.To}, msg)
        if err != nil </span><span class="cov0" title="0">{
                s.logger.Error("failed to send email", "error", err, "to", email.To)
                return fmt.Errorf("failed to send email: %w", err)
        }</span>

        <span class="cov0" title="0">s.logger.Info("email sent successfully", "to", email.To, "subject", email.Subject)
        return nil</span>
}

// buildMessage builds the email message
func (s *Service) buildMessage(email Email) []byte <span class="cov0" title="0">{
        var msg strings.Builder

        // Headers
        msg.WriteString(fmt.Sprintf("From: %s &lt;%s&gt;\r\n", s.config.FromName, s.config.From))
        msg.WriteString(fmt.Sprintf("To: %s\r\n", email.To))
        msg.WriteString(fmt.Sprintf("Subject: %s\r\n", email.Subject))

        // Content type
        if email.HTML </span><span class="cov0" title="0">{
                msg.WriteString("MIME-Version: 1.0\r\n")
                msg.WriteString("Content-Type: text/html; charset=\"UTF-8\"\r\n")
        }</span> else<span class="cov0" title="0"> {
                msg.WriteString("Content-Type: text/plain; charset=\"UTF-8\"\r\n")
        }</span>

        // Body
        <span class="cov0" title="0">msg.WriteString("\r\n")
        msg.WriteString(email.Body)

        return []byte(msg.String())</span>
}

// sendEmailWithTLS sends email using TLS
func (s *Service) sendEmailWithTLS(addr string, auth smtp.Auth, from string, to []string, msg []byte) error <span class="cov0" title="0">{
        // Connect to the SMTP server
        client, err := smtp.Dial(addr)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov0" title="0">defer func() </span><span class="cov0" title="0">{
                if err := client.Close(); err != nil </span><span class="cov0" title="0">{
                        s.logger.Warn("failed to close SMTP client", "error", err)
                }</span>
        }()

        // Start TLS
        <span class="cov0" title="0">tlsConfig := &amp;tls.Config{
                ServerName: s.config.Host,
        }
        if err = client.StartTLS(tlsConfig); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        // Authenticate
        <span class="cov0" title="0">if err = client.Auth(auth); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        // Set sender and recipients
        <span class="cov0" title="0">if err = client.Mail(from); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov0" title="0">for _, addr := range to </span><span class="cov0" title="0">{
                if err = client.Rcpt(addr); err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>
        }

        // Send the email body
        <span class="cov0" title="0">w, err := client.Data()
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov0" title="0">_, err = w.Write(msg)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov0" title="0">err = w.Close()
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        // Send the QUIT command and close the connection
        <span class="cov0" title="0">return client.Quit()</span>
}

// SendVerificationEmail sends a verification email to a user
func (s *Service) SendVerificationEmail(ctx context.Context, toEmail, userName, verificationToken string) error <span class="cov0" title="0">{
        // Build verification URL - this should be configured
        baseURL := "http://localhost:3000" // TODO: Get from config
        verificationURL := fmt.Sprintf("%s/auth/verify-email?token=%s", baseURL, verificationToken)

        subject := "Verify your ArchesAI account"

        // HTML email body
        htmlBody := fmt.Sprintf(`
&lt;!DOCTYPE html&gt;
&lt;html&gt;
&lt;head&gt;
    &lt;meta charset="UTF-8"&gt;
    &lt;title&gt;Verify your email&lt;/title&gt;
    &lt;style&gt;
        body { font-family: Arial, sans-serif; line-height: 1.6; color: #333; }
        .container { max-width: 600px; margin: 0 auto; padding: 20px; }
        .header { background-color: #f4f4f4; padding: 20px; text-align: center; }
        .content { padding: 20px; }
        .button { display: inline-block; padding: 12px 24px; background-color: #007bff; color: white; text-decoration: none; border-radius: 4px; }
        .footer { margin-top: 20px; padding-top: 20px; border-top: 1px solid #ddd; color: #666; font-size: 14px; }
    &lt;/style&gt;
&lt;/head&gt;
&lt;body&gt;
    &lt;div class="container"&gt;
        &lt;div class="header"&gt;
            &lt;h1&gt;Welcome to ArchesAI!&lt;/h1&gt;
        &lt;/div&gt;
        &lt;div class="content"&gt;
            &lt;p&gt;Hi %s,&lt;/p&gt;
            &lt;p&gt;Thank you for signing up with ArchesAI. Please verify your email address by clicking the button below:&lt;/p&gt;
            &lt;p style="text-align: center; margin: 30px 0;"&gt;
                &lt;a href="%s" class="button"&gt;Verify Email Address&lt;/a&gt;
            &lt;/p&gt;
            &lt;p&gt;Or copy and paste this link into your browser:&lt;/p&gt;
            &lt;p style="word-break: break-all; color: #007bff;"&gt;%s&lt;/p&gt;
            &lt;p&gt;This link will expire in 24 hours.&lt;/p&gt;
            &lt;p&gt;If you didn't create an account with ArchesAI, you can safely ignore this email.&lt;/p&gt;
        &lt;/div&gt;
        &lt;div class="footer"&gt;
            &lt;p&gt;Best regards,&lt;br&gt;The ArchesAI Team&lt;/p&gt;
        &lt;/div&gt;
    &lt;/div&gt;
&lt;/body&gt;
&lt;/html&gt;
`, userName, verificationURL, verificationURL)

        return s.SendEmail(ctx, Email{
                To:      toEmail,
                Subject: subject,
                Body:    htmlBody,
                HTML:    true,
        })
}</span>

// SendPasswordResetEmail sends a password reset email
func (s *Service) SendPasswordResetEmail(ctx context.Context, toEmail, userName, resetToken string) error <span class="cov0" title="0">{
        // Build reset URL
        baseURL := "http://localhost:3000" // TODO: Get from config
        resetURL := fmt.Sprintf("%s/auth/reset-password?token=%s", baseURL, resetToken)

        subject := "Reset your ArchesAI password"

        // HTML email body
        htmlBody := fmt.Sprintf(`
&lt;!DOCTYPE html&gt;
&lt;html&gt;
&lt;head&gt;
    &lt;meta charset="UTF-8"&gt;
    &lt;title&gt;Reset your password&lt;/title&gt;
    &lt;style&gt;
        body { font-family: Arial, sans-serif; line-height: 1.6; color: #333; }
        .container { max-width: 600px; margin: 0 auto; padding: 20px; }
        .header { background-color: #f4f4f4; padding: 20px; text-align: center; }
        .content { padding: 20px; }
        .button { display: inline-block; padding: 12px 24px; background-color: #dc3545; color: white; text-decoration: none; border-radius: 4px; }
        .footer { margin-top: 20px; padding-top: 20px; border-top: 1px solid #ddd; color: #666; font-size: 14px; }
    &lt;/style&gt;
&lt;/head&gt;
&lt;body&gt;
    &lt;div class="container"&gt;
        &lt;div class="header"&gt;
            &lt;h1&gt;Password Reset Request&lt;/h1&gt;
        &lt;/div&gt;
        &lt;div class="content"&gt;
            &lt;p&gt;Hi %s,&lt;/p&gt;
            &lt;p&gt;We received a request to reset your password. Click the button below to create a new password:&lt;/p&gt;
            &lt;p style="text-align: center; margin: 30px 0;"&gt;
                &lt;a href="%s" class="button"&gt;Reset Password&lt;/a&gt;
            &lt;/p&gt;
            &lt;p&gt;Or copy and paste this link into your browser:&lt;/p&gt;
            &lt;p style="word-break: break-all; color: #dc3545;"&gt;%s&lt;/p&gt;
            &lt;p&gt;This link will expire in 1 hour for security reasons.&lt;/p&gt;
            &lt;p&gt;If you didn't request a password reset, please ignore this email. Your password won't be changed.&lt;/p&gt;
        &lt;/div&gt;
        &lt;div class="footer"&gt;
            &lt;p&gt;Best regards,&lt;br&gt;The ArchesAI Team&lt;/p&gt;
        &lt;/div&gt;
    &lt;/div&gt;
&lt;/body&gt;
&lt;/html&gt;
`, userName, resetURL, resetURL)

        return s.SendEmail(ctx, Email{
                To:      toEmail,
                Subject: subject,
                Body:    htmlBody,
                HTML:    true,
        })
}</span>

// SendWelcomeEmail sends a welcome email after successful verification
func (s *Service) SendWelcomeEmail(ctx context.Context, toEmail, userName string) error <span class="cov0" title="0">{
        subject := "Welcome to ArchesAI!"

        // HTML email body
        htmlBody := fmt.Sprintf(`
&lt;!DOCTYPE html&gt;
&lt;html&gt;
&lt;head&gt;
    &lt;meta charset="UTF-8"&gt;
    &lt;title&gt;Welcome to ArchesAI&lt;/title&gt;
    &lt;style&gt;
        body { font-family: Arial, sans-serif; line-height: 1.6; color: #333; }
        .container { max-width: 600px; margin: 0 auto; padding: 20px; }
        .header { background-color: #28a745; color: white; padding: 20px; text-align: center; }
        .content { padding: 20px; }
        .footer { margin-top: 20px; padding-top: 20px; border-top: 1px solid #ddd; color: #666; font-size: 14px; }
    &lt;/style&gt;
&lt;/head&gt;
&lt;body&gt;
    &lt;div class="container"&gt;
        &lt;div class="header"&gt;
            &lt;h1&gt;Email Verified Successfully!&lt;/h1&gt;
        &lt;/div&gt;
        &lt;div class="content"&gt;
            &lt;p&gt;Hi %s,&lt;/p&gt;
            &lt;p&gt;Your email has been successfully verified. You now have full access to all ArchesAI features!&lt;/p&gt;
            &lt;p&gt;Here are some things you can do next:&lt;/p&gt;
            &lt;ul&gt;
                &lt;li&gt;Complete your profile&lt;/li&gt;
                &lt;li&gt;Create your first organization&lt;/li&gt;
                &lt;li&gt;Explore our workflow automation features&lt;/li&gt;
                &lt;li&gt;Connect with AI providers&lt;/li&gt;
            &lt;/ul&gt;
            &lt;p&gt;If you have any questions, don't hesitate to reach out to our support team.&lt;/p&gt;
        &lt;/div&gt;
        &lt;div class="footer"&gt;
            &lt;p&gt;Best regards,&lt;br&gt;The ArchesAI Team&lt;/p&gt;
        &lt;/div&gt;
    &lt;/div&gt;
&lt;/body&gt;
&lt;/html&gt;
`, userName)

        return s.SendEmail(ctx, Email{
                To:      toEmail,
                Subject: subject,
                Body:    htmlBody,
                HTML:    true,
        })
}</span>
</pre>
		
		<pre class="file" id="file78" style="display: none">package events

import (
        "context"
)

// NoOpPublisher is a no-op event publisher implementation for testing
type NoOpPublisher struct{}

// NewNoOpPublisher creates a new no-op event publisher
func NewNoOpPublisher() PublisherSubscriber <span class="cov0" title="0">{
        return &amp;NoOpPublisher{}
}</span>

// Publish does nothing in no-op implementation
func (p *NoOpPublisher) Publish(_ context.Context, _ Event) error <span class="cov0" title="0">{
        return nil
}</span>

// PublishRaw does nothing in no-op implementation
func (p *NoOpPublisher) PublishRaw(_ context.Context, _ string, _ string, _ interface{}) error <span class="cov0" title="0">{
        return nil
}</span>

// Subscribe does nothing in no-op implementation
func (p *NoOpPublisher) Subscribe(_ context.Context, _ string, _ func(event Event) error) error <span class="cov0" title="0">{
        return nil
}</span>

// SubscribeToType does nothing in no-op implementation
func (p *NoOpPublisher) SubscribeToType(_ context.Context, _ string, _ string, _ func(event Event) error) error <span class="cov0" title="0">{
        return nil
}</span>

// Ensure NoOpPublisher implements the interfaces
var _ Publisher = (*NoOpPublisher)(nil)
var _ PublisherSubscriber = (*NoOpPublisher)(nil)
</pre>
		
		<pre class="file" id="file79" style="display: none">package events

import (
        "context"
        "fmt"
        "time"

        "github.com/google/uuid"
)

// DomainEvent is the interface that all domain events must implement
type DomainEvent interface {
        // EventType returns the event type string (e.g., "user.created")
        EventType() string
        // EventDomain returns the domain this event belongs to (e.g., "users")
        EventDomain() string
        // EventData returns the actual event data
        EventData() interface{}
}

// BaseEvent provides common fields for all events
type BaseEvent struct {
        ID        string    `json:"id"`
        Domain    string    `json:"domain"`
        Type      string    `json:"type"`
        Timestamp time.Time `json:"timestamp"`
        Version   string    `json:"version,omitempty"`
}

// NewBaseEvent creates a new base event
func NewBaseEvent(domain, eventType string) BaseEvent <span class="cov0" title="0">{
        return BaseEvent{
                ID:        uuid.New().String(),
                Domain:    domain,
                Type:      eventType,
                Timestamp: time.Now().UTC(),
                Version:   "1.0",
        }
}</span>

// PublishDomainEvent is a helper function to publish domain events
func PublishDomainEvent(ctx context.Context, publisher Publisher, event DomainEvent) error <span class="cov0" title="0">{
        if event == nil </span><span class="cov0" title="0">{
                return fmt.Errorf("event cannot be nil")
        }</span>

        // Create the full event structure
        <span class="cov0" title="0">fullEvent := Event{
                ID:        uuid.New().String(),
                Type:      event.EventType(),
                Domain:    event.EventDomain(),
                Timestamp: time.Now().UTC(),
                Source:    event.EventDomain(),
                Data:      event.EventData(),
        }

        return publisher.Publish(ctx, fullEvent)</span>
}
</pre>
		
		<pre class="file" id="file80" style="display: none">package events

import (
        "context"
        "encoding/json"
        "fmt"
        "time"

        "github.com/google/uuid"
        "github.com/redis/go-redis/v9"
)

// RedisPublisher implements PublisherSubscriber using Redis pub/sub
type RedisPublisher struct {
        client  *redis.Client
        channel string
}

// NewRedisPublisher creates a new Redis event publisher with default channel
func NewRedisPublisher(client *redis.Client) PublisherSubscriber <span class="cov0" title="0">{
        return &amp;RedisPublisher{
                client:  client,
                channel: "events", // Global channel for all events
        }
}</span>

// Publish sends an event to Redis
func (p *RedisPublisher) Publish(ctx context.Context, event Event) error <span class="cov0" title="0">{
        if event.ID == "" </span><span class="cov0" title="0">{
                event.ID = uuid.New().String()
        }</span>
        <span class="cov0" title="0">if event.Timestamp.IsZero() </span><span class="cov0" title="0">{
                event.Timestamp = time.Now().UTC()
        }</span>

        // Marshal event to JSON
        <span class="cov0" title="0">data, err := json.Marshal(event)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to marshal event: %w", err)
        }</span>

        // Publish to main channel
        <span class="cov0" title="0">if err := p.client.Publish(ctx, p.channel, data).Err(); err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to publish event to Redis: %w", err)
        }</span>

        // Also publish to domain-specific channel for selective subscription
        <span class="cov0" title="0">domainChannel := fmt.Sprintf("%s:%s", p.channel, event.Domain)
        if err := p.client.Publish(ctx, domainChannel, data).Err(); err != nil </span><span class="cov0" title="0">{
                // Log error but don't fail - domain-specific channel is optional
                _ = err
        }</span>

        // Also publish to type-specific channel
        <span class="cov0" title="0">typeChannel := fmt.Sprintf("%s:%s:%s", p.channel, event.Domain, event.Type)
        if err := p.client.Publish(ctx, typeChannel, data).Err(); err != nil </span><span class="cov0" title="0">{
                // Log error but don't fail - type-specific channel is optional
                _ = err
        }</span>

        <span class="cov0" title="0">return nil</span>
}

// PublishRaw publishes an event with domain context
func (p *RedisPublisher) PublishRaw(ctx context.Context, domain string, eventType string, data interface{}) error <span class="cov0" title="0">{
        event := Event{
                ID:        uuid.New().String(),
                Type:      eventType,
                Domain:    domain,
                Timestamp: time.Now().UTC(),
                Source:    domain,
                Data:      data,
        }

        // If data is already an event-like structure with ID, preserve it
        if dataMap, ok := data.(map[string]interface{}); ok </span><span class="cov0" title="0">{
                if id, exists := dataMap["id"]; exists </span><span class="cov0" title="0">{
                        if idStr, ok := id.(string); ok </span><span class="cov0" title="0">{
                                event.Metadata = map[string]string{
                                        "entity_id": idStr,
                                }
                        }</span>
                }
        }

        <span class="cov0" title="0">return p.Publish(ctx, event)</span>
}

// Subscribe subscribes to all events from a specific domain
func (p *RedisPublisher) Subscribe(ctx context.Context, domain string, handler func(event Event) error) error <span class="cov0" title="0">{
        // Subscribe to domain-specific channel
        domainChannel := fmt.Sprintf("%s:%s", p.channel, domain)

        pubsub := p.client.Subscribe(ctx, domainChannel)
        defer func() </span><span class="cov0" title="0">{
                _ = pubsub.Close()
        }</span>()

        // Wait for subscription confirmation
        <span class="cov0" title="0">_, err := pubsub.Receive(ctx)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to subscribe to domain channel: %w", err)
        }</span>

        // Get channel for messages
        <span class="cov0" title="0">ch := pubsub.Channel()

        // Process messages
        for </span><span class="cov0" title="0">{
                select </span>{
                case &lt;-ctx.Done():<span class="cov0" title="0">
                        return ctx.Err()</span>
                case msg := &lt;-ch:<span class="cov0" title="0">
                        if msg == nil </span><span class="cov0" title="0">{
                                continue</span>
                        }

                        // Unmarshal event
                        <span class="cov0" title="0">var event Event
                        if err := json.Unmarshal([]byte(msg.Payload), &amp;event); err != nil </span><span class="cov0" title="0">{
                                // Log error but continue processing
                                continue</span>
                        }

                        // Handle event
                        <span class="cov0" title="0">if err := handler(event); err != nil </span><span class="cov0" title="0">{
                                // Log error but continue processing
                                continue</span>
                        }
                }
        }
}

// SubscribeToType subscribes to specific event types
func (p *RedisPublisher) SubscribeToType(ctx context.Context, domain string, eventType string, handler func(event Event) error) error <span class="cov0" title="0">{
        // Subscribe to type-specific channel
        typeChannel := fmt.Sprintf("%s:%s:%s", p.channel, domain, eventType)

        pubsub := p.client.Subscribe(ctx, typeChannel)
        defer func() </span><span class="cov0" title="0">{
                _ = pubsub.Close()
        }</span>()

        // Wait for subscription confirmation
        <span class="cov0" title="0">_, err := pubsub.Receive(ctx)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to subscribe to type channel: %w", err)
        }</span>

        // Get channel for messages
        <span class="cov0" title="0">ch := pubsub.Channel()

        // Process messages
        for </span><span class="cov0" title="0">{
                select </span>{
                case &lt;-ctx.Done():<span class="cov0" title="0">
                        return ctx.Err()</span>
                case msg := &lt;-ch:<span class="cov0" title="0">
                        if msg == nil </span><span class="cov0" title="0">{
                                continue</span>
                        }

                        // Unmarshal event
                        <span class="cov0" title="0">var event Event
                        if err := json.Unmarshal([]byte(msg.Payload), &amp;event); err != nil </span><span class="cov0" title="0">{
                                // Log error but continue processing
                                continue</span>
                        }

                        // Handle event
                        <span class="cov0" title="0">if err := handler(event); err != nil </span><span class="cov0" title="0">{
                                // Log error but continue processing
                                continue</span>
                        }
                }
        }
}

// Ensure RedisPublisher implements the interfaces
var _ Publisher = (*RedisPublisher)(nil)
var _ PublisherSubscriber = (*RedisPublisher)(nil)
</pre>
		
		<pre class="file" id="file81" style="display: none">// Package health provides HTTP handlers for health checks
package health

import (
        "context"
        "log/slog"
        "time"
)

// Handler handles health check operations
type Handler struct {
        service *Service
        logger  *slog.Logger
}

// Ensure Handler implements StrictServerInterface
var _ StrictServerInterface = (*Handler)(nil)

// NewHandler creates a new health handler
func NewHandler(service *Service, logger *slog.Logger) *Handler <span class="cov0" title="0">{
        return &amp;Handler{
                service: service,
                logger:  logger,
        }
}</span>

// GetHealth implements the health check endpoint
func (h *Handler) GetHealth(ctx context.Context, _ GetHealthRequestObject) (GetHealthResponseObject, error) <span class="cov0" title="0">{
        h.logger.Debug("health check requested")

        status := h.service.CheckHealth(ctx)

        response := HealthResponse{
                Services: struct {
                        Database string `json:"database" yaml:"database"`
                        Email    string `json:"email" yaml:"email"`
                        Redis    string `json:"redis" yaml:"redis"`
                }{
                        Database: status.Database,
                        Email:    status.Email,
                        Redis:    status.Redis,
                },
                Timestamp: time.Now().Format(time.RFC3339),
                Uptime:    float32(status.Uptime),
        }

        return GetHealth200JSONResponse(response), nil
}</span>
</pre>
		
		<pre class="file" id="file82" style="display: none">// Package health provides primitives to interact with the openapi HTTP API.
//
// Code generated by github.com/oapi-codegen/oapi-codegen/v2 version v2.5.0 DO NOT EDIT.
package health

import (
        "context"
        "encoding/json"
        "fmt"
        "net/http"

        "github.com/labstack/echo/v4"
        strictecho "github.com/oapi-codegen/runtime/strictmiddleware/echo"
)

// ServerInterface represents all server handlers.
type ServerInterface interface {
        // Health check endpoint
        // (GET /health)
        GetHealth(ctx echo.Context) error
}

// ServerInterfaceWrapper converts echo contexts to parameters.
type ServerInterfaceWrapper struct {
        Handler ServerInterface
}

// GetHealth converts echo context to params.
func (w *ServerInterfaceWrapper) GetHealth(ctx echo.Context) error <span class="cov0" title="0">{
        var err error

        ctx.Set(BearerAuthScopes, []string{})

        ctx.Set(SessionCookieScopes, []string{})

        // Invoke the callback with all the unmarshaled arguments
        err = w.Handler.GetHealth(ctx)
        return err
}</span>

// This is a simple interface which specifies echo.Route addition functions which
// are present on both echo.Echo and echo.Group, since we want to allow using
// either of them for path registration
type EchoRouter interface {
        CONNECT(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
        DELETE(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
        GET(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
        HEAD(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
        OPTIONS(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
        PATCH(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
        POST(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
        PUT(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
        TRACE(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
}

// RegisterHandlers adds each server route to the EchoRouter.
func RegisterHandlers(router EchoRouter, si ServerInterface) <span class="cov0" title="0">{
        RegisterHandlersWithBaseURL(router, si, "")
}</span>

// Registers handlers, and prepends BaseURL to the paths, so that the paths
// can be served under a prefix.
func RegisterHandlersWithBaseURL(router EchoRouter, si ServerInterface, baseURL string) <span class="cov0" title="0">{

        wrapper := ServerInterfaceWrapper{
                Handler: si,
        }

        router.GET(baseURL+"/health", wrapper.GetHealth)

}</span>

type BadRequestApplicationProblemPlusJSONResponse Problem

type GetHealthRequestObject struct {
}

type GetHealthResponseObject interface {
        VisitGetHealthResponse(w http.ResponseWriter) error
}

type GetHealth200JSONResponse HealthResponse

func (response GetHealth200JSONResponse) VisitGetHealthResponse(w http.ResponseWriter) error <span class="cov0" title="0">{
        w.Header().Set("Content-Type", "application/json")
        w.WriteHeader(200)

        return json.NewEncoder(w).Encode(response)
}</span>

type GetHealth400ApplicationProblemPlusJSONResponse struct {
        BadRequestApplicationProblemPlusJSONResponse
}

func (response GetHealth400ApplicationProblemPlusJSONResponse) VisitGetHealthResponse(w http.ResponseWriter) error <span class="cov0" title="0">{
        w.Header().Set("Content-Type", "application/problem+json")
        w.WriteHeader(400)

        return json.NewEncoder(w).Encode(response)
}</span>

// StrictServerInterface represents all server handlers.
type StrictServerInterface interface {
        // Health check endpoint
        // (GET /health)
        GetHealth(ctx context.Context, request GetHealthRequestObject) (GetHealthResponseObject, error)
}

type StrictHandlerFunc = strictecho.StrictEchoHandlerFunc
type StrictMiddlewareFunc = strictecho.StrictEchoMiddlewareFunc

func NewStrictHandler(ssi StrictServerInterface, middlewares []StrictMiddlewareFunc) ServerInterface <span class="cov0" title="0">{
        return &amp;strictHandler{ssi: ssi, middlewares: middlewares}
}</span>

type strictHandler struct {
        ssi         StrictServerInterface
        middlewares []StrictMiddlewareFunc
}

// GetHealth operation middleware
func (sh *strictHandler) GetHealth(ctx echo.Context) error <span class="cov0" title="0">{
        var request GetHealthRequestObject

        handler := func(ctx echo.Context, request interface{}) (interface{}, error) </span><span class="cov0" title="0">{
                return sh.ssi.GetHealth(ctx.Request().Context(), request.(GetHealthRequestObject))
        }</span>
        <span class="cov0" title="0">for _, middleware := range sh.middlewares </span><span class="cov0" title="0">{
                handler = middleware(handler, "GetHealth")
        }</span>

        <span class="cov0" title="0">response, err := handler(ctx, request)

        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span> else<span class="cov0" title="0"> if validResponse, ok := response.(GetHealthResponseObject); ok </span><span class="cov0" title="0">{
                return validResponse.VisitGetHealthResponse(ctx.Response())
        }</span> else<span class="cov0" title="0"> if response != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("unexpected response type: %T", response)
        }</span>
        <span class="cov0" title="0">return nil</span>
}
</pre>
		
		<pre class="file" id="file83" style="display: none">package health

import (
        "context"
        "log/slog"
        "time"
)

// Service handles health check operations
type Service struct {
        startTime time.Time
        logger    *slog.Logger
}

// NewService creates a new health service
func NewService(logger *slog.Logger) *Service <span class="cov3" title="2">{
        return &amp;Service{
                startTime: time.Now(),
                logger:    logger,
        }
}</span>

// ServiceStatus represents the status of a service
type ServiceStatus struct {
        Database string
        Email    string
        Redis    string
        Uptime   float64
}

// CheckHealth checks the health of all services
func (s *Service) CheckHealth(_ context.Context) ServiceStatus <span class="cov10" title="16">{
        uptime := time.Since(s.startTime).Seconds()

        // TODO: Implement actual health checks
        return ServiceStatus{
                Database: StatusHealthy,
                Email:    StatusHealthy,
                Redis:    StatusHealthy,
                Uptime:   uptime,
        }
}</span>
</pre>
		
		<pre class="file" id="file84" style="display: none">// Package health provides primitives to interact with the openapi HTTP API.
//
// Code generated by github.com/oapi-codegen/oapi-codegen/v2 version v2.5.0 DO NOT EDIT.
package health

import (
        "encoding/json"

        "github.com/oapi-codegen/runtime"
)

const (
        BearerAuthScopes    = "bearerAuth.Scopes"
        SessionCookieScopes = "sessionCookie.Scopes"
)

// HealthResponse defines model for HealthResponse.
type HealthResponse struct {
        Services struct {
                Database string `json:"database" yaml:"database"`
                Email    string `json:"email" yaml:"email"`
                Redis    string `json:"redis" yaml:"redis"`
        } `json:"services" yaml:"services"`
        Timestamp string  `json:"timestamp" yaml:"timestamp"`
        Uptime    float32 `json:"uptime" yaml:"uptime"`
}

// Problem RFC 7807 (Problem Details) compliant error response
type Problem struct {
        // Detail Human-readable explanation specific to this occurrence
        Detail string `json:"detail" yaml:"detail"`

        // Errors Additional validation errors for specific fields
        Errors []ValidationError `json:"errors,omitempty,omitzero" yaml:"errors,omitempty"`

        // Instance URI identifying the specific occurrence
        Instance string `json:"instance,omitempty,omitzero" yaml:"instance,omitempty"`

        // Status HTTP status code
        Status int `json:"status" yaml:"status"`

        // Title Short, human-readable summary
        Title string `json:"title" yaml:"title"`

        // Type URI identifying the problem type
        Type string `json:"type" yaml:"type"`
}

// ValidationError Individual field validation error
type ValidationError struct {
        // Field The field path that failed validation
        Field string `json:"field" yaml:"field"`

        // Message Human-readable error message
        Message string `json:"message" yaml:"message"`

        // Value The invalid value that was provided
        Value ValidationError_Value `json:"value,omitempty,omitzero" yaml:"value,omitempty"`
}

// ValidationErrorValue0 defines model for .
type ValidationErrorValue0 = string

// ValidationErrorValue1 defines model for .
type ValidationErrorValue1 = float32

// ValidationErrorValue2 defines model for .
type ValidationErrorValue2 = bool

// ValidationError_Value The invalid value that was provided
type ValidationError_Value struct {
        union json.RawMessage
}

// BadRequest RFC 7807 (Problem Details) compliant error response
type BadRequest = Problem

// AsValidationErrorValue0 returns the union data inside the ValidationError_Value as a ValidationErrorValue0
func (t ValidationError_Value) AsValidationErrorValue0() (ValidationErrorValue0, error) <span class="cov0" title="0">{
        var body ValidationErrorValue0
        err := json.Unmarshal(t.union, &amp;body)
        return body, err
}</span>

// FromValidationErrorValue0 overwrites any union data inside the ValidationError_Value as the provided ValidationErrorValue0
func (t *ValidationError_Value) FromValidationErrorValue0(v ValidationErrorValue0) error <span class="cov0" title="0">{
        b, err := json.Marshal(v)
        t.union = b
        return err
}</span>

// MergeValidationErrorValue0 performs a merge with any union data inside the ValidationError_Value, using the provided ValidationErrorValue0
func (t *ValidationError_Value) MergeValidationErrorValue0(v ValidationErrorValue0) error <span class="cov0" title="0">{
        b, err := json.Marshal(v)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov0" title="0">merged, err := runtime.JSONMerge(t.union, b)
        t.union = merged
        return err</span>
}

// AsValidationErrorValue1 returns the union data inside the ValidationError_Value as a ValidationErrorValue1
func (t ValidationError_Value) AsValidationErrorValue1() (ValidationErrorValue1, error) <span class="cov0" title="0">{
        var body ValidationErrorValue1
        err := json.Unmarshal(t.union, &amp;body)
        return body, err
}</span>

// FromValidationErrorValue1 overwrites any union data inside the ValidationError_Value as the provided ValidationErrorValue1
func (t *ValidationError_Value) FromValidationErrorValue1(v ValidationErrorValue1) error <span class="cov0" title="0">{
        b, err := json.Marshal(v)
        t.union = b
        return err
}</span>

// MergeValidationErrorValue1 performs a merge with any union data inside the ValidationError_Value, using the provided ValidationErrorValue1
func (t *ValidationError_Value) MergeValidationErrorValue1(v ValidationErrorValue1) error <span class="cov0" title="0">{
        b, err := json.Marshal(v)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov0" title="0">merged, err := runtime.JSONMerge(t.union, b)
        t.union = merged
        return err</span>
}

// AsValidationErrorValue2 returns the union data inside the ValidationError_Value as a ValidationErrorValue2
func (t ValidationError_Value) AsValidationErrorValue2() (ValidationErrorValue2, error) <span class="cov0" title="0">{
        var body ValidationErrorValue2
        err := json.Unmarshal(t.union, &amp;body)
        return body, err
}</span>

// FromValidationErrorValue2 overwrites any union data inside the ValidationError_Value as the provided ValidationErrorValue2
func (t *ValidationError_Value) FromValidationErrorValue2(v ValidationErrorValue2) error <span class="cov0" title="0">{
        b, err := json.Marshal(v)
        t.union = b
        return err
}</span>

// MergeValidationErrorValue2 performs a merge with any union data inside the ValidationError_Value, using the provided ValidationErrorValue2
func (t *ValidationError_Value) MergeValidationErrorValue2(v ValidationErrorValue2) error <span class="cov0" title="0">{
        b, err := json.Marshal(v)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov0" title="0">merged, err := runtime.JSONMerge(t.union, b)
        t.union = merged
        return err</span>
}

func (t ValidationError_Value) MarshalJSON() ([]byte, error) <span class="cov0" title="0">{
        b, err := t.union.MarshalJSON()
        return b, err
}</span>

func (t *ValidationError_Value) UnmarshalJSON(b []byte) error <span class="cov0" title="0">{
        err := t.union.UnmarshalJSON(b)
        return err
}</span>
</pre>
		
		<pre class="file" id="file85" style="display: none">// Package invitations provides primitives to interact with the openapi HTTP API.
//
// Code generated by github.com/oapi-codegen/oapi-codegen/v2 version v2.5.0 DO NOT EDIT.
package invitations

import (
        "context"
        "encoding/json"
        "fmt"
        "net/http"

        "github.com/labstack/echo/v4"
        "github.com/oapi-codegen/runtime"
        strictecho "github.com/oapi-codegen/runtime/strictmiddleware/echo"
        openapi_types "github.com/oapi-codegen/runtime/types"
)

// ServerInterface represents all server handlers.
type ServerInterface interface {
        // Find many invitations
        // (GET /organizations/{id}/invitations)
        FindManyInvitations(ctx echo.Context, id openapi_types.UUID, params FindManyInvitationsParams) error
        // Create a new invitation
        // (POST /organizations/{id}/invitations)
        CreateInvitation(ctx echo.Context, id openapi_types.UUID) error
        // Delete an invitation
        // (DELETE /organizations/{id}/invitations/{invitationId})
        DeleteInvitation(ctx echo.Context, id openapi_types.UUID, invitationId openapi_types.UUID) error
        // Find an invitation
        // (GET /organizations/{id}/invitations/{invitationId})
        GetOneInvitation(ctx echo.Context, id openapi_types.UUID, invitationId openapi_types.UUID) error
        // Update an invitation
        // (PATCH /organizations/{id}/invitations/{invitationId})
        UpdateInvitation(ctx echo.Context, id openapi_types.UUID, invitationId openapi_types.UUID) error
}

// ServerInterfaceWrapper converts echo contexts to parameters.
type ServerInterfaceWrapper struct {
        Handler ServerInterface
}

// FindManyInvitations converts echo context to params.
func (w *ServerInterfaceWrapper) FindManyInvitations(ctx echo.Context) error <span class="cov0" title="0">{
        var err error
        // ------------- Path parameter "id" -------------
        var id openapi_types.UUID

        err = runtime.BindStyledParameterWithOptions("simple", "id", ctx.Param("id"), &amp;id, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
        if err != nil </span><span class="cov0" title="0">{
                return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter id: %s", err))
        }</span>

        <span class="cov0" title="0">ctx.Set(BearerAuthScopes, []string{})

        // Parameter object where we will unmarshal all parameters from the context
        var params FindManyInvitationsParams
        // ------------- Optional query parameter "filter" -------------

        err = runtime.BindQueryParameter("deepObject", true, false, "filter", ctx.QueryParams(), &amp;params.Filter)
        if err != nil </span><span class="cov0" title="0">{
                return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter filter: %s", err))
        }</span>

        // ------------- Optional query parameter "page" -------------

        <span class="cov0" title="0">err = runtime.BindQueryParameter("form", true, false, "page", ctx.QueryParams(), &amp;params.Page)
        if err != nil </span><span class="cov0" title="0">{
                return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter page: %s", err))
        }</span>

        // ------------- Optional query parameter "sort" -------------

        <span class="cov0" title="0">err = runtime.BindQueryParameter("form", true, false, "sort", ctx.QueryParams(), &amp;params.Sort)
        if err != nil </span><span class="cov0" title="0">{
                return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter sort: %s", err))
        }</span>

        // Invoke the callback with all the unmarshaled arguments
        <span class="cov0" title="0">err = w.Handler.FindManyInvitations(ctx, id, params)
        return err</span>
}

// CreateInvitation converts echo context to params.
func (w *ServerInterfaceWrapper) CreateInvitation(ctx echo.Context) error <span class="cov0" title="0">{
        var err error
        // ------------- Path parameter "id" -------------
        var id openapi_types.UUID

        err = runtime.BindStyledParameterWithOptions("simple", "id", ctx.Param("id"), &amp;id, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
        if err != nil </span><span class="cov0" title="0">{
                return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter id: %s", err))
        }</span>

        <span class="cov0" title="0">ctx.Set(BearerAuthScopes, []string{})

        // Invoke the callback with all the unmarshaled arguments
        err = w.Handler.CreateInvitation(ctx, id)
        return err</span>
}

// DeleteInvitation converts echo context to params.
func (w *ServerInterfaceWrapper) DeleteInvitation(ctx echo.Context) error <span class="cov0" title="0">{
        var err error
        // ------------- Path parameter "id" -------------
        var id openapi_types.UUID

        err = runtime.BindStyledParameterWithOptions("simple", "id", ctx.Param("id"), &amp;id, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
        if err != nil </span><span class="cov0" title="0">{
                return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter id: %s", err))
        }</span>

        // ------------- Path parameter "invitationId" -------------
        <span class="cov0" title="0">var invitationId openapi_types.UUID

        err = runtime.BindStyledParameterWithOptions("simple", "invitationId", ctx.Param("invitationId"), &amp;invitationId, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
        if err != nil </span><span class="cov0" title="0">{
                return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter invitationId: %s", err))
        }</span>

        <span class="cov0" title="0">ctx.Set(BearerAuthScopes, []string{})

        // Invoke the callback with all the unmarshaled arguments
        err = w.Handler.DeleteInvitation(ctx, id, invitationId)
        return err</span>
}

// GetOneInvitation converts echo context to params.
func (w *ServerInterfaceWrapper) GetOneInvitation(ctx echo.Context) error <span class="cov0" title="0">{
        var err error
        // ------------- Path parameter "id" -------------
        var id openapi_types.UUID

        err = runtime.BindStyledParameterWithOptions("simple", "id", ctx.Param("id"), &amp;id, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
        if err != nil </span><span class="cov0" title="0">{
                return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter id: %s", err))
        }</span>

        // ------------- Path parameter "invitationId" -------------
        <span class="cov0" title="0">var invitationId openapi_types.UUID

        err = runtime.BindStyledParameterWithOptions("simple", "invitationId", ctx.Param("invitationId"), &amp;invitationId, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
        if err != nil </span><span class="cov0" title="0">{
                return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter invitationId: %s", err))
        }</span>

        <span class="cov0" title="0">ctx.Set(BearerAuthScopes, []string{})

        // Invoke the callback with all the unmarshaled arguments
        err = w.Handler.GetOneInvitation(ctx, id, invitationId)
        return err</span>
}

// UpdateInvitation converts echo context to params.
func (w *ServerInterfaceWrapper) UpdateInvitation(ctx echo.Context) error <span class="cov0" title="0">{
        var err error
        // ------------- Path parameter "id" -------------
        var id openapi_types.UUID

        err = runtime.BindStyledParameterWithOptions("simple", "id", ctx.Param("id"), &amp;id, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
        if err != nil </span><span class="cov0" title="0">{
                return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter id: %s", err))
        }</span>

        // ------------- Path parameter "invitationId" -------------
        <span class="cov0" title="0">var invitationId openapi_types.UUID

        err = runtime.BindStyledParameterWithOptions("simple", "invitationId", ctx.Param("invitationId"), &amp;invitationId, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
        if err != nil </span><span class="cov0" title="0">{
                return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter invitationId: %s", err))
        }</span>

        <span class="cov0" title="0">ctx.Set(BearerAuthScopes, []string{})

        // Invoke the callback with all the unmarshaled arguments
        err = w.Handler.UpdateInvitation(ctx, id, invitationId)
        return err</span>
}

// This is a simple interface which specifies echo.Route addition functions which
// are present on both echo.Echo and echo.Group, since we want to allow using
// either of them for path registration
type EchoRouter interface {
        CONNECT(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
        DELETE(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
        GET(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
        HEAD(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
        OPTIONS(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
        PATCH(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
        POST(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
        PUT(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
        TRACE(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
}

// RegisterHandlers adds each server route to the EchoRouter.
func RegisterHandlers(router EchoRouter, si ServerInterface) <span class="cov0" title="0">{
        RegisterHandlersWithBaseURL(router, si, "")
}</span>

// Registers handlers, and prepends BaseURL to the paths, so that the paths
// can be served under a prefix.
func RegisterHandlersWithBaseURL(router EchoRouter, si ServerInterface, baseURL string) <span class="cov0" title="0">{

        wrapper := ServerInterfaceWrapper{
                Handler: si,
        }

        router.GET(baseURL+"/organizations/:id/invitations", wrapper.FindManyInvitations)
        router.POST(baseURL+"/organizations/:id/invitations", wrapper.CreateInvitation)
        router.DELETE(baseURL+"/organizations/:id/invitations/:invitationId", wrapper.DeleteInvitation)
        router.GET(baseURL+"/organizations/:id/invitations/:invitationId", wrapper.GetOneInvitation)
        router.PATCH(baseURL+"/organizations/:id/invitations/:invitationId", wrapper.UpdateInvitation)

}</span>

type BadRequestApplicationProblemPlusJSONResponse Problem

type NotFoundApplicationProblemPlusJSONResponse Problem

type UnauthorizedApplicationProblemPlusJSONResponse Problem

type FindManyInvitationsRequestObject struct {
        Id     openapi_types.UUID `json:"id"`
        Params FindManyInvitationsParams
}

type FindManyInvitationsResponseObject interface {
        VisitFindManyInvitationsResponse(w http.ResponseWriter) error
}

type FindManyInvitations200JSONResponse struct {
        Data []Invitation `json:"data"`
        Meta struct {
                // Total Total number of items in the collection
                Total float32 `json:"total"`
        } `json:"meta"`
}

func (response FindManyInvitations200JSONResponse) VisitFindManyInvitationsResponse(w http.ResponseWriter) error <span class="cov0" title="0">{
        w.Header().Set("Content-Type", "application/json")
        w.WriteHeader(200)

        return json.NewEncoder(w).Encode(response)
}</span>

type FindManyInvitations400ApplicationProblemPlusJSONResponse struct {
        BadRequestApplicationProblemPlusJSONResponse
}

func (response FindManyInvitations400ApplicationProblemPlusJSONResponse) VisitFindManyInvitationsResponse(w http.ResponseWriter) error <span class="cov0" title="0">{
        w.Header().Set("Content-Type", "application/problem+json")
        w.WriteHeader(400)

        return json.NewEncoder(w).Encode(response)
}</span>

type FindManyInvitations401ApplicationProblemPlusJSONResponse struct {
        UnauthorizedApplicationProblemPlusJSONResponse
}

func (response FindManyInvitations401ApplicationProblemPlusJSONResponse) VisitFindManyInvitationsResponse(w http.ResponseWriter) error <span class="cov0" title="0">{
        w.Header().Set("Content-Type", "application/problem+json")
        w.WriteHeader(401)

        return json.NewEncoder(w).Encode(response)
}</span>

type CreateInvitationRequestObject struct {
        Id   openapi_types.UUID `json:"id"`
        Body *CreateInvitationJSONRequestBody
}

type CreateInvitationResponseObject interface {
        VisitCreateInvitationResponse(w http.ResponseWriter) error
}

type CreateInvitation201JSONResponse struct {
        // Data Schema for Invitation entity
        Data Invitation `json:"data"`
}

func (response CreateInvitation201JSONResponse) VisitCreateInvitationResponse(w http.ResponseWriter) error <span class="cov0" title="0">{
        w.Header().Set("Content-Type", "application/json")
        w.WriteHeader(201)

        return json.NewEncoder(w).Encode(response)
}</span>

type CreateInvitation400ApplicationProblemPlusJSONResponse struct {
        BadRequestApplicationProblemPlusJSONResponse
}

func (response CreateInvitation400ApplicationProblemPlusJSONResponse) VisitCreateInvitationResponse(w http.ResponseWriter) error <span class="cov0" title="0">{
        w.Header().Set("Content-Type", "application/problem+json")
        w.WriteHeader(400)

        return json.NewEncoder(w).Encode(response)
}</span>

type CreateInvitation401ApplicationProblemPlusJSONResponse struct {
        UnauthorizedApplicationProblemPlusJSONResponse
}

func (response CreateInvitation401ApplicationProblemPlusJSONResponse) VisitCreateInvitationResponse(w http.ResponseWriter) error <span class="cov0" title="0">{
        w.Header().Set("Content-Type", "application/problem+json")
        w.WriteHeader(401)

        return json.NewEncoder(w).Encode(response)
}</span>

type DeleteInvitationRequestObject struct {
        Id           openapi_types.UUID `json:"id"`
        InvitationId openapi_types.UUID `json:"invitationId"`
}

type DeleteInvitationResponseObject interface {
        VisitDeleteInvitationResponse(w http.ResponseWriter) error
}

type DeleteInvitation200JSONResponse struct {
        // Data Schema for Invitation entity
        Data Invitation `json:"data"`
}

func (response DeleteInvitation200JSONResponse) VisitDeleteInvitationResponse(w http.ResponseWriter) error <span class="cov0" title="0">{
        w.Header().Set("Content-Type", "application/json")
        w.WriteHeader(200)

        return json.NewEncoder(w).Encode(response)
}</span>

type DeleteInvitation404ApplicationProblemPlusJSONResponse struct {
        NotFoundApplicationProblemPlusJSONResponse
}

func (response DeleteInvitation404ApplicationProblemPlusJSONResponse) VisitDeleteInvitationResponse(w http.ResponseWriter) error <span class="cov0" title="0">{
        w.Header().Set("Content-Type", "application/problem+json")
        w.WriteHeader(404)

        return json.NewEncoder(w).Encode(response)
}</span>

type GetOneInvitationRequestObject struct {
        Id           openapi_types.UUID `json:"id"`
        InvitationId openapi_types.UUID `json:"invitationId"`
}

type GetOneInvitationResponseObject interface {
        VisitGetOneInvitationResponse(w http.ResponseWriter) error
}

type GetOneInvitation200JSONResponse struct {
        // Data Schema for Invitation entity
        Data Invitation `json:"data"`
}

func (response GetOneInvitation200JSONResponse) VisitGetOneInvitationResponse(w http.ResponseWriter) error <span class="cov0" title="0">{
        w.Header().Set("Content-Type", "application/json")
        w.WriteHeader(200)

        return json.NewEncoder(w).Encode(response)
}</span>

type GetOneInvitation404ApplicationProblemPlusJSONResponse struct {
        NotFoundApplicationProblemPlusJSONResponse
}

func (response GetOneInvitation404ApplicationProblemPlusJSONResponse) VisitGetOneInvitationResponse(w http.ResponseWriter) error <span class="cov0" title="0">{
        w.Header().Set("Content-Type", "application/problem+json")
        w.WriteHeader(404)

        return json.NewEncoder(w).Encode(response)
}</span>

type UpdateInvitationRequestObject struct {
        Id           openapi_types.UUID `json:"id"`
        InvitationId openapi_types.UUID `json:"invitationId"`
        Body         *UpdateInvitationJSONRequestBody
}

type UpdateInvitationResponseObject interface {
        VisitUpdateInvitationResponse(w http.ResponseWriter) error
}

type UpdateInvitation200JSONResponse struct {
        // Data Schema for Invitation entity
        Data Invitation `json:"data"`
}

func (response UpdateInvitation200JSONResponse) VisitUpdateInvitationResponse(w http.ResponseWriter) error <span class="cov0" title="0">{
        w.Header().Set("Content-Type", "application/json")
        w.WriteHeader(200)

        return json.NewEncoder(w).Encode(response)
}</span>

type UpdateInvitation404ApplicationProblemPlusJSONResponse struct {
        NotFoundApplicationProblemPlusJSONResponse
}

func (response UpdateInvitation404ApplicationProblemPlusJSONResponse) VisitUpdateInvitationResponse(w http.ResponseWriter) error <span class="cov0" title="0">{
        w.Header().Set("Content-Type", "application/problem+json")
        w.WriteHeader(404)

        return json.NewEncoder(w).Encode(response)
}</span>

// StrictServerInterface represents all server handlers.
type StrictServerInterface interface {
        // Find many invitations
        // (GET /organizations/{id}/invitations)
        FindManyInvitations(ctx context.Context, request FindManyInvitationsRequestObject) (FindManyInvitationsResponseObject, error)
        // Create a new invitation
        // (POST /organizations/{id}/invitations)
        CreateInvitation(ctx context.Context, request CreateInvitationRequestObject) (CreateInvitationResponseObject, error)
        // Delete an invitation
        // (DELETE /organizations/{id}/invitations/{invitationId})
        DeleteInvitation(ctx context.Context, request DeleteInvitationRequestObject) (DeleteInvitationResponseObject, error)
        // Find an invitation
        // (GET /organizations/{id}/invitations/{invitationId})
        GetOneInvitation(ctx context.Context, request GetOneInvitationRequestObject) (GetOneInvitationResponseObject, error)
        // Update an invitation
        // (PATCH /organizations/{id}/invitations/{invitationId})
        UpdateInvitation(ctx context.Context, request UpdateInvitationRequestObject) (UpdateInvitationResponseObject, error)
}

type StrictHandlerFunc = strictecho.StrictEchoHandlerFunc
type StrictMiddlewareFunc = strictecho.StrictEchoMiddlewareFunc

func NewStrictHandler(ssi StrictServerInterface, middlewares []StrictMiddlewareFunc) ServerInterface <span class="cov0" title="0">{
        return &amp;strictHandler{ssi: ssi, middlewares: middlewares}
}</span>

type strictHandler struct {
        ssi         StrictServerInterface
        middlewares []StrictMiddlewareFunc
}

// FindManyInvitations operation middleware
func (sh *strictHandler) FindManyInvitations(ctx echo.Context, id openapi_types.UUID, params FindManyInvitationsParams) error <span class="cov0" title="0">{
        var request FindManyInvitationsRequestObject

        request.Id = id
        request.Params = params

        handler := func(ctx echo.Context, request interface{}) (interface{}, error) </span><span class="cov0" title="0">{
                return sh.ssi.FindManyInvitations(ctx.Request().Context(), request.(FindManyInvitationsRequestObject))
        }</span>
        <span class="cov0" title="0">for _, middleware := range sh.middlewares </span><span class="cov0" title="0">{
                handler = middleware(handler, "FindManyInvitations")
        }</span>

        <span class="cov0" title="0">response, err := handler(ctx, request)

        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span> else<span class="cov0" title="0"> if validResponse, ok := response.(FindManyInvitationsResponseObject); ok </span><span class="cov0" title="0">{
                return validResponse.VisitFindManyInvitationsResponse(ctx.Response())
        }</span> else<span class="cov0" title="0"> if response != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("unexpected response type: %T", response)
        }</span>
        <span class="cov0" title="0">return nil</span>
}

// CreateInvitation operation middleware
func (sh *strictHandler) CreateInvitation(ctx echo.Context, id openapi_types.UUID) error <span class="cov0" title="0">{
        var request CreateInvitationRequestObject

        request.Id = id

        var body CreateInvitationJSONRequestBody
        if err := ctx.Bind(&amp;body); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov0" title="0">request.Body = &amp;body

        handler := func(ctx echo.Context, request interface{}) (interface{}, error) </span><span class="cov0" title="0">{
                return sh.ssi.CreateInvitation(ctx.Request().Context(), request.(CreateInvitationRequestObject))
        }</span>
        <span class="cov0" title="0">for _, middleware := range sh.middlewares </span><span class="cov0" title="0">{
                handler = middleware(handler, "CreateInvitation")
        }</span>

        <span class="cov0" title="0">response, err := handler(ctx, request)

        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span> else<span class="cov0" title="0"> if validResponse, ok := response.(CreateInvitationResponseObject); ok </span><span class="cov0" title="0">{
                return validResponse.VisitCreateInvitationResponse(ctx.Response())
        }</span> else<span class="cov0" title="0"> if response != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("unexpected response type: %T", response)
        }</span>
        <span class="cov0" title="0">return nil</span>
}

// DeleteInvitation operation middleware
func (sh *strictHandler) DeleteInvitation(ctx echo.Context, id openapi_types.UUID, invitationId openapi_types.UUID) error <span class="cov0" title="0">{
        var request DeleteInvitationRequestObject

        request.Id = id
        request.InvitationId = invitationId

        handler := func(ctx echo.Context, request interface{}) (interface{}, error) </span><span class="cov0" title="0">{
                return sh.ssi.DeleteInvitation(ctx.Request().Context(), request.(DeleteInvitationRequestObject))
        }</span>
        <span class="cov0" title="0">for _, middleware := range sh.middlewares </span><span class="cov0" title="0">{
                handler = middleware(handler, "DeleteInvitation")
        }</span>

        <span class="cov0" title="0">response, err := handler(ctx, request)

        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span> else<span class="cov0" title="0"> if validResponse, ok := response.(DeleteInvitationResponseObject); ok </span><span class="cov0" title="0">{
                return validResponse.VisitDeleteInvitationResponse(ctx.Response())
        }</span> else<span class="cov0" title="0"> if response != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("unexpected response type: %T", response)
        }</span>
        <span class="cov0" title="0">return nil</span>
}

// GetOneInvitation operation middleware
func (sh *strictHandler) GetOneInvitation(ctx echo.Context, id openapi_types.UUID, invitationId openapi_types.UUID) error <span class="cov0" title="0">{
        var request GetOneInvitationRequestObject

        request.Id = id
        request.InvitationId = invitationId

        handler := func(ctx echo.Context, request interface{}) (interface{}, error) </span><span class="cov0" title="0">{
                return sh.ssi.GetOneInvitation(ctx.Request().Context(), request.(GetOneInvitationRequestObject))
        }</span>
        <span class="cov0" title="0">for _, middleware := range sh.middlewares </span><span class="cov0" title="0">{
                handler = middleware(handler, "GetOneInvitation")
        }</span>

        <span class="cov0" title="0">response, err := handler(ctx, request)

        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span> else<span class="cov0" title="0"> if validResponse, ok := response.(GetOneInvitationResponseObject); ok </span><span class="cov0" title="0">{
                return validResponse.VisitGetOneInvitationResponse(ctx.Response())
        }</span> else<span class="cov0" title="0"> if response != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("unexpected response type: %T", response)
        }</span>
        <span class="cov0" title="0">return nil</span>
}

// UpdateInvitation operation middleware
func (sh *strictHandler) UpdateInvitation(ctx echo.Context, id openapi_types.UUID, invitationId openapi_types.UUID) error <span class="cov0" title="0">{
        var request UpdateInvitationRequestObject

        request.Id = id
        request.InvitationId = invitationId

        var body UpdateInvitationJSONRequestBody
        if err := ctx.Bind(&amp;body); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov0" title="0">request.Body = &amp;body

        handler := func(ctx echo.Context, request interface{}) (interface{}, error) </span><span class="cov0" title="0">{
                return sh.ssi.UpdateInvitation(ctx.Request().Context(), request.(UpdateInvitationRequestObject))
        }</span>
        <span class="cov0" title="0">for _, middleware := range sh.middlewares </span><span class="cov0" title="0">{
                handler = middleware(handler, "UpdateInvitation")
        }</span>

        <span class="cov0" title="0">response, err := handler(ctx, request)

        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span> else<span class="cov0" title="0"> if validResponse, ok := response.(UpdateInvitationResponseObject); ok </span><span class="cov0" title="0">{
                return validResponse.VisitUpdateInvitationResponse(ctx.Response())
        }</span> else<span class="cov0" title="0"> if response != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("unexpected response type: %T", response)
        }</span>
        <span class="cov0" title="0">return nil</span>
}
</pre>
		
		<pre class="file" id="file86" style="display: none">// Code generated by codegen repository. DO NOT EDIT.
package invitations

import (
        "context"
        "errors"

        "github.com/archesai/archesai/internal/database/postgresql"
        "github.com/google/uuid"
        "github.com/jackc/pgx/v5/pgxpool"
)

// PostgresRepository implements Repository using PostgreSQL.
type PostgresRepository struct {
        db      *pgxpool.Pool
        queries *postgresql.Queries
}

// NewPostgresRepository creates a new PostgreSQL repository.
func NewPostgresRepository(db *pgxpool.Pool) Repository <span class="cov0" title="0">{
        return &amp;PostgresRepository{
                db:      db,
                queries: postgresql.New(db),
        }
}</span>

// Invitation operations

func (r *PostgresRepository) Create(ctx context.Context, entity *Invitation) (*Invitation, error) <span class="cov0" title="0">{
        // Check if SQLC has the CreateInvitation method
        // For now, we'll generate a stub but with proper error handling
        // TODO: Parse SQLC to detect available queries

        // Example of what it should look like when SQLC query exists:
        // params := postgresql.CreateInvitationParams{
        //     Id: entity.Id,
        //     // ... map other fields
        // }
        // dbInvitation, err := r.queries.CreateInvitation(ctx, params)
        // if err != nil {
        //     return nil, NewRepositoryError("create", err)
        // }
        // return mapInvitationToDomain(&amp;dbInvitation), nil

        return nil, NewRepositoryError("create", errors.New("not implemented - SQLC query not found"))
}</span>

func (r *PostgresRepository) Get(ctx context.Context, id uuid.UUID) (*Invitation, error) <span class="cov0" title="0">{
        // Try to call SQLC GetInvitation if it exists
        // For now, return not implemented
        return nil, NewRepositoryError("get", errors.New("not implemented - SQLC query not found"))
}</span>

func (r *PostgresRepository) Update(ctx context.Context, id uuid.UUID, entity *Invitation) (*Invitation, error) <span class="cov0" title="0">{
        // Update operations are often custom and may not have SQLC queries
        return nil, NewRepositoryError("update", errors.New("not implemented - SQLC query not found"))
}</span>

func (r *PostgresRepository) Delete(ctx context.Context, id uuid.UUID) error <span class="cov0" title="0">{
        // Try to call SQLC DeleteInvitation if it exists
        // For now, return not implemented
        return NewRepositoryError("delete", errors.New("not implemented - SQLC query not found"))
}</span>

func (r *PostgresRepository) List(ctx context.Context, params ListInvitationsParams) ([]*Invitation, int64, error) <span class="cov0" title="0">{
        // List operations need both List and Count queries from SQLC
        return nil, 0, NewRepositoryError("list", errors.New("not implemented - SQLC query not found"))
}</span>

// ListByOrganization retrieves multiple invitations by organizationId
func (r *PostgresRepository) ListByOrganization(ctx context.Context, organizationId string) ([]*Invitation, error) <span class="cov0" title="0">{

        // Try to call SQLC ListByOrganization if it exists
        // For now, return not implemented
        return nil, NewRepositoryError("listbyorganization", errors.New("not implemented - SQLC query not found"))

}</span>

// GetByEmail retrieves invitation by emailorganizationId
func (r *PostgresRepository) GetByEmail(ctx context.Context, email string, organizationId string) (*Invitation, error) <span class="cov0" title="0">{

        // Try to call SQLC GetByEmail if it exists
        // For now, return not implemented
        return nil, NewRepositoryError("getbyemail", errors.New("not implemented - SQLC query not found"))

}</span>

// ListByInviter retrieves multiple invitations by inviterId
func (r *PostgresRepository) ListByInviter(ctx context.Context, inviterId string) ([]*Invitation, error) <span class="cov0" title="0">{

        // Try to call SQLC ListByInviter if it exists
        // For now, return not implemented
        return nil, NewRepositoryError("listbyinviter", errors.New("not implemented - SQLC query not found"))

}</span>

// Mapper functions - Convert between domain types and database types
// These need to be customized based on the actual field mappings

func mapInvitationToDomain(db *postgresql.Invitation) *Invitation <span class="cov0" title="0">{
        if db == nil </span><span class="cov0" title="0">{
                return nil
        }</span>

        // This is a basic mapping - needs to be customized based on actual types
        // The challenge is that OpenAPI types and database types don't always match
        // For example:
        // - OpenAPI might use string, database uses *string
        // - OpenAPI might use custom UUID type, database uses uuid.UUID
        // - Field names might differ (Id vs ID)

        <span class="cov0" title="0">result := &amp;Invitation{
                // TODO: Map fields properly based on actual type definitions
                // This requires parsing both OpenAPI types and SQLC types
        }

        // Basic field mapping - customize based on your entity structure
        // result.Id = db.Id
        // result.CreatedAt = db.CreatedAt
        // result.UpdatedAt = db.UpdatedAt
        // Add specific field mappings as needed

        return result</span>
}
</pre>
		
		<pre class="file" id="file87" style="display: none">// Code generated by codegen repository. DO NOT EDIT.
package invitations

import (
        "context"
        "fmt"
        "github.com/google/uuid"
)

// Repository handles invitation persistence
type Repository interface {
        Create(ctx context.Context, entity *Invitation) (*Invitation, error)
        Get(ctx context.Context, id uuid.UUID) (*Invitation, error)
        Update(ctx context.Context, id uuid.UUID, entity *Invitation) (*Invitation, error)
        Delete(ctx context.Context, id uuid.UUID) error
        List(ctx context.Context, params ListInvitationsParams) ([]*Invitation, int64, error)

        // Additional operations
        ListByOrganization(ctx context.Context, organizationId string) ([]*Invitation, error)
        GetByEmail(ctx context.Context, email string, organizationId string) (*Invitation, error)
        ListByInviter(ctx context.Context, inviterId string) ([]*Invitation, error)
}

// ListInvitationsParams represents parameters for listing invitations.
type ListInvitationsParams struct {
        Limit  int
        Offset int
}

// RepositoryError represents a repository error.
type RepositoryError struct {
        Operation string
        Err       error
}

func (e *RepositoryError) Error() string <span class="cov0" title="0">{
        return fmt.Sprintf("repository %s: %v", e.Operation, e.Err)
}</span>

func (e *RepositoryError) Unwrap() error <span class="cov0" title="0">{
        return e.Err
}</span>

// NewRepositoryError creates a new repository error.
func NewRepositoryError(operation string, err error) *RepositoryError <span class="cov0" title="0">{
        return &amp;RepositoryError{
                Operation: operation,
                Err:       err,
        }
}</span>
</pre>
		
		<pre class="file" id="file88" style="display: none">// Code generated by codegen repository. DO NOT EDIT.
package invitations

import (
        "context"
        "database/sql"
        "fmt"

        "github.com/archesai/archesai/internal/database/sqlite"
        "github.com/google/uuid"
)

// SQLiteRepository implements Repository using SQLite.
type SQLiteRepository struct {
        db      *sql.DB
        queries *sqlite.Queries
}

// NewSQLiteRepository creates a new SQLite repository.
func NewSQLiteRepository(db *sql.DB) Repository <span class="cov0" title="0">{
        return &amp;SQLiteRepository{
                db:      db,
                queries: sqlite.New(db),
        }
}</span>

// Invitation operations

func (r *SQLiteRepository) Create(ctx context.Context, entity *Invitation) (*Invitation, error) <span class="cov0" title="0">{
        // For now, return a basic implementation
        // Actual implementation would need to be customized per entity
        return nil, fmt.Errorf("CreateInvitation not yet implemented - requires custom mapping")
}</span>

func (r *SQLiteRepository) Get(ctx context.Context, id uuid.UUID) (*Invitation, error) <span class="cov0" title="0">{
        // For now, return a basic implementation
        // Actual implementation would need to be customized per entity
        return nil, fmt.Errorf("GetInvitation not yet implemented - requires custom mapping")
}</span>

func (r *SQLiteRepository) Update(ctx context.Context, id uuid.UUID, entity *Invitation) (*Invitation, error) <span class="cov0" title="0">{
        // For now, return a basic implementation
        // Actual implementation would need to be customized per entity
        return nil, fmt.Errorf("UpdateInvitation not yet implemented - requires custom mapping")
}</span>

func (r *SQLiteRepository) Delete(ctx context.Context, id uuid.UUID) error <span class="cov0" title="0">{
        // For now, return a basic implementation
        // Actual implementation would need to be customized per entity
        return fmt.Errorf("DeleteInvitation not yet implemented - requires custom mapping")
}</span>

func (r *SQLiteRepository) List(ctx context.Context, params ListInvitationsParams) ([]*Invitation, int64, error) <span class="cov0" title="0">{
        // For now, return a basic implementation
        // Actual implementation would need to be customized per entity
        return nil, 0, fmt.Errorf("ListInvitations not yet implemented - requires custom mapping")
}</span>

// ListByOrganization retrieves multiple invitations by organizationId
func (r *SQLiteRepository) ListByOrganization(ctx context.Context, organizationId string) ([]*Invitation, error) <span class="cov0" title="0">{

        // For now, return a basic implementation
        return nil, fmt.Errorf("ListByOrganization not yet implemented - requires custom mapping")

}</span>

// GetByEmail retrieves invitation by emailorganizationId
func (r *SQLiteRepository) GetByEmail(ctx context.Context, email string, organizationId string) (*Invitation, error) <span class="cov0" title="0">{

        // For now, return a basic implementation
        return nil, fmt.Errorf("GetByEmail not yet implemented - requires custom mapping")

}</span>

// ListByInviter retrieves multiple invitations by inviterId
func (r *SQLiteRepository) ListByInviter(ctx context.Context, inviterId string) ([]*Invitation, error) <span class="cov0" title="0">{

        // For now, return a basic implementation
        return nil, fmt.Errorf("ListByInviter not yet implemented - requires custom mapping")

}</span>
</pre>
		
		<pre class="file" id="file89" style="display: none">// Package invitations provides primitives to interact with the openapi HTTP API.
//
// Code generated by github.com/oapi-codegen/oapi-codegen/v2 version v2.5.0 DO NOT EDIT.
package invitations

import (
        "encoding/json"
        "time"

        "github.com/oapi-codegen/runtime"
        openapi_types "github.com/oapi-codegen/runtime/types"
)

const (
        BearerAuthScopes = "bearerAuth.Scopes"
)

// Defines values for InvitationRole.
const (
        InvitationRoleAdmin  InvitationRole = "admin"
        InvitationRoleMember InvitationRole = "member"
        InvitationRoleOwner  InvitationRole = "owner"
)

// Defines values for FindManyInvitationsParamsSortField.
const (
        CreatedAt      FindManyInvitationsParamsSortField = "createdAt"
        Email          FindManyInvitationsParamsSortField = "email"
        ExpiresAt      FindManyInvitationsParamsSortField = "expiresAt"
        Id             FindManyInvitationsParamsSortField = "id"
        InviterId      FindManyInvitationsParamsSortField = "inviterId"
        OrganizationId FindManyInvitationsParamsSortField = "organizationId"
        Role           FindManyInvitationsParamsSortField = "role"
        Status         FindManyInvitationsParamsSortField = "status"
        UpdatedAt      FindManyInvitationsParamsSortField = "updatedAt"
)

// Defines values for FindManyInvitationsParamsSortOrder.
const (
        Asc  FindManyInvitationsParamsSortOrder = "asc"
        Desc FindManyInvitationsParamsSortOrder = "desc"
)

// Defines values for CreateInvitationJSONBodyRole.
const (
        CreateInvitationJSONBodyRoleAdmin  CreateInvitationJSONBodyRole = "admin"
        CreateInvitationJSONBodyRoleMember CreateInvitationJSONBodyRole = "member"
        CreateInvitationJSONBodyRoleOwner  CreateInvitationJSONBodyRole = "owner"
)

// Defines values for UpdateInvitationJSONBodyRole.
const (
        Admin  UpdateInvitationJSONBodyRole = "admin"
        Member UpdateInvitationJSONBodyRole = "member"
        Owner  UpdateInvitationJSONBodyRole = "owner"
)

// FilterNode A recursive filter node that can be a condition or group
type FilterNode = interface{}

// Invitation Schema for Invitation entity
type Invitation struct {
        // CreatedAt The date this item was created
        CreatedAt time.Time `json:"createdAt" yaml:"createdAt"`

        // Email The email of the invitated user
        Email string `json:"email" yaml:"email"`

        // ExpiresAt The date and time when the invitation expires
        ExpiresAt string `json:"expiresAt" yaml:"expiresAt"`

        // Id The ID of the item
        Id openapi_types.UUID `json:"id" yaml:"id"`

        // InviterId The user id of the inviter
        InviterId string `json:"inviterId" yaml:"inviterId"`

        // OrganizationId The name of the organization the token belongs to
        OrganizationId string `json:"organizationId" yaml:"organizationId"`

        // Role The role of the invitation
        Role InvitationRole `json:"role" yaml:"role"`

        // Status The status of the invitation, e.g., pending, accepted, declined
        Status string `json:"status" yaml:"status"`

        // UpdatedAt The date this item was last updated
        UpdatedAt time.Time `json:"updatedAt" yaml:"updatedAt"`
}

// InvitationRole The role of the invitation
type InvitationRole string

// Page Pagination (page number &amp; size)
type Page struct {
        Number int `json:"number,omitempty,omitzero" yaml:"number,omitempty"`
        Size   int `json:"size,omitempty,omitzero" yaml:"size,omitempty"`
}

// Problem RFC 7807 (Problem Details) compliant error response
type Problem struct {
        // Detail Human-readable explanation specific to this occurrence
        Detail string `json:"detail" yaml:"detail"`

        // Errors Additional validation errors for specific fields
        Errors []ValidationError `json:"errors,omitempty,omitzero" yaml:"errors,omitempty"`

        // Instance URI identifying the specific occurrence
        Instance string `json:"instance,omitempty,omitzero" yaml:"instance,omitempty"`

        // Status HTTP status code
        Status int `json:"status" yaml:"status"`

        // Title Short, human-readable summary
        Title string `json:"title" yaml:"title"`

        // Type URI identifying the problem type
        Type string `json:"type" yaml:"type"`
}

// ValidationError Individual field validation error
type ValidationError struct {
        // Field The field path that failed validation
        Field string `json:"field" yaml:"field"`

        // Message Human-readable error message
        Message string `json:"message" yaml:"message"`

        // Value The invalid value that was provided
        Value ValidationError_Value `json:"value,omitempty,omitzero" yaml:"value,omitempty"`
}

// ValidationErrorValue0 defines model for .
type ValidationErrorValue0 = string

// ValidationErrorValue1 defines model for .
type ValidationErrorValue1 = float32

// ValidationErrorValue2 defines model for .
type ValidationErrorValue2 = bool

// ValidationError_Value The invalid value that was provided
type ValidationError_Value struct {
        union json.RawMessage
}

// InvitationsFilter A recursive filter node that can be a condition or group
type InvitationsFilter = FilterNode

// InvitationsSort defines model for InvitationsSort.
type InvitationsSort = []struct {
        Field string `json:"field" yaml:"field"`
        Order string `json:"order" yaml:"order"`
}

// PageQuery Pagination (page number &amp; size)
type PageQuery = Page

// BadRequest RFC 7807 (Problem Details) compliant error response
type BadRequest = Problem

// NotFound RFC 7807 (Problem Details) compliant error response
type NotFound = Problem

// Unauthorized RFC 7807 (Problem Details) compliant error response
type Unauthorized = Problem

// FindManyInvitationsParams defines parameters for FindManyInvitations.
type FindManyInvitationsParams struct {
        // Filter Filter invitations by field values. Supported fields:
        // - createdAt, id, updatedAt, email, expiresAt
        // - inviterId, organizationId, role, status
        Filter InvitationsFilter `json:"filter,omitempty,omitzero" yaml:"filter,omitempty"`

        // Page The page parameter
        Page PageQuery `form:"page,omitempty" json:"page,omitempty,omitzero" yaml:"page,omitempty"`

        // Sort The sort parameter
        Sort InvitationsSort `form:"sort,omitempty" json:"sort,omitempty,omitzero" yaml:"sort,omitempty"`
}

// FindManyInvitationsParamsSortField defines parameters for FindManyInvitations.
type FindManyInvitationsParamsSortField string

// FindManyInvitationsParamsSortOrder defines parameters for FindManyInvitations.
type FindManyInvitationsParamsSortOrder string

// CreateInvitationJSONBody defines parameters for CreateInvitation.
type CreateInvitationJSONBody struct {
        // Email The email of the invitated user
        Email string `json:"email" yaml:"email"`

        // Role The role of the invitation
        Role CreateInvitationJSONBodyRole `json:"role" yaml:"role"`
}

// CreateInvitationJSONBodyRole defines parameters for CreateInvitation.
type CreateInvitationJSONBodyRole string

// UpdateInvitationJSONBody defines parameters for UpdateInvitation.
type UpdateInvitationJSONBody struct {
        // Email The email of the invitated user
        Email string `json:"email,omitempty,omitzero" yaml:"email,omitempty"`

        // Role The role of the invitation
        Role UpdateInvitationJSONBodyRole `json:"role,omitempty,omitzero" yaml:"role,omitempty"`
}

// UpdateInvitationJSONBodyRole defines parameters for UpdateInvitation.
type UpdateInvitationJSONBodyRole string

// CreateInvitationJSONRequestBody defines body for CreateInvitation for application/json ContentType.
type CreateInvitationJSONRequestBody CreateInvitationJSONBody

// UpdateInvitationJSONRequestBody defines body for UpdateInvitation for application/json ContentType.
type UpdateInvitationJSONRequestBody UpdateInvitationJSONBody

// AsValidationErrorValue0 returns the union data inside the ValidationError_Value as a ValidationErrorValue0
func (t ValidationError_Value) AsValidationErrorValue0() (ValidationErrorValue0, error) <span class="cov0" title="0">{
        var body ValidationErrorValue0
        err := json.Unmarshal(t.union, &amp;body)
        return body, err
}</span>

// FromValidationErrorValue0 overwrites any union data inside the ValidationError_Value as the provided ValidationErrorValue0
func (t *ValidationError_Value) FromValidationErrorValue0(v ValidationErrorValue0) error <span class="cov0" title="0">{
        b, err := json.Marshal(v)
        t.union = b
        return err
}</span>

// MergeValidationErrorValue0 performs a merge with any union data inside the ValidationError_Value, using the provided ValidationErrorValue0
func (t *ValidationError_Value) MergeValidationErrorValue0(v ValidationErrorValue0) error <span class="cov0" title="0">{
        b, err := json.Marshal(v)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov0" title="0">merged, err := runtime.JSONMerge(t.union, b)
        t.union = merged
        return err</span>
}

// AsValidationErrorValue1 returns the union data inside the ValidationError_Value as a ValidationErrorValue1
func (t ValidationError_Value) AsValidationErrorValue1() (ValidationErrorValue1, error) <span class="cov0" title="0">{
        var body ValidationErrorValue1
        err := json.Unmarshal(t.union, &amp;body)
        return body, err
}</span>

// FromValidationErrorValue1 overwrites any union data inside the ValidationError_Value as the provided ValidationErrorValue1
func (t *ValidationError_Value) FromValidationErrorValue1(v ValidationErrorValue1) error <span class="cov0" title="0">{
        b, err := json.Marshal(v)
        t.union = b
        return err
}</span>

// MergeValidationErrorValue1 performs a merge with any union data inside the ValidationError_Value, using the provided ValidationErrorValue1
func (t *ValidationError_Value) MergeValidationErrorValue1(v ValidationErrorValue1) error <span class="cov0" title="0">{
        b, err := json.Marshal(v)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov0" title="0">merged, err := runtime.JSONMerge(t.union, b)
        t.union = merged
        return err</span>
}

// AsValidationErrorValue2 returns the union data inside the ValidationError_Value as a ValidationErrorValue2
func (t ValidationError_Value) AsValidationErrorValue2() (ValidationErrorValue2, error) <span class="cov0" title="0">{
        var body ValidationErrorValue2
        err := json.Unmarshal(t.union, &amp;body)
        return body, err
}</span>

// FromValidationErrorValue2 overwrites any union data inside the ValidationError_Value as the provided ValidationErrorValue2
func (t *ValidationError_Value) FromValidationErrorValue2(v ValidationErrorValue2) error <span class="cov0" title="0">{
        b, err := json.Marshal(v)
        t.union = b
        return err
}</span>

// MergeValidationErrorValue2 performs a merge with any union data inside the ValidationError_Value, using the provided ValidationErrorValue2
func (t *ValidationError_Value) MergeValidationErrorValue2(v ValidationErrorValue2) error <span class="cov0" title="0">{
        b, err := json.Marshal(v)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov0" title="0">merged, err := runtime.JSONMerge(t.union, b)
        t.union = merged
        return err</span>
}

func (t ValidationError_Value) MarshalJSON() ([]byte, error) <span class="cov0" title="0">{
        b, err := t.union.MarshalJSON()
        return b, err
}</span>

func (t *ValidationError_Value) UnmarshalJSON(b []byte) error <span class="cov0" title="0">{
        err := t.union.UnmarshalJSON(b)
        return err
}</span>
</pre>
		
		<pre class="file" id="file90" style="display: none">// Package labels provides primitives to interact with the openapi HTTP API.
//
// Code generated by github.com/oapi-codegen/oapi-codegen/v2 version v2.5.0 DO NOT EDIT.
package labels

import (
        "context"
        "encoding/json"
        "fmt"
        "net/http"

        "github.com/labstack/echo/v4"
        "github.com/oapi-codegen/runtime"
        strictecho "github.com/oapi-codegen/runtime/strictmiddleware/echo"
        openapi_types "github.com/oapi-codegen/runtime/types"
)

// ServerInterface represents all server handlers.
type ServerInterface interface {
        // Find many labels
        // (GET /content/labels)
        FindManyLabels(ctx echo.Context, params FindManyLabelsParams) error
        // Create a new label
        // (POST /content/labels)
        CreateLabel(ctx echo.Context) error
        // Delete a label
        // (DELETE /content/labels/{id})
        DeleteLabel(ctx echo.Context, id openapi_types.UUID) error
        // Find a label
        // (GET /content/labels/{id})
        GetOneLabel(ctx echo.Context, id openapi_types.UUID) error
        // Update a label
        // (PATCH /content/labels/{id})
        UpdateLabel(ctx echo.Context, id openapi_types.UUID) error
}

// ServerInterfaceWrapper converts echo contexts to parameters.
type ServerInterfaceWrapper struct {
        Handler ServerInterface
}

// FindManyLabels converts echo context to params.
func (w *ServerInterfaceWrapper) FindManyLabels(ctx echo.Context) error <span class="cov0" title="0">{
        var err error

        ctx.Set(BearerAuthScopes, []string{})

        // Parameter object where we will unmarshal all parameters from the context
        var params FindManyLabelsParams
        // ------------- Optional query parameter "filter" -------------

        err = runtime.BindQueryParameter("deepObject", true, false, "filter", ctx.QueryParams(), &amp;params.Filter)
        if err != nil </span><span class="cov0" title="0">{
                return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter filter: %s", err))
        }</span>

        // ------------- Optional query parameter "page" -------------

        <span class="cov0" title="0">err = runtime.BindQueryParameter("form", true, false, "page", ctx.QueryParams(), &amp;params.Page)
        if err != nil </span><span class="cov0" title="0">{
                return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter page: %s", err))
        }</span>

        // ------------- Optional query parameter "sort" -------------

        <span class="cov0" title="0">err = runtime.BindQueryParameter("form", true, false, "sort", ctx.QueryParams(), &amp;params.Sort)
        if err != nil </span><span class="cov0" title="0">{
                return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter sort: %s", err))
        }</span>

        // Invoke the callback with all the unmarshaled arguments
        <span class="cov0" title="0">err = w.Handler.FindManyLabels(ctx, params)
        return err</span>
}

// CreateLabel converts echo context to params.
func (w *ServerInterfaceWrapper) CreateLabel(ctx echo.Context) error <span class="cov0" title="0">{
        var err error

        ctx.Set(BearerAuthScopes, []string{})

        // Invoke the callback with all the unmarshaled arguments
        err = w.Handler.CreateLabel(ctx)
        return err
}</span>

// DeleteLabel converts echo context to params.
func (w *ServerInterfaceWrapper) DeleteLabel(ctx echo.Context) error <span class="cov0" title="0">{
        var err error
        // ------------- Path parameter "id" -------------
        var id openapi_types.UUID

        err = runtime.BindStyledParameterWithOptions("simple", "id", ctx.Param("id"), &amp;id, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
        if err != nil </span><span class="cov0" title="0">{
                return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter id: %s", err))
        }</span>

        <span class="cov0" title="0">ctx.Set(BearerAuthScopes, []string{})

        // Invoke the callback with all the unmarshaled arguments
        err = w.Handler.DeleteLabel(ctx, id)
        return err</span>
}

// GetOneLabel converts echo context to params.
func (w *ServerInterfaceWrapper) GetOneLabel(ctx echo.Context) error <span class="cov0" title="0">{
        var err error
        // ------------- Path parameter "id" -------------
        var id openapi_types.UUID

        err = runtime.BindStyledParameterWithOptions("simple", "id", ctx.Param("id"), &amp;id, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
        if err != nil </span><span class="cov0" title="0">{
                return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter id: %s", err))
        }</span>

        <span class="cov0" title="0">ctx.Set(BearerAuthScopes, []string{})

        // Invoke the callback with all the unmarshaled arguments
        err = w.Handler.GetOneLabel(ctx, id)
        return err</span>
}

// UpdateLabel converts echo context to params.
func (w *ServerInterfaceWrapper) UpdateLabel(ctx echo.Context) error <span class="cov0" title="0">{
        var err error
        // ------------- Path parameter "id" -------------
        var id openapi_types.UUID

        err = runtime.BindStyledParameterWithOptions("simple", "id", ctx.Param("id"), &amp;id, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
        if err != nil </span><span class="cov0" title="0">{
                return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter id: %s", err))
        }</span>

        <span class="cov0" title="0">ctx.Set(BearerAuthScopes, []string{})

        // Invoke the callback with all the unmarshaled arguments
        err = w.Handler.UpdateLabel(ctx, id)
        return err</span>
}

// This is a simple interface which specifies echo.Route addition functions which
// are present on both echo.Echo and echo.Group, since we want to allow using
// either of them for path registration
type EchoRouter interface {
        CONNECT(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
        DELETE(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
        GET(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
        HEAD(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
        OPTIONS(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
        PATCH(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
        POST(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
        PUT(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
        TRACE(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
}

// RegisterHandlers adds each server route to the EchoRouter.
func RegisterHandlers(router EchoRouter, si ServerInterface) <span class="cov0" title="0">{
        RegisterHandlersWithBaseURL(router, si, "")
}</span>

// Registers handlers, and prepends BaseURL to the paths, so that the paths
// can be served under a prefix.
func RegisterHandlersWithBaseURL(router EchoRouter, si ServerInterface, baseURL string) <span class="cov0" title="0">{

        wrapper := ServerInterfaceWrapper{
                Handler: si,
        }

        router.GET(baseURL+"/content/labels", wrapper.FindManyLabels)
        router.POST(baseURL+"/content/labels", wrapper.CreateLabel)
        router.DELETE(baseURL+"/content/labels/:id", wrapper.DeleteLabel)
        router.GET(baseURL+"/content/labels/:id", wrapper.GetOneLabel)
        router.PATCH(baseURL+"/content/labels/:id", wrapper.UpdateLabel)

}</span>

type BadRequestApplicationProblemPlusJSONResponse Problem

type NotFoundApplicationProblemPlusJSONResponse Problem

type UnauthorizedApplicationProblemPlusJSONResponse Problem

type FindManyLabelsRequestObject struct {
        Params FindManyLabelsParams
}

type FindManyLabelsResponseObject interface {
        VisitFindManyLabelsResponse(w http.ResponseWriter) error
}

type FindManyLabels200JSONResponse struct {
        Data []Label `json:"data"`
        Meta struct {
                // Total Total number of items in the collection
                Total float32 `json:"total"`
        } `json:"meta"`
}

func (response FindManyLabels200JSONResponse) VisitFindManyLabelsResponse(w http.ResponseWriter) error <span class="cov0" title="0">{
        w.Header().Set("Content-Type", "application/json")
        w.WriteHeader(200)

        return json.NewEncoder(w).Encode(response)
}</span>

type FindManyLabels400ApplicationProblemPlusJSONResponse struct {
        BadRequestApplicationProblemPlusJSONResponse
}

func (response FindManyLabels400ApplicationProblemPlusJSONResponse) VisitFindManyLabelsResponse(w http.ResponseWriter) error <span class="cov0" title="0">{
        w.Header().Set("Content-Type", "application/problem+json")
        w.WriteHeader(400)

        return json.NewEncoder(w).Encode(response)
}</span>

type FindManyLabels401ApplicationProblemPlusJSONResponse struct {
        UnauthorizedApplicationProblemPlusJSONResponse
}

func (response FindManyLabels401ApplicationProblemPlusJSONResponse) VisitFindManyLabelsResponse(w http.ResponseWriter) error <span class="cov0" title="0">{
        w.Header().Set("Content-Type", "application/problem+json")
        w.WriteHeader(401)

        return json.NewEncoder(w).Encode(response)
}</span>

type CreateLabelRequestObject struct {
        Body *CreateLabelJSONRequestBody
}

type CreateLabelResponseObject interface {
        VisitCreateLabelResponse(w http.ResponseWriter) error
}

type CreateLabel201JSONResponse struct {
        // Data Schema for Label entity
        Data Label `json:"data"`
}

func (response CreateLabel201JSONResponse) VisitCreateLabelResponse(w http.ResponseWriter) error <span class="cov0" title="0">{
        w.Header().Set("Content-Type", "application/json")
        w.WriteHeader(201)

        return json.NewEncoder(w).Encode(response)
}</span>

type CreateLabel400ApplicationProblemPlusJSONResponse struct {
        BadRequestApplicationProblemPlusJSONResponse
}

func (response CreateLabel400ApplicationProblemPlusJSONResponse) VisitCreateLabelResponse(w http.ResponseWriter) error <span class="cov0" title="0">{
        w.Header().Set("Content-Type", "application/problem+json")
        w.WriteHeader(400)

        return json.NewEncoder(w).Encode(response)
}</span>

type CreateLabel401ApplicationProblemPlusJSONResponse struct {
        UnauthorizedApplicationProblemPlusJSONResponse
}

func (response CreateLabel401ApplicationProblemPlusJSONResponse) VisitCreateLabelResponse(w http.ResponseWriter) error <span class="cov0" title="0">{
        w.Header().Set("Content-Type", "application/problem+json")
        w.WriteHeader(401)

        return json.NewEncoder(w).Encode(response)
}</span>

type DeleteLabelRequestObject struct {
        Id openapi_types.UUID `json:"id"`
}

type DeleteLabelResponseObject interface {
        VisitDeleteLabelResponse(w http.ResponseWriter) error
}

type DeleteLabel200JSONResponse struct {
        // Data Schema for Label entity
        Data Label `json:"data"`
}

func (response DeleteLabel200JSONResponse) VisitDeleteLabelResponse(w http.ResponseWriter) error <span class="cov0" title="0">{
        w.Header().Set("Content-Type", "application/json")
        w.WriteHeader(200)

        return json.NewEncoder(w).Encode(response)
}</span>

type DeleteLabel404ApplicationProblemPlusJSONResponse struct {
        NotFoundApplicationProblemPlusJSONResponse
}

func (response DeleteLabel404ApplicationProblemPlusJSONResponse) VisitDeleteLabelResponse(w http.ResponseWriter) error <span class="cov0" title="0">{
        w.Header().Set("Content-Type", "application/problem+json")
        w.WriteHeader(404)

        return json.NewEncoder(w).Encode(response)
}</span>

type GetOneLabelRequestObject struct {
        Id openapi_types.UUID `json:"id"`
}

type GetOneLabelResponseObject interface {
        VisitGetOneLabelResponse(w http.ResponseWriter) error
}

type GetOneLabel200JSONResponse struct {
        // Data Schema for Label entity
        Data Label `json:"data"`
}

func (response GetOneLabel200JSONResponse) VisitGetOneLabelResponse(w http.ResponseWriter) error <span class="cov0" title="0">{
        w.Header().Set("Content-Type", "application/json")
        w.WriteHeader(200)

        return json.NewEncoder(w).Encode(response)
}</span>

type GetOneLabel404ApplicationProblemPlusJSONResponse struct {
        NotFoundApplicationProblemPlusJSONResponse
}

func (response GetOneLabel404ApplicationProblemPlusJSONResponse) VisitGetOneLabelResponse(w http.ResponseWriter) error <span class="cov0" title="0">{
        w.Header().Set("Content-Type", "application/problem+json")
        w.WriteHeader(404)

        return json.NewEncoder(w).Encode(response)
}</span>

type UpdateLabelRequestObject struct {
        Id   openapi_types.UUID `json:"id"`
        Body *UpdateLabelJSONRequestBody
}

type UpdateLabelResponseObject interface {
        VisitUpdateLabelResponse(w http.ResponseWriter) error
}

type UpdateLabel200JSONResponse struct {
        // Data Schema for Label entity
        Data Label `json:"data"`
}

func (response UpdateLabel200JSONResponse) VisitUpdateLabelResponse(w http.ResponseWriter) error <span class="cov0" title="0">{
        w.Header().Set("Content-Type", "application/json")
        w.WriteHeader(200)

        return json.NewEncoder(w).Encode(response)
}</span>

type UpdateLabel404ApplicationProblemPlusJSONResponse struct {
        NotFoundApplicationProblemPlusJSONResponse
}

func (response UpdateLabel404ApplicationProblemPlusJSONResponse) VisitUpdateLabelResponse(w http.ResponseWriter) error <span class="cov0" title="0">{
        w.Header().Set("Content-Type", "application/problem+json")
        w.WriteHeader(404)

        return json.NewEncoder(w).Encode(response)
}</span>

// StrictServerInterface represents all server handlers.
type StrictServerInterface interface {
        // Find many labels
        // (GET /content/labels)
        FindManyLabels(ctx context.Context, request FindManyLabelsRequestObject) (FindManyLabelsResponseObject, error)
        // Create a new label
        // (POST /content/labels)
        CreateLabel(ctx context.Context, request CreateLabelRequestObject) (CreateLabelResponseObject, error)
        // Delete a label
        // (DELETE /content/labels/{id})
        DeleteLabel(ctx context.Context, request DeleteLabelRequestObject) (DeleteLabelResponseObject, error)
        // Find a label
        // (GET /content/labels/{id})
        GetOneLabel(ctx context.Context, request GetOneLabelRequestObject) (GetOneLabelResponseObject, error)
        // Update a label
        // (PATCH /content/labels/{id})
        UpdateLabel(ctx context.Context, request UpdateLabelRequestObject) (UpdateLabelResponseObject, error)
}

type StrictHandlerFunc = strictecho.StrictEchoHandlerFunc
type StrictMiddlewareFunc = strictecho.StrictEchoMiddlewareFunc

func NewStrictHandler(ssi StrictServerInterface, middlewares []StrictMiddlewareFunc) ServerInterface <span class="cov0" title="0">{
        return &amp;strictHandler{ssi: ssi, middlewares: middlewares}
}</span>

type strictHandler struct {
        ssi         StrictServerInterface
        middlewares []StrictMiddlewareFunc
}

// FindManyLabels operation middleware
func (sh *strictHandler) FindManyLabels(ctx echo.Context, params FindManyLabelsParams) error <span class="cov0" title="0">{
        var request FindManyLabelsRequestObject

        request.Params = params

        handler := func(ctx echo.Context, request interface{}) (interface{}, error) </span><span class="cov0" title="0">{
                return sh.ssi.FindManyLabels(ctx.Request().Context(), request.(FindManyLabelsRequestObject))
        }</span>
        <span class="cov0" title="0">for _, middleware := range sh.middlewares </span><span class="cov0" title="0">{
                handler = middleware(handler, "FindManyLabels")
        }</span>

        <span class="cov0" title="0">response, err := handler(ctx, request)

        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span> else<span class="cov0" title="0"> if validResponse, ok := response.(FindManyLabelsResponseObject); ok </span><span class="cov0" title="0">{
                return validResponse.VisitFindManyLabelsResponse(ctx.Response())
        }</span> else<span class="cov0" title="0"> if response != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("unexpected response type: %T", response)
        }</span>
        <span class="cov0" title="0">return nil</span>
}

// CreateLabel operation middleware
func (sh *strictHandler) CreateLabel(ctx echo.Context) error <span class="cov0" title="0">{
        var request CreateLabelRequestObject

        var body CreateLabelJSONRequestBody
        if err := ctx.Bind(&amp;body); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov0" title="0">request.Body = &amp;body

        handler := func(ctx echo.Context, request interface{}) (interface{}, error) </span><span class="cov0" title="0">{
                return sh.ssi.CreateLabel(ctx.Request().Context(), request.(CreateLabelRequestObject))
        }</span>
        <span class="cov0" title="0">for _, middleware := range sh.middlewares </span><span class="cov0" title="0">{
                handler = middleware(handler, "CreateLabel")
        }</span>

        <span class="cov0" title="0">response, err := handler(ctx, request)

        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span> else<span class="cov0" title="0"> if validResponse, ok := response.(CreateLabelResponseObject); ok </span><span class="cov0" title="0">{
                return validResponse.VisitCreateLabelResponse(ctx.Response())
        }</span> else<span class="cov0" title="0"> if response != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("unexpected response type: %T", response)
        }</span>
        <span class="cov0" title="0">return nil</span>
}

// DeleteLabel operation middleware
func (sh *strictHandler) DeleteLabel(ctx echo.Context, id openapi_types.UUID) error <span class="cov0" title="0">{
        var request DeleteLabelRequestObject

        request.Id = id

        handler := func(ctx echo.Context, request interface{}) (interface{}, error) </span><span class="cov0" title="0">{
                return sh.ssi.DeleteLabel(ctx.Request().Context(), request.(DeleteLabelRequestObject))
        }</span>
        <span class="cov0" title="0">for _, middleware := range sh.middlewares </span><span class="cov0" title="0">{
                handler = middleware(handler, "DeleteLabel")
        }</span>

        <span class="cov0" title="0">response, err := handler(ctx, request)

        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span> else<span class="cov0" title="0"> if validResponse, ok := response.(DeleteLabelResponseObject); ok </span><span class="cov0" title="0">{
                return validResponse.VisitDeleteLabelResponse(ctx.Response())
        }</span> else<span class="cov0" title="0"> if response != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("unexpected response type: %T", response)
        }</span>
        <span class="cov0" title="0">return nil</span>
}

// GetOneLabel operation middleware
func (sh *strictHandler) GetOneLabel(ctx echo.Context, id openapi_types.UUID) error <span class="cov0" title="0">{
        var request GetOneLabelRequestObject

        request.Id = id

        handler := func(ctx echo.Context, request interface{}) (interface{}, error) </span><span class="cov0" title="0">{
                return sh.ssi.GetOneLabel(ctx.Request().Context(), request.(GetOneLabelRequestObject))
        }</span>
        <span class="cov0" title="0">for _, middleware := range sh.middlewares </span><span class="cov0" title="0">{
                handler = middleware(handler, "GetOneLabel")
        }</span>

        <span class="cov0" title="0">response, err := handler(ctx, request)

        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span> else<span class="cov0" title="0"> if validResponse, ok := response.(GetOneLabelResponseObject); ok </span><span class="cov0" title="0">{
                return validResponse.VisitGetOneLabelResponse(ctx.Response())
        }</span> else<span class="cov0" title="0"> if response != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("unexpected response type: %T", response)
        }</span>
        <span class="cov0" title="0">return nil</span>
}

// UpdateLabel operation middleware
func (sh *strictHandler) UpdateLabel(ctx echo.Context, id openapi_types.UUID) error <span class="cov0" title="0">{
        var request UpdateLabelRequestObject

        request.Id = id

        var body UpdateLabelJSONRequestBody
        if err := ctx.Bind(&amp;body); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov0" title="0">request.Body = &amp;body

        handler := func(ctx echo.Context, request interface{}) (interface{}, error) </span><span class="cov0" title="0">{
                return sh.ssi.UpdateLabel(ctx.Request().Context(), request.(UpdateLabelRequestObject))
        }</span>
        <span class="cov0" title="0">for _, middleware := range sh.middlewares </span><span class="cov0" title="0">{
                handler = middleware(handler, "UpdateLabel")
        }</span>

        <span class="cov0" title="0">response, err := handler(ctx, request)

        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span> else<span class="cov0" title="0"> if validResponse, ok := response.(UpdateLabelResponseObject); ok </span><span class="cov0" title="0">{
                return validResponse.VisitUpdateLabelResponse(ctx.Response())
        }</span> else<span class="cov0" title="0"> if response != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("unexpected response type: %T", response)
        }</span>
        <span class="cov0" title="0">return nil</span>
}
</pre>
		
		<pre class="file" id="file91" style="display: none">// Code generated by codegen repository. DO NOT EDIT.
package labels

import (
        "context"
        "errors"

        "github.com/archesai/archesai/internal/database/postgresql"
        "github.com/google/uuid"
        "github.com/jackc/pgx/v5/pgxpool"
)

// PostgresRepository implements Repository using PostgreSQL.
type PostgresRepository struct {
        db      *pgxpool.Pool
        queries *postgresql.Queries
}

// NewPostgresRepository creates a new PostgreSQL repository.
func NewPostgresRepository(db *pgxpool.Pool) Repository <span class="cov0" title="0">{
        return &amp;PostgresRepository{
                db:      db,
                queries: postgresql.New(db),
        }
}</span>

// Label operations

func (r *PostgresRepository) Create(ctx context.Context, entity *Label) (*Label, error) <span class="cov0" title="0">{
        // Check if SQLC has the CreateLabel method
        // For now, we'll generate a stub but with proper error handling
        // TODO: Parse SQLC to detect available queries

        // Example of what it should look like when SQLC query exists:
        // params := postgresql.CreateLabelParams{
        //     Id: entity.Id,
        //     // ... map other fields
        // }
        // dbLabel, err := r.queries.CreateLabel(ctx, params)
        // if err != nil {
        //     return nil, NewRepositoryError("create", err)
        // }
        // return mapLabelToDomain(&amp;dbLabel), nil

        return nil, NewRepositoryError("create", errors.New("not implemented - SQLC query not found"))
}</span>

func (r *PostgresRepository) Get(ctx context.Context, id uuid.UUID) (*Label, error) <span class="cov0" title="0">{
        // Try to call SQLC GetLabel if it exists
        // For now, return not implemented
        return nil, NewRepositoryError("get", errors.New("not implemented - SQLC query not found"))
}</span>

func (r *PostgresRepository) Update(ctx context.Context, id uuid.UUID, entity *Label) (*Label, error) <span class="cov0" title="0">{
        // Update operations are often custom and may not have SQLC queries
        return nil, NewRepositoryError("update", errors.New("not implemented - SQLC query not found"))
}</span>

func (r *PostgresRepository) Delete(ctx context.Context, id uuid.UUID) error <span class="cov0" title="0">{
        // Try to call SQLC DeleteLabel if it exists
        // For now, return not implemented
        return NewRepositoryError("delete", errors.New("not implemented - SQLC query not found"))
}</span>

func (r *PostgresRepository) List(ctx context.Context, params ListLabelsParams) ([]*Label, int64, error) <span class="cov0" title="0">{
        // List operations need both List and Count queries from SQLC
        return nil, 0, NewRepositoryError("list", errors.New("not implemented - SQLC query not found"))
}</span>

// ListByOrganization retrieves multiple labels by organizationId
func (r *PostgresRepository) ListByOrganization(ctx context.Context, organizationId string) ([]*Label, error) <span class="cov0" title="0">{

        // Try to call SQLC ListByOrganization if it exists
        // For now, return not implemented
        return nil, NewRepositoryError("listbyorganization", errors.New("not implemented - SQLC query not found"))

}</span>

// GetByName retrieves label by nameorganizationId
func (r *PostgresRepository) GetByName(ctx context.Context, name string, organizationId string) (*Label, error) <span class="cov0" title="0">{

        // Try to call SQLC GetByName if it exists
        // For now, return not implemented
        return nil, NewRepositoryError("getbyname", errors.New("not implemented - SQLC query not found"))

}</span>

// Mapper functions - Convert between domain types and database types
// These need to be customized based on the actual field mappings

func mapLabelToDomain(db *postgresql.Label) *Label <span class="cov0" title="0">{
        if db == nil </span><span class="cov0" title="0">{
                return nil
        }</span>

        // This is a basic mapping - needs to be customized based on actual types
        // The challenge is that OpenAPI types and database types don't always match
        // For example:
        // - OpenAPI might use string, database uses *string
        // - OpenAPI might use custom UUID type, database uses uuid.UUID
        // - Field names might differ (Id vs ID)

        <span class="cov0" title="0">result := &amp;Label{
                // TODO: Map fields properly based on actual type definitions
                // This requires parsing both OpenAPI types and SQLC types
        }

        // Basic field mapping - customize based on your entity structure
        // result.Id = db.Id
        // result.CreatedAt = db.CreatedAt
        // result.UpdatedAt = db.UpdatedAt
        // Add specific field mappings as needed

        return result</span>
}
</pre>
		
		<pre class="file" id="file92" style="display: none">// Code generated by codegen repository. DO NOT EDIT.
package labels

import (
        "context"
        "fmt"
        "github.com/google/uuid"
)

// Repository handles label persistence
type Repository interface {
        Create(ctx context.Context, entity *Label) (*Label, error)
        Get(ctx context.Context, id uuid.UUID) (*Label, error)
        Update(ctx context.Context, id uuid.UUID, entity *Label) (*Label, error)
        Delete(ctx context.Context, id uuid.UUID) error
        List(ctx context.Context, params ListLabelsParams) ([]*Label, int64, error)

        // Additional operations
        ListByOrganization(ctx context.Context, organizationId string) ([]*Label, error)
        GetByName(ctx context.Context, name string, organizationId string) (*Label, error)
}

// ListLabelsParams represents parameters for listing labels.
type ListLabelsParams struct {
        Limit  int
        Offset int
}

// RepositoryError represents a repository error.
type RepositoryError struct {
        Operation string
        Err       error
}

func (e *RepositoryError) Error() string <span class="cov0" title="0">{
        return fmt.Sprintf("repository %s: %v", e.Operation, e.Err)
}</span>

func (e *RepositoryError) Unwrap() error <span class="cov0" title="0">{
        return e.Err
}</span>

// NewRepositoryError creates a new repository error.
func NewRepositoryError(operation string, err error) *RepositoryError <span class="cov0" title="0">{
        return &amp;RepositoryError{
                Operation: operation,
                Err:       err,
        }
}</span>
</pre>
		
		<pre class="file" id="file93" style="display: none">package labels

import (
        "context"
        "database/sql"
        "errors"
        "fmt"
        "log/slog"
        "strings"
        "time"

        "github.com/google/uuid"
)

// Service provides label management business logic
type Service struct {
        repo   Repository
        logger *slog.Logger
}

// NewService creates a new labels service
func NewService(repo Repository, logger *slog.Logger) *Service <span class="cov10" title="10">{
        return &amp;Service{
                repo:   repo,
                logger: logger,
        }
}</span>

// Create creates a new label for an organization
func (s *Service) Create(ctx context.Context, req *CreateLabelJSONRequestBody, orgID string) (*Label, error) <span class="cov5" title="3">{
        s.logger.Debug("creating label",
                slog.String("name", req.Name),
                slog.String("org", orgID))

        // Validate inputs
        if err := s.validateCreateRequest(req); err != nil </span><span class="cov1" title="1">{
                return nil, fmt.Errorf("validation failed: %w", err)
        }</span>

        <span class="cov3" title="2">if orgID == "" </span><span class="cov1" title="1">{
                return nil, errors.New("organization ID is required")
        }</span>

        // Check if label with same name already exists
        // TODO: Implement GetLabelByName when repository supports it
        // existing, err := s.repo.GetLabelByName(ctx, req.Name, orgID)
        // if err == nil &amp;&amp; existing != nil {
        //         return nil, ErrLabelExists
        // }

        <span class="cov1" title="1">label := &amp;Label{
                Id:             uuid.New(),
                Name:           s.sanitizeName(req.Name),
                OrganizationId: orgID,
                CreatedAt:      time.Now().UTC(),
                UpdatedAt:      time.Now().UTC(),
        }

        // TODO: Add color and description when fields are added to schema

        createdLabel, err := s.repo.Create(ctx, label)
        if err != nil </span><span class="cov0" title="0">{
                s.logger.Error("failed to create label",
                        slog.String("error", err.Error()),
                        slog.String("name", req.Name))
                return nil, fmt.Errorf("failed to create label: %w", err)
        }</span>

        <span class="cov1" title="1">s.logger.Info("label created successfully",
                slog.String("id", createdLabel.Id.String()),
                slog.String("name", createdLabel.Name),
                slog.String("org", orgID))

        return createdLabel, nil</span>
}

// Get retrieves a label by ID
func (s *Service) Get(ctx context.Context, id uuid.UUID) (*Label, error) <span class="cov8" title="6">{
        if id == uuid.Nil </span><span class="cov0" title="0">{
                return nil, errors.New("invalid label ID")
        }</span>

        <span class="cov8" title="6">label, err := s.repo.Get(ctx, id)
        if err != nil </span><span class="cov5" title="3">{
                if errors.Is(err, sql.ErrNoRows) </span><span class="cov0" title="0">{
                        return nil, ErrLabelNotFound
                }</span>
                <span class="cov5" title="3">s.logger.Error("failed to get label",
                        slog.String("id", id.String()),
                        slog.String("error", err.Error()))
                return nil, fmt.Errorf("failed to get label: %w", err)</span>
        }

        <span class="cov5" title="3">return label, nil</span>
}

// Update updates a label
func (s *Service) Update(ctx context.Context, id uuid.UUID, req *UpdateLabelJSONRequestBody) (*Label, error) <span class="cov3" title="2">{
        if id == uuid.Nil </span><span class="cov0" title="0">{
                return nil, errors.New("invalid label ID")
        }</span>

        // Get existing label
        <span class="cov3" title="2">label, err := s.Get(ctx, id)
        if err != nil </span><span class="cov1" title="1">{
                return nil, err
        }</span>

        // Track if any changes were made
        <span class="cov1" title="1">hasChanges := false

        // Update name if provided
        if req.Name != "" &amp;&amp; req.Name != label.Name </span><span class="cov1" title="1">{
                // TODO: Check for duplicate names
                label.Name = s.sanitizeName(req.Name)
                hasChanges = true
        }</span>

        // TODO: Update color and description when fields are added to schema

        // Only update if changes were made
        <span class="cov1" title="1">if !hasChanges </span><span class="cov0" title="0">{
                return label, nil
        }</span>

        <span class="cov1" title="1">label.UpdatedAt = time.Now().UTC()

        updatedLabel, err := s.repo.Update(ctx, id, label)
        if err != nil </span><span class="cov0" title="0">{
                s.logger.Error("failed to update label",
                        slog.String("id", id.String()),
                        slog.String("error", err.Error()))
                return nil, fmt.Errorf("failed to update label: %w", err)
        }</span>

        <span class="cov1" title="1">s.logger.Info("label updated successfully",
                slog.String("id", id.String()))

        return updatedLabel, nil</span>
}

// Delete deletes a label
func (s *Service) Delete(ctx context.Context, id uuid.UUID) error <span class="cov3" title="2">{
        if id == uuid.Nil </span><span class="cov0" title="0">{
                return errors.New("invalid label ID")
        }</span>

        // Check if label exists
        <span class="cov3" title="2">_, err := s.Get(ctx, id)
        if err != nil </span><span class="cov1" title="1">{
                return err
        }</span>

        // TODO: Check if label is in use by any artifacts
        // This would require querying artifact_labels junction table

        <span class="cov1" title="1">err = s.repo.Delete(ctx, id)
        if err != nil </span><span class="cov0" title="0">{
                s.logger.Error("failed to delete label",
                        slog.String("id", id.String()),
                        slog.String("error", err.Error()))
                return fmt.Errorf("failed to delete label: %w", err)
        }</span>

        <span class="cov1" title="1">s.logger.Info("label deleted successfully",
                slog.String("id", id.String()))

        return nil</span>
}

// List retrieves labels for an organization with pagination
func (s *Service) List(ctx context.Context, orgID string, limit, offset int) ([]*Label, int, error) <span class="cov1" title="1">{
        // Validate pagination parameters
        if limit &lt;= 0 </span><span class="cov0" title="0">{
                limit = 50 // Default limit
        }</span>
        <span class="cov1" title="1">if limit &gt; 500 </span><span class="cov0" title="0">{
                limit = 500 // Max limit for labels
        }</span>
        <span class="cov1" title="1">if offset &lt; 0 </span><span class="cov0" title="0">{
                offset = 0
        }</span>

        <span class="cov1" title="1">params := ListLabelsParams{
                Limit:  limit,
                Offset: offset,
                // TODO: Add organization filtering when repository supports it
        }

        labels, total, err := s.repo.List(ctx, params)
        if err != nil </span><span class="cov0" title="0">{
                s.logger.Error("failed to list labels",
                        slog.String("org", orgID),
                        slog.String("error", err.Error()))
                return nil, 0, fmt.Errorf("failed to list labels: %w", err)
        }</span>

        // Filter by organization if not handled by repository
        // This is temporary until repository layer supports filtering
        <span class="cov1" title="1">filtered := make([]*Label, 0, len(labels))
        for _, label := range labels </span><span class="cov3" title="2">{
                if label.OrganizationId == orgID </span><span class="cov3" title="2">{
                        filtered = append(filtered, label)
                }</span>
        }

        <span class="cov1" title="1">return filtered, int(total), nil</span>
}

// GetLabelByName retrieves a label by name within an organization
func (s *Service) GetLabelByName(ctx context.Context, name, orgID string) (*Label, error) <span class="cov0" title="0">{
        if name == "" </span><span class="cov0" title="0">{
                return nil, errors.New("label name is required")
        }</span>
        <span class="cov0" title="0">if orgID == "" </span><span class="cov0" title="0">{
                return nil, errors.New("organization ID is required")
        }</span>

        // TODO: Implement when repository supports GetLabelByName
        // For now, list all and filter
        <span class="cov0" title="0">labels, _, err := s.List(ctx, orgID, 1000, 0)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov0" title="0">normalizedName := strings.ToLower(strings.TrimSpace(name))
        for _, label := range labels </span><span class="cov0" title="0">{
                if strings.ToLower(label.Name) == normalizedName </span><span class="cov0" title="0">{
                        return label, nil
                }</span>
        }

        <span class="cov0" title="0">return nil, ErrLabelNotFound</span>
}

// GetLabelsByArtifact retrieves all labels for a specific artifact
func (s *Service) GetLabelsByArtifact(_ context.Context, artifactID uuid.UUID) ([]*Label, error) <span class="cov0" title="0">{
        if artifactID == uuid.Nil </span><span class="cov0" title="0">{
                return nil, errors.New("invalid artifact ID")
        }</span>

        // TODO: Implement when many-to-many relationship is added to database
        // This would query the artifact_labels junction table

        <span class="cov0" title="0">return []*Label{}, nil</span>
}

// GetLabelStats returns statistics for labels in an organization
func (s *Service) GetLabelStats(ctx context.Context, orgID string) (map[string]interface{}, error) <span class="cov0" title="0">{
        // Get total count
        _, total, err := s.List(ctx, orgID, 1, 0)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov0" title="0">stats := map[string]interface{}{
                "total_labels":     total,
                "organization_id":  orgID,
                "max_labels":       MaxLabelsPerOrganization,
                "labels_used":      total,
                "labels_remaining": MaxLabelsPerOrganization - total,
                "timestamp":        time.Now().UTC(),
        }

        return stats, nil</span>
}

// Helper methods

// validateCreateRequest validates the create label request
func (s *Service) validateCreateRequest(req *CreateLabelJSONRequestBody) error <span class="cov5" title="3">{
        if req == nil </span><span class="cov0" title="0">{
                return errors.New("request is required")
        }</span>

        <span class="cov5" title="3">if req.Name == "" </span><span class="cov1" title="1">{
                return errors.New("label name is required")
        }</span>

        <span class="cov3" title="2">if len(req.Name) &gt; 100 </span><span class="cov0" title="0">{
                return errors.New("label name must be 100 characters or less")
        }</span>

        // TODO: Validate description when field is added to schema

        <span class="cov3" title="2">return nil</span>
}

// sanitizeName cleans and validates the label name
func (s *Service) sanitizeName(name string) string <span class="cov3" title="2">{
        // Trim whitespace
        name = strings.TrimSpace(name)

        // Limit length
        if len(name) &gt; 100 </span><span class="cov0" title="0">{
                name = name[:100]
        }</span>

        <span class="cov3" title="2">return name</span>
}

// isValidColor validates a hex color string
// nolint:unused // kept for future use when color field is added
func (s *Service) isValidColor(color string) bool <span class="cov0" title="0">{
        // Accept colors with or without #
        color = strings.TrimPrefix(color, "#")

        // Check if it's a valid 6-character hex color
        if len(color) != 6 </span><span class="cov0" title="0">{
                return false
        }</span>

        // Check if all characters are valid hex
        <span class="cov0" title="0">for _, c := range color </span><span class="cov0" title="0">{
                if (c &lt; '0' || c &gt; '9') &amp;&amp; (c &lt; 'a' || c &gt; 'f') &amp;&amp; (c &lt; 'A' || c &gt; 'F') </span><span class="cov0" title="0">{
                        return false
                }</span>
        }

        <span class="cov0" title="0">return true</span>
}

// BulkCreateLabels creates multiple labels in a single operation
func (s *Service) BulkCreateLabels(ctx context.Context, labels []*CreateLabelJSONRequestBody, orgID string) ([]*Label, error) <span class="cov0" title="0">{
        if len(labels) == 0 </span><span class="cov0" title="0">{
                return nil, errors.New("no labels to create")
        }</span>

        <span class="cov0" title="0">if len(labels) &gt; 50 </span><span class="cov0" title="0">{
                return nil, errors.New("bulk create limited to 50 labels")
        }</span>

        <span class="cov0" title="0">created := make([]*Label, 0, len(labels))
        for _, req := range labels </span><span class="cov0" title="0">{
                label, err := s.Create(ctx, req, orgID)
                if err != nil </span><span class="cov0" title="0">{
                        // Log error but continue with other labels
                        s.logger.Error("failed to create label in bulk operation",
                                slog.String("name", req.Name),
                                slog.String("error", err.Error()))
                        continue</span>
                }
                <span class="cov0" title="0">created = append(created, label)</span>
        }

        <span class="cov0" title="0">if len(created) == 0 </span><span class="cov0" title="0">{
                return nil, errors.New("all labels failed to create")
        }</span>

        <span class="cov0" title="0">return created, nil</span>
}

// MergeLabels merges one label into another
func (s *Service) MergeLabels(ctx context.Context, sourceID, targetID uuid.UUID) error <span class="cov0" title="0">{
        if sourceID == uuid.Nil || targetID == uuid.Nil </span><span class="cov0" title="0">{
                return errors.New("invalid label IDs")
        }</span>

        <span class="cov0" title="0">if sourceID == targetID </span><span class="cov0" title="0">{
                return errors.New("cannot merge label with itself")
        }</span>

        // Verify both labels exist
        <span class="cov0" title="0">source, err := s.Get(ctx, sourceID)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("source label not found: %w", err)
        }</span>

        <span class="cov0" title="0">target, err := s.Get(ctx, targetID)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("target label not found: %w", err)
        }</span>

        // Verify they're in the same organization
        <span class="cov0" title="0">if source.OrganizationId != target.OrganizationId </span><span class="cov0" title="0">{
                return errors.New("labels must be in the same organization")
        }</span>

        // TODO: Update all artifacts with source label to use target label
        // This would require updating artifact_labels junction table

        // Delete the source label
        <span class="cov0" title="0">if err := s.Delete(ctx, sourceID); err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to delete source label: %w", err)
        }</span>

        <span class="cov0" title="0">s.logger.Info("labels merged successfully",
                slog.String("source_id", sourceID.String()),
                slog.String("target_id", targetID.String()))

        return nil</span>
}
</pre>
		
		<pre class="file" id="file94" style="display: none">// Code generated by codegen repository. DO NOT EDIT.
package labels

import (
        "context"
        "database/sql"
        "fmt"

        "github.com/archesai/archesai/internal/database/sqlite"
        "github.com/google/uuid"
)

// SQLiteRepository implements Repository using SQLite.
type SQLiteRepository struct {
        db      *sql.DB
        queries *sqlite.Queries
}

// NewSQLiteRepository creates a new SQLite repository.
func NewSQLiteRepository(db *sql.DB) Repository <span class="cov0" title="0">{
        return &amp;SQLiteRepository{
                db:      db,
                queries: sqlite.New(db),
        }
}</span>

// Label operations

func (r *SQLiteRepository) Create(ctx context.Context, entity *Label) (*Label, error) <span class="cov0" title="0">{
        // For now, return a basic implementation
        // Actual implementation would need to be customized per entity
        return nil, fmt.Errorf("CreateLabel not yet implemented - requires custom mapping")
}</span>

func (r *SQLiteRepository) Get(ctx context.Context, id uuid.UUID) (*Label, error) <span class="cov0" title="0">{
        // For now, return a basic implementation
        // Actual implementation would need to be customized per entity
        return nil, fmt.Errorf("GetLabel not yet implemented - requires custom mapping")
}</span>

func (r *SQLiteRepository) Update(ctx context.Context, id uuid.UUID, entity *Label) (*Label, error) <span class="cov0" title="0">{
        // For now, return a basic implementation
        // Actual implementation would need to be customized per entity
        return nil, fmt.Errorf("UpdateLabel not yet implemented - requires custom mapping")
}</span>

func (r *SQLiteRepository) Delete(ctx context.Context, id uuid.UUID) error <span class="cov0" title="0">{
        // For now, return a basic implementation
        // Actual implementation would need to be customized per entity
        return fmt.Errorf("DeleteLabel not yet implemented - requires custom mapping")
}</span>

func (r *SQLiteRepository) List(ctx context.Context, params ListLabelsParams) ([]*Label, int64, error) <span class="cov0" title="0">{
        // For now, return a basic implementation
        // Actual implementation would need to be customized per entity
        return nil, 0, fmt.Errorf("ListLabels not yet implemented - requires custom mapping")
}</span>

// ListByOrganization retrieves multiple labels by organizationId
func (r *SQLiteRepository) ListByOrganization(ctx context.Context, organizationId string) ([]*Label, error) <span class="cov0" title="0">{

        // For now, return a basic implementation
        return nil, fmt.Errorf("ListByOrganization not yet implemented - requires custom mapping")

}</span>

// GetByName retrieves label by nameorganizationId
func (r *SQLiteRepository) GetByName(ctx context.Context, name string, organizationId string) (*Label, error) <span class="cov0" title="0">{

        // For now, return a basic implementation
        return nil, fmt.Errorf("GetByName not yet implemented - requires custom mapping")

}</span>
</pre>
		
		<pre class="file" id="file95" style="display: none">// Package labels provides primitives to interact with the openapi HTTP API.
//
// Code generated by github.com/oapi-codegen/oapi-codegen/v2 version v2.5.0 DO NOT EDIT.
package labels

import (
        "encoding/json"
        "time"

        "github.com/oapi-codegen/runtime"
        openapi_types "github.com/oapi-codegen/runtime/types"
)

const (
        BearerAuthScopes = "bearerAuth.Scopes"
)

// Defines values for FindManyLabelsParamsSortField.
const (
        CreatedAt      FindManyLabelsParamsSortField = "createdAt"
        Id             FindManyLabelsParamsSortField = "id"
        Name           FindManyLabelsParamsSortField = "name"
        OrganizationId FindManyLabelsParamsSortField = "organizationId"
        UpdatedAt      FindManyLabelsParamsSortField = "updatedAt"
)

// Defines values for FindManyLabelsParamsSortOrder.
const (
        Asc  FindManyLabelsParamsSortOrder = "asc"
        Desc FindManyLabelsParamsSortOrder = "desc"
)

// FilterNode A recursive filter node that can be a condition or group
type FilterNode = interface{}

// Label Schema for Label entity
type Label struct {
        // CreatedAt The date this item was created
        CreatedAt time.Time `json:"createdAt" yaml:"createdAt"`

        // Id The ID of the item
        Id openapi_types.UUID `json:"id" yaml:"id"`

        // Name The name of the label
        Name string `json:"name" yaml:"name"`

        // OrganizationId The organization name
        OrganizationId string `json:"organizationId" yaml:"organizationId"`

        // UpdatedAt The date this item was last updated
        UpdatedAt time.Time `json:"updatedAt" yaml:"updatedAt"`
}

// Page Pagination (page number &amp; size)
type Page struct {
        Number int `json:"number,omitempty,omitzero" yaml:"number,omitempty"`
        Size   int `json:"size,omitempty,omitzero" yaml:"size,omitempty"`
}

// Problem RFC 7807 (Problem Details) compliant error response
type Problem struct {
        // Detail Human-readable explanation specific to this occurrence
        Detail string `json:"detail" yaml:"detail"`

        // Errors Additional validation errors for specific fields
        Errors []ValidationError `json:"errors,omitempty,omitzero" yaml:"errors,omitempty"`

        // Instance URI identifying the specific occurrence
        Instance string `json:"instance,omitempty,omitzero" yaml:"instance,omitempty"`

        // Status HTTP status code
        Status int `json:"status" yaml:"status"`

        // Title Short, human-readable summary
        Title string `json:"title" yaml:"title"`

        // Type URI identifying the problem type
        Type string `json:"type" yaml:"type"`
}

// ValidationError Individual field validation error
type ValidationError struct {
        // Field The field path that failed validation
        Field string `json:"field" yaml:"field"`

        // Message Human-readable error message
        Message string `json:"message" yaml:"message"`

        // Value The invalid value that was provided
        Value ValidationError_Value `json:"value,omitempty,omitzero" yaml:"value,omitempty"`
}

// ValidationErrorValue0 defines model for .
type ValidationErrorValue0 = string

// ValidationErrorValue1 defines model for .
type ValidationErrorValue1 = float32

// ValidationErrorValue2 defines model for .
type ValidationErrorValue2 = bool

// ValidationError_Value The invalid value that was provided
type ValidationError_Value struct {
        union json.RawMessage
}

// LabelsFilter A recursive filter node that can be a condition or group
type LabelsFilter = FilterNode

// LabelsSort defines model for LabelsSort.
type LabelsSort = []struct {
        Field string `json:"field" yaml:"field"`
        Order string `json:"order" yaml:"order"`
}

// PageQuery Pagination (page number &amp; size)
type PageQuery = Page

// BadRequest RFC 7807 (Problem Details) compliant error response
type BadRequest = Problem

// NotFound RFC 7807 (Problem Details) compliant error response
type NotFound = Problem

// Unauthorized RFC 7807 (Problem Details) compliant error response
type Unauthorized = Problem

// FindManyLabelsParams defines parameters for FindManyLabels.
type FindManyLabelsParams struct {
        // Filter Filter labels by field values. Supported fields:
        // - createdAt, id, updatedAt, name, organizationId
        Filter LabelsFilter `json:"filter,omitempty,omitzero" yaml:"filter,omitempty"`

        // Page The page parameter
        Page PageQuery `form:"page,omitempty" json:"page,omitempty,omitzero" yaml:"page,omitempty"`

        // Sort The sort parameter
        Sort LabelsSort `form:"sort,omitempty" json:"sort,omitempty,omitzero" yaml:"sort,omitempty"`
}

// FindManyLabelsParamsSortField defines parameters for FindManyLabels.
type FindManyLabelsParamsSortField string

// FindManyLabelsParamsSortOrder defines parameters for FindManyLabels.
type FindManyLabelsParamsSortOrder string

// CreateLabelJSONBody defines parameters for CreateLabel.
type CreateLabelJSONBody struct {
        // Name The name of the label
        Name string `json:"name" yaml:"name"`
}

// UpdateLabelJSONBody defines parameters for UpdateLabel.
type UpdateLabelJSONBody struct {
        // Name The name of the label
        Name string `json:"name,omitempty,omitzero" yaml:"name,omitempty"`
}

// CreateLabelJSONRequestBody defines body for CreateLabel for application/json ContentType.
type CreateLabelJSONRequestBody CreateLabelJSONBody

// UpdateLabelJSONRequestBody defines body for UpdateLabel for application/json ContentType.
type UpdateLabelJSONRequestBody UpdateLabelJSONBody

// AsValidationErrorValue0 returns the union data inside the ValidationError_Value as a ValidationErrorValue0
func (t ValidationError_Value) AsValidationErrorValue0() (ValidationErrorValue0, error) <span class="cov0" title="0">{
        var body ValidationErrorValue0
        err := json.Unmarshal(t.union, &amp;body)
        return body, err
}</span>

// FromValidationErrorValue0 overwrites any union data inside the ValidationError_Value as the provided ValidationErrorValue0
func (t *ValidationError_Value) FromValidationErrorValue0(v ValidationErrorValue0) error <span class="cov0" title="0">{
        b, err := json.Marshal(v)
        t.union = b
        return err
}</span>

// MergeValidationErrorValue0 performs a merge with any union data inside the ValidationError_Value, using the provided ValidationErrorValue0
func (t *ValidationError_Value) MergeValidationErrorValue0(v ValidationErrorValue0) error <span class="cov0" title="0">{
        b, err := json.Marshal(v)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov0" title="0">merged, err := runtime.JSONMerge(t.union, b)
        t.union = merged
        return err</span>
}

// AsValidationErrorValue1 returns the union data inside the ValidationError_Value as a ValidationErrorValue1
func (t ValidationError_Value) AsValidationErrorValue1() (ValidationErrorValue1, error) <span class="cov0" title="0">{
        var body ValidationErrorValue1
        err := json.Unmarshal(t.union, &amp;body)
        return body, err
}</span>

// FromValidationErrorValue1 overwrites any union data inside the ValidationError_Value as the provided ValidationErrorValue1
func (t *ValidationError_Value) FromValidationErrorValue1(v ValidationErrorValue1) error <span class="cov0" title="0">{
        b, err := json.Marshal(v)
        t.union = b
        return err
}</span>

// MergeValidationErrorValue1 performs a merge with any union data inside the ValidationError_Value, using the provided ValidationErrorValue1
func (t *ValidationError_Value) MergeValidationErrorValue1(v ValidationErrorValue1) error <span class="cov0" title="0">{
        b, err := json.Marshal(v)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov0" title="0">merged, err := runtime.JSONMerge(t.union, b)
        t.union = merged
        return err</span>
}

// AsValidationErrorValue2 returns the union data inside the ValidationError_Value as a ValidationErrorValue2
func (t ValidationError_Value) AsValidationErrorValue2() (ValidationErrorValue2, error) <span class="cov0" title="0">{
        var body ValidationErrorValue2
        err := json.Unmarshal(t.union, &amp;body)
        return body, err
}</span>

// FromValidationErrorValue2 overwrites any union data inside the ValidationError_Value as the provided ValidationErrorValue2
func (t *ValidationError_Value) FromValidationErrorValue2(v ValidationErrorValue2) error <span class="cov0" title="0">{
        b, err := json.Marshal(v)
        t.union = b
        return err
}</span>

// MergeValidationErrorValue2 performs a merge with any union data inside the ValidationError_Value, using the provided ValidationErrorValue2
func (t *ValidationError_Value) MergeValidationErrorValue2(v ValidationErrorValue2) error <span class="cov0" title="0">{
        b, err := json.Marshal(v)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov0" title="0">merged, err := runtime.JSONMerge(t.union, b)
        t.union = merged
        return err</span>
}

func (t ValidationError_Value) MarshalJSON() ([]byte, error) <span class="cov0" title="0">{
        b, err := t.union.MarshalJSON()
        return b, err
}</span>

func (t *ValidationError_Value) UnmarshalJSON(b []byte) error <span class="cov0" title="0">{
        err := t.union.UnmarshalJSON(b)
        return err
}</span>
</pre>
		
		<pre class="file" id="file96" style="display: none">// Package llm provides interfaces and implementations for interacting with language models.
package llm

import (
        "context"
        "fmt"
)

// ChatPersona represents a chat agent/assistant persona
type ChatPersona struct {
        Name         string
        SystemPrompt string
        Model        string
        Temperature  float32
}

// ChatSession manages a conversation with an LLM
type ChatSession struct {
        Messages []Message
        Persona  *ChatPersona
        Context  map[string]interface{}
}

// ChatClient provides a high-level interface for chat conversations
type ChatClient interface {
        // NewSession creates a new chat session
        NewSession(persona *ChatPersona) *ChatSession

        // SendMessage sends a message and returns the response
        SendMessage(ctx context.Context, session *ChatSession, content string) (*Message, error)

        // SendMessageStream sends a message and returns a streaming response
        SendMessageStream(ctx context.Context, session *ChatSession, content string) (ChatCompletionStream, error)
}

// DefaultChatClient implements ChatClient using an LLM provider
type DefaultChatClient struct {
        llm LLM
}

// NewChatClient creates a new chat client
func NewChatClient(llm LLM) ChatClient <span class="cov0" title="0">{
        return &amp;DefaultChatClient{llm: llm}
}</span>

// NewSession creates a new chat session
func (c *DefaultChatClient) NewSession(persona *ChatPersona) *ChatSession <span class="cov0" title="0">{
        session := &amp;ChatSession{
                Messages: []Message{},
                Persona:  persona,
                Context:  make(map[string]interface{}),
        }

        // Add system message if persona has a system prompt
        if persona != nil &amp;&amp; persona.SystemPrompt != "" </span><span class="cov0" title="0">{
                session.Messages = append(session.Messages, Message{
                        Role:    RoleSystem,
                        Content: persona.SystemPrompt,
                })
        }</span>

        <span class="cov0" title="0">return session</span>
}

// SendMessage sends a message and returns the response
func (c *DefaultChatClient) SendMessage(ctx context.Context, session *ChatSession, content string) (*Message, error) <span class="cov0" title="0">{
        // Add user message to session
        userMsg := Message{
                Role:    RoleUser,
                Content: content,
        }
        session.Messages = append(session.Messages, userMsg)

        // Prepare request
        req := ChatCompletionRequest{
                Model:    session.Persona.Model,
                Messages: session.Messages,
        }

        if session.Persona.Temperature &gt; 0 </span><span class="cov0" title="0">{
                req.Temperature = session.Persona.Temperature
        }</span>

        // Get response from LLM
        <span class="cov0" title="0">resp, err := c.llm.CreateChatCompletion(ctx, req)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("chat completion error: %w", err)
        }</span>

        <span class="cov0" title="0">if len(resp.Choices) == 0 </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("no response choices received")
        }</span>

        // Extract assistant message
        <span class="cov0" title="0">assistantMsg := resp.Choices[0].Message

        // Add response to session history
        session.Messages = append(session.Messages, assistantMsg)

        return &amp;assistantMsg, nil</span>
}

// SendMessageStream sends a message and returns a streaming response
func (c *DefaultChatClient) SendMessageStream(ctx context.Context, session *ChatSession, content string) (ChatCompletionStream, error) <span class="cov0" title="0">{
        // Add user message to session
        userMsg := Message{
                Role:    RoleUser,
                Content: content,
        }
        session.Messages = append(session.Messages, userMsg)

        // Prepare request
        req := ChatCompletionRequest{
                Model:    session.Persona.Model,
                Messages: session.Messages,
                Stream:   true,
        }

        if session.Persona.Temperature &gt; 0 </span><span class="cov0" title="0">{
                req.Temperature = session.Persona.Temperature
        }</span>

        // Get streaming response from LLM
        <span class="cov0" title="0">stream, err := c.llm.CreateChatCompletionStream(ctx, req)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("chat completion stream error: %w", err)
        }</span>

        <span class="cov0" title="0">return stream, nil</span>
}

// AddAssistantMessage adds an assistant message to the session (useful after streaming)
func (session *ChatSession) AddAssistantMessage(content string) <span class="cov0" title="0">{
        assistantMsg := Message{
                Role:    RoleAssistant,
                Content: content,
        }
        session.Messages = append(session.Messages, assistantMsg)
}</span>

// ClearHistory clears the message history but keeps the system prompt
func (session *ChatSession) ClearHistory() <span class="cov0" title="0">{
        var systemMessages []Message
        for _, msg := range session.Messages </span><span class="cov0" title="0">{
                if msg.Role == RoleSystem </span><span class="cov0" title="0">{
                        systemMessages = append(systemMessages, msg)
                }</span>
        }
        <span class="cov0" title="0">session.Messages = systemMessages</span>
}

// GetLastMessage returns the last message in the session
func (session *ChatSession) GetLastMessage() *Message <span class="cov0" title="0">{
        if len(session.Messages) == 0 </span><span class="cov0" title="0">{
                return nil
        }</span>
        <span class="cov0" title="0">return &amp;session.Messages[len(session.Messages)-1]</span>
}

// DefaultPersonas provides some common chat personas
var DefaultPersonas = struct {
        Assistant      *ChatPersona
        CodeHelper     *ChatPersona
        CreativeWriter *ChatPersona
        DataAnalyst    *ChatPersona
        Researcher     *ChatPersona
}{
        Assistant: &amp;ChatPersona{
                Name:         "Assistant",
                SystemPrompt: "You are a helpful AI assistant. Be concise and informative.",
                Model:        "gpt-4",
                Temperature:  0.7,
        },
        CodeHelper: &amp;ChatPersona{
                Name:         "CodeHelper",
                SystemPrompt: "You are a coding assistant. Help with programming questions, debugging, and best practices.",
                Model:        "gpt-4",
                Temperature:  0.3,
        },
        CreativeWriter: &amp;ChatPersona{
                Name:         "CreativeWriter",
                SystemPrompt: "You are a creative writing assistant. Help with stories, poems, and creative content.",
                Model:        "gpt-4",
                Temperature:  0.8,
        },
        DataAnalyst: &amp;ChatPersona{
                Name:         "DataAnalyst",
                SystemPrompt: "You are a data analysis expert. Help with data interpretation, statistics, and insights.",
                Model:        "gpt-4",
                Temperature:  0.4,
        },
        Researcher: &amp;ChatPersona{
                Name:         "Researcher",
                SystemPrompt: "You are a research assistant. Help find information, summarize topics, and provide citations when possible.",
                Model:        "gpt-4",
                Temperature:  0.5,
        },
}
</pre>
		
		<pre class="file" id="file97" style="display: none">package llm

import (
        "context"
        "encoding/json"
        "fmt"
        "io"
        "net/url"

        "github.com/ollama/ollama/api"
)

// OllamaLLM implements the LLM interface for Ollama
type OllamaLLM struct {
        client *api.Client
}

// NewOllamaLLM creates a new Ollama LLM client
func NewOllamaLLM() (*OllamaLLM, error) <span class="cov0" title="0">{
        client, err := api.ClientFromEnvironment()
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to create Ollama client: %w", err)
        }</span>
        <span class="cov0" title="0">return &amp;OllamaLLM{client: client}, nil</span>
}

// NewOllamaLLMWithURL creates a new Ollama LLM client with a custom URL
func NewOllamaLLMWithURL(baseURL string) (*OllamaLLM, error) <span class="cov0" title="0">{
        parsedURL, err := url.Parse(baseURL)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to parse URL: %w", err)
        }</span>
        <span class="cov0" title="0">client := api.NewClient(parsedURL, nil)
        return &amp;OllamaLLM{client: client}, nil</span>
}

// convertToOllamaRole converts our Role type to Ollama's role string
func convertToOllamaRole(role Role) string <span class="cov0" title="0">{
        if role == RoleFunction </span><span class="cov0" title="0">{
                return "tool"
        }</span>
        <span class="cov0" title="0">return string(role)</span>
}

// convertFromOllamaRole converts Ollama's role string to our Role type
func convertFromOllamaRole(role string) Role <span class="cov0" title="0">{
        if role == "tool" </span><span class="cov0" title="0">{
                return RoleFunction
        }</span>
        <span class="cov0" title="0">return Role(role)</span>
}

// convertToOllamaMessages converts our generic Message type to Ollama's message format
func convertToOllamaMessages(messages []Message) []api.Message <span class="cov0" title="0">{
        ollamaMessages := make([]api.Message, len(messages))
        for i, msg := range messages </span><span class="cov0" title="0">{
                ollamaMessages[i] = api.Message{
                        Role:      convertToOllamaRole(msg.Role),
                        Content:   msg.Content,
                        ToolCalls: convertToOllamaToolCalls(msg.ToolCalls),
                }
        }</span>
        <span class="cov0" title="0">return ollamaMessages</span>
}

// convertToOllamaTools converts our generic Tool type to Ollama's tool type
func convertToOllamaTools(tools []Tool) api.Tools <span class="cov0" title="0">{
        if len(tools) == 0 </span><span class="cov0" title="0">{
                return nil
        }</span>

        <span class="cov0" title="0">ollamaTools := make([]api.Tool, len(tools))
        for i, tool := range tools </span><span class="cov0" title="0">{
                // Convert required array
                required := make([]string, len(tool.Function.Parameters["required"].([]interface{})))
                for i, v := range tool.Function.Parameters["required"].([]interface{}) </span><span class="cov0" title="0">{
                        required[i] = v.(string)
                }</span>

                // Convert properties map
                <span class="cov0" title="0">rawProps := tool.Function.Parameters["properties"].(map[string]interface{})
                properties := make(map[string]struct {
                        Type        string   `json:"type"`
                        Description string   `json:"description"`
                        Enum        []string `json:"enum,omitempty"`
                })

                for propName, propValue := range rawProps </span><span class="cov0" title="0">{
                        propMap := propValue.(map[string]interface{})
                        prop := struct {
                                Type        string   `json:"type"`
                                Description string   `json:"description"`
                                Enum        []string `json:"enum,omitempty"`
                        }{
                                Type:        propMap["type"].(string),
                                Description: propMap["description"].(string),
                        }

                        // Handle optional enum field
                        if enumVal, ok := propMap["enum"]; ok </span><span class="cov0" title="0">{
                                enumInterface := enumVal.([]interface{})
                                enumStrings := make([]string, len(enumInterface))
                                for j, e := range enumInterface </span><span class="cov0" title="0">{
                                        enumStrings[j] = e.(string)
                                }</span>
                                <span class="cov0" title="0">prop.Enum = enumStrings</span>
                        }

                        <span class="cov0" title="0">properties[propName] = prop</span>
                }

                <span class="cov0" title="0">ollamaTools[i] = api.Tool{
                        Type: "function",
                        Function: api.ToolFunction{
                                Name:        tool.Function.Name,
                                Description: tool.Function.Description,
                                Parameters: api.ToolFunctionParameters{
                                        Type:     tool.Function.Parameters["type"].(string),
                                        Required: required,
                                        // Properties: properties, // FIXME
                                },
                        },
                }</span>
        }
        <span class="cov0" title="0">return ollamaTools</span>
}

// convertToOllamaToolCalls converts our generic ToolCall type to Ollama's type
func convertToOllamaToolCalls(toolCalls []ToolCall) []api.ToolCall <span class="cov0" title="0">{
        if len(toolCalls) == 0 </span><span class="cov0" title="0">{
                return nil
        }</span>

        <span class="cov0" title="0">calls := make([]api.ToolCall, len(toolCalls))
        for i, call := range toolCalls </span><span class="cov0" title="0">{
                // Convert map[string]interface{} to api.ToolCallFunctionArguments
                args := make(map[string]any)
                err := json.Unmarshal([]byte(call.Function.Arguments), &amp;args)
                if err != nil </span><span class="cov0" title="0">{
                        // Handle error (e.g., log it or use a default empty map)
                        args = make(map[string]any)
                }</span>

                <span class="cov0" title="0">calls[i] = api.ToolCall{
                        Function: api.ToolCallFunction{
                                Name:      call.Function.Name,
                                Arguments: args,
                        },
                }</span>
        }
        <span class="cov0" title="0">return calls</span>
}

// convertFromOllamaToolCalls converts Ollama's tool calls to our generic type
func convertFromOllamaToolCalls(toolCalls []api.ToolCall) []ToolCall <span class="cov0" title="0">{
        if len(toolCalls) == 0 </span><span class="cov0" title="0">{
                return nil
        }</span>

        <span class="cov0" title="0">calls := make([]ToolCall, len(toolCalls))
        for i, call := range toolCalls </span><span class="cov0" title="0">{
                // Convert api.ToolCallFunctionArguments to map[string]interface{}

                calls[i] = ToolCall{
                        ID:   call.Function.Name, // Using name as ID since Ollama doesn't have a separate ID field
                        Type: "function",
                        Function: ToolCallFunction{
                                Name:      call.Function.Name,
                                Arguments: call.Function.Arguments.String(),
                        },
                }
        }</span>
        <span class="cov0" title="0">return calls</span>
}

// CreateChatCompletion implements the LLM interface for Ollama
func (o *OllamaLLM) CreateChatCompletion(ctx context.Context, req ChatCompletionRequest) (ChatCompletionResponse, error) <span class="cov0" title="0">{
        stream := false
        ollamaReq := &amp;api.ChatRequest{
                Model:    req.Model,
                Messages: convertToOllamaMessages(req.Messages),
                Stream:   &amp;stream,
                Tools:    convertToOllamaTools(req.Tools),
                Options:  make(map[string]interface{}),
        }

        var response ChatCompletionResponse
        var finalMessage Message

        err := o.client.Chat(ctx, ollamaReq, func(resp api.ChatResponse) error </span><span class="cov0" title="0">{
                if resp.Done </span><span class="cov0" title="0">{
                        finalMessage = Message{
                                Role:      convertFromOllamaRole(resp.Message.Role),
                                Content:   resp.Message.Content,
                                ToolCalls: convertFromOllamaToolCalls(resp.Message.ToolCalls),
                        }
                }</span>
                <span class="cov0" title="0">return nil</span>
        })

        <span class="cov0" title="0">if err != nil </span><span class="cov0" title="0">{
                return ChatCompletionResponse{}, fmt.Errorf("ollama chat completion failed: %w", err)
        }</span>

        <span class="cov0" title="0">response.Choices = []Choice{
                {
                        Index:        0,
                        Message:      finalMessage,
                        FinishReason: "stop",
                },
        }

        return response, nil</span>
}

type ollamaStreamWrapper struct {
        ctx            context.Context
        client         *api.Client
        req            *api.ChatRequest
        done           bool
        content        string
        toolCallBuffer map[string]*ToolCall
}

func newOllamaStreamWrapper(ctx context.Context, client *api.Client, req *api.ChatRequest) *ollamaStreamWrapper <span class="cov0" title="0">{
        return &amp;ollamaStreamWrapper{
                ctx:            ctx,
                client:         client,
                req:            req,
                toolCallBuffer: make(map[string]*ToolCall),
        }
}</span>

func (s *ollamaStreamWrapper) Recv() (ChatCompletionResponse, error) <span class="cov0" title="0">{
        if s.done </span><span class="cov0" title="0">{
                return ChatCompletionResponse{}, io.EOF
        }</span>

        <span class="cov0" title="0">var response ChatCompletionResponse
        err := s.client.Chat(s.ctx, s.req, func(resp api.ChatResponse) error </span><span class="cov0" title="0">{
                if resp.Done </span><span class="cov0" title="0">{
                        s.done = true
                        return io.EOF
                }</span>

                <span class="cov0" title="0">s.content += resp.Message.Content
                response.Choices = []Choice{
                        {
                                Index: 0,
                                Message: Message{
                                        Role:      convertFromOllamaRole(resp.Message.Role),
                                        Content:   resp.Message.Content,
                                        ToolCalls: convertFromOllamaToolCalls(resp.Message.ToolCalls),
                                },
                                FinishReason: "",
                        },
                }
                return nil</span>
        })

        <span class="cov0" title="0">if err == io.EOF </span><span class="cov0" title="0">{
                response.Choices[0].FinishReason = "stop"
                return response, nil
        }</span>

        <span class="cov0" title="0">if err != nil </span><span class="cov0" title="0">{
                return ChatCompletionResponse{}, fmt.Errorf("ollama stream failed: %w", err)
        }</span>

        <span class="cov0" title="0">return response, nil</span>
}

func (s *ollamaStreamWrapper) Close() error <span class="cov0" title="0">{
        return nil
}</span>

// CreateChatCompletionStream implements the LLM interface for Ollama streaming
func (o *OllamaLLM) CreateChatCompletionStream(ctx context.Context, req ChatCompletionRequest) (ChatCompletionStream, error) <span class="cov0" title="0">{
        stream := true
        ollamaReq := &amp;api.ChatRequest{
                Model:    req.Model,
                Messages: convertToOllamaMessages(req.Messages),
                Stream:   &amp;stream,
                Tools:    convertToOllamaTools(req.Tools),
                Options:  make(map[string]interface{}),
        }

        return newOllamaStreamWrapper(ctx, o.client, ollamaReq), nil
}</span>
</pre>
		
		<pre class="file" id="file98" style="display: none">package llm

import (
        "context"
        "fmt"
        "io"
        "os"

        "github.com/openai/openai-go"
        "github.com/openai/openai-go/option"
        "github.com/openai/openai-go/packages/ssestream"
)

// OpenAILLM implements the LLM interface for OpenAI
type OpenAILLM struct {
        client *openai.Client
}

// NewOpenAILLM creates a new OpenAI LLM client
func NewOpenAILLM(apiKey string) *OpenAILLM <span class="cov0" title="0">{
        // If apiKey is empty, try to get from environment
        if apiKey == "" </span><span class="cov0" title="0">{
                apiKey = os.Getenv("OPENAI_API_KEY")
        }</span>

        <span class="cov0" title="0">client := openai.NewClient(
                option.WithAPIKey(apiKey),
        )
        return &amp;OpenAILLM{client: &amp;client}</span>
}

// NewOpenAILLMWithHost creates an OpenAI client with custom host
func NewOpenAILLMWithHost(apiKey string, host string) *OpenAILLM <span class="cov0" title="0">{
        if apiKey == "" </span><span class="cov0" title="0">{
                apiKey = os.Getenv("OPENAI_API_KEY")
        }</span>

        <span class="cov0" title="0">client := openai.NewClient(
                option.WithAPIKey(apiKey),
                option.WithBaseURL(host),
        )
        return &amp;OpenAILLM{client: &amp;client}</span>
}

// convertToOpenAIMessages converts our generic Message type to OpenAI's message param type
func convertToOpenAIMessages(messages []Message) []openai.ChatCompletionMessageParamUnion <span class="cov0" title="0">{
        var openAIMessages []openai.ChatCompletionMessageParamUnion

        for _, msg := range messages </span><span class="cov0" title="0">{
                switch msg.Role </span>{
                case RoleSystem:<span class="cov0" title="0">
                        openAIMessages = append(openAIMessages, openai.SystemMessage(msg.Content))</span>
                case RoleUser:<span class="cov0" title="0">
                        openAIMessages = append(openAIMessages, openai.UserMessage(msg.Content))</span>
                case RoleAssistant:<span class="cov0" title="0">
                        // AssistantMessage constructor doesn't support tool calls directly
                        // Tool calls would need to be handled with a custom message type
                        openAIMessages = append(openAIMessages, openai.AssistantMessage(msg.Content))</span>
                case RoleFunction:<span class="cov0" title="0">
                        // Tool/Function messages
                        openAIMessages = append(openAIMessages, openai.ToolMessage(msg.Name, msg.Content))</span>
                }
        }

        <span class="cov0" title="0">return openAIMessages</span>
}

// convertToOpenAITools converts our Tool type to OpenAI's tool param
func convertToOpenAITools(tools []Tool) []openai.ChatCompletionToolParam <span class="cov0" title="0">{
        if len(tools) == 0 </span><span class="cov0" title="0">{
                return nil
        }</span>

        <span class="cov0" title="0">var openAITools []openai.ChatCompletionToolParam
        for _, tool := range tools </span><span class="cov0" title="0">{
                // Convert parameters to FunctionParameters (which is just map[string]any)
                var params openai.FunctionParameters
                if tool.Function.Parameters != nil </span><span class="cov0" title="0">{
                        params = openai.FunctionParameters(tool.Function.Parameters)
                }</span>

                <span class="cov0" title="0">openAITools = append(openAITools, openai.ChatCompletionToolParam{
                        Type: openai.ChatCompletionToolParam{}.Type,
                        Function: openai.FunctionDefinitionParam{
                                Name:        tool.Function.Name,
                                Description: openai.String(tool.Function.Description),
                                Parameters:  params,
                        },
                })</span>
        }

        <span class="cov0" title="0">return openAITools</span>
}

// CreateChatCompletion implements the LLM interface for OpenAI
func (o *OpenAILLM) CreateChatCompletion(ctx context.Context, req ChatCompletionRequest) (ChatCompletionResponse, error) <span class="cov0" title="0">{
        params := openai.ChatCompletionNewParams{
                Model:    req.Model,
                Messages: convertToOpenAIMessages(req.Messages),
        }

        // Optional parameters
        if req.Temperature &gt; 0 </span><span class="cov0" title="0">{
                params.Temperature = openai.Float(float64(req.Temperature))
        }</span>
        <span class="cov0" title="0">if req.TopP &gt; 0 </span><span class="cov0" title="0">{
                params.TopP = openai.Float(float64(req.TopP))
        }</span>
        <span class="cov0" title="0">if req.MaxTokens &gt; 0 </span><span class="cov0" title="0">{
                params.MaxTokens = openai.Int(int64(req.MaxTokens))
        }</span>
        <span class="cov0" title="0">if len(req.Stop) &gt; 0 </span><span class="cov0" title="0">{
                // Use the union type for stop sequences
                params.Stop = openai.ChatCompletionNewParamsStopUnion{
                        OfStringArray: req.Stop,
                }
        }</span>
        <span class="cov0" title="0">if req.PresencePenalty != 0 </span><span class="cov0" title="0">{
                params.PresencePenalty = openai.Float(float64(req.PresencePenalty))
        }</span>

        // Add tools if present
        <span class="cov0" title="0">if len(req.Tools) &gt; 0 </span><span class="cov0" title="0">{
                params.Tools = convertToOpenAITools(req.Tools)
        }</span>

        // Make the API call
        <span class="cov0" title="0">completion, err := o.client.Chat.Completions.New(ctx, params)
        if err != nil </span><span class="cov0" title="0">{
                return ChatCompletionResponse{}, fmt.Errorf("OpenAI API error: %w", err)
        }</span>

        // Convert response
        <span class="cov0" title="0">var choices []Choice
        for _, c := range completion.Choices </span><span class="cov0" title="0">{
                msg := Message{
                        Role:    RoleAssistant,
                        Content: c.Message.Content,
                }

                // Convert tool calls
                if len(c.Message.ToolCalls) &gt; 0 </span><span class="cov0" title="0">{
                        for _, tc := range c.Message.ToolCalls </span><span class="cov0" title="0">{
                                msg.ToolCalls = append(msg.ToolCalls, ToolCall{
                                        ID:   tc.ID,
                                        Type: string(tc.Type),
                                        Function: ToolCallFunction{
                                                Name:      tc.Function.Name,
                                                Arguments: tc.Function.Arguments,
                                        },
                                })
                        }</span>
                }

                <span class="cov0" title="0">choices = append(choices, Choice{
                        Index:        int(c.Index),
                        Message:      msg,
                        FinishReason: c.FinishReason,
                })</span>
        }

        <span class="cov0" title="0">return ChatCompletionResponse{
                ID:      completion.ID,
                Choices: choices,
                Usage: Usage{
                        PromptTokens:     int(completion.Usage.PromptTokens),
                        CompletionTokens: int(completion.Usage.CompletionTokens),
                        TotalTokens:      int(completion.Usage.TotalTokens),
                },
        }, nil</span>
}

// openAIStreamWrapper wraps the OpenAI stream
type openAIStreamWrapper struct {
        stream *ssestream.Stream[openai.ChatCompletionChunk]
}

func newOpenAIStreamWrapper(stream *ssestream.Stream[openai.ChatCompletionChunk]) *openAIStreamWrapper <span class="cov0" title="0">{
        return &amp;openAIStreamWrapper{
                stream: stream,
        }
}</span>

func (w *openAIStreamWrapper) Recv() (ChatCompletionResponse, error) <span class="cov0" title="0">{
        if !w.stream.Next() </span><span class="cov0" title="0">{
                err := w.stream.Err()
                if err == nil </span><span class="cov0" title="0">{
                        return ChatCompletionResponse{}, io.EOF
                }</span>
                <span class="cov0" title="0">return ChatCompletionResponse{}, err</span>
        }

        <span class="cov0" title="0">chunk := w.stream.Current()

        var choices []Choice
        for _, c := range chunk.Choices </span><span class="cov0" title="0">{
                msg := Message{}

                // Handle delta content
                if c.Delta.Content != "" </span><span class="cov0" title="0">{
                        msg.Content = c.Delta.Content
                        msg.Role = RoleAssistant
                }</span>

                // Handle delta tool calls
                <span class="cov0" title="0">if len(c.Delta.ToolCalls) &gt; 0 </span><span class="cov0" title="0">{
                        for _, tc := range c.Delta.ToolCalls </span><span class="cov0" title="0">{
                                msg.ToolCalls = append(msg.ToolCalls, ToolCall{
                                        ID:   tc.ID,
                                        Type: tc.Type,
                                        Function: ToolCallFunction{
                                                Name:      tc.Function.Name,
                                                Arguments: tc.Function.Arguments,
                                        },
                                })
                        }</span>
                }

                <span class="cov0" title="0">choices = append(choices, Choice{
                        Index:        int(c.Index),
                        Message:      msg,
                        FinishReason: c.FinishReason,
                })</span>
        }

        <span class="cov0" title="0">return ChatCompletionResponse{
                ID:      chunk.ID,
                Choices: choices,
        }, nil</span>
}

func (w *openAIStreamWrapper) Close() error <span class="cov0" title="0">{
        // The stream closes automatically when iteration is done
        return nil
}</span>

// CreateChatCompletionStream implements the LLM interface for OpenAI streaming
func (o *OpenAILLM) CreateChatCompletionStream(ctx context.Context, req ChatCompletionRequest) (ChatCompletionStream, error) <span class="cov0" title="0">{
        params := openai.ChatCompletionNewParams{
                Model:    req.Model,
                Messages: convertToOpenAIMessages(req.Messages),
        }

        // Optional parameters
        if req.Temperature &gt; 0 </span><span class="cov0" title="0">{
                params.Temperature = openai.Float(float64(req.Temperature))
        }</span>
        <span class="cov0" title="0">if req.TopP &gt; 0 </span><span class="cov0" title="0">{
                params.TopP = openai.Float(float64(req.TopP))
        }</span>
        <span class="cov0" title="0">if req.MaxTokens &gt; 0 </span><span class="cov0" title="0">{
                params.MaxTokens = openai.Int(int64(req.MaxTokens))
        }</span>
        <span class="cov0" title="0">if len(req.Stop) &gt; 0 </span><span class="cov0" title="0">{
                // Use the union type for stop sequences
                params.Stop = openai.ChatCompletionNewParamsStopUnion{
                        OfStringArray: req.Stop,
                }
        }</span>
        <span class="cov0" title="0">if req.PresencePenalty != 0 </span><span class="cov0" title="0">{
                params.PresencePenalty = openai.Float(float64(req.PresencePenalty))
        }</span>

        // Add tools if present
        <span class="cov0" title="0">if len(req.Tools) &gt; 0 </span><span class="cov0" title="0">{
                params.Tools = convertToOpenAITools(req.Tools)
        }</span>

        // Create streaming response
        <span class="cov0" title="0">stream := o.client.Chat.Completions.NewStreaming(ctx, params)

        return newOpenAIStreamWrapper(stream), nil</span>
}
</pre>
		
		<pre class="file" id="file99" style="display: none">// Package logger provides centralized logging configuration and utilities
package logger

import (
        "io"
        "log/slog"
        "os"
)

// Config defines logger configuration
type Config struct {
        Level  string // "debug", "info", "warn", "error"
        Pretty bool   // Enable pretty-printed logs for development
}

// New creates a configured logger with stdout output
func New(cfg Config) *slog.Logger <span class="cov0" title="0">{
        level := parseLevel(cfg.Level)

        if cfg.Pretty </span><span class="cov0" title="0">{
                return slog.New(slog.NewTextHandler(os.Stdout, &amp;slog.HandlerOptions{
                        Level:     level,
                        AddSource: level == slog.LevelDebug,
                }))
        }</span>

        <span class="cov0" title="0">return slog.New(slog.NewJSONHandler(os.Stdout, &amp;slog.HandlerOptions{
                Level: level,
        }))</span>
}

// NewTest creates a test logger that discards all output
func NewTest() *slog.Logger <span class="cov0" title="0">{
        return slog.New(slog.NewTextHandler(io.Discard, nil))
}</span>

// NewWithWriter creates a logger with a custom writer
func NewWithWriter(w io.Writer, cfg Config) *slog.Logger <span class="cov0" title="0">{
        level := parseLevel(cfg.Level)

        if cfg.Pretty </span><span class="cov0" title="0">{
                return slog.New(slog.NewTextHandler(w, &amp;slog.HandlerOptions{
                        Level:     level,
                        AddSource: level == slog.LevelDebug,
                }))
        }</span>

        <span class="cov0" title="0">return slog.New(slog.NewJSONHandler(w, &amp;slog.HandlerOptions{
                Level: level,
        }))</span>
}

// parseLevel converts string log level to slog.Level
func parseLevel(level string) slog.Level <span class="cov0" title="0">{
        switch level </span>{
        case "debug", "trace":<span class="cov0" title="0">
                return slog.LevelDebug</span>
        case "info":<span class="cov0" title="0">
                return slog.LevelInfo</span>
        case "warn":<span class="cov0" title="0">
                return slog.LevelWarn</span>
        case "error", "fatal":<span class="cov0" title="0">
                return slog.LevelError</span>
        case "silent":<span class="cov0" title="0">
                // Set to highest level to suppress all logs
                return slog.LevelError + 1</span>
        default:<span class="cov0" title="0">
                return slog.LevelInfo</span>
        }
}
</pre>
		
		<pre class="file" id="file100" style="display: none">// Package members provides primitives to interact with the openapi HTTP API.
//
// Code generated by github.com/oapi-codegen/oapi-codegen/v2 version v2.5.0 DO NOT EDIT.
package members

import (
        "context"
        "encoding/json"
        "fmt"
        "net/http"

        "github.com/labstack/echo/v4"
        "github.com/oapi-codegen/runtime"
        strictecho "github.com/oapi-codegen/runtime/strictmiddleware/echo"
        openapi_types "github.com/oapi-codegen/runtime/types"
)

// ServerInterface represents all server handlers.
type ServerInterface interface {
        // Find many members
        // (GET /organizations/{id}/members)
        FindManyMembers(ctx echo.Context, id string, params FindManyMembersParams) error
        // Create a new member
        // (POST /organizations/{id}/members)
        CreateMember(ctx echo.Context, id string) error
        // Delete a member
        // (DELETE /organizations/{id}/members/{memberId})
        DeleteMember(ctx echo.Context, id openapi_types.UUID, memberId openapi_types.UUID) error
        // Find a member
        // (GET /organizations/{id}/members/{memberId})
        GetOneMember(ctx echo.Context, id openapi_types.UUID, memberId openapi_types.UUID) error
        // Update a member
        // (PATCH /organizations/{id}/members/{memberId})
        UpdateMember(ctx echo.Context, id openapi_types.UUID, memberId openapi_types.UUID) error
}

// ServerInterfaceWrapper converts echo contexts to parameters.
type ServerInterfaceWrapper struct {
        Handler ServerInterface
}

// FindManyMembers converts echo context to params.
func (w *ServerInterfaceWrapper) FindManyMembers(ctx echo.Context) error <span class="cov0" title="0">{
        var err error
        // ------------- Path parameter "id" -------------
        var id string

        err = runtime.BindStyledParameterWithOptions("simple", "id", ctx.Param("id"), &amp;id, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
        if err != nil </span><span class="cov0" title="0">{
                return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter id: %s", err))
        }</span>

        <span class="cov0" title="0">ctx.Set(BearerAuthScopes, []string{})

        // Parameter object where we will unmarshal all parameters from the context
        var params FindManyMembersParams
        // ------------- Optional query parameter "filter" -------------

        err = runtime.BindQueryParameter("deepObject", true, false, "filter", ctx.QueryParams(), &amp;params.Filter)
        if err != nil </span><span class="cov0" title="0">{
                return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter filter: %s", err))
        }</span>

        // ------------- Optional query parameter "page" -------------

        <span class="cov0" title="0">err = runtime.BindQueryParameter("form", true, false, "page", ctx.QueryParams(), &amp;params.Page)
        if err != nil </span><span class="cov0" title="0">{
                return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter page: %s", err))
        }</span>

        // ------------- Optional query parameter "sort" -------------

        <span class="cov0" title="0">err = runtime.BindQueryParameter("form", true, false, "sort", ctx.QueryParams(), &amp;params.Sort)
        if err != nil </span><span class="cov0" title="0">{
                return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter sort: %s", err))
        }</span>

        // Invoke the callback with all the unmarshaled arguments
        <span class="cov0" title="0">err = w.Handler.FindManyMembers(ctx, id, params)
        return err</span>
}

// CreateMember converts echo context to params.
func (w *ServerInterfaceWrapper) CreateMember(ctx echo.Context) error <span class="cov0" title="0">{
        var err error
        // ------------- Path parameter "id" -------------
        var id string

        err = runtime.BindStyledParameterWithOptions("simple", "id", ctx.Param("id"), &amp;id, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
        if err != nil </span><span class="cov0" title="0">{
                return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter id: %s", err))
        }</span>

        <span class="cov0" title="0">ctx.Set(BearerAuthScopes, []string{})

        // Invoke the callback with all the unmarshaled arguments
        err = w.Handler.CreateMember(ctx, id)
        return err</span>
}

// DeleteMember converts echo context to params.
func (w *ServerInterfaceWrapper) DeleteMember(ctx echo.Context) error <span class="cov0" title="0">{
        var err error
        // ------------- Path parameter "id" -------------
        var id openapi_types.UUID

        err = runtime.BindStyledParameterWithOptions("simple", "id", ctx.Param("id"), &amp;id, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
        if err != nil </span><span class="cov0" title="0">{
                return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter id: %s", err))
        }</span>

        // ------------- Path parameter "memberId" -------------
        <span class="cov0" title="0">var memberId openapi_types.UUID

        err = runtime.BindStyledParameterWithOptions("simple", "memberId", ctx.Param("memberId"), &amp;memberId, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
        if err != nil </span><span class="cov0" title="0">{
                return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter memberId: %s", err))
        }</span>

        <span class="cov0" title="0">ctx.Set(BearerAuthScopes, []string{})

        // Invoke the callback with all the unmarshaled arguments
        err = w.Handler.DeleteMember(ctx, id, memberId)
        return err</span>
}

// GetOneMember converts echo context to params.
func (w *ServerInterfaceWrapper) GetOneMember(ctx echo.Context) error <span class="cov0" title="0">{
        var err error
        // ------------- Path parameter "id" -------------
        var id openapi_types.UUID

        err = runtime.BindStyledParameterWithOptions("simple", "id", ctx.Param("id"), &amp;id, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
        if err != nil </span><span class="cov0" title="0">{
                return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter id: %s", err))
        }</span>

        // ------------- Path parameter "memberId" -------------
        <span class="cov0" title="0">var memberId openapi_types.UUID

        err = runtime.BindStyledParameterWithOptions("simple", "memberId", ctx.Param("memberId"), &amp;memberId, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
        if err != nil </span><span class="cov0" title="0">{
                return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter memberId: %s", err))
        }</span>

        <span class="cov0" title="0">ctx.Set(BearerAuthScopes, []string{})

        // Invoke the callback with all the unmarshaled arguments
        err = w.Handler.GetOneMember(ctx, id, memberId)
        return err</span>
}

// UpdateMember converts echo context to params.
func (w *ServerInterfaceWrapper) UpdateMember(ctx echo.Context) error <span class="cov0" title="0">{
        var err error
        // ------------- Path parameter "id" -------------
        var id openapi_types.UUID

        err = runtime.BindStyledParameterWithOptions("simple", "id", ctx.Param("id"), &amp;id, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
        if err != nil </span><span class="cov0" title="0">{
                return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter id: %s", err))
        }</span>

        // ------------- Path parameter "memberId" -------------
        <span class="cov0" title="0">var memberId openapi_types.UUID

        err = runtime.BindStyledParameterWithOptions("simple", "memberId", ctx.Param("memberId"), &amp;memberId, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
        if err != nil </span><span class="cov0" title="0">{
                return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter memberId: %s", err))
        }</span>

        <span class="cov0" title="0">ctx.Set(BearerAuthScopes, []string{})

        // Invoke the callback with all the unmarshaled arguments
        err = w.Handler.UpdateMember(ctx, id, memberId)
        return err</span>
}

// This is a simple interface which specifies echo.Route addition functions which
// are present on both echo.Echo and echo.Group, since we want to allow using
// either of them for path registration
type EchoRouter interface {
        CONNECT(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
        DELETE(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
        GET(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
        HEAD(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
        OPTIONS(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
        PATCH(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
        POST(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
        PUT(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
        TRACE(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
}

// RegisterHandlers adds each server route to the EchoRouter.
func RegisterHandlers(router EchoRouter, si ServerInterface) <span class="cov0" title="0">{
        RegisterHandlersWithBaseURL(router, si, "")
}</span>

// Registers handlers, and prepends BaseURL to the paths, so that the paths
// can be served under a prefix.
func RegisterHandlersWithBaseURL(router EchoRouter, si ServerInterface, baseURL string) <span class="cov0" title="0">{

        wrapper := ServerInterfaceWrapper{
                Handler: si,
        }

        router.GET(baseURL+"/organizations/:id/members", wrapper.FindManyMembers)
        router.POST(baseURL+"/organizations/:id/members", wrapper.CreateMember)
        router.DELETE(baseURL+"/organizations/:id/members/:memberId", wrapper.DeleteMember)
        router.GET(baseURL+"/organizations/:id/members/:memberId", wrapper.GetOneMember)
        router.PATCH(baseURL+"/organizations/:id/members/:memberId", wrapper.UpdateMember)

}</span>

type BadRequestApplicationProblemPlusJSONResponse Problem

type NotFoundApplicationProblemPlusJSONResponse Problem

type UnauthorizedApplicationProblemPlusJSONResponse Problem

type FindManyMembersRequestObject struct {
        Id     string `json:"id"`
        Params FindManyMembersParams
}

type FindManyMembersResponseObject interface {
        VisitFindManyMembersResponse(w http.ResponseWriter) error
}

type FindManyMembers200JSONResponse struct {
        Data []Member `json:"data"`
        Meta struct {
                // Total Total number of items in the collection
                Total float32 `json:"total"`
        } `json:"meta"`
}

func (response FindManyMembers200JSONResponse) VisitFindManyMembersResponse(w http.ResponseWriter) error <span class="cov0" title="0">{
        w.Header().Set("Content-Type", "application/json")
        w.WriteHeader(200)

        return json.NewEncoder(w).Encode(response)
}</span>

type FindManyMembers400ApplicationProblemPlusJSONResponse struct {
        BadRequestApplicationProblemPlusJSONResponse
}

func (response FindManyMembers400ApplicationProblemPlusJSONResponse) VisitFindManyMembersResponse(w http.ResponseWriter) error <span class="cov0" title="0">{
        w.Header().Set("Content-Type", "application/problem+json")
        w.WriteHeader(400)

        return json.NewEncoder(w).Encode(response)
}</span>

type FindManyMembers401ApplicationProblemPlusJSONResponse struct {
        UnauthorizedApplicationProblemPlusJSONResponse
}

func (response FindManyMembers401ApplicationProblemPlusJSONResponse) VisitFindManyMembersResponse(w http.ResponseWriter) error <span class="cov0" title="0">{
        w.Header().Set("Content-Type", "application/problem+json")
        w.WriteHeader(401)

        return json.NewEncoder(w).Encode(response)
}</span>

type CreateMemberRequestObject struct {
        Id   string `json:"id"`
        Body *CreateMemberJSONRequestBody
}

type CreateMemberResponseObject interface {
        VisitCreateMemberResponse(w http.ResponseWriter) error
}

type CreateMember201JSONResponse struct {
        // Data Schema for Member entity
        Data Member `json:"data"`
}

func (response CreateMember201JSONResponse) VisitCreateMemberResponse(w http.ResponseWriter) error <span class="cov0" title="0">{
        w.Header().Set("Content-Type", "application/json")
        w.WriteHeader(201)

        return json.NewEncoder(w).Encode(response)
}</span>

type CreateMember400ApplicationProblemPlusJSONResponse struct {
        BadRequestApplicationProblemPlusJSONResponse
}

func (response CreateMember400ApplicationProblemPlusJSONResponse) VisitCreateMemberResponse(w http.ResponseWriter) error <span class="cov0" title="0">{
        w.Header().Set("Content-Type", "application/problem+json")
        w.WriteHeader(400)

        return json.NewEncoder(w).Encode(response)
}</span>

type CreateMember401ApplicationProblemPlusJSONResponse struct {
        UnauthorizedApplicationProblemPlusJSONResponse
}

func (response CreateMember401ApplicationProblemPlusJSONResponse) VisitCreateMemberResponse(w http.ResponseWriter) error <span class="cov0" title="0">{
        w.Header().Set("Content-Type", "application/problem+json")
        w.WriteHeader(401)

        return json.NewEncoder(w).Encode(response)
}</span>

type DeleteMemberRequestObject struct {
        Id       openapi_types.UUID `json:"id"`
        MemberId openapi_types.UUID `json:"memberId"`
}

type DeleteMemberResponseObject interface {
        VisitDeleteMemberResponse(w http.ResponseWriter) error
}

type DeleteMember200JSONResponse struct {
        // Data Schema for Member entity
        Data Member `json:"data"`
}

func (response DeleteMember200JSONResponse) VisitDeleteMemberResponse(w http.ResponseWriter) error <span class="cov0" title="0">{
        w.Header().Set("Content-Type", "application/json")
        w.WriteHeader(200)

        return json.NewEncoder(w).Encode(response)
}</span>

type DeleteMember404ApplicationProblemPlusJSONResponse struct {
        NotFoundApplicationProblemPlusJSONResponse
}

func (response DeleteMember404ApplicationProblemPlusJSONResponse) VisitDeleteMemberResponse(w http.ResponseWriter) error <span class="cov0" title="0">{
        w.Header().Set("Content-Type", "application/problem+json")
        w.WriteHeader(404)

        return json.NewEncoder(w).Encode(response)
}</span>

type GetOneMemberRequestObject struct {
        Id       openapi_types.UUID `json:"id"`
        MemberId openapi_types.UUID `json:"memberId"`
}

type GetOneMemberResponseObject interface {
        VisitGetOneMemberResponse(w http.ResponseWriter) error
}

type GetOneMember200JSONResponse struct {
        // Data Schema for Member entity
        Data Member `json:"data"`
}

func (response GetOneMember200JSONResponse) VisitGetOneMemberResponse(w http.ResponseWriter) error <span class="cov0" title="0">{
        w.Header().Set("Content-Type", "application/json")
        w.WriteHeader(200)

        return json.NewEncoder(w).Encode(response)
}</span>

type GetOneMember404ApplicationProblemPlusJSONResponse struct {
        NotFoundApplicationProblemPlusJSONResponse
}

func (response GetOneMember404ApplicationProblemPlusJSONResponse) VisitGetOneMemberResponse(w http.ResponseWriter) error <span class="cov0" title="0">{
        w.Header().Set("Content-Type", "application/problem+json")
        w.WriteHeader(404)

        return json.NewEncoder(w).Encode(response)
}</span>

type UpdateMemberRequestObject struct {
        Id       openapi_types.UUID `json:"id"`
        MemberId openapi_types.UUID `json:"memberId"`
        Body     *UpdateMemberJSONRequestBody
}

type UpdateMemberResponseObject interface {
        VisitUpdateMemberResponse(w http.ResponseWriter) error
}

type UpdateMember200JSONResponse struct {
        // Data Schema for Member entity
        Data Member `json:"data"`
}

func (response UpdateMember200JSONResponse) VisitUpdateMemberResponse(w http.ResponseWriter) error <span class="cov0" title="0">{
        w.Header().Set("Content-Type", "application/json")
        w.WriteHeader(200)

        return json.NewEncoder(w).Encode(response)
}</span>

type UpdateMember404ApplicationProblemPlusJSONResponse struct {
        NotFoundApplicationProblemPlusJSONResponse
}

func (response UpdateMember404ApplicationProblemPlusJSONResponse) VisitUpdateMemberResponse(w http.ResponseWriter) error <span class="cov0" title="0">{
        w.Header().Set("Content-Type", "application/problem+json")
        w.WriteHeader(404)

        return json.NewEncoder(w).Encode(response)
}</span>

// StrictServerInterface represents all server handlers.
type StrictServerInterface interface {
        // Find many members
        // (GET /organizations/{id}/members)
        FindManyMembers(ctx context.Context, request FindManyMembersRequestObject) (FindManyMembersResponseObject, error)
        // Create a new member
        // (POST /organizations/{id}/members)
        CreateMember(ctx context.Context, request CreateMemberRequestObject) (CreateMemberResponseObject, error)
        // Delete a member
        // (DELETE /organizations/{id}/members/{memberId})
        DeleteMember(ctx context.Context, request DeleteMemberRequestObject) (DeleteMemberResponseObject, error)
        // Find a member
        // (GET /organizations/{id}/members/{memberId})
        GetOneMember(ctx context.Context, request GetOneMemberRequestObject) (GetOneMemberResponseObject, error)
        // Update a member
        // (PATCH /organizations/{id}/members/{memberId})
        UpdateMember(ctx context.Context, request UpdateMemberRequestObject) (UpdateMemberResponseObject, error)
}

type StrictHandlerFunc = strictecho.StrictEchoHandlerFunc
type StrictMiddlewareFunc = strictecho.StrictEchoMiddlewareFunc

func NewStrictHandler(ssi StrictServerInterface, middlewares []StrictMiddlewareFunc) ServerInterface <span class="cov0" title="0">{
        return &amp;strictHandler{ssi: ssi, middlewares: middlewares}
}</span>

type strictHandler struct {
        ssi         StrictServerInterface
        middlewares []StrictMiddlewareFunc
}

// FindManyMembers operation middleware
func (sh *strictHandler) FindManyMembers(ctx echo.Context, id string, params FindManyMembersParams) error <span class="cov0" title="0">{
        var request FindManyMembersRequestObject

        request.Id = id
        request.Params = params

        handler := func(ctx echo.Context, request interface{}) (interface{}, error) </span><span class="cov0" title="0">{
                return sh.ssi.FindManyMembers(ctx.Request().Context(), request.(FindManyMembersRequestObject))
        }</span>
        <span class="cov0" title="0">for _, middleware := range sh.middlewares </span><span class="cov0" title="0">{
                handler = middleware(handler, "FindManyMembers")
        }</span>

        <span class="cov0" title="0">response, err := handler(ctx, request)

        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span> else<span class="cov0" title="0"> if validResponse, ok := response.(FindManyMembersResponseObject); ok </span><span class="cov0" title="0">{
                return validResponse.VisitFindManyMembersResponse(ctx.Response())
        }</span> else<span class="cov0" title="0"> if response != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("unexpected response type: %T", response)
        }</span>
        <span class="cov0" title="0">return nil</span>
}

// CreateMember operation middleware
func (sh *strictHandler) CreateMember(ctx echo.Context, id string) error <span class="cov0" title="0">{
        var request CreateMemberRequestObject

        request.Id = id

        var body CreateMemberJSONRequestBody
        if err := ctx.Bind(&amp;body); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov0" title="0">request.Body = &amp;body

        handler := func(ctx echo.Context, request interface{}) (interface{}, error) </span><span class="cov0" title="0">{
                return sh.ssi.CreateMember(ctx.Request().Context(), request.(CreateMemberRequestObject))
        }</span>
        <span class="cov0" title="0">for _, middleware := range sh.middlewares </span><span class="cov0" title="0">{
                handler = middleware(handler, "CreateMember")
        }</span>

        <span class="cov0" title="0">response, err := handler(ctx, request)

        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span> else<span class="cov0" title="0"> if validResponse, ok := response.(CreateMemberResponseObject); ok </span><span class="cov0" title="0">{
                return validResponse.VisitCreateMemberResponse(ctx.Response())
        }</span> else<span class="cov0" title="0"> if response != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("unexpected response type: %T", response)
        }</span>
        <span class="cov0" title="0">return nil</span>
}

// DeleteMember operation middleware
func (sh *strictHandler) DeleteMember(ctx echo.Context, id openapi_types.UUID, memberId openapi_types.UUID) error <span class="cov0" title="0">{
        var request DeleteMemberRequestObject

        request.Id = id
        request.MemberId = memberId

        handler := func(ctx echo.Context, request interface{}) (interface{}, error) </span><span class="cov0" title="0">{
                return sh.ssi.DeleteMember(ctx.Request().Context(), request.(DeleteMemberRequestObject))
        }</span>
        <span class="cov0" title="0">for _, middleware := range sh.middlewares </span><span class="cov0" title="0">{
                handler = middleware(handler, "DeleteMember")
        }</span>

        <span class="cov0" title="0">response, err := handler(ctx, request)

        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span> else<span class="cov0" title="0"> if validResponse, ok := response.(DeleteMemberResponseObject); ok </span><span class="cov0" title="0">{
                return validResponse.VisitDeleteMemberResponse(ctx.Response())
        }</span> else<span class="cov0" title="0"> if response != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("unexpected response type: %T", response)
        }</span>
        <span class="cov0" title="0">return nil</span>
}

// GetOneMember operation middleware
func (sh *strictHandler) GetOneMember(ctx echo.Context, id openapi_types.UUID, memberId openapi_types.UUID) error <span class="cov0" title="0">{
        var request GetOneMemberRequestObject

        request.Id = id
        request.MemberId = memberId

        handler := func(ctx echo.Context, request interface{}) (interface{}, error) </span><span class="cov0" title="0">{
                return sh.ssi.GetOneMember(ctx.Request().Context(), request.(GetOneMemberRequestObject))
        }</span>
        <span class="cov0" title="0">for _, middleware := range sh.middlewares </span><span class="cov0" title="0">{
                handler = middleware(handler, "GetOneMember")
        }</span>

        <span class="cov0" title="0">response, err := handler(ctx, request)

        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span> else<span class="cov0" title="0"> if validResponse, ok := response.(GetOneMemberResponseObject); ok </span><span class="cov0" title="0">{
                return validResponse.VisitGetOneMemberResponse(ctx.Response())
        }</span> else<span class="cov0" title="0"> if response != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("unexpected response type: %T", response)
        }</span>
        <span class="cov0" title="0">return nil</span>
}

// UpdateMember operation middleware
func (sh *strictHandler) UpdateMember(ctx echo.Context, id openapi_types.UUID, memberId openapi_types.UUID) error <span class="cov0" title="0">{
        var request UpdateMemberRequestObject

        request.Id = id
        request.MemberId = memberId

        var body UpdateMemberJSONRequestBody
        if err := ctx.Bind(&amp;body); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov0" title="0">request.Body = &amp;body

        handler := func(ctx echo.Context, request interface{}) (interface{}, error) </span><span class="cov0" title="0">{
                return sh.ssi.UpdateMember(ctx.Request().Context(), request.(UpdateMemberRequestObject))
        }</span>
        <span class="cov0" title="0">for _, middleware := range sh.middlewares </span><span class="cov0" title="0">{
                handler = middleware(handler, "UpdateMember")
        }</span>

        <span class="cov0" title="0">response, err := handler(ctx, request)

        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span> else<span class="cov0" title="0"> if validResponse, ok := response.(UpdateMemberResponseObject); ok </span><span class="cov0" title="0">{
                return validResponse.VisitUpdateMemberResponse(ctx.Response())
        }</span> else<span class="cov0" title="0"> if response != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("unexpected response type: %T", response)
        }</span>
        <span class="cov0" title="0">return nil</span>
}
</pre>
		
		<pre class="file" id="file101" style="display: none">// Code generated by codegen repository. DO NOT EDIT.
package members

import (
        "context"
        "errors"

        "github.com/archesai/archesai/internal/database/postgresql"
        "github.com/google/uuid"
        "github.com/jackc/pgx/v5/pgxpool"
)

// PostgresRepository implements Repository using PostgreSQL.
type PostgresRepository struct {
        db      *pgxpool.Pool
        queries *postgresql.Queries
}

// NewPostgresRepository creates a new PostgreSQL repository.
func NewPostgresRepository(db *pgxpool.Pool) Repository <span class="cov0" title="0">{
        return &amp;PostgresRepository{
                db:      db,
                queries: postgresql.New(db),
        }
}</span>

// Member operations

func (r *PostgresRepository) Create(ctx context.Context, entity *Member) (*Member, error) <span class="cov0" title="0">{
        // Check if SQLC has the CreateMember method
        // For now, we'll generate a stub but with proper error handling
        // TODO: Parse SQLC to detect available queries

        // Example of what it should look like when SQLC query exists:
        // params := postgresql.CreateMemberParams{
        //     Id: entity.Id,
        //     // ... map other fields
        // }
        // dbMember, err := r.queries.CreateMember(ctx, params)
        // if err != nil {
        //     return nil, NewRepositoryError("create", err)
        // }
        // return mapMemberToDomain(&amp;dbMember), nil

        return nil, NewRepositoryError("create", errors.New("not implemented - SQLC query not found"))
}</span>

func (r *PostgresRepository) Get(ctx context.Context, id uuid.UUID) (*Member, error) <span class="cov0" title="0">{
        // Try to call SQLC GetMember if it exists
        // For now, return not implemented
        return nil, NewRepositoryError("get", errors.New("not implemented - SQLC query not found"))
}</span>

func (r *PostgresRepository) Update(ctx context.Context, id uuid.UUID, entity *Member) (*Member, error) <span class="cov0" title="0">{
        // Update operations are often custom and may not have SQLC queries
        return nil, NewRepositoryError("update", errors.New("not implemented - SQLC query not found"))
}</span>

func (r *PostgresRepository) Delete(ctx context.Context, id uuid.UUID) error <span class="cov0" title="0">{
        // Try to call SQLC DeleteMember if it exists
        // For now, return not implemented
        return NewRepositoryError("delete", errors.New("not implemented - SQLC query not found"))
}</span>

func (r *PostgresRepository) List(ctx context.Context, params ListMembersParams) ([]*Member, int64, error) <span class="cov0" title="0">{
        // List operations need both List and Count queries from SQLC
        return nil, 0, NewRepositoryError("list", errors.New("not implemented - SQLC query not found"))
}</span>

// ListByOrganization retrieves multiple members by organizationId
func (r *PostgresRepository) ListByOrganization(ctx context.Context, organizationId string) ([]*Member, error) <span class="cov0" title="0">{

        // Try to call SQLC ListByOrganization if it exists
        // For now, return not implemented
        return nil, NewRepositoryError("listbyorganization", errors.New("not implemented - SQLC query not found"))

}</span>

// ListByUser retrieves multiple members by userId
func (r *PostgresRepository) ListByUser(ctx context.Context, userId uuid.UUID) ([]*Member, error) <span class="cov0" title="0">{

        // Try to call SQLC ListByUser if it exists
        // For now, return not implemented
        return nil, NewRepositoryError("listbyuser", errors.New("not implemented - SQLC query not found"))

}</span>

// GetByUserAndOrganization retrieves member by userIdorganizationId
func (r *PostgresRepository) GetByUserAndOrganization(ctx context.Context, userId uuid.UUID, organizationId string) (*Member, error) <span class="cov0" title="0">{

        // Try to call SQLC GetByUserAndOrganization if it exists
        // For now, return not implemented
        return nil, NewRepositoryError("getbyuserandorganization", errors.New("not implemented - SQLC query not found"))

}</span>

// Mapper functions - Convert between domain types and database types
// These need to be customized based on the actual field mappings

func mapMemberToDomain(db *postgresql.Member) *Member <span class="cov0" title="0">{
        if db == nil </span><span class="cov0" title="0">{
                return nil
        }</span>

        // This is a basic mapping - needs to be customized based on actual types
        // The challenge is that OpenAPI types and database types don't always match
        // For example:
        // - OpenAPI might use string, database uses *string
        // - OpenAPI might use custom UUID type, database uses uuid.UUID
        // - Field names might differ (Id vs ID)

        <span class="cov0" title="0">result := &amp;Member{
                // TODO: Map fields properly based on actual type definitions
                // This requires parsing both OpenAPI types and SQLC types
        }

        // Basic field mapping - customize based on your entity structure
        // result.Id = db.Id
        // result.CreatedAt = db.CreatedAt
        // result.UpdatedAt = db.UpdatedAt
        // Add specific field mappings as needed

        return result</span>
}
</pre>
		
		<pre class="file" id="file102" style="display: none">// Code generated by codegen repository. DO NOT EDIT.
package members

import (
        "context"
        "fmt"
        "github.com/google/uuid"
)

// Repository handles member persistence
type Repository interface {
        Create(ctx context.Context, entity *Member) (*Member, error)
        Get(ctx context.Context, id uuid.UUID) (*Member, error)
        Update(ctx context.Context, id uuid.UUID, entity *Member) (*Member, error)
        Delete(ctx context.Context, id uuid.UUID) error
        List(ctx context.Context, params ListMembersParams) ([]*Member, int64, error)

        // Additional operations
        ListByOrganization(ctx context.Context, organizationId string) ([]*Member, error)
        ListByUser(ctx context.Context, userId uuid.UUID) ([]*Member, error)
        GetByUserAndOrganization(ctx context.Context, userId uuid.UUID, organizationId string) (*Member, error)
}

// ListMembersParams represents parameters for listing members.
type ListMembersParams struct {
        Limit  int
        Offset int
}

// RepositoryError represents a repository error.
type RepositoryError struct {
        Operation string
        Err       error
}

func (e *RepositoryError) Error() string <span class="cov0" title="0">{
        return fmt.Sprintf("repository %s: %v", e.Operation, e.Err)
}</span>

func (e *RepositoryError) Unwrap() error <span class="cov0" title="0">{
        return e.Err
}</span>

// NewRepositoryError creates a new repository error.
func NewRepositoryError(operation string, err error) *RepositoryError <span class="cov0" title="0">{
        return &amp;RepositoryError{
                Operation: operation,
                Err:       err,
        }
}</span>
</pre>
		
		<pre class="file" id="file103" style="display: none">// Code generated by codegen repository. DO NOT EDIT.
package members

import (
        "context"
        "database/sql"
        "fmt"

        "github.com/archesai/archesai/internal/database/sqlite"
        "github.com/google/uuid"
)

// SQLiteRepository implements Repository using SQLite.
type SQLiteRepository struct {
        db      *sql.DB
        queries *sqlite.Queries
}

// NewSQLiteRepository creates a new SQLite repository.
func NewSQLiteRepository(db *sql.DB) Repository <span class="cov0" title="0">{
        return &amp;SQLiteRepository{
                db:      db,
                queries: sqlite.New(db),
        }
}</span>

// Member operations

func (r *SQLiteRepository) Create(ctx context.Context, entity *Member) (*Member, error) <span class="cov0" title="0">{
        // For now, return a basic implementation
        // Actual implementation would need to be customized per entity
        return nil, fmt.Errorf("CreateMember not yet implemented - requires custom mapping")
}</span>

func (r *SQLiteRepository) Get(ctx context.Context, id uuid.UUID) (*Member, error) <span class="cov0" title="0">{
        // For now, return a basic implementation
        // Actual implementation would need to be customized per entity
        return nil, fmt.Errorf("GetMember not yet implemented - requires custom mapping")
}</span>

func (r *SQLiteRepository) Update(ctx context.Context, id uuid.UUID, entity *Member) (*Member, error) <span class="cov0" title="0">{
        // For now, return a basic implementation
        // Actual implementation would need to be customized per entity
        return nil, fmt.Errorf("UpdateMember not yet implemented - requires custom mapping")
}</span>

func (r *SQLiteRepository) Delete(ctx context.Context, id uuid.UUID) error <span class="cov0" title="0">{
        // For now, return a basic implementation
        // Actual implementation would need to be customized per entity
        return fmt.Errorf("DeleteMember not yet implemented - requires custom mapping")
}</span>

func (r *SQLiteRepository) List(ctx context.Context, params ListMembersParams) ([]*Member, int64, error) <span class="cov0" title="0">{
        // For now, return a basic implementation
        // Actual implementation would need to be customized per entity
        return nil, 0, fmt.Errorf("ListMembers not yet implemented - requires custom mapping")
}</span>

// ListByOrganization retrieves multiple members by organizationId
func (r *SQLiteRepository) ListByOrganization(ctx context.Context, organizationId string) ([]*Member, error) <span class="cov0" title="0">{

        // For now, return a basic implementation
        return nil, fmt.Errorf("ListByOrganization not yet implemented - requires custom mapping")

}</span>

// ListByUser retrieves multiple members by userId
func (r *SQLiteRepository) ListByUser(ctx context.Context, userId uuid.UUID) ([]*Member, error) <span class="cov0" title="0">{

        // For now, return a basic implementation
        return nil, fmt.Errorf("ListByUser not yet implemented - requires custom mapping")

}</span>

// GetByUserAndOrganization retrieves member by userIdorganizationId
func (r *SQLiteRepository) GetByUserAndOrganization(ctx context.Context, userId uuid.UUID, organizationId string) (*Member, error) <span class="cov0" title="0">{

        // For now, return a basic implementation
        return nil, fmt.Errorf("GetByUserAndOrganization not yet implemented - requires custom mapping")

}</span>
</pre>
		
		<pre class="file" id="file104" style="display: none">// Package members provides primitives to interact with the openapi HTTP API.
//
// Code generated by github.com/oapi-codegen/oapi-codegen/v2 version v2.5.0 DO NOT EDIT.
package members

import (
        "encoding/json"
        "time"

        "github.com/oapi-codegen/runtime"
        openapi_types "github.com/oapi-codegen/runtime/types"
)

const (
        BearerAuthScopes = "bearerAuth.Scopes"
)

// Defines values for MemberRole.
const (
        MemberRoleAdmin  MemberRole = "admin"
        MemberRoleMember MemberRole = "member"
        MemberRoleOwner  MemberRole = "owner"
)

// Defines values for FindManyMembersParamsSortField.
const (
        CreatedAt      FindManyMembersParamsSortField = "createdAt"
        Id             FindManyMembersParamsSortField = "id"
        OrganizationId FindManyMembersParamsSortField = "organizationId"
        Role           FindManyMembersParamsSortField = "role"
        UpdatedAt      FindManyMembersParamsSortField = "updatedAt"
        UserId         FindManyMembersParamsSortField = "userId"
)

// Defines values for FindManyMembersParamsSortOrder.
const (
        Asc  FindManyMembersParamsSortOrder = "asc"
        Desc FindManyMembersParamsSortOrder = "desc"
)

// Defines values for CreateMemberJSONBodyRole.
const (
        CreateMemberJSONBodyRoleAdmin  CreateMemberJSONBodyRole = "admin"
        CreateMemberJSONBodyRoleMember CreateMemberJSONBodyRole = "member"
        CreateMemberJSONBodyRoleOwner  CreateMemberJSONBodyRole = "owner"
)

// Defines values for UpdateMemberJSONBodyRole.
const (
        UpdateMemberJSONBodyRoleAdmin  UpdateMemberJSONBodyRole = "admin"
        UpdateMemberJSONBodyRoleMember UpdateMemberJSONBodyRole = "member"
        UpdateMemberJSONBodyRoleOwner  UpdateMemberJSONBodyRole = "owner"
)

// FilterNode A recursive filter node that can be a condition or group
type FilterNode = interface{}

// Member Schema for Member entity
type Member struct {
        // CreatedAt The date this item was created
        CreatedAt time.Time `json:"createdAt" yaml:"createdAt"`

        // Id The ID of the item
        Id openapi_types.UUID `json:"id" yaml:"id"`

        // OrganizationId The organization name
        OrganizationId string `json:"organizationId" yaml:"organizationId"`

        // Role The role of the member
        Role MemberRole `json:"role" yaml:"role"`

        // UpdatedAt The date this item was last updated
        UpdatedAt time.Time `json:"updatedAt" yaml:"updatedAt"`

        // UserId The user id
        UserId string `json:"userId" yaml:"userId"`
}

// MemberRole The role of the member
type MemberRole string

// Page Pagination (page number &amp; size)
type Page struct {
        Number int `json:"number,omitempty,omitzero" yaml:"number,omitempty"`
        Size   int `json:"size,omitempty,omitzero" yaml:"size,omitempty"`
}

// Problem RFC 7807 (Problem Details) compliant error response
type Problem struct {
        // Detail Human-readable explanation specific to this occurrence
        Detail string `json:"detail" yaml:"detail"`

        // Errors Additional validation errors for specific fields
        Errors []ValidationError `json:"errors,omitempty,omitzero" yaml:"errors,omitempty"`

        // Instance URI identifying the specific occurrence
        Instance string `json:"instance,omitempty,omitzero" yaml:"instance,omitempty"`

        // Status HTTP status code
        Status int `json:"status" yaml:"status"`

        // Title Short, human-readable summary
        Title string `json:"title" yaml:"title"`

        // Type URI identifying the problem type
        Type string `json:"type" yaml:"type"`
}

// ValidationError Individual field validation error
type ValidationError struct {
        // Field The field path that failed validation
        Field string `json:"field" yaml:"field"`

        // Message Human-readable error message
        Message string `json:"message" yaml:"message"`

        // Value The invalid value that was provided
        Value ValidationError_Value `json:"value,omitempty,omitzero" yaml:"value,omitempty"`
}

// ValidationErrorValue0 defines model for .
type ValidationErrorValue0 = string

// ValidationErrorValue1 defines model for .
type ValidationErrorValue1 = float32

// ValidationErrorValue2 defines model for .
type ValidationErrorValue2 = bool

// ValidationError_Value The invalid value that was provided
type ValidationError_Value struct {
        union json.RawMessage
}

// MembersFilter A recursive filter node that can be a condition or group
type MembersFilter = FilterNode

// MembersSort defines model for MembersSort.
type MembersSort = []struct {
        Field string `json:"field" yaml:"field"`
        Order string `json:"order" yaml:"order"`
}

// PageQuery Pagination (page number &amp; size)
type PageQuery = Page

// BadRequest RFC 7807 (Problem Details) compliant error response
type BadRequest = Problem

// NotFound RFC 7807 (Problem Details) compliant error response
type NotFound = Problem

// Unauthorized RFC 7807 (Problem Details) compliant error response
type Unauthorized = Problem

// FindManyMembersParams defines parameters for FindManyMembers.
type FindManyMembersParams struct {
        // Filter Filter members by field values. Supported fields:
        // - createdAt, id, updatedAt, organizationId, role, userId
        Filter MembersFilter `json:"filter,omitempty,omitzero" yaml:"filter,omitempty"`

        // Page The page parameter
        Page PageQuery `form:"page,omitempty" json:"page,omitempty,omitzero" yaml:"page,omitempty"`

        // Sort The sort parameter
        Sort MembersSort `form:"sort,omitempty" json:"sort,omitempty,omitzero" yaml:"sort,omitempty"`
}

// FindManyMembersParamsSortField defines parameters for FindManyMembers.
type FindManyMembersParamsSortField string

// FindManyMembersParamsSortOrder defines parameters for FindManyMembers.
type FindManyMembersParamsSortOrder string

// CreateMemberJSONBody defines parameters for CreateMember.
type CreateMemberJSONBody struct {
        // Role The role of the member
        Role CreateMemberJSONBodyRole `json:"role" yaml:"role"`
}

// CreateMemberJSONBodyRole defines parameters for CreateMember.
type CreateMemberJSONBodyRole string

// UpdateMemberJSONBody defines parameters for UpdateMember.
type UpdateMemberJSONBody struct {
        // Role The role of the member
        Role UpdateMemberJSONBodyRole `json:"role,omitempty,omitzero" yaml:"role,omitempty"`
}

// UpdateMemberJSONBodyRole defines parameters for UpdateMember.
type UpdateMemberJSONBodyRole string

// CreateMemberJSONRequestBody defines body for CreateMember for application/json ContentType.
type CreateMemberJSONRequestBody CreateMemberJSONBody

// UpdateMemberJSONRequestBody defines body for UpdateMember for application/json ContentType.
type UpdateMemberJSONRequestBody UpdateMemberJSONBody

// AsValidationErrorValue0 returns the union data inside the ValidationError_Value as a ValidationErrorValue0
func (t ValidationError_Value) AsValidationErrorValue0() (ValidationErrorValue0, error) <span class="cov0" title="0">{
        var body ValidationErrorValue0
        err := json.Unmarshal(t.union, &amp;body)
        return body, err
}</span>

// FromValidationErrorValue0 overwrites any union data inside the ValidationError_Value as the provided ValidationErrorValue0
func (t *ValidationError_Value) FromValidationErrorValue0(v ValidationErrorValue0) error <span class="cov0" title="0">{
        b, err := json.Marshal(v)
        t.union = b
        return err
}</span>

// MergeValidationErrorValue0 performs a merge with any union data inside the ValidationError_Value, using the provided ValidationErrorValue0
func (t *ValidationError_Value) MergeValidationErrorValue0(v ValidationErrorValue0) error <span class="cov0" title="0">{
        b, err := json.Marshal(v)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov0" title="0">merged, err := runtime.JSONMerge(t.union, b)
        t.union = merged
        return err</span>
}

// AsValidationErrorValue1 returns the union data inside the ValidationError_Value as a ValidationErrorValue1
func (t ValidationError_Value) AsValidationErrorValue1() (ValidationErrorValue1, error) <span class="cov0" title="0">{
        var body ValidationErrorValue1
        err := json.Unmarshal(t.union, &amp;body)
        return body, err
}</span>

// FromValidationErrorValue1 overwrites any union data inside the ValidationError_Value as the provided ValidationErrorValue1
func (t *ValidationError_Value) FromValidationErrorValue1(v ValidationErrorValue1) error <span class="cov0" title="0">{
        b, err := json.Marshal(v)
        t.union = b
        return err
}</span>

// MergeValidationErrorValue1 performs a merge with any union data inside the ValidationError_Value, using the provided ValidationErrorValue1
func (t *ValidationError_Value) MergeValidationErrorValue1(v ValidationErrorValue1) error <span class="cov0" title="0">{
        b, err := json.Marshal(v)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov0" title="0">merged, err := runtime.JSONMerge(t.union, b)
        t.union = merged
        return err</span>
}

// AsValidationErrorValue2 returns the union data inside the ValidationError_Value as a ValidationErrorValue2
func (t ValidationError_Value) AsValidationErrorValue2() (ValidationErrorValue2, error) <span class="cov0" title="0">{
        var body ValidationErrorValue2
        err := json.Unmarshal(t.union, &amp;body)
        return body, err
}</span>

// FromValidationErrorValue2 overwrites any union data inside the ValidationError_Value as the provided ValidationErrorValue2
func (t *ValidationError_Value) FromValidationErrorValue2(v ValidationErrorValue2) error <span class="cov0" title="0">{
        b, err := json.Marshal(v)
        t.union = b
        return err
}</span>

// MergeValidationErrorValue2 performs a merge with any union data inside the ValidationError_Value, using the provided ValidationErrorValue2
func (t *ValidationError_Value) MergeValidationErrorValue2(v ValidationErrorValue2) error <span class="cov0" title="0">{
        b, err := json.Marshal(v)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov0" title="0">merged, err := runtime.JSONMerge(t.union, b)
        t.union = merged
        return err</span>
}

func (t ValidationError_Value) MarshalJSON() ([]byte, error) <span class="cov0" title="0">{
        b, err := t.union.MarshalJSON()
        return b, err
}</span>

func (t *ValidationError_Value) UnmarshalJSON(b []byte) error <span class="cov0" title="0">{
        err := t.union.UnmarshalJSON(b)
        return err
}</span>
</pre>
		
		<pre class="file" id="file105" style="display: none">// Package migrations provides database migration functionality
package migrations

import (
        "database/sql"
        "embed"
        "fmt"
        "log/slog"
        "os"

        "github.com/archesai/archesai/internal/database"
        "github.com/pressly/goose/v3"
)

//go:embed postgresql/*.sql
var migrations embed.FS

// MigrationRunner handles database migrations
type MigrationRunner struct {
        db     database.Database
        logger *slog.Logger
}

// NewMigrationRunner creates a new migration runner
func NewMigrationRunner(db database.Database, logger *slog.Logger) *MigrationRunner <span class="cov0" title="0">{
        return &amp;MigrationRunner{
                db:     db,
                logger: logger,
        }
}</span>

// Up applies all pending migrations
func (m *MigrationRunner) Up() error <span class="cov0" title="0">{
        if err := m.setEnvironmentVariables(); err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to set environment variables: %w", err)
        }</span>

        <span class="cov0" title="0">sqlDB, err := m.getSQLDB()
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to get SQL database: %w", err)
        }</span>

        <span class="cov0" title="0">goose.SetBaseFS(migrations)

        // Set the dialect based on database type
        dialect := m.getDialect()
        if err := goose.SetDialect(dialect); err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to set dialect: %w", err)
        }</span>

        <span class="cov0" title="0">if err := goose.Up(sqlDB, "migrations"); err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to apply migrations: %w", err)
        }</span>

        <span class="cov0" title="0">m.logger.Info("Migrations applied successfully")
        return nil</span>
}

// Down rolls back the last migration
func (m *MigrationRunner) Down() error <span class="cov0" title="0">{
        if err := m.setEnvironmentVariables(); err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to set environment variables: %w", err)
        }</span>

        <span class="cov0" title="0">sqlDB, err := m.getSQLDB()
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to get SQL database: %w", err)
        }</span>

        <span class="cov0" title="0">goose.SetBaseFS(migrations)

        dialect := m.getDialect()
        if err := goose.SetDialect(dialect); err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to set dialect: %w", err)
        }</span>

        <span class="cov0" title="0">if err := goose.Down(sqlDB, "migrations"); err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to rollback migration: %w", err)
        }</span>

        <span class="cov0" title="0">m.logger.Info("Migration rolled back successfully")
        return nil</span>
}

// Version returns the current migration version
func (m *MigrationRunner) Version() (int64, error) <span class="cov0" title="0">{
        sqlDB, err := m.getSQLDB()
        if err != nil </span><span class="cov0" title="0">{
                return 0, fmt.Errorf("failed to get SQL database: %w", err)
        }</span>

        <span class="cov0" title="0">goose.SetBaseFS(migrations)

        dialect := m.getDialect()
        if err := goose.SetDialect(dialect); err != nil </span><span class="cov0" title="0">{
                return 0, fmt.Errorf("failed to set dialect: %w", err)
        }</span>

        <span class="cov0" title="0">version, err := goose.GetDBVersion(sqlDB)
        if err != nil </span><span class="cov0" title="0">{
                return 0, fmt.Errorf("failed to get version: %w", err)
        }</span>

        <span class="cov0" title="0">return version, nil</span>
}

// Force sets the migration version without running migrations
func (m *MigrationRunner) Force(version int64) error <span class="cov0" title="0">{
        if err := m.setEnvironmentVariables(); err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to set environment variables: %w", err)
        }</span>

        <span class="cov0" title="0">sqlDB, err := m.getSQLDB()
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to get SQL database: %w", err)
        }</span>

        <span class="cov0" title="0">goose.SetBaseFS(migrations)

        dialect := m.getDialect()
        if err := goose.SetDialect(dialect); err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to set dialect: %w", err)
        }</span>

        // Force the version by resetting and then applying up to the target version
        <span class="cov0" title="0">if err := goose.Reset(sqlDB, "migrations"); err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to reset migrations: %w", err)
        }</span>

        <span class="cov0" title="0">if version &gt; 0 </span><span class="cov0" title="0">{
                if err := goose.UpTo(sqlDB, "migrations", version); err != nil </span><span class="cov0" title="0">{
                        return fmt.Errorf("failed to migrate to version %d: %w", version, err)
                }</span>
        }

        <span class="cov0" title="0">m.logger.Info("Migration version forced", "version", version)
        return nil</span>
}

// setEnvironmentVariables sets database-specific environment variables for migrations
func (m *MigrationRunner) setEnvironmentVariables() error <span class="cov0" title="0">{
        switch m.db.Type() </span>{
        case database.TypePostgreSQL:<span class="cov0" title="0">
                _ = os.Setenv("TIMESTAMP_TYPE", "TIMESTAMPTZ")
                _ = os.Setenv("TIMESTAMP_DEFAULT", "CURRENT_TIMESTAMP")
                _ = os.Setenv("REAL_TYPE", "DOUBLE PRECISION")</span>
        case database.TypeSQLite:<span class="cov0" title="0">
                _ = os.Setenv("TIMESTAMP_TYPE", "TEXT")
                _ = os.Setenv("TIMESTAMP_DEFAULT", "(strftime('%Y-%m-%d %H:%M:%f', 'now'))")
                _ = os.Setenv("REAL_TYPE", "REAL")</span>
        default:<span class="cov0" title="0">
                return fmt.Errorf("unsupported database type: %s", m.db.Type())</span>
        }
        <span class="cov0" title="0">return nil</span>
}

// getDialect returns the goose dialect string for the database type
func (m *MigrationRunner) getDialect() string <span class="cov0" title="0">{
        switch m.db.Type() </span>{
        case database.TypePostgreSQL:<span class="cov0" title="0">
                return "postgres"</span>
        case database.TypeSQLite:<span class="cov0" title="0">
                return "sqlite3"</span>
        default:<span class="cov0" title="0">
                return ""</span>
        }
}

// getSQLDB gets a database/sql connection
func (m *MigrationRunner) getSQLDB() (*sql.DB, error) <span class="cov0" title="0">{
        switch m.db.Type() </span>{
        case database.TypePostgreSQL:<span class="cov0" title="0">
                cfg, ok := m.db.(*database.PGDatabase)
                if !ok </span><span class="cov0" title="0">{
                        return nil, fmt.Errorf("database is not PostgreSQL")
                }</span>
                <span class="cov0" title="0">return cfg.GetSQLDB(), nil</span>
        case database.TypeSQLite:<span class="cov0" title="0">
                sqlDB, ok := m.db.Underlying().(*sql.DB)
                if !ok </span><span class="cov0" title="0">{
                        return nil, fmt.Errorf("SQLite database does not have *sql.DB underlying connection")
                }</span>
                <span class="cov0" title="0">return sqlDB, nil</span>
        default:<span class="cov0" title="0">
                return nil, fmt.Errorf("unsupported database type: %s", m.db.Type())</span>
        }
}

// RunMigrations is a convenience function to run migrations on a database
func RunMigrations(db database.Database, logger *slog.Logger) error <span class="cov0" title="0">{
        runner := NewMigrationRunner(db, logger)
        return runner.Up()
}</span>

// MigrationConfig holds configuration for migrations
type MigrationConfig struct {
        Direction string // "up" or "down"
        Steps     int    // Number of steps (0 means all)
        Force     int64  // Force to a specific version (-1 means don't force)
}

// RunMigrationsWithConfig runs migrations with specific configuration
func RunMigrationsWithConfig(db database.Database, cfg MigrationConfig, logger *slog.Logger) error <span class="cov0" title="0">{
        runner := NewMigrationRunner(db, logger)

        if cfg.Force &gt;= 0 </span><span class="cov0" title="0">{
                return runner.Force(cfg.Force)
        }</span>

        <span class="cov0" title="0">switch cfg.Direction </span>{
        case "up":<span class="cov0" title="0">
                return runner.Up()</span>
        case "down":<span class="cov0" title="0">
                return runner.Down()</span>
        default:<span class="cov0" title="0">
                return fmt.Errorf("invalid migration direction: %s", cfg.Direction)</span>
        }
}
</pre>
		
		<pre class="file" id="file106" style="display: none">// Code generated by codegen cache. DO NOT EDIT.
package organizations

import (
        "context"
        "time"

        genericcache "github.com/archesai/archesai/internal/cache"
        "github.com/google/uuid"
)

// ErrCacheMiss re-exported from generic cache package
var ErrCacheMiss = genericcache.ErrCacheMiss

// Cache provides caching operations for organizations domain.
type Cache interface {

        // Organization caching
        Get(ctx context.Context, id uuid.UUID) (*Organization, error)
        Set(ctx context.Context, entity *Organization, ttl time.Duration) error
        Delete(ctx context.Context, id uuid.UUID) error
        GetBySlug(ctx context.Context, slug string) (*Organization, error)
        GetByStripeCustomerId(ctx context.Context, stripeCustomerId string) (*Organization, error)

        // Batch operations
        FlushAll(ctx context.Context) error
}

// NewNoOpCache creates a no-op cache using the generic NoOpCache with the adapter
func NewNoOpCache() Cache <span class="cov0" title="0">{
        return NewCacheAdapter(genericcache.NewNoOpCache[Organization]())
}</span>

// CacheAdapter adapts generic cache implementations to the domain Cache interface
type CacheAdapter struct {
        organizationCache genericcache.Cache[Organization]
}

// NewCacheAdapter creates a new cache adapter using generic caches
func NewCacheAdapter(organizationCache genericcache.Cache[Organization]) Cache <span class="cov0" title="0">{
        return &amp;CacheAdapter{
                organizationCache: organizationCache,
        }
}</span>

// Get retrieves organization from cache by ID
func (a *CacheAdapter) Get(ctx context.Context, id uuid.UUID) (*Organization, error) <span class="cov0" title="0">{
        entity, err := a.organizationCache.Get(ctx, id.String())
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">if entity == nil </span><span class="cov0" title="0">{
                return nil, ErrCacheMiss
        }</span>
        <span class="cov0" title="0">return entity, nil</span>
}

// Set stores organization in cache with TTL
func (a *CacheAdapter) Set(ctx context.Context, entity *Organization, ttl time.Duration) error <span class="cov0" title="0">{
        if entity == nil </span><span class="cov0" title="0">{
                return nil
        }</span>
        <span class="cov0" title="0">return a.organizationCache.Set(ctx, entity.Id.String(), entity, ttl)</span>
}

// Delete removes organization from cache
func (a *CacheAdapter) Delete(ctx context.Context, id uuid.UUID) error <span class="cov0" title="0">{
        return a.organizationCache.Delete(ctx, id.String())
}</span>

// GetBySlug retrieves organization from cache by slug
func (a *CacheAdapter) GetBySlug(ctx context.Context, slug string) (*Organization, error) <span class="cov0" title="0">{
        key := "slug:" + slug
        entity, err := a.organizationCache.Get(ctx, key)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">if entity == nil </span><span class="cov0" title="0">{
                return nil, ErrCacheMiss
        }</span>
        <span class="cov0" title="0">return entity, nil</span>
}

// GetByStripeCustomerId retrieves organization from cache by stripeCustomerId
func (a *CacheAdapter) GetByStripeCustomerId(ctx context.Context, stripeCustomerId string) (*Organization, error) <span class="cov0" title="0">{
        key := "stripeCustomerId:" + stripeCustomerId
        entity, err := a.organizationCache.Get(ctx, key)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">if entity == nil </span><span class="cov0" title="0">{
                return nil, ErrCacheMiss
        }</span>
        <span class="cov0" title="0">return entity, nil</span>
}

// FlushAll clears all cached data
func (a *CacheAdapter) FlushAll(ctx context.Context) error <span class="cov0" title="0">{
        if err := a.organizationCache.Clear(ctx); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov0" title="0">return nil</span>
}

// Ensure CacheAdapter implements Cache interface
var _ Cache = (*CacheAdapter)(nil)
</pre>
		
		<pre class="file" id="file107" style="display: none">// Code generated by codegen events. DO NOT EDIT.
package organizations

import (
        "context"
        "github.com/archesai/archesai/internal/events"
)

// Event type constants for organizations domain.
const (
        EventOrganizationCreated         = "organization.created"
        EventOrganizationUpdated         = "organization.updated"
        EventOrganizationDeleted         = "organization.deleted"
        EventOrganizationPlan_changed    = "organization.plan-changed"
        EventOrganizationCredits_updated = "organization.credits-updated"
)

// OrganizationCreatedEvent represents a created event event for Organization.
type OrganizationCreatedEvent struct {
        events.BaseEvent
        Organization *Organization `json:"organization"`
}

// NewOrganizationCreatedEvent creates a new Organization created event.
func NewOrganizationCreatedEvent(entity *Organization) *OrganizationCreatedEvent <span class="cov0" title="0">{
        return &amp;OrganizationCreatedEvent{
                BaseEvent:    events.NewBaseEvent("organizations", EventOrganizationCreated),
                Organization: entity,
        }
}</span>

// EventType returns the event type string.
func (e *OrganizationCreatedEvent) EventType() string <span class="cov0" title="0">{
        return EventOrganizationCreated
}</span>

// EventDomain returns the domain this event belongs to.
func (e *OrganizationCreatedEvent) EventDomain() string <span class="cov0" title="0">{
        return "organizations"
}</span>

// EventData returns the actual event data.
func (e *OrganizationCreatedEvent) EventData() interface{} <span class="cov0" title="0">{
        return e.Organization
}</span>

// OrganizationUpdatedEvent represents a updated event event for Organization.
type OrganizationUpdatedEvent struct {
        events.BaseEvent
        Organization *Organization `json:"organization"`
}

// NewOrganizationUpdatedEvent creates a new Organization updated event.
func NewOrganizationUpdatedEvent(entity *Organization) *OrganizationUpdatedEvent <span class="cov0" title="0">{
        return &amp;OrganizationUpdatedEvent{
                BaseEvent:    events.NewBaseEvent("organizations", EventOrganizationUpdated),
                Organization: entity,
        }
}</span>

// EventType returns the event type string.
func (e *OrganizationUpdatedEvent) EventType() string <span class="cov0" title="0">{
        return EventOrganizationUpdated
}</span>

// EventDomain returns the domain this event belongs to.
func (e *OrganizationUpdatedEvent) EventDomain() string <span class="cov0" title="0">{
        return "organizations"
}</span>

// EventData returns the actual event data.
func (e *OrganizationUpdatedEvent) EventData() interface{} <span class="cov0" title="0">{
        return e.Organization
}</span>

// OrganizationDeletedEvent represents a deleted event event for Organization.
type OrganizationDeletedEvent struct {
        events.BaseEvent
        Organization *Organization `json:"organization"`
}

// NewOrganizationDeletedEvent creates a new Organization deleted event.
func NewOrganizationDeletedEvent(entity *Organization) *OrganizationDeletedEvent <span class="cov0" title="0">{
        return &amp;OrganizationDeletedEvent{
                BaseEvent:    events.NewBaseEvent("organizations", EventOrganizationDeleted),
                Organization: entity,
        }
}</span>

// EventType returns the event type string.
func (e *OrganizationDeletedEvent) EventType() string <span class="cov0" title="0">{
        return EventOrganizationDeleted
}</span>

// EventDomain returns the domain this event belongs to.
func (e *OrganizationDeletedEvent) EventDomain() string <span class="cov0" title="0">{
        return "organizations"
}</span>

// EventData returns the actual event data.
func (e *OrganizationDeletedEvent) EventData() interface{} <span class="cov0" title="0">{
        return e.Organization
}</span>

// OrganizationPlan_changedEvent represents a plan_changed event event for Organization.
type OrganizationPlan_changedEvent struct {
        events.BaseEvent
        Organization *Organization `json:"organization"`
}

// NewOrganizationPlan_changedEvent creates a new Organization plan_changed event.
func NewOrganizationPlan_changedEvent(entity *Organization) *OrganizationPlan_changedEvent <span class="cov0" title="0">{
        return &amp;OrganizationPlan_changedEvent{
                BaseEvent:    events.NewBaseEvent("organizations", EventOrganizationPlan_changed),
                Organization: entity,
        }
}</span>

// EventType returns the event type string.
func (e *OrganizationPlan_changedEvent) EventType() string <span class="cov0" title="0">{
        return EventOrganizationPlan_changed
}</span>

// EventDomain returns the domain this event belongs to.
func (e *OrganizationPlan_changedEvent) EventDomain() string <span class="cov0" title="0">{
        return "organizations"
}</span>

// EventData returns the actual event data.
func (e *OrganizationPlan_changedEvent) EventData() interface{} <span class="cov0" title="0">{
        return e.Organization
}</span>

// OrganizationCredits_updatedEvent represents a credits_updated event event for Organization.
type OrganizationCredits_updatedEvent struct {
        events.BaseEvent
        Organization *Organization `json:"organization"`
}

// NewOrganizationCredits_updatedEvent creates a new Organization credits_updated event.
func NewOrganizationCredits_updatedEvent(entity *Organization) *OrganizationCredits_updatedEvent <span class="cov0" title="0">{
        return &amp;OrganizationCredits_updatedEvent{
                BaseEvent:    events.NewBaseEvent("organizations", EventOrganizationCredits_updated),
                Organization: entity,
        }
}</span>

// EventType returns the event type string.
func (e *OrganizationCredits_updatedEvent) EventType() string <span class="cov0" title="0">{
        return EventOrganizationCredits_updated
}</span>

// EventDomain returns the domain this event belongs to.
func (e *OrganizationCredits_updatedEvent) EventDomain() string <span class="cov0" title="0">{
        return "organizations"
}</span>

// EventData returns the actual event data.
func (e *OrganizationCredits_updatedEvent) EventData() interface{} <span class="cov0" title="0">{
        return e.Organization
}</span>

// EventPublisher publishes domain events for organizations.
type EventPublisher interface {
        PublishOrganizationCreated(ctx context.Context, entity *Organization) error
        PublishOrganizationUpdated(ctx context.Context, entity *Organization) error
        PublishOrganizationDeleted(ctx context.Context, entity *Organization) error
        PublishOrganizationPlan_changed(ctx context.Context, entity *Organization) error
        PublishOrganizationCredits_updated(ctx context.Context, entity *Organization) error
}

// eventPublisher implements EventPublisher for organizations domain.
type eventPublisher struct {
        publisher events.Publisher
}

// NewEventPublisher creates a new event publisher for organizations domain.
func NewEventPublisher(publisher events.Publisher) EventPublisher <span class="cov0" title="0">{
        return &amp;eventPublisher{
                publisher: publisher,
        }
}</span>

// PublishOrganizationCreated publishes a created event event for Organization.
func (p *eventPublisher) PublishOrganizationCreated(ctx context.Context, entity *Organization) error <span class="cov0" title="0">{
        event := NewOrganizationCreatedEvent(entity)
        return events.PublishDomainEvent(ctx, p.publisher, event)
}</span>

// PublishOrganizationUpdated publishes a updated event event for Organization.
func (p *eventPublisher) PublishOrganizationUpdated(ctx context.Context, entity *Organization) error <span class="cov0" title="0">{
        event := NewOrganizationUpdatedEvent(entity)
        return events.PublishDomainEvent(ctx, p.publisher, event)
}</span>

// PublishOrganizationDeleted publishes a deleted event event for Organization.
func (p *eventPublisher) PublishOrganizationDeleted(ctx context.Context, entity *Organization) error <span class="cov0" title="0">{
        event := NewOrganizationDeletedEvent(entity)
        return events.PublishDomainEvent(ctx, p.publisher, event)
}</span>

// PublishOrganizationPlan_changed publishes a plan_changed event event for Organization.
func (p *eventPublisher) PublishOrganizationPlan_changed(ctx context.Context, entity *Organization) error <span class="cov0" title="0">{
        event := NewOrganizationPlan_changedEvent(entity)
        return events.PublishDomainEvent(ctx, p.publisher, event)
}</span>

// PublishOrganizationCredits_updated publishes a credits_updated event event for Organization.
func (p *eventPublisher) PublishOrganizationCredits_updated(ctx context.Context, entity *Organization) error <span class="cov0" title="0">{
        event := NewOrganizationCredits_updatedEvent(entity)
        return events.PublishDomainEvent(ctx, p.publisher, event)
}</span>

// NewNoOpEventPublisher creates a new no-op event publisher for testing.
func NewNoOpEventPublisher() EventPublisher <span class="cov0" title="0">{
        return NewEventPublisher(events.NewNoOpPublisher())
}</span>
</pre>
		
		<pre class="file" id="file108" style="display: none">// Package organizations provides HTTP handlers for organization operations
package organizations

import (
        "context"
        "log/slog"
)

const (
        // Placeholder constants for development
        userPlaceholder = "user-placeholder"
)

// Handler handles HTTP requests for organization operations
type Handler struct {
        service *Service
        logger  *slog.Logger
}

// Ensure Handler implements StrictServerInterface
var _ StrictServerInterface = (*Handler)(nil)

// NewHandler creates a new organizations handler
func NewHandler(service *Service, logger *slog.Logger) *Handler <span class="cov0" title="0">{
        return &amp;Handler{
                service: service,
                logger:  logger,
        }
}</span>

// FindManyOrganizations retrieves organizations (implements StrictServerInterface)
func (h *Handler) FindManyOrganizations(ctx context.Context, req FindManyOrganizationsRequestObject) (FindManyOrganizationsResponseObject, error) <span class="cov0" title="0">{
        // Default pagination
        limit := 50
        offset := 0

        // Handle page-based pagination if provided
        if req.Params.Page.Number &gt; 0 &amp;&amp; req.Params.Page.Size &gt; 0 </span><span class="cov0" title="0">{
                limit = req.Params.Page.Size
                offset = (req.Params.Page.Number - 1) * req.Params.Page.Size
        }</span>

        <span class="cov0" title="0">organizations, total, err := h.service.List(ctx, limit, offset)
        if err != nil </span><span class="cov0" title="0">{
                h.logger.Error("failed to list organizations", "error", err)
                return nil, err
        }</span>

        // Convert to API entities
        <span class="cov0" title="0">data := make([]Organization, len(organizations))
        for i, org := range organizations </span><span class="cov0" title="0">{
                data[i] = *org
        }</span>

        <span class="cov0" title="0">totalFloat32 := float32(total)
        return FindManyOrganizations200JSONResponse{
                Data: data,
                Meta: struct {
                        Total float32 `json:"total"`
                }{
                        Total: totalFloat32,
                },
        }, nil</span>
}

// CreateOrganization creates a new organization (implements StrictServerInterface)
func (h *Handler) CreateOrganization(ctx context.Context, req CreateOrganizationRequestObject) (CreateOrganizationResponseObject, error) <span class="cov0" title="0">{
        // TODO: Get creator user ID from auth context
        creatorUserID := userPlaceholder

        createReq := &amp;CreateOrganizationRequest{
                OrganizationId: req.Body.OrganizationId,
                BillingEmail:   req.Body.BillingEmail,
        }

        organization, err := h.service.Create(ctx, createReq, creatorUserID)
        if err != nil </span><span class="cov0" title="0">{
                h.logger.Error("failed to create organization", "error", err)
                return nil, err
        }</span>

        <span class="cov0" title="0">return CreateOrganization201JSONResponse{
                Data: *organization,
        }, nil</span>
}

// GetOneOrganization retrieves an organization by ID (implements StrictServerInterface)
func (h *Handler) GetOneOrganization(ctx context.Context, req GetOneOrganizationRequestObject) (GetOneOrganizationResponseObject, error) <span class="cov0" title="0">{
        organization, err := h.service.Get(ctx, req.Id)
        if err != nil </span><span class="cov0" title="0">{
                if err == ErrOrganizationNotFound </span><span class="cov0" title="0">{
                        return GetOneOrganization404ApplicationProblemPlusJSONResponse{
                                NotFoundApplicationProblemPlusJSONResponse: NotFoundApplicationProblemPlusJSONResponse{
                                        Detail: "Organization not found",
                                        Status: 404,
                                        Title:  "Organization not found",
                                },
                        }, nil
                }</span>
                <span class="cov0" title="0">h.logger.Error("failed to get organization", "error", err)
                return nil, err</span>
        }

        <span class="cov0" title="0">return GetOneOrganization200JSONResponse{
                Data: *organization,
        }, nil</span>
}

// UpdateOrganization updates an organization (implements StrictServerInterface)
func (h *Handler) UpdateOrganization(ctx context.Context, req UpdateOrganizationRequestObject) (UpdateOrganizationResponseObject, error) <span class="cov0" title="0">{
        updateReq := &amp;UpdateOrganizationRequest{
                BillingEmail: req.Body.BillingEmail,
        }

        organization, err := h.service.Update(ctx, req.Id, updateReq)
        if err != nil </span><span class="cov0" title="0">{
                if err == ErrOrganizationNotFound </span><span class="cov0" title="0">{
                        return UpdateOrganization404ApplicationProblemPlusJSONResponse{
                                NotFoundApplicationProblemPlusJSONResponse: NotFoundApplicationProblemPlusJSONResponse{
                                        Detail: "Organization not found",
                                        Status: 404,
                                        Title:  "Organization not found",
                                },
                        }, nil
                }</span>
                <span class="cov0" title="0">h.logger.Error("failed to update organization", "error", err)
                return nil, err</span>
        }

        <span class="cov0" title="0">return UpdateOrganization200JSONResponse{
                Data: *organization,
        }, nil</span>
}

// DeleteOrganization deletes an organization (implements StrictServerInterface)
func (h *Handler) DeleteOrganization(ctx context.Context, req DeleteOrganizationRequestObject) (DeleteOrganizationResponseObject, error) <span class="cov0" title="0">{
        err := h.service.Delete(ctx, req.Id)
        if err != nil </span><span class="cov0" title="0">{
                if err == ErrOrganizationNotFound </span><span class="cov0" title="0">{
                        return DeleteOrganization404ApplicationProblemPlusJSONResponse{
                                NotFoundApplicationProblemPlusJSONResponse: NotFoundApplicationProblemPlusJSONResponse{
                                        Detail: "Organization not found",
                                        Status: 404,
                                        Title:  "Organization not found",
                                },
                        }, nil
                }</span>
                <span class="cov0" title="0">h.logger.Error("failed to delete organization", "error", err)
                return nil, err</span>
        }

        <span class="cov0" title="0">return DeleteOrganization200JSONResponse{}, nil</span>
}
</pre>
		
		<pre class="file" id="file109" style="display: none">// Package organizations provides primitives to interact with the openapi HTTP API.
//
// Code generated by github.com/oapi-codegen/oapi-codegen/v2 version v2.5.0 DO NOT EDIT.
package organizations

import (
        "context"
        "encoding/json"
        "fmt"
        "net/http"

        "github.com/labstack/echo/v4"
        "github.com/oapi-codegen/runtime"
        strictecho "github.com/oapi-codegen/runtime/strictmiddleware/echo"
        openapi_types "github.com/oapi-codegen/runtime/types"
)

// ServerInterface represents all server handlers.
type ServerInterface interface {
        // Find many organizations
        // (GET /organizations)
        FindManyOrganizations(ctx echo.Context, params FindManyOrganizationsParams) error
        // Create a new organization
        // (POST /organizations)
        CreateOrganization(ctx echo.Context) error
        // Delete an organization
        // (DELETE /organizations/{id})
        DeleteOrganization(ctx echo.Context, id openapi_types.UUID) error
        // Find an organization
        // (GET /organizations/{id})
        GetOneOrganization(ctx echo.Context, id openapi_types.UUID) error
        // Update an organization
        // (PATCH /organizations/{id})
        UpdateOrganization(ctx echo.Context, id openapi_types.UUID) error
}

// ServerInterfaceWrapper converts echo contexts to parameters.
type ServerInterfaceWrapper struct {
        Handler ServerInterface
}

// FindManyOrganizations converts echo context to params.
func (w *ServerInterfaceWrapper) FindManyOrganizations(ctx echo.Context) error <span class="cov0" title="0">{
        var err error

        ctx.Set(BearerAuthScopes, []string{})

        // Parameter object where we will unmarshal all parameters from the context
        var params FindManyOrganizationsParams
        // ------------- Optional query parameter "filter" -------------

        err = runtime.BindQueryParameter("deepObject", true, false, "filter", ctx.QueryParams(), &amp;params.Filter)
        if err != nil </span><span class="cov0" title="0">{
                return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter filter: %s", err))
        }</span>

        // ------------- Optional query parameter "page" -------------

        <span class="cov0" title="0">err = runtime.BindQueryParameter("form", true, false, "page", ctx.QueryParams(), &amp;params.Page)
        if err != nil </span><span class="cov0" title="0">{
                return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter page: %s", err))
        }</span>

        // ------------- Optional query parameter "sort" -------------

        <span class="cov0" title="0">err = runtime.BindQueryParameter("form", true, false, "sort", ctx.QueryParams(), &amp;params.Sort)
        if err != nil </span><span class="cov0" title="0">{
                return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter sort: %s", err))
        }</span>

        // Invoke the callback with all the unmarshaled arguments
        <span class="cov0" title="0">err = w.Handler.FindManyOrganizations(ctx, params)
        return err</span>
}

// CreateOrganization converts echo context to params.
func (w *ServerInterfaceWrapper) CreateOrganization(ctx echo.Context) error <span class="cov0" title="0">{
        var err error

        ctx.Set(BearerAuthScopes, []string{})

        // Invoke the callback with all the unmarshaled arguments
        err = w.Handler.CreateOrganization(ctx)
        return err
}</span>

// DeleteOrganization converts echo context to params.
func (w *ServerInterfaceWrapper) DeleteOrganization(ctx echo.Context) error <span class="cov0" title="0">{
        var err error
        // ------------- Path parameter "id" -------------
        var id openapi_types.UUID

        err = runtime.BindStyledParameterWithOptions("simple", "id", ctx.Param("id"), &amp;id, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
        if err != nil </span><span class="cov0" title="0">{
                return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter id: %s", err))
        }</span>

        <span class="cov0" title="0">ctx.Set(BearerAuthScopes, []string{})

        // Invoke the callback with all the unmarshaled arguments
        err = w.Handler.DeleteOrganization(ctx, id)
        return err</span>
}

// GetOneOrganization converts echo context to params.
func (w *ServerInterfaceWrapper) GetOneOrganization(ctx echo.Context) error <span class="cov0" title="0">{
        var err error
        // ------------- Path parameter "id" -------------
        var id openapi_types.UUID

        err = runtime.BindStyledParameterWithOptions("simple", "id", ctx.Param("id"), &amp;id, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
        if err != nil </span><span class="cov0" title="0">{
                return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter id: %s", err))
        }</span>

        <span class="cov0" title="0">ctx.Set(BearerAuthScopes, []string{})

        // Invoke the callback with all the unmarshaled arguments
        err = w.Handler.GetOneOrganization(ctx, id)
        return err</span>
}

// UpdateOrganization converts echo context to params.
func (w *ServerInterfaceWrapper) UpdateOrganization(ctx echo.Context) error <span class="cov0" title="0">{
        var err error
        // ------------- Path parameter "id" -------------
        var id openapi_types.UUID

        err = runtime.BindStyledParameterWithOptions("simple", "id", ctx.Param("id"), &amp;id, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
        if err != nil </span><span class="cov0" title="0">{
                return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter id: %s", err))
        }</span>

        <span class="cov0" title="0">ctx.Set(BearerAuthScopes, []string{})

        // Invoke the callback with all the unmarshaled arguments
        err = w.Handler.UpdateOrganization(ctx, id)
        return err</span>
}

// This is a simple interface which specifies echo.Route addition functions which
// are present on both echo.Echo and echo.Group, since we want to allow using
// either of them for path registration
type EchoRouter interface {
        CONNECT(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
        DELETE(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
        GET(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
        HEAD(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
        OPTIONS(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
        PATCH(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
        POST(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
        PUT(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
        TRACE(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
}

// RegisterHandlers adds each server route to the EchoRouter.
func RegisterHandlers(router EchoRouter, si ServerInterface) <span class="cov0" title="0">{
        RegisterHandlersWithBaseURL(router, si, "")
}</span>

// Registers handlers, and prepends BaseURL to the paths, so that the paths
// can be served under a prefix.
func RegisterHandlersWithBaseURL(router EchoRouter, si ServerInterface, baseURL string) <span class="cov0" title="0">{

        wrapper := ServerInterfaceWrapper{
                Handler: si,
        }

        router.GET(baseURL+"/organizations", wrapper.FindManyOrganizations)
        router.POST(baseURL+"/organizations", wrapper.CreateOrganization)
        router.DELETE(baseURL+"/organizations/:id", wrapper.DeleteOrganization)
        router.GET(baseURL+"/organizations/:id", wrapper.GetOneOrganization)
        router.PATCH(baseURL+"/organizations/:id", wrapper.UpdateOrganization)

}</span>

type BadRequestApplicationProblemPlusJSONResponse Problem

type NotFoundApplicationProblemPlusJSONResponse Problem

type UnauthorizedApplicationProblemPlusJSONResponse Problem

type FindManyOrganizationsRequestObject struct {
        Params FindManyOrganizationsParams
}

type FindManyOrganizationsResponseObject interface {
        VisitFindManyOrganizationsResponse(w http.ResponseWriter) error
}

type FindManyOrganizations200JSONResponse struct {
        Data []Organization `json:"data"`
        Meta struct {
                // Total Total number of items in the collection
                Total float32 `json:"total"`
        } `json:"meta"`
}

func (response FindManyOrganizations200JSONResponse) VisitFindManyOrganizationsResponse(w http.ResponseWriter) error <span class="cov0" title="0">{
        w.Header().Set("Content-Type", "application/json")
        w.WriteHeader(200)

        return json.NewEncoder(w).Encode(response)
}</span>

type FindManyOrganizations400ApplicationProblemPlusJSONResponse struct {
        BadRequestApplicationProblemPlusJSONResponse
}

func (response FindManyOrganizations400ApplicationProblemPlusJSONResponse) VisitFindManyOrganizationsResponse(w http.ResponseWriter) error <span class="cov0" title="0">{
        w.Header().Set("Content-Type", "application/problem+json")
        w.WriteHeader(400)

        return json.NewEncoder(w).Encode(response)
}</span>

type FindManyOrganizations401ApplicationProblemPlusJSONResponse struct {
        UnauthorizedApplicationProblemPlusJSONResponse
}

func (response FindManyOrganizations401ApplicationProblemPlusJSONResponse) VisitFindManyOrganizationsResponse(w http.ResponseWriter) error <span class="cov0" title="0">{
        w.Header().Set("Content-Type", "application/problem+json")
        w.WriteHeader(401)

        return json.NewEncoder(w).Encode(response)
}</span>

type CreateOrganizationRequestObject struct {
        Body *CreateOrganizationJSONRequestBody
}

type CreateOrganizationResponseObject interface {
        VisitCreateOrganizationResponse(w http.ResponseWriter) error
}

type CreateOrganization201JSONResponse struct {
        // Data Schema for Organization entity
        Data Organization `json:"data"`
}

func (response CreateOrganization201JSONResponse) VisitCreateOrganizationResponse(w http.ResponseWriter) error <span class="cov0" title="0">{
        w.Header().Set("Content-Type", "application/json")
        w.WriteHeader(201)

        return json.NewEncoder(w).Encode(response)
}</span>

type CreateOrganization400ApplicationProblemPlusJSONResponse struct {
        BadRequestApplicationProblemPlusJSONResponse
}

func (response CreateOrganization400ApplicationProblemPlusJSONResponse) VisitCreateOrganizationResponse(w http.ResponseWriter) error <span class="cov0" title="0">{
        w.Header().Set("Content-Type", "application/problem+json")
        w.WriteHeader(400)

        return json.NewEncoder(w).Encode(response)
}</span>

type CreateOrganization401ApplicationProblemPlusJSONResponse struct {
        UnauthorizedApplicationProblemPlusJSONResponse
}

func (response CreateOrganization401ApplicationProblemPlusJSONResponse) VisitCreateOrganizationResponse(w http.ResponseWriter) error <span class="cov0" title="0">{
        w.Header().Set("Content-Type", "application/problem+json")
        w.WriteHeader(401)

        return json.NewEncoder(w).Encode(response)
}</span>

type DeleteOrganizationRequestObject struct {
        Id openapi_types.UUID `json:"id"`
}

type DeleteOrganizationResponseObject interface {
        VisitDeleteOrganizationResponse(w http.ResponseWriter) error
}

type DeleteOrganization200JSONResponse struct {
        // Data Schema for Organization entity
        Data Organization `json:"data"`
}

func (response DeleteOrganization200JSONResponse) VisitDeleteOrganizationResponse(w http.ResponseWriter) error <span class="cov0" title="0">{
        w.Header().Set("Content-Type", "application/json")
        w.WriteHeader(200)

        return json.NewEncoder(w).Encode(response)
}</span>

type DeleteOrganization404ApplicationProblemPlusJSONResponse struct {
        NotFoundApplicationProblemPlusJSONResponse
}

func (response DeleteOrganization404ApplicationProblemPlusJSONResponse) VisitDeleteOrganizationResponse(w http.ResponseWriter) error <span class="cov0" title="0">{
        w.Header().Set("Content-Type", "application/problem+json")
        w.WriteHeader(404)

        return json.NewEncoder(w).Encode(response)
}</span>

type GetOneOrganizationRequestObject struct {
        Id openapi_types.UUID `json:"id"`
}

type GetOneOrganizationResponseObject interface {
        VisitGetOneOrganizationResponse(w http.ResponseWriter) error
}

type GetOneOrganization200JSONResponse struct {
        // Data Schema for Organization entity
        Data Organization `json:"data"`
}

func (response GetOneOrganization200JSONResponse) VisitGetOneOrganizationResponse(w http.ResponseWriter) error <span class="cov0" title="0">{
        w.Header().Set("Content-Type", "application/json")
        w.WriteHeader(200)

        return json.NewEncoder(w).Encode(response)
}</span>

type GetOneOrganization404ApplicationProblemPlusJSONResponse struct {
        NotFoundApplicationProblemPlusJSONResponse
}

func (response GetOneOrganization404ApplicationProblemPlusJSONResponse) VisitGetOneOrganizationResponse(w http.ResponseWriter) error <span class="cov0" title="0">{
        w.Header().Set("Content-Type", "application/problem+json")
        w.WriteHeader(404)

        return json.NewEncoder(w).Encode(response)
}</span>

type UpdateOrganizationRequestObject struct {
        Id   openapi_types.UUID `json:"id"`
        Body *UpdateOrganizationJSONRequestBody
}

type UpdateOrganizationResponseObject interface {
        VisitUpdateOrganizationResponse(w http.ResponseWriter) error
}

type UpdateOrganization200JSONResponse struct {
        // Data Schema for Organization entity
        Data Organization `json:"data"`
}

func (response UpdateOrganization200JSONResponse) VisitUpdateOrganizationResponse(w http.ResponseWriter) error <span class="cov0" title="0">{
        w.Header().Set("Content-Type", "application/json")
        w.WriteHeader(200)

        return json.NewEncoder(w).Encode(response)
}</span>

type UpdateOrganization404ApplicationProblemPlusJSONResponse struct {
        NotFoundApplicationProblemPlusJSONResponse
}

func (response UpdateOrganization404ApplicationProblemPlusJSONResponse) VisitUpdateOrganizationResponse(w http.ResponseWriter) error <span class="cov0" title="0">{
        w.Header().Set("Content-Type", "application/problem+json")
        w.WriteHeader(404)

        return json.NewEncoder(w).Encode(response)
}</span>

// StrictServerInterface represents all server handlers.
type StrictServerInterface interface {
        // Find many organizations
        // (GET /organizations)
        FindManyOrganizations(ctx context.Context, request FindManyOrganizationsRequestObject) (FindManyOrganizationsResponseObject, error)
        // Create a new organization
        // (POST /organizations)
        CreateOrganization(ctx context.Context, request CreateOrganizationRequestObject) (CreateOrganizationResponseObject, error)
        // Delete an organization
        // (DELETE /organizations/{id})
        DeleteOrganization(ctx context.Context, request DeleteOrganizationRequestObject) (DeleteOrganizationResponseObject, error)
        // Find an organization
        // (GET /organizations/{id})
        GetOneOrganization(ctx context.Context, request GetOneOrganizationRequestObject) (GetOneOrganizationResponseObject, error)
        // Update an organization
        // (PATCH /organizations/{id})
        UpdateOrganization(ctx context.Context, request UpdateOrganizationRequestObject) (UpdateOrganizationResponseObject, error)
}

type StrictHandlerFunc = strictecho.StrictEchoHandlerFunc
type StrictMiddlewareFunc = strictecho.StrictEchoMiddlewareFunc

func NewStrictHandler(ssi StrictServerInterface, middlewares []StrictMiddlewareFunc) ServerInterface <span class="cov0" title="0">{
        return &amp;strictHandler{ssi: ssi, middlewares: middlewares}
}</span>

type strictHandler struct {
        ssi         StrictServerInterface
        middlewares []StrictMiddlewareFunc
}

// FindManyOrganizations operation middleware
func (sh *strictHandler) FindManyOrganizations(ctx echo.Context, params FindManyOrganizationsParams) error <span class="cov0" title="0">{
        var request FindManyOrganizationsRequestObject

        request.Params = params

        handler := func(ctx echo.Context, request interface{}) (interface{}, error) </span><span class="cov0" title="0">{
                return sh.ssi.FindManyOrganizations(ctx.Request().Context(), request.(FindManyOrganizationsRequestObject))
        }</span>
        <span class="cov0" title="0">for _, middleware := range sh.middlewares </span><span class="cov0" title="0">{
                handler = middleware(handler, "FindManyOrganizations")
        }</span>

        <span class="cov0" title="0">response, err := handler(ctx, request)

        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span> else<span class="cov0" title="0"> if validResponse, ok := response.(FindManyOrganizationsResponseObject); ok </span><span class="cov0" title="0">{
                return validResponse.VisitFindManyOrganizationsResponse(ctx.Response())
        }</span> else<span class="cov0" title="0"> if response != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("unexpected response type: %T", response)
        }</span>
        <span class="cov0" title="0">return nil</span>
}

// CreateOrganization operation middleware
func (sh *strictHandler) CreateOrganization(ctx echo.Context) error <span class="cov0" title="0">{
        var request CreateOrganizationRequestObject

        var body CreateOrganizationJSONRequestBody
        if err := ctx.Bind(&amp;body); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov0" title="0">request.Body = &amp;body

        handler := func(ctx echo.Context, request interface{}) (interface{}, error) </span><span class="cov0" title="0">{
                return sh.ssi.CreateOrganization(ctx.Request().Context(), request.(CreateOrganizationRequestObject))
        }</span>
        <span class="cov0" title="0">for _, middleware := range sh.middlewares </span><span class="cov0" title="0">{
                handler = middleware(handler, "CreateOrganization")
        }</span>

        <span class="cov0" title="0">response, err := handler(ctx, request)

        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span> else<span class="cov0" title="0"> if validResponse, ok := response.(CreateOrganizationResponseObject); ok </span><span class="cov0" title="0">{
                return validResponse.VisitCreateOrganizationResponse(ctx.Response())
        }</span> else<span class="cov0" title="0"> if response != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("unexpected response type: %T", response)
        }</span>
        <span class="cov0" title="0">return nil</span>
}

// DeleteOrganization operation middleware
func (sh *strictHandler) DeleteOrganization(ctx echo.Context, id openapi_types.UUID) error <span class="cov0" title="0">{
        var request DeleteOrganizationRequestObject

        request.Id = id

        handler := func(ctx echo.Context, request interface{}) (interface{}, error) </span><span class="cov0" title="0">{
                return sh.ssi.DeleteOrganization(ctx.Request().Context(), request.(DeleteOrganizationRequestObject))
        }</span>
        <span class="cov0" title="0">for _, middleware := range sh.middlewares </span><span class="cov0" title="0">{
                handler = middleware(handler, "DeleteOrganization")
        }</span>

        <span class="cov0" title="0">response, err := handler(ctx, request)

        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span> else<span class="cov0" title="0"> if validResponse, ok := response.(DeleteOrganizationResponseObject); ok </span><span class="cov0" title="0">{
                return validResponse.VisitDeleteOrganizationResponse(ctx.Response())
        }</span> else<span class="cov0" title="0"> if response != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("unexpected response type: %T", response)
        }</span>
        <span class="cov0" title="0">return nil</span>
}

// GetOneOrganization operation middleware
func (sh *strictHandler) GetOneOrganization(ctx echo.Context, id openapi_types.UUID) error <span class="cov0" title="0">{
        var request GetOneOrganizationRequestObject

        request.Id = id

        handler := func(ctx echo.Context, request interface{}) (interface{}, error) </span><span class="cov0" title="0">{
                return sh.ssi.GetOneOrganization(ctx.Request().Context(), request.(GetOneOrganizationRequestObject))
        }</span>
        <span class="cov0" title="0">for _, middleware := range sh.middlewares </span><span class="cov0" title="0">{
                handler = middleware(handler, "GetOneOrganization")
        }</span>

        <span class="cov0" title="0">response, err := handler(ctx, request)

        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span> else<span class="cov0" title="0"> if validResponse, ok := response.(GetOneOrganizationResponseObject); ok </span><span class="cov0" title="0">{
                return validResponse.VisitGetOneOrganizationResponse(ctx.Response())
        }</span> else<span class="cov0" title="0"> if response != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("unexpected response type: %T", response)
        }</span>
        <span class="cov0" title="0">return nil</span>
}

// UpdateOrganization operation middleware
func (sh *strictHandler) UpdateOrganization(ctx echo.Context, id openapi_types.UUID) error <span class="cov0" title="0">{
        var request UpdateOrganizationRequestObject

        request.Id = id

        var body UpdateOrganizationJSONRequestBody
        if err := ctx.Bind(&amp;body); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov0" title="0">request.Body = &amp;body

        handler := func(ctx echo.Context, request interface{}) (interface{}, error) </span><span class="cov0" title="0">{
                return sh.ssi.UpdateOrganization(ctx.Request().Context(), request.(UpdateOrganizationRequestObject))
        }</span>
        <span class="cov0" title="0">for _, middleware := range sh.middlewares </span><span class="cov0" title="0">{
                handler = middleware(handler, "UpdateOrganization")
        }</span>

        <span class="cov0" title="0">response, err := handler(ctx, request)

        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span> else<span class="cov0" title="0"> if validResponse, ok := response.(UpdateOrganizationResponseObject); ok </span><span class="cov0" title="0">{
                return validResponse.VisitUpdateOrganizationResponse(ctx.Response())
        }</span> else<span class="cov0" title="0"> if response != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("unexpected response type: %T", response)
        }</span>
        <span class="cov0" title="0">return nil</span>
}
</pre>
		
		<pre class="file" id="file110" style="display: none">// Code generated by codegen repository. DO NOT EDIT.
package organizations

import (
        "context"
        "errors"

        "github.com/archesai/archesai/internal/database/postgresql"
        "github.com/google/uuid"
        "github.com/jackc/pgx/v5/pgxpool"
)

// PostgresRepository implements Repository using PostgreSQL.
type PostgresRepository struct {
        db      *pgxpool.Pool
        queries *postgresql.Queries
}

// NewPostgresRepository creates a new PostgreSQL repository.
func NewPostgresRepository(db *pgxpool.Pool) Repository <span class="cov0" title="0">{
        return &amp;PostgresRepository{
                db:      db,
                queries: postgresql.New(db),
        }
}</span>

// Organization operations

func (r *PostgresRepository) Create(ctx context.Context, entity *Organization) (*Organization, error) <span class="cov0" title="0">{
        // Check if SQLC has the CreateOrganization method
        // For now, we'll generate a stub but with proper error handling
        // TODO: Parse SQLC to detect available queries

        // Example of what it should look like when SQLC query exists:
        // params := postgresql.CreateOrganizationParams{
        //     Id: entity.Id,
        //     // ... map other fields
        // }
        // dbOrganization, err := r.queries.CreateOrganization(ctx, params)
        // if err != nil {
        //     return nil, NewRepositoryError("create", err)
        // }
        // return mapOrganizationToDomain(&amp;dbOrganization), nil

        return nil, NewRepositoryError("create", errors.New("not implemented - SQLC query not found"))
}</span>

func (r *PostgresRepository) Get(ctx context.Context, id uuid.UUID) (*Organization, error) <span class="cov0" title="0">{
        // Try to call SQLC GetOrganization if it exists
        // For now, return not implemented
        return nil, NewRepositoryError("get", errors.New("not implemented - SQLC query not found"))
}</span>

func (r *PostgresRepository) Update(ctx context.Context, id uuid.UUID, entity *Organization) (*Organization, error) <span class="cov0" title="0">{
        // Update operations are often custom and may not have SQLC queries
        return nil, NewRepositoryError("update", errors.New("not implemented - SQLC query not found"))
}</span>

func (r *PostgresRepository) Delete(ctx context.Context, id uuid.UUID) error <span class="cov0" title="0">{
        // Try to call SQLC DeleteOrganization if it exists
        // For now, return not implemented
        return NewRepositoryError("delete", errors.New("not implemented - SQLC query not found"))
}</span>

func (r *PostgresRepository) List(ctx context.Context, params ListOrganizationsParams) ([]*Organization, int64, error) <span class="cov0" title="0">{
        // List operations need both List and Count queries from SQLC
        return nil, 0, NewRepositoryError("list", errors.New("not implemented - SQLC query not found"))
}</span>

// GetBySlug retrieves organization by slug
func (r *PostgresRepository) GetBySlug(ctx context.Context, slug string) (*Organization, error) <span class="cov0" title="0">{

        // Try to call SQLC GetBySlug if it exists
        // For now, return not implemented
        return nil, NewRepositoryError("getbyslug", errors.New("not implemented - SQLC query not found"))

}</span>

// GetByStripeCustomerId retrieves organization by stripeCustomerId
func (r *PostgresRepository) GetByStripeCustomerId(ctx context.Context, stripeCustomerId string) (*Organization, error) <span class="cov0" title="0">{

        // Try to call SQLC GetByStripeCustomerId if it exists
        // For now, return not implemented
        return nil, NewRepositoryError("getbystripecustomerid", errors.New("not implemented - SQLC query not found"))

}</span>

// Mapper functions - Convert between domain types and database types
// These need to be customized based on the actual field mappings

func mapOrganizationToDomain(db *postgresql.Organization) *Organization <span class="cov0" title="0">{
        if db == nil </span><span class="cov0" title="0">{
                return nil
        }</span>

        // This is a basic mapping - needs to be customized based on actual types
        // The challenge is that OpenAPI types and database types don't always match
        // For example:
        // - OpenAPI might use string, database uses *string
        // - OpenAPI might use custom UUID type, database uses uuid.UUID
        // - Field names might differ (Id vs ID)

        <span class="cov0" title="0">result := &amp;Organization{
                // TODO: Map fields properly based on actual type definitions
                // This requires parsing both OpenAPI types and SQLC types
        }

        // Basic field mapping - customize based on your entity structure
        // result.Id = db.Id
        // result.CreatedAt = db.CreatedAt
        // result.UpdatedAt = db.UpdatedAt
        // Add specific field mappings as needed

        return result</span>
}
</pre>
		
		<pre class="file" id="file111" style="display: none">// Code generated by codegen repository. DO NOT EDIT.
package organizations

import (
        "context"
        "fmt"
        "github.com/google/uuid"
)

// Repository handles organization persistence
type Repository interface {
        Create(ctx context.Context, entity *Organization) (*Organization, error)
        Get(ctx context.Context, id uuid.UUID) (*Organization, error)
        Update(ctx context.Context, id uuid.UUID, entity *Organization) (*Organization, error)
        Delete(ctx context.Context, id uuid.UUID) error
        List(ctx context.Context, params ListOrganizationsParams) ([]*Organization, int64, error)

        // Additional operations
        GetBySlug(ctx context.Context, slug string) (*Organization, error)
        GetByStripeCustomerId(ctx context.Context, stripeCustomerId string) (*Organization, error)
}

// ListOrganizationsParams represents parameters for listing organizations.
type ListOrganizationsParams struct {
        Limit  int
        Offset int
}

// RepositoryError represents a repository error.
type RepositoryError struct {
        Operation string
        Err       error
}

func (e *RepositoryError) Error() string <span class="cov0" title="0">{
        return fmt.Sprintf("repository %s: %v", e.Operation, e.Err)
}</span>

func (e *RepositoryError) Unwrap() error <span class="cov0" title="0">{
        return e.Err
}</span>

// NewRepositoryError creates a new repository error.
func NewRepositoryError(operation string, err error) *RepositoryError <span class="cov0" title="0">{
        return &amp;RepositoryError{
                Operation: operation,
                Err:       err,
        }
}</span>
</pre>
		
		<pre class="file" id="file112" style="display: none">package organizations

import (
        "context"
        "fmt"
        "log/slog"
        "time"

        "github.com/google/uuid"
        openapi_types "github.com/oapi-codegen/runtime/types"
)

// Service provides organization business logic
type Service struct {
        repository Repository
        logger     *slog.Logger
}

// NewService creates a new organization service
func NewService(repository Repository, logger *slog.Logger) *Service <span class="cov10" title="12">{
        return &amp;Service{
                repository: repository,
                logger:     logger,
        }
}</span>

// Create creates a new organization
func (s *Service) Create(ctx context.Context, req *CreateOrganizationRequest, creatorUserID string) (*Organization, error) <span class="cov3" title="2">{
        s.logger.Debug("creating organization", "id", req.OrganizationId, "creator", creatorUserID)

        // Set default plan
        plan := OrganizationPlan(DefaultPlan)

        org := &amp;Organization{
                Id:           req.OrganizationId,
                Name:         "", // Name should be set from somewhere else
                BillingEmail: openapi_types.Email(req.BillingEmail),
                Plan:         plan,
                Credits:      0.0, // Start with 0 credits
                CreatedAt:    time.Now(),
                UpdatedAt:    time.Now(),
        }

        createdOrg, err := s.repository.Create(ctx, org)
        if err != nil </span><span class="cov1" title="1">{
                s.logger.Error("failed to create organization", "error", err)
                return nil, fmt.Errorf("failed to create organization: %w", err)
        }</span>

        <span class="cov1" title="1">s.logger.Info("organization created successfully", "id", createdOrg.Id, "name", createdOrg.Name)
        return createdOrg, nil</span>
}

// Get retrieves an organization by ID
func (s *Service) Get(ctx context.Context, id uuid.UUID) (*Organization, error) <span class="cov3" title="2">{
        org, err := s.repository.Get(ctx, id)
        if err != nil </span><span class="cov1" title="1">{
                return nil, fmt.Errorf("failed to get organization: %w", err)
        }</span>
        <span class="cov1" title="1">return org, nil</span>
}

// Update updates an organization
func (s *Service) Update(ctx context.Context, id uuid.UUID, req *UpdateOrganizationRequest) (*Organization, error) <span class="cov4" title="3">{
        org, err := s.repository.Get(ctx, id)
        if err != nil </span><span class="cov1" title="1">{
                return nil, fmt.Errorf("failed to get organization: %w", err)
        }</span>

        // Update fields that were provided
        <span class="cov3" title="2">if req.BillingEmail != "" </span><span class="cov3" title="2">{
                org.BillingEmail = openapi_types.Email(req.BillingEmail)
        }</span>
        <span class="cov3" title="2">org.UpdatedAt = time.Now()

        updatedOrg, err := s.repository.Update(ctx, org.Id, org)
        if err != nil </span><span class="cov1" title="1">{
                return nil, fmt.Errorf("failed to update organization: %w", err)
        }</span>

        <span class="cov1" title="1">return updatedOrg, nil</span>
}

// Delete deletes an organization
func (s *Service) Delete(ctx context.Context, id uuid.UUID) error <span class="cov3" title="2">{
        // TODO: Add additional checks (e.g., organization has no active resources)
        err := s.repository.Delete(ctx, id)
        if err != nil </span><span class="cov1" title="1">{
                return fmt.Errorf("failed to delete organization: %w", err)
        }</span>
        <span class="cov1" title="1">return nil</span>
}

// List retrieves a list of organizations
func (s *Service) List(ctx context.Context, limit, offset int) ([]*Organization, int, error) <span class="cov4" title="3">{
        orgs, totalInt64, err := s.repository.List(ctx, ListOrganizationsParams{Limit: limit, Offset: offset})
        total := int(totalInt64)
        if err != nil </span><span class="cov1" title="1">{
                return nil, 0, fmt.Errorf("failed to list organizations: %w", err)
        }</span>
        <span class="cov3" title="2">return orgs, total, nil</span>
}
</pre>
		
		<pre class="file" id="file113" style="display: none">// Code generated by codegen repository. DO NOT EDIT.
package organizations

import (
        "context"
        "database/sql"
        "fmt"

        "github.com/archesai/archesai/internal/database/sqlite"
        "github.com/google/uuid"
)

// SQLiteRepository implements Repository using SQLite.
type SQLiteRepository struct {
        db      *sql.DB
        queries *sqlite.Queries
}

// NewSQLiteRepository creates a new SQLite repository.
func NewSQLiteRepository(db *sql.DB) Repository <span class="cov0" title="0">{
        return &amp;SQLiteRepository{
                db:      db,
                queries: sqlite.New(db),
        }
}</span>

// Organization operations

func (r *SQLiteRepository) Create(ctx context.Context, entity *Organization) (*Organization, error) <span class="cov0" title="0">{
        // For now, return a basic implementation
        // Actual implementation would need to be customized per entity
        return nil, fmt.Errorf("CreateOrganization not yet implemented - requires custom mapping")
}</span>

func (r *SQLiteRepository) Get(ctx context.Context, id uuid.UUID) (*Organization, error) <span class="cov0" title="0">{
        // For now, return a basic implementation
        // Actual implementation would need to be customized per entity
        return nil, fmt.Errorf("GetOrganization not yet implemented - requires custom mapping")
}</span>

func (r *SQLiteRepository) Update(ctx context.Context, id uuid.UUID, entity *Organization) (*Organization, error) <span class="cov0" title="0">{
        // For now, return a basic implementation
        // Actual implementation would need to be customized per entity
        return nil, fmt.Errorf("UpdateOrganization not yet implemented - requires custom mapping")
}</span>

func (r *SQLiteRepository) Delete(ctx context.Context, id uuid.UUID) error <span class="cov0" title="0">{
        // For now, return a basic implementation
        // Actual implementation would need to be customized per entity
        return fmt.Errorf("DeleteOrganization not yet implemented - requires custom mapping")
}</span>

func (r *SQLiteRepository) List(ctx context.Context, params ListOrganizationsParams) ([]*Organization, int64, error) <span class="cov0" title="0">{
        // For now, return a basic implementation
        // Actual implementation would need to be customized per entity
        return nil, 0, fmt.Errorf("ListOrganizations not yet implemented - requires custom mapping")
}</span>

// GetBySlug retrieves organization by slug
func (r *SQLiteRepository) GetBySlug(ctx context.Context, slug string) (*Organization, error) <span class="cov0" title="0">{

        // For now, return a basic implementation
        return nil, fmt.Errorf("GetBySlug not yet implemented - requires custom mapping")

}</span>

// GetByStripeCustomerId retrieves organization by stripeCustomerId
func (r *SQLiteRepository) GetByStripeCustomerId(ctx context.Context, stripeCustomerId string) (*Organization, error) <span class="cov0" title="0">{

        // For now, return a basic implementation
        return nil, fmt.Errorf("GetByStripeCustomerId not yet implemented - requires custom mapping")

}</span>
</pre>
		
		<pre class="file" id="file114" style="display: none">// Package organizations provides primitives to interact with the openapi HTTP API.
//
// Code generated by github.com/oapi-codegen/oapi-codegen/v2 version v2.5.0 DO NOT EDIT.
package organizations

import (
        "encoding/json"
        "time"

        "github.com/google/uuid"
        "github.com/oapi-codegen/runtime"
        openapi_types "github.com/oapi-codegen/runtime/types"
)

const (
        BearerAuthScopes = "bearerAuth.Scopes"
)

// Defines values for OrganizationPlan.
const (
        BASIC     OrganizationPlan = "BASIC"
        FREE      OrganizationPlan = "FREE"
        PREMIUM   OrganizationPlan = "PREMIUM"
        STANDARD  OrganizationPlan = "STANDARD"
        UNLIMITED OrganizationPlan = "UNLIMITED"
)

// Defines values for FindManyOrganizationsParamsSortField.
const (
        BillingEmail     FindManyOrganizationsParamsSortField = "billingEmail"
        CreatedAt        FindManyOrganizationsParamsSortField = "createdAt"
        Credits          FindManyOrganizationsParamsSortField = "credits"
        Id               FindManyOrganizationsParamsSortField = "id"
        Logo             FindManyOrganizationsParamsSortField = "logo"
        Metadata         FindManyOrganizationsParamsSortField = "metadata"
        Name             FindManyOrganizationsParamsSortField = "name"
        Plan             FindManyOrganizationsParamsSortField = "plan"
        Slug             FindManyOrganizationsParamsSortField = "slug"
        StripeCustomerId FindManyOrganizationsParamsSortField = "stripeCustomerId"
        UpdatedAt        FindManyOrganizationsParamsSortField = "updatedAt"
)

// Defines values for FindManyOrganizationsParamsSortOrder.
const (
        Asc  FindManyOrganizationsParamsSortOrder = "asc"
        Desc FindManyOrganizationsParamsSortOrder = "desc"
)

// Base defines model for Base.
type Base struct {
        // CreatedAt The date and time when the resource was created
        CreatedAt time.Time `json:"createdAt" yaml:"createdAt"`

        // Id Universally Unique Identifier
        Id UUID `json:"id" yaml:"id"`

        // UpdatedAt The date and time when the resource was last updated
        UpdatedAt time.Time `json:"updatedAt" yaml:"updatedAt"`
}

// FilterNode A recursive filter node that can be a condition or group
type FilterNode = interface{}

// Organization defines model for Organization.
type Organization struct {
        // BillingEmail Email address for billing communications
        BillingEmail openapi_types.Email `json:"billingEmail,omitempty,omitzero" yaml:"billingEmail,omitempty"`

        // CreatedAt The date and time when the resource was created
        CreatedAt time.Time `json:"createdAt" yaml:"createdAt"`

        // Credits Available credits for this organization
        Credits float32 `json:"credits" yaml:"credits"`

        // Id Universally Unique Identifier
        Id UUID `json:"id" yaml:"id"`

        // Logo The organization's logo URL
        Logo string `json:"logo,omitempty,omitzero" yaml:"logo,omitempty"`

        // Metadata Custom metadata in JSON format
        Metadata map[string]interface{} `json:"metadata" yaml:"metadata"`

        // Name The organization's display name
        Name string `json:"name" yaml:"name"`

        // Plan The current subscription plan
        Plan OrganizationPlan `json:"plan" yaml:"plan"`

        // Slug URL-friendly unique identifier for the organization
        Slug string `json:"slug" yaml:"slug"`

        // StripeCustomerId Stripe customer identifier
        StripeCustomerId string `json:"stripeCustomerId,omitempty,omitzero" yaml:"stripeCustomerId,omitempty"`

        // UpdatedAt The date and time when the resource was last updated
        UpdatedAt time.Time `json:"updatedAt" yaml:"updatedAt"`
}

// OrganizationPlan The current subscription plan
type OrganizationPlan string

// Page Pagination (page number &amp; size)
type Page struct {
        Number int `json:"number,omitempty,omitzero" yaml:"number,omitempty"`
        Size   int `json:"size,omitempty,omitzero" yaml:"size,omitempty"`
}

// Problem RFC 7807 (Problem Details) compliant error response
type Problem struct {
        // Detail Human-readable explanation specific to this occurrence
        Detail string `json:"detail" yaml:"detail"`

        // Errors Additional validation errors for specific fields
        Errors []ValidationError `json:"errors,omitempty,omitzero" yaml:"errors,omitempty"`

        // Instance URI identifying the specific occurrence
        Instance string `json:"instance,omitempty,omitzero" yaml:"instance,omitempty"`

        // Status HTTP status code
        Status int `json:"status" yaml:"status"`

        // Title Short, human-readable summary
        Title string `json:"title" yaml:"title"`

        // Type URI identifying the problem type
        Type string `json:"type" yaml:"type"`
}

// UUID Universally Unique Identifier
type UUID = uuid.UUID

// ValidationError Individual field validation error
type ValidationError struct {
        // Field The field path that failed validation
        Field string `json:"field" yaml:"field"`

        // Message Human-readable error message
        Message string `json:"message" yaml:"message"`

        // Value The invalid value that was provided
        Value ValidationError_Value `json:"value,omitempty,omitzero" yaml:"value,omitempty"`
}

// ValidationErrorValue0 defines model for .
type ValidationErrorValue0 = string

// ValidationErrorValue1 defines model for .
type ValidationErrorValue1 = float32

// ValidationErrorValue2 defines model for .
type ValidationErrorValue2 = bool

// ValidationError_Value The invalid value that was provided
type ValidationError_Value struct {
        union json.RawMessage
}

// OrganizationsFilter A recursive filter node that can be a condition or group
type OrganizationsFilter = FilterNode

// OrganizationsSort defines model for OrganizationsSort.
type OrganizationsSort = []struct {
        Field string `json:"field" yaml:"field"`
        Order string `json:"order" yaml:"order"`
}

// PageQuery Pagination (page number &amp; size)
type PageQuery = Page

// BadRequest RFC 7807 (Problem Details) compliant error response
type BadRequest = Problem

// NotFound RFC 7807 (Problem Details) compliant error response
type NotFound = Problem

// Unauthorized RFC 7807 (Problem Details) compliant error response
type Unauthorized = Problem

// FindManyOrganizationsParams defines parameters for FindManyOrganizations.
type FindManyOrganizationsParams struct {
        // Filter Filter organizations by field values. Supported fields:
        // - createdAt, id, updatedAt, billingEmail, credits, logo
        // - metadata, name, plan, slug, stripeCustomerId
        Filter OrganizationsFilter `json:"filter,omitempty,omitzero" yaml:"filter,omitempty"`

        // Page The page parameter
        Page PageQuery `form:"page,omitempty" json:"page,omitempty,omitzero" yaml:"page,omitempty"`

        // Sort The sort parameter
        Sort OrganizationsSort `form:"sort,omitempty" json:"sort,omitempty,omitzero" yaml:"sort,omitempty"`
}

// FindManyOrganizationsParamsSortField defines parameters for FindManyOrganizations.
type FindManyOrganizationsParamsSortField string

// FindManyOrganizationsParamsSortOrder defines parameters for FindManyOrganizations.
type FindManyOrganizationsParamsSortOrder string

// CreateOrganizationJSONBody defines parameters for CreateOrganization.
type CreateOrganizationJSONBody struct {
        // BillingEmail The billing email to use for the organization
        BillingEmail string `json:"billingEmail" yaml:"billingEmail"`

        // OrganizationId The ID of the item
        OrganizationId openapi_types.UUID `json:"organizationId" yaml:"organizationId"`
}

// UpdateOrganizationJSONBody defines parameters for UpdateOrganization.
type UpdateOrganizationJSONBody struct {
        // BillingEmail The billing email to use for the organization
        BillingEmail string `json:"billingEmail,omitempty,omitzero" yaml:"billingEmail,omitempty"`

        // OrganizationId The ID of the item
        OrganizationId openapi_types.UUID `json:"organizationId,omitempty,omitzero" yaml:"organizationId,omitempty"`
}

// CreateOrganizationJSONRequestBody defines body for CreateOrganization for application/json ContentType.
type CreateOrganizationJSONRequestBody CreateOrganizationJSONBody

// UpdateOrganizationJSONRequestBody defines body for UpdateOrganization for application/json ContentType.
type UpdateOrganizationJSONRequestBody UpdateOrganizationJSONBody

// AsValidationErrorValue0 returns the union data inside the ValidationError_Value as a ValidationErrorValue0
func (t ValidationError_Value) AsValidationErrorValue0() (ValidationErrorValue0, error) <span class="cov0" title="0">{
        var body ValidationErrorValue0
        err := json.Unmarshal(t.union, &amp;body)
        return body, err
}</span>

// FromValidationErrorValue0 overwrites any union data inside the ValidationError_Value as the provided ValidationErrorValue0
func (t *ValidationError_Value) FromValidationErrorValue0(v ValidationErrorValue0) error <span class="cov0" title="0">{
        b, err := json.Marshal(v)
        t.union = b
        return err
}</span>

// MergeValidationErrorValue0 performs a merge with any union data inside the ValidationError_Value, using the provided ValidationErrorValue0
func (t *ValidationError_Value) MergeValidationErrorValue0(v ValidationErrorValue0) error <span class="cov0" title="0">{
        b, err := json.Marshal(v)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov0" title="0">merged, err := runtime.JSONMerge(t.union, b)
        t.union = merged
        return err</span>
}

// AsValidationErrorValue1 returns the union data inside the ValidationError_Value as a ValidationErrorValue1
func (t ValidationError_Value) AsValidationErrorValue1() (ValidationErrorValue1, error) <span class="cov0" title="0">{
        var body ValidationErrorValue1
        err := json.Unmarshal(t.union, &amp;body)
        return body, err
}</span>

// FromValidationErrorValue1 overwrites any union data inside the ValidationError_Value as the provided ValidationErrorValue1
func (t *ValidationError_Value) FromValidationErrorValue1(v ValidationErrorValue1) error <span class="cov0" title="0">{
        b, err := json.Marshal(v)
        t.union = b
        return err
}</span>

// MergeValidationErrorValue1 performs a merge with any union data inside the ValidationError_Value, using the provided ValidationErrorValue1
func (t *ValidationError_Value) MergeValidationErrorValue1(v ValidationErrorValue1) error <span class="cov0" title="0">{
        b, err := json.Marshal(v)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov0" title="0">merged, err := runtime.JSONMerge(t.union, b)
        t.union = merged
        return err</span>
}

// AsValidationErrorValue2 returns the union data inside the ValidationError_Value as a ValidationErrorValue2
func (t ValidationError_Value) AsValidationErrorValue2() (ValidationErrorValue2, error) <span class="cov0" title="0">{
        var body ValidationErrorValue2
        err := json.Unmarshal(t.union, &amp;body)
        return body, err
}</span>

// FromValidationErrorValue2 overwrites any union data inside the ValidationError_Value as the provided ValidationErrorValue2
func (t *ValidationError_Value) FromValidationErrorValue2(v ValidationErrorValue2) error <span class="cov0" title="0">{
        b, err := json.Marshal(v)
        t.union = b
        return err
}</span>

// MergeValidationErrorValue2 performs a merge with any union data inside the ValidationError_Value, using the provided ValidationErrorValue2
func (t *ValidationError_Value) MergeValidationErrorValue2(v ValidationErrorValue2) error <span class="cov0" title="0">{
        b, err := json.Marshal(v)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov0" title="0">merged, err := runtime.JSONMerge(t.union, b)
        t.union = merged
        return err</span>
}

func (t ValidationError_Value) MarshalJSON() ([]byte, error) <span class="cov0" title="0">{
        b, err := t.union.MarshalJSON()
        return b, err
}</span>

func (t *ValidationError_Value) UnmarshalJSON(b []byte) error <span class="cov0" title="0">{
        err := t.union.UnmarshalJSON(b)
        return err
}</span>
</pre>
		
		<pre class="file" id="file115" style="display: none">package pipelines

import (
        "context"
        "fmt"
        "sync"

        "github.com/archesai/archesai/internal/tools"
        "github.com/google/uuid"
)

// DAGNode represents a node in the workflow DAG
type DAGNode struct {
        ID           uuid.UUID
        Step         *PipelineStep
        Dependencies []*DAGNode
        Dependents   []*DAGNode
        Status       NodeStatus
        Result       interface{}
        Error        error
}

// NodeStatus represents the execution status of a DAG node
type NodeStatus int

// Node status constants
const (
        NodeStatusPending   NodeStatus = iota // Node is waiting for dependencies
        NodeStatusReady                       // Node is ready to execute
        NodeStatusRunning                     // Node is currently executing
        NodeStatusCompleted                   // Node completed successfully
        NodeStatusFailed                      // Node execution failed
        NodeStatusSkipped                     // Node was skipped due to upstream failure
)

// DAG represents a Directed Acyclic Graph for workflow execution
type DAG struct {
        Nodes     map[uuid.UUID]*DAGNode
        RootNodes []*DAGNode // Nodes with no dependencies
        mu        sync.RWMutex
}

// NewDAG creates a new DAG from pipeline steps
func NewDAG(steps []PipelineStep, dependencies map[uuid.UUID][]uuid.UUID) (*DAG, error) <span class="cov7" title="15">{
        dag := &amp;DAG{
                Nodes:     make(map[uuid.UUID]*DAGNode),
                RootNodes: []*DAGNode{},
        }

        // Create nodes
        for i := range steps </span><span class="cov10" title="43">{
                step := &amp;steps[i]
                node := &amp;DAGNode{
                        ID:           step.Id,
                        Step:         step,
                        Dependencies: []*DAGNode{},
                        Dependents:   []*DAGNode{},
                        Status:       NodeStatusPending,
                }
                dag.Nodes[step.Id] = node
        }</span>

        // Build edges
        <span class="cov7" title="15">for nodeID, depIDs := range dependencies </span><span class="cov9" title="30">{
                node, exists := dag.Nodes[nodeID]
                if !exists </span><span class="cov0" title="0">{
                        return nil, fmt.Errorf("node %s not found", nodeID)
                }</span>

                <span class="cov9" title="30">for _, depID := range depIDs </span><span class="cov9" title="35">{
                        depNode, exists := dag.Nodes[depID]
                        if !exists </span><span class="cov1" title="1">{
                                return nil, fmt.Errorf("dependency %s not found for node %s", depID, nodeID)
                        }</span>

                        <span class="cov9" title="34">node.Dependencies = append(node.Dependencies, depNode)
                        depNode.Dependents = append(depNode.Dependents, node)</span>
                }
        }

        // Identify root nodes
        <span class="cov7" title="14">for _, node := range dag.Nodes </span><span class="cov9" title="42">{
                if len(node.Dependencies) == 0 </span><span class="cov7" title="13">{
                        dag.RootNodes = append(dag.RootNodes, node)
                        node.Status = NodeStatusReady
                }</span>
        }

        // Validate DAG (check for cycles)
        <span class="cov7" title="14">if err := dag.ValidateCycles(); err != nil </span><span class="cov2" title="2">{
                return nil, err
        }</span>

        <span class="cov6" title="12">return dag, nil</span>
}

// ValidateCycles checks if the DAG contains any cycles
func (d *DAG) ValidateCycles() error <span class="cov7" title="14">{
        visited := make(map[uuid.UUID]bool)
        recStack := make(map[uuid.UUID]bool)

        for id := range d.Nodes </span><span class="cov9" title="41">{
                if !visited[id] </span><span class="cov8" title="21">{
                        if d.hasCycleDFS(id, visited, recStack) </span><span class="cov2" title="2">{
                                return fmt.Errorf("cycle detected in workflow DAG")
                        }</span>
                }
        }
        <span class="cov6" title="12">return nil</span>
}

// hasCycleDFS is a helper function for cycle detection using DFS
func (d *DAG) hasCycleDFS(nodeID uuid.UUID, visited, recStack map[uuid.UUID]bool) bool <span class="cov9" title="42">{
        visited[nodeID] = true
        recStack[nodeID] = true

        node := d.Nodes[nodeID]
        for _, dependent := range node.Dependents </span><span class="cov9" title="34">{
                if !visited[dependent.ID] </span><span class="cov8" title="21">{
                        if d.hasCycleDFS(dependent.ID, visited, recStack) </span><span class="cov1" title="1">{
                                return true
                        }</span>
                } else<span class="cov7" title="13"> if recStack[dependent.ID] </span><span class="cov2" title="2">{
                        return true
                }</span>
        }

        <span class="cov9" title="39">recStack[nodeID] = false
        return false</span>
}

// TopologicalSort returns nodes in topological order
func (d *DAG) TopologicalSort() ([]*DAGNode, error) <span class="cov5" title="8">{
        d.mu.RLock()
        defer d.mu.RUnlock()

        // Create a copy of in-degree counts
        inDegree := make(map[uuid.UUID]int)
        for id, node := range d.Nodes </span><span class="cov9" title="29">{
                inDegree[id] = len(node.Dependencies)
        }</span>

        // Queue for nodes with no dependencies
        <span class="cov5" title="8">queue := make([]*DAGNode, 0, len(d.RootNodes))
        queue = append(queue, d.RootNodes...)

        result := make([]*DAGNode, 0, len(d.Nodes))

        for len(queue) &gt; 0 </span><span class="cov9" title="29">{
                // Dequeue
                current := queue[0]
                queue = queue[1:]
                result = append(result, current)

                // Decrease in-degree for dependent nodes
                for _, dependent := range current.Dependents </span><span class="cov8" title="23">{
                        inDegree[dependent.ID]--
                        if inDegree[dependent.ID] == 0 </span><span class="cov8" title="20">{
                                queue = append(queue, dependent)
                        }</span>
                }
        }

        <span class="cov5" title="8">if len(result) != len(d.Nodes) </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("cycle detected: topological sort incomplete")
        }</span>

        <span class="cov5" title="8">return result, nil</span>
}

// GetReadyNodes returns all nodes that are ready to execute
func (d *DAG) GetReadyNodes() []*DAGNode <span class="cov0" title="0">{
        d.mu.RLock()
        defer d.mu.RUnlock()

        ready := []*DAGNode{}
        for _, node := range d.Nodes </span><span class="cov0" title="0">{
                if node.Status == NodeStatusReady </span><span class="cov0" title="0">{
                        ready = append(ready, node)
                }</span>
        }
        <span class="cov0" title="0">return ready</span>
}

// MarkNodeCompleted marks a node as completed and updates dependent nodes
func (d *DAG) MarkNodeCompleted(nodeID uuid.UUID, result interface{}) <span class="cov0" title="0">{
        d.mu.Lock()
        defer d.mu.Unlock()

        node, exists := d.Nodes[nodeID]
        if !exists </span><span class="cov0" title="0">{
                return
        }</span>

        <span class="cov0" title="0">node.Status = NodeStatusCompleted
        node.Result = result

        // Check if dependent nodes are ready
        for _, dependent := range node.Dependents </span><span class="cov0" title="0">{
                if d.areAllDependenciesCompleted(dependent) </span><span class="cov0" title="0">{
                        dependent.Status = NodeStatusReady
                }</span>
        }
}

// MarkNodeFailed marks a node as failed and skips dependent nodes
func (d *DAG) MarkNodeFailed(nodeID uuid.UUID, err error) <span class="cov0" title="0">{
        d.mu.Lock()
        defer d.mu.Unlock()

        node, exists := d.Nodes[nodeID]
        if !exists </span><span class="cov0" title="0">{
                return
        }</span>

        <span class="cov0" title="0">node.Status = NodeStatusFailed
        node.Error = err

        // Skip all dependent nodes
        d.skipDependents(node)</span>
}

// skipDependents recursively skips all dependent nodes
func (d *DAG) skipDependents(node *DAGNode) <span class="cov0" title="0">{
        for _, dependent := range node.Dependents </span><span class="cov0" title="0">{
                if dependent.Status != NodeStatusSkipped </span><span class="cov0" title="0">{
                        dependent.Status = NodeStatusSkipped
                        d.skipDependents(dependent)
                }</span>
        }
}

// areAllDependenciesCompleted checks if all dependencies of a node are completed
func (d *DAG) areAllDependenciesCompleted(node *DAGNode) bool <span class="cov0" title="0">{
        for _, dep := range node.Dependencies </span><span class="cov0" title="0">{
                if dep.Status != NodeStatusCompleted </span><span class="cov0" title="0">{
                        return false
                }</span>
        }
        <span class="cov0" title="0">return true</span>
}

// GetExecutionPlan returns the execution plan as levels of parallel tasks
func (d *DAG) GetExecutionPlan() ([][]uuid.UUID, error) <span class="cov5" title="6">{
        sorted, err := d.TopologicalSort()
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov5" title="6">levels := [][]uuid.UUID{}
        processed := make(map[uuid.UUID]int)

        for _, node := range sorted </span><span class="cov8" title="23">{
                level := 0
                for _, dep := range node.Dependencies </span><span class="cov8" title="19">{
                        if depLevel, ok := processed[dep.ID]; ok &amp;&amp; depLevel &gt;= level </span><span class="cov7" title="17">{
                                level = depLevel + 1
                        }</span>
                }

                <span class="cov8" title="23">processed[node.ID] = level

                // Extend levels if needed
                for len(levels) &lt;= level </span><span class="cov7" title="18">{
                        levels = append(levels, []uuid.UUID{})
                }</span>

                <span class="cov8" title="23">levels[level] = append(levels[level], node.ID)</span>
        }

        <span class="cov5" title="6">return levels, nil</span>
}

// DAGExecutor handles the execution of a DAG
type DAGExecutor struct {
        dag         *DAG
        executor    ToolExecutor
        maxParallel int
}

// ToolExecutor defines the interface for executing tools
type ToolExecutor interface {
        Execute(ctx context.Context, tool *tools.Tool, input interface{}) (interface{}, error)
}

// NewDAGExecutor creates a new DAG executor
func NewDAGExecutor(dag *DAG, executor ToolExecutor, maxParallel int) *DAGExecutor <span class="cov0" title="0">{
        if maxParallel &lt;= 0 </span><span class="cov0" title="0">{
                maxParallel = 1
        }</span>
        <span class="cov0" title="0">return &amp;DAGExecutor{
                dag:         dag,
                executor:    executor,
                maxParallel: maxParallel,
        }</span>
}

// Execute runs the DAG execution
func (e *DAGExecutor) Execute(ctx context.Context) error <span class="cov0" title="0">{
        // Get execution plan
        plan, err := e.dag.GetExecutionPlan()
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to get execution plan: %w", err)
        }</span>

        // Execute level by level
        <span class="cov0" title="0">for levelIdx, level := range plan </span><span class="cov0" title="0">{
                select </span>{
                case &lt;-ctx.Done():<span class="cov0" title="0">
                        return ctx.Err()</span>
                default:<span class="cov0" title="0"></span>
                }

                // Execute nodes in parallel within each level
                <span class="cov0" title="0">var wg sync.WaitGroup
                semaphore := make(chan struct{}, e.maxParallel)
                errors := make(chan error, len(level))

                for _, nodeID := range level </span><span class="cov0" title="0">{
                        node := e.dag.Nodes[nodeID]

                        // Skip if node is not ready (due to previous failures)
                        if node.Status == NodeStatusSkipped </span><span class="cov0" title="0">{
                                continue</span>
                        }

                        <span class="cov0" title="0">wg.Add(1)
                        go func(n *DAGNode) </span><span class="cov0" title="0">{
                                defer wg.Done()

                                // Acquire semaphore
                                semaphore &lt;- struct{}{}
                                defer func() </span><span class="cov0" title="0">{ &lt;-semaphore }</span>()

                                // Execute node
                                <span class="cov0" title="0">if err := e.executeNode(ctx, n); err != nil </span><span class="cov0" title="0">{
                                        errors &lt;- fmt.Errorf("node %s failed: %w", n.ID, err)
                                        e.dag.MarkNodeFailed(n.ID, err)
                                }</span> else<span class="cov0" title="0"> {
                                        e.dag.MarkNodeCompleted(n.ID, n.Result)
                                }</span>
                        }(node)
                }

                <span class="cov0" title="0">wg.Wait()
                close(errors)

                // Check for errors
                for err := range errors </span><span class="cov0" title="0">{
                        if err != nil </span><span class="cov0" title="0">{
                                return fmt.Errorf("level %d execution failed: %w", levelIdx, err)
                        }</span>
                }
        }

        <span class="cov0" title="0">return nil</span>
}

// executeNode executes a single node
func (e *DAGExecutor) executeNode(ctx context.Context, node *DAGNode) error <span class="cov0" title="0">{
        node.Status = NodeStatusRunning

        // Get input from dependencies
        input := e.collectInputs(node)

        // Execute the tool
        // Note: You'll need to implement the actual tool execution logic
        // This is a placeholder for the actual implementation
        result, err := e.executeStep(ctx, node.Step, input)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov0" title="0">node.Result = result
        return nil</span>
}

// collectInputs collects outputs from dependencies
func (e *DAGExecutor) collectInputs(node *DAGNode) map[uuid.UUID]interface{} <span class="cov0" title="0">{
        inputs := make(map[uuid.UUID]interface{})
        for _, dep := range node.Dependencies </span><span class="cov0" title="0">{
                if dep.Status == NodeStatusCompleted </span><span class="cov0" title="0">{
                        inputs[dep.ID] = dep.Result
                }</span>
        }
        <span class="cov0" title="0">return inputs</span>
}

// executeStep executes a pipeline step
// This is a placeholder - you'll need to implement actual tool execution
func (e *DAGExecutor) executeStep(_ context.Context, step *PipelineStep, inputs map[uuid.UUID]interface{}) (interface{}, error) <span class="cov0" title="0">{
        // TODO: Implement actual tool execution
        // This would typically:
        // 1. Load the tool configuration
        // 2. Prepare the input based on the tool's requirements
        // 3. Execute the tool (could be a container, function, API call, etc.)
        // 4. Return the output

        // For now, just return a placeholder result
        _ = inputs // will be used in actual implementation

        // Placeholder: in real implementation, this could return an error
        if step.ToolId == uuid.Nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("invalid tool ID")
        }</span>

        <span class="cov0" title="0">return map[string]interface{}{
                "stepId": step.Id,
                "toolId": step.ToolId,
                "status": "completed",
        }, nil</span>
}
</pre>
		
		<pre class="file" id="file116" style="display: none">package pipelines

import (
        "context"
        "encoding/json"
        "fmt"
        "log/slog"
        "sync"
        "time"

        "github.com/archesai/archesai/internal/runs"
        "github.com/archesai/archesai/internal/tools"
        "github.com/google/uuid"
)

// QueueService defines the interface for workflow queueing
type QueueService interface {
        EnqueueRun(ctx context.Context, runID uuid.UUID) error
        DequeueRun(ctx context.Context, status string) (*uuid.UUID, error)
}

// ToolRunner defines the interface for executing tools
type ToolRunner interface {
        // Run executes a tool with the given configuration and input
        Run(ctx context.Context, tool *tools.Tool, config map[string]interface{}, input interface{}) (interface{}, error)
}

// ToolRunnerFunc is an adapter to allow functions to be used as ToolRunner
type ToolRunnerFunc func(ctx context.Context, tool *tools.Tool, config map[string]interface{}, input interface{}) (interface{}, error)

// Run implements ToolRunner
func (f ToolRunnerFunc) Run(ctx context.Context, tool *tools.Tool, config map[string]interface{}, input interface{}) (interface{}, error) <span class="cov0" title="0">{
        return f(ctx, tool, config, input)
}</span>

// WorkflowExecutor handles the execution of workflow pipelines
type WorkflowExecutor struct {
        pipelineRepo    Repository
        runRepo         runs.Repository
        toolRepo        tools.Repository
        pipelineManager *PipelineManager
        runner          ToolRunner
        queue           QueueService
        logger          *slog.Logger
        maxParallel     int
        mu              sync.RWMutex
        executions      map[uuid.UUID]*ExecutionContext
}

// ExecutionContext tracks the state of a running pipeline
type ExecutionContext struct {
        RunID      uuid.UUID
        PipelineID uuid.UUID
        DAG        *DAG
        Executor   *DAGExecutor
        StartTime  time.Time
        EndTime    *time.Time
        Status     runs.RunStatus
        Error      error
        Results    map[uuid.UUID]interface{}
        mu         sync.RWMutex
}

// NewWorkflowExecutor creates a new workflow executor
func NewWorkflowExecutor(pipelineRepo Repository, runRepo runs.Repository, toolRepo tools.Repository, pipelineManager *PipelineManager, runner ToolRunner, queue QueueService, logger *slog.Logger, maxParallel int) *WorkflowExecutor <span class="cov0" title="0">{
        if maxParallel &lt;= 0 </span><span class="cov0" title="0">{
                maxParallel = 4 // Default parallelism
        }</span>
        <span class="cov0" title="0">return &amp;WorkflowExecutor{
                pipelineRepo:    pipelineRepo,
                runRepo:         runRepo,
                toolRepo:        toolRepo,
                pipelineManager: pipelineManager,
                runner:          runner,
                queue:           queue,
                logger:          logger,
                maxParallel:     maxParallel,
                executions:      make(map[uuid.UUID]*ExecutionContext),
        }</span>
}

// ExecutePipeline starts the execution of a pipeline
func (we *WorkflowExecutor) ExecutePipeline(ctx context.Context, pipelineID uuid.UUID, input map[string]interface{}) (*runs.Run, error) <span class="cov0" title="0">{
        // Get pipeline
        pipeline, err := we.pipelineRepo.Get(ctx, pipelineID)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to get pipeline: %w", err)
        }</span>

        // Create run record
        <span class="cov0" title="0">run := &amp;runs.Run{
                Id:         uuid.New(),
                PipelineId: pipeline.Id.String(),
                Status:     runs.QUEUED,
                Progress:   0,
                CreatedAt:  time.Now(),
                UpdatedAt:  time.Now(),
        }

        // Store input as metadata in error field for now
        // TODO: Add proper metadata field or use a separate table
        if input != nil </span><span class="cov0" title="0">{
                inputJSON, err := json.Marshal(input)
                if err != nil </span><span class="cov0" title="0">{
                        return nil, fmt.Errorf("failed to marshal input: %w", err)
                }</span>
                // Temporarily store in error field - this should be refactored
                <span class="cov0" title="0">run.Error = string(inputJSON)</span>
        }

        // Save run to database
        <span class="cov0" title="0">createdRun, err := we.runRepo.Create(ctx, run)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to create run: %w", err)
        }</span>

        // Queue the execution
        <span class="cov0" title="0">err = we.queue.EnqueueRun(ctx, createdRun.Id)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to queue run: %w", err)
        }</span>

        // Start execution in background
        <span class="cov0" title="0">go we.executeRun(context.Background(), createdRun.Id)

        return createdRun, nil</span>
}

// executeRun performs the actual pipeline execution
func (we *WorkflowExecutor) executeRun(ctx context.Context, runID uuid.UUID) <span class="cov0" title="0">{
        we.logger.Info("Starting pipeline execution", "runId", runID)

        // Get run details
        run, err := we.runRepo.Get(ctx, runID)
        if err != nil </span><span class="cov0" title="0">{
                we.logger.Error("Failed to get run", "error", err, "runId", runID)
                return
        }</span>

        // Update run status to processing
        <span class="cov0" title="0">run.Status = runs.PROCESSING
        run.StartedAt = time.Now()
        _, err = we.runRepo.Update(ctx, run.Id, run)
        if err != nil </span><span class="cov0" title="0">{
                we.logger.Error("Failed to update run status", "error", err, "runId", runID)
                return
        }</span>

        // Parse pipeline ID from string
        <span class="cov0" title="0">pipelineID, err := uuid.Parse(run.PipelineId)
        if err != nil </span><span class="cov0" title="0">{
                we.logger.Error("Invalid pipeline ID", "error", err, "pipelineId", run.PipelineId)
                return
        }</span>

        // Build DAG from pipeline steps
        <span class="cov0" title="0">dag, err := we.buildDAG(ctx, pipelineID)
        if err != nil </span><span class="cov0" title="0">{
                we.handleRunFailure(ctx, run, err)
                return
        }</span>

        // Create execution context
        <span class="cov0" title="0">execCtx := &amp;ExecutionContext{
                RunID:      runID,
                PipelineID: pipelineID,
                DAG:        dag,
                StartTime:  time.Now(),
                Status:     runs.PROCESSING,
                Results:    make(map[uuid.UUID]interface{}),
        }

        // Store execution context
        we.mu.Lock()
        we.executions[runID] = execCtx
        we.mu.Unlock()

        // Create DAG executor with tool runner adapter
        toolExecutor := &amp;dagToolExecutor{
                executor: we,
                runID:    runID,
        }
        execCtx.Executor = NewDAGExecutor(dag, toolExecutor, we.maxParallel)

        // Execute the DAG
        err = execCtx.Executor.Execute(ctx)
        if err != nil </span><span class="cov0" title="0">{
                we.handleRunFailure(ctx, run, err)
                return
        }</span>

        // Mark run as completed
        <span class="cov0" title="0">we.handleRunSuccess(ctx, run)</span>
}

// buildDAG creates a DAG from pipeline steps
func (we *WorkflowExecutor) buildDAG(ctx context.Context, pipelineID uuid.UUID) (*DAG, error) <span class="cov0" title="0">{
        we.logger.Info("Building DAG for pipeline", "pipelineId", pipelineID)

        // Use the pipeline manager to get DAG structure
        steps, dependencies, err := we.pipelineManager.GetPipelineDAG(ctx, pipelineID)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to get pipeline DAG: %w", err)
        }</span>

        <span class="cov0" title="0">return NewDAG(steps, dependencies)</span>
}

// handleRunFailure updates the run status to failed
func (we *WorkflowExecutor) handleRunFailure(ctx context.Context, run *runs.Run, err error) <span class="cov0" title="0">{
        we.logger.Error("Pipeline execution failed", "error", err, "runId", run.Id)

        run.Status = runs.FAILED
        run.CompletedAt = time.Now()

        // Store error message
        run.Error = err.Error()

        _, updateErr := we.runRepo.Update(ctx, run.Id, run)
        if updateErr != nil </span><span class="cov0" title="0">{
                we.logger.Error("Failed to update failed run", "error", updateErr, "runId", run.Id)
        }</span>
}

// handleRunSuccess updates the run status to completed
func (we *WorkflowExecutor) handleRunSuccess(ctx context.Context, run *runs.Run) <span class="cov0" title="0">{
        we.logger.Info("Pipeline execution completed", "runId", run.Id)

        run.Status = runs.COMPLETED
        run.CompletedAt = time.Now()
        run.Progress = 100

        _, err := we.runRepo.Update(ctx, run.Id, run)
        if err != nil </span><span class="cov0" title="0">{
                we.logger.Error("Failed to update completed run", "error", err, "runId", run.Id)
        }</span>
}

// GetExecutionStatus returns the current status of a run
func (we *WorkflowExecutor) GetExecutionStatus(runID uuid.UUID) (*ExecutionContext, bool) <span class="cov0" title="0">{
        we.mu.RLock()
        defer we.mu.RUnlock()

        exec, exists := we.executions[runID]
        return exec, exists
}</span>

// dagToolExecutor adapts WorkflowExecutor to work with DAGExecutor
type dagToolExecutor struct {
        executor *WorkflowExecutor
        runID    uuid.UUID
}

// Execute implements ToolExecutor interface for DAGExecutor
func (dte *dagToolExecutor) Execute(ctx context.Context, tool *tools.Tool, input interface{}) (interface{}, error) <span class="cov0" title="0">{
        // Get the step configuration from the execution context
        dte.executor.mu.RLock()
        execCtx, exists := dte.executor.executions[dte.runID]
        dte.executor.mu.RUnlock()

        if !exists </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("execution context not found")
        }</span>

        // Execute the tool using the runner
        <span class="cov0" title="0">config := make(map[string]interface{}) // Get from step config
        result, err := dte.executor.runner.Run(ctx, tool, config, input)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("tool execution failed: %w", err)
        }</span>

        // Store result in execution context
        <span class="cov0" title="0">execCtx.mu.Lock()
        // Store by tool ID for now - you might want to use step ID instead
        execCtx.Results[tool.Id] = result
        execCtx.mu.Unlock()

        return result, nil</span>
}

// ContainerToolRunner executes tools in containers
type ContainerToolRunner struct {
        logger *slog.Logger
}

// NewContainerToolRunner creates a new container-based tool runner
func NewContainerToolRunner(logger *slog.Logger) *ContainerToolRunner <span class="cov0" title="0">{
        return &amp;ContainerToolRunner{
                logger: logger,
        }
}</span>

// Run executes a tool in a container
func (ctr *ContainerToolRunner) Run(_ context.Context, tool *tools.Tool, config map[string]interface{}, input interface{}) (interface{}, error) <span class="cov0" title="0">{
        _ = input // will be used in actual implementation
        ctr.logger.Info("Executing tool in container",
                "toolId", tool.Id,
                "toolName", tool.Name,
                "config", config,
        )

        // TODO: Implement actual container execution
        // This would typically:
        // 1. Pull the container image specified in tool configuration
        // 2. Mount input data as volume or pass as environment
        // 3. Run the container with resource limits
        // 4. Capture output and logs
        // 5. Clean up resources

        // For now, return a mock result
        return map[string]interface{}{
                "toolId":     tool.Id,
                "toolName":   tool.Name,
                "executedAt": time.Now(),
                "status":     "success",
                "output":     "Mock execution result",
        }, nil
}</span>

// HTTPToolRunner executes tools via HTTP API calls
type HTTPToolRunner struct {
        logger *slog.Logger
}

// NewHTTPToolRunner creates a new HTTP-based tool runner
func NewHTTPToolRunner(logger *slog.Logger) *HTTPToolRunner <span class="cov0" title="0">{
        return &amp;HTTPToolRunner{
                logger: logger,
        }
}</span>

// Run executes a tool via HTTP API
func (htr *HTTPToolRunner) Run(_ context.Context, tool *tools.Tool, config map[string]interface{}, input interface{}) (interface{}, error) <span class="cov0" title="0">{
        _ = input // will be used in actual implementation
        htr.logger.Info("Executing tool via HTTP",
                "toolId", tool.Id,
                "toolName", tool.Name,
                "config", config,
        )

        // TODO: Implement actual HTTP execution
        // This would typically:
        // 1. Build HTTP request from tool configuration
        // 2. Add authentication if required
        // 3. Send request with input data
        // 4. Handle retries and timeouts
        // 5. Parse response

        return map[string]interface{}{
                "toolId":     tool.Id,
                "toolName":   tool.Name,
                "executedAt": time.Now(),
                "status":     "success",
                "response":   "Mock HTTP response",
        }, nil
}</span>

// CompositeToolRunner routes to different runners based on tool type
type CompositeToolRunner struct {
        runners map[string]ToolRunner
        logger  *slog.Logger
}

// NewCompositeToolRunner creates a runner that delegates to specific runners
func NewCompositeToolRunner(logger *slog.Logger) *CompositeToolRunner <span class="cov0" title="0">{
        return &amp;CompositeToolRunner{
                runners: make(map[string]ToolRunner),
                logger:  logger,
        }
}</span>

// RegisterRunner registers a runner for a specific tool type
func (ctr *CompositeToolRunner) RegisterRunner(toolType string, runner ToolRunner) <span class="cov0" title="0">{
        ctr.runners[toolType] = runner
}</span>

// Run delegates to the appropriate runner based on tool type
func (ctr *CompositeToolRunner) Run(ctx context.Context, tool *tools.Tool, config map[string]interface{}, input interface{}) (interface{}, error) <span class="cov0" title="0">{
        // Determine tool type from configuration or metadata
        toolType := "container" // Default type
        if typeVal, ok := config["type"].(string); ok </span><span class="cov0" title="0">{
                toolType = typeVal
        }</span>

        <span class="cov0" title="0">runner, exists := ctr.runners[toolType]
        if !exists </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("no runner registered for tool type: %s", toolType)
        }</span>

        <span class="cov0" title="0">return runner.Run(ctx, tool, config, input)</span>
}
</pre>
		
		<pre class="file" id="file117" style="display: none">// Package pipelines provides HTTP handlers for pipeline operations
package pipelines

import (
        "context"
        "log/slog"
        "time"

        "github.com/google/uuid"
        openapi_types "github.com/oapi-codegen/runtime/types"
)

const (
        // Placeholder constants for development
        orgPlaceholder = "org-placeholder"
)

// Handler handles HTTP requests for workflow operations
type Handler struct {
        service *Service
        logger  *slog.Logger
}

// Ensure Handler implements StrictServerInterface
var _ StrictServerInterface = (*Handler)(nil)

// NewHandler creates a new workflow handler
func NewHandler(service *Service, logger *slog.Logger) *Handler <span class="cov0" title="0">{
        return &amp;Handler{
                service: service,
                logger:  logger,
        }
}</span>

// NewWorkflowStrictHandler creates a StrictHandler with middleware
func NewWorkflowStrictHandler(handler StrictServerInterface) ServerInterface <span class="cov0" title="0">{
        return NewStrictHandler(handler, nil)
}</span>

// Pipeline handlers

// FindManyPipelines retrieves pipelines (implements StrictServerInterface)
func (h *Handler) FindManyPipelines(ctx context.Context, req FindManyPipelinesRequestObject) (FindManyPipelinesResponseObject, error) <span class="cov0" title="0">{
        limit := 50
        offset := 0

        // Handle page-based pagination if provided
        if req.Params.Page.Number &gt; 0 &amp;&amp; req.Params.Page.Size &gt; 0 </span><span class="cov0" title="0">{
                limit = req.Params.Page.Size
                offset = (req.Params.Page.Number - 1) * req.Params.Page.Size
        }</span>

        // TODO: Get organization ID from context
        <span class="cov0" title="0">orgID := orgPlaceholder

        pipelines, total, err := h.service.List(ctx, orgID, limit, offset)
        if err != nil </span><span class="cov0" title="0">{
                h.logger.Error("failed to list pipelines", "error", err)
                return nil, err
        }</span>

        // Convert to API entities
        <span class="cov0" title="0">data := make([]Pipeline, len(pipelines))
        for i, pipeline := range pipelines </span><span class="cov0" title="0">{
                data[i] = *pipeline
        }</span>

        <span class="cov0" title="0">totalFloat32 := float32(total)
        return FindManyPipelines200JSONResponse{
                Data: data,
                Meta: struct {
                        Total float32 `json:"total"`
                }{
                        Total: totalFloat32,
                },
        }, nil</span>
}

// CreatePipeline creates a new pipeline (implements StrictServerInterface)
func (h *Handler) CreatePipeline(ctx context.Context, req CreatePipelineRequestObject) (CreatePipelineResponseObject, error) <span class="cov0" title="0">{
        // TODO: Get organization ID from context
        orgID := orgPlaceholder

        createReq := &amp;CreatePipelineRequest{
                Name:        req.Body.Name,
                Description: req.Body.Description,
        }

        pipeline, err := h.service.Create(ctx, createReq, orgID)
        if err != nil </span><span class="cov0" title="0">{
                h.logger.Error("failed to create pipeline", "error", err)
                return nil, err
        }</span>

        <span class="cov0" title="0">return CreatePipeline201JSONResponse{
                Data: *pipeline,
        }, nil</span>
}

// GetOnePipeline retrieves a pipeline by ID (implements StrictServerInterface)
func (h *Handler) GetOnePipeline(ctx context.Context, req GetOnePipelineRequestObject) (GetOnePipelineResponseObject, error) <span class="cov0" title="0">{
        pipeline, err := h.service.Get(ctx, req.Id)
        if err != nil </span><span class="cov0" title="0">{
                if err == ErrPipelineNotFound </span><span class="cov0" title="0">{
                        return GetOnePipeline404ApplicationProblemPlusJSONResponse{
                                NotFoundApplicationProblemPlusJSONResponse: NotFoundApplicationProblemPlusJSONResponse{
                                        Detail: "Pipeline not found",
                                        Status: 404,
                                        Title:  "Pipeline not found",
                                },
                        }, nil
                }</span>
                <span class="cov0" title="0">h.logger.Error("failed to get pipeline", "error", err)
                return nil, err</span>
        }

        <span class="cov0" title="0">return GetOnePipeline200JSONResponse{
                Data: *pipeline,
        }, nil</span>
}

// UpdatePipeline updates a pipeline (implements StrictServerInterface)
func (h *Handler) UpdatePipeline(ctx context.Context, req UpdatePipelineRequestObject) (UpdatePipelineResponseObject, error) <span class="cov0" title="0">{
        updateReq := &amp;UpdatePipelineRequest{
                Name:        req.Body.Name,
                Description: req.Body.Description,
        }

        pipeline, err := h.service.Update(ctx, req.Id, updateReq)
        if err != nil </span><span class="cov0" title="0">{
                if err == ErrPipelineNotFound </span><span class="cov0" title="0">{
                        return UpdatePipeline404ApplicationProblemPlusJSONResponse{
                                NotFoundApplicationProblemPlusJSONResponse: NotFoundApplicationProblemPlusJSONResponse{
                                        Detail: "Pipeline not found",
                                        Status: 404,
                                        Title:  "Pipeline not found",
                                },
                        }, nil
                }</span>
                <span class="cov0" title="0">h.logger.Error("failed to update pipeline", "error", err)
                return nil, err</span>
        }

        <span class="cov0" title="0">return UpdatePipeline200JSONResponse{
                Data: *pipeline,
        }, nil</span>
}

// DeletePipeline deletes a pipeline (implements StrictServerInterface)
func (h *Handler) DeletePipeline(ctx context.Context, req DeletePipelineRequestObject) (DeletePipelineResponseObject, error) <span class="cov0" title="0">{
        err := h.service.Delete(ctx, req.Id)
        if err != nil </span><span class="cov0" title="0">{
                if err == ErrPipelineNotFound </span><span class="cov0" title="0">{
                        return DeletePipeline404ApplicationProblemPlusJSONResponse{
                                NotFoundApplicationProblemPlusJSONResponse: NotFoundApplicationProblemPlusJSONResponse{
                                        Detail: "Pipeline not found",
                                        Status: 404,
                                        Title:  "Pipeline not found",
                                },
                        }, nil
                }</span>
                <span class="cov0" title="0">h.logger.Error("failed to delete pipeline", "error", err)
                return nil, err</span>
        }

        <span class="cov0" title="0">return DeletePipeline200JSONResponse{}, nil</span>
}

// GetPipelineSteps retrieves all steps for a pipeline
func (h *Handler) GetPipelineSteps(_ context.Context, req GetPipelineStepsRequestObject) (GetPipelineStepsResponseObject, error) <span class="cov0" title="0">{
        // TODO: Implement GetPipelineSteps in service
        _ = req
        steps := []PipelineStep{}

        return GetPipelineSteps200JSONResponse{
                Data: steps,
        }, nil
}</span>

// CreatePipelineStep adds a step to a pipeline
func (h *Handler) CreatePipelineStep(_ context.Context, req CreatePipelineStepRequestObject) (CreatePipelineStepResponseObject, error) <span class="cov0" title="0">{
        // TODO: Implement CreatePipelineStep in service
        step := PipelineStep{
                Id:           uuid.New(),
                PipelineId:   req.Id,
                ToolId:       req.Body.ToolId,
                Name:         req.Body.Name,
                Description:  req.Body.Description,
                Config:       req.Body.Config,
                Position:     req.Body.Position,
                Dependencies: req.Body.Dependencies,
                CreatedAt:    time.Now(),
                UpdatedAt:    time.Now(),
        }

        return CreatePipelineStep201JSONResponse{
                Data: step,
        }, nil
}</span>

// GetPipelineExecutionPlan gets the execution plan for a pipeline
func (h *Handler) GetPipelineExecutionPlan(_ context.Context, req GetPipelineExecutionPlanRequestObject) (GetPipelineExecutionPlanResponseObject, error) <span class="cov0" title="0">{
        // TODO: Implement GetPipelineExecutionPlan in service
        _ = req

        return GetPipelineExecutionPlan200JSONResponse{
                Data: struct {
                        EstimatedDuration *int `json:"estimatedDuration,omitempty"`
                        IsValid           bool `json:"isValid"`
                        Levels            []struct {
                                Level int                  `json:"level"`
                                Steps []openapi_types.UUID `json:"steps"`
                        } `json:"levels"`
                        PipelineId openapi_types.UUID `json:"pipelineId"` //nolint:revive // matches generated code
                        TotalSteps int                `json:"totalSteps"`
                }{
                        PipelineId: req.Id,
                        IsValid:    true,
                        TotalSteps: 0,
                        Levels: []struct {
                                Level int                  `json:"level"`
                                Steps []openapi_types.UUID `json:"steps"`
                        }{},
                },
        }, nil
}</span>

// ValidatePipelineExecutionPlan validates a pipeline configuration
func (h *Handler) ValidatePipelineExecutionPlan(_ context.Context, req ValidatePipelineExecutionPlanRequestObject) (ValidatePipelineExecutionPlanResponseObject, error) <span class="cov0" title="0">{
        // TODO: Implement ValidatePipelineExecutionPlan in service
        _ = req

        return ValidatePipelineExecutionPlan200JSONResponse{
                Data: struct {
                        Issues *[]string `json:"issues,omitempty"`
                        Valid  bool      `json:"valid"`
                }{
                        Valid:  true,
                        Issues: &amp;[]string{},
                },
        }, nil
}</span>
</pre>
		
		<pre class="file" id="file118" style="display: none">// Package pipelines provides primitives to interact with the openapi HTTP API.
//
// Code generated by github.com/oapi-codegen/oapi-codegen/v2 version v2.5.0 DO NOT EDIT.
package pipelines

import (
        "context"
        "encoding/json"
        "fmt"
        "net/http"

        "github.com/labstack/echo/v4"
        "github.com/oapi-codegen/runtime"
        strictecho "github.com/oapi-codegen/runtime/strictmiddleware/echo"
        openapi_types "github.com/oapi-codegen/runtime/types"
)

// ServerInterface represents all server handlers.
type ServerInterface interface {
        // Find many pipelines
        // (GET /workflows/pipelines)
        FindManyPipelines(ctx echo.Context, params FindManyPipelinesParams) error
        // Create a new pipeline
        // (POST /workflows/pipelines)
        CreatePipeline(ctx echo.Context) error
        // Delete a pipeline
        // (DELETE /workflows/pipelines/{id})
        DeletePipeline(ctx echo.Context, id openapi_types.UUID) error
        // Find a pipeline
        // (GET /workflows/pipelines/{id})
        GetOnePipeline(ctx echo.Context, id openapi_types.UUID) error
        // Update a pipeline
        // (PATCH /workflows/pipelines/{id})
        UpdatePipeline(ctx echo.Context, id openapi_types.UUID) error
        // Get execution plan for a pipeline
        // (GET /workflows/pipelines/{id}/execution-plans)
        GetPipelineExecutionPlan(ctx echo.Context, id openapi_types.UUID) error
        // Validate a pipeline configuration
        // (POST /workflows/pipelines/{id}/execution-plans)
        ValidatePipelineExecutionPlan(ctx echo.Context, id openapi_types.UUID) error
        // Get all steps for a pipeline
        // (GET /workflows/pipelines/{id}/steps)
        GetPipelineSteps(ctx echo.Context, id openapi_types.UUID) error
        // Add a step to a pipeline
        // (POST /workflows/pipelines/{id}/steps)
        CreatePipelineStep(ctx echo.Context, id openapi_types.UUID) error
}

// ServerInterfaceWrapper converts echo contexts to parameters.
type ServerInterfaceWrapper struct {
        Handler ServerInterface
}

// FindManyPipelines converts echo context to params.
func (w *ServerInterfaceWrapper) FindManyPipelines(ctx echo.Context) error <span class="cov0" title="0">{
        var err error

        ctx.Set(BearerAuthScopes, []string{})

        // Parameter object where we will unmarshal all parameters from the context
        var params FindManyPipelinesParams
        // ------------- Optional query parameter "filter" -------------

        err = runtime.BindQueryParameter("deepObject", true, false, "filter", ctx.QueryParams(), &amp;params.Filter)
        if err != nil </span><span class="cov0" title="0">{
                return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter filter: %s", err))
        }</span>

        // ------------- Optional query parameter "page" -------------

        <span class="cov0" title="0">err = runtime.BindQueryParameter("form", true, false, "page", ctx.QueryParams(), &amp;params.Page)
        if err != nil </span><span class="cov0" title="0">{
                return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter page: %s", err))
        }</span>

        // ------------- Optional query parameter "sort" -------------

        <span class="cov0" title="0">err = runtime.BindQueryParameter("form", true, false, "sort", ctx.QueryParams(), &amp;params.Sort)
        if err != nil </span><span class="cov0" title="0">{
                return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter sort: %s", err))
        }</span>

        // Invoke the callback with all the unmarshaled arguments
        <span class="cov0" title="0">err = w.Handler.FindManyPipelines(ctx, params)
        return err</span>
}

// CreatePipeline converts echo context to params.
func (w *ServerInterfaceWrapper) CreatePipeline(ctx echo.Context) error <span class="cov0" title="0">{
        var err error

        ctx.Set(BearerAuthScopes, []string{})

        // Invoke the callback with all the unmarshaled arguments
        err = w.Handler.CreatePipeline(ctx)
        return err
}</span>

// DeletePipeline converts echo context to params.
func (w *ServerInterfaceWrapper) DeletePipeline(ctx echo.Context) error <span class="cov0" title="0">{
        var err error
        // ------------- Path parameter "id" -------------
        var id openapi_types.UUID

        err = runtime.BindStyledParameterWithOptions("simple", "id", ctx.Param("id"), &amp;id, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
        if err != nil </span><span class="cov0" title="0">{
                return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter id: %s", err))
        }</span>

        <span class="cov0" title="0">ctx.Set(BearerAuthScopes, []string{})

        // Invoke the callback with all the unmarshaled arguments
        err = w.Handler.DeletePipeline(ctx, id)
        return err</span>
}

// GetOnePipeline converts echo context to params.
func (w *ServerInterfaceWrapper) GetOnePipeline(ctx echo.Context) error <span class="cov0" title="0">{
        var err error
        // ------------- Path parameter "id" -------------
        var id openapi_types.UUID

        err = runtime.BindStyledParameterWithOptions("simple", "id", ctx.Param("id"), &amp;id, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
        if err != nil </span><span class="cov0" title="0">{
                return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter id: %s", err))
        }</span>

        <span class="cov0" title="0">ctx.Set(BearerAuthScopes, []string{})

        // Invoke the callback with all the unmarshaled arguments
        err = w.Handler.GetOnePipeline(ctx, id)
        return err</span>
}

// UpdatePipeline converts echo context to params.
func (w *ServerInterfaceWrapper) UpdatePipeline(ctx echo.Context) error <span class="cov0" title="0">{
        var err error
        // ------------- Path parameter "id" -------------
        var id openapi_types.UUID

        err = runtime.BindStyledParameterWithOptions("simple", "id", ctx.Param("id"), &amp;id, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
        if err != nil </span><span class="cov0" title="0">{
                return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter id: %s", err))
        }</span>

        <span class="cov0" title="0">ctx.Set(BearerAuthScopes, []string{})

        // Invoke the callback with all the unmarshaled arguments
        err = w.Handler.UpdatePipeline(ctx, id)
        return err</span>
}

// GetPipelineExecutionPlan converts echo context to params.
func (w *ServerInterfaceWrapper) GetPipelineExecutionPlan(ctx echo.Context) error <span class="cov0" title="0">{
        var err error
        // ------------- Path parameter "id" -------------
        var id openapi_types.UUID

        err = runtime.BindStyledParameterWithOptions("simple", "id", ctx.Param("id"), &amp;id, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
        if err != nil </span><span class="cov0" title="0">{
                return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter id: %s", err))
        }</span>

        <span class="cov0" title="0">ctx.Set(BearerAuthScopes, []string{})

        // Invoke the callback with all the unmarshaled arguments
        err = w.Handler.GetPipelineExecutionPlan(ctx, id)
        return err</span>
}

// ValidatePipelineExecutionPlan converts echo context to params.
func (w *ServerInterfaceWrapper) ValidatePipelineExecutionPlan(ctx echo.Context) error <span class="cov0" title="0">{
        var err error
        // ------------- Path parameter "id" -------------
        var id openapi_types.UUID

        err = runtime.BindStyledParameterWithOptions("simple", "id", ctx.Param("id"), &amp;id, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
        if err != nil </span><span class="cov0" title="0">{
                return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter id: %s", err))
        }</span>

        <span class="cov0" title="0">ctx.Set(BearerAuthScopes, []string{})

        // Invoke the callback with all the unmarshaled arguments
        err = w.Handler.ValidatePipelineExecutionPlan(ctx, id)
        return err</span>
}

// GetPipelineSteps converts echo context to params.
func (w *ServerInterfaceWrapper) GetPipelineSteps(ctx echo.Context) error <span class="cov0" title="0">{
        var err error
        // ------------- Path parameter "id" -------------
        var id openapi_types.UUID

        err = runtime.BindStyledParameterWithOptions("simple", "id", ctx.Param("id"), &amp;id, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
        if err != nil </span><span class="cov0" title="0">{
                return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter id: %s", err))
        }</span>

        <span class="cov0" title="0">ctx.Set(BearerAuthScopes, []string{})

        // Invoke the callback with all the unmarshaled arguments
        err = w.Handler.GetPipelineSteps(ctx, id)
        return err</span>
}

// CreatePipelineStep converts echo context to params.
func (w *ServerInterfaceWrapper) CreatePipelineStep(ctx echo.Context) error <span class="cov0" title="0">{
        var err error
        // ------------- Path parameter "id" -------------
        var id openapi_types.UUID

        err = runtime.BindStyledParameterWithOptions("simple", "id", ctx.Param("id"), &amp;id, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
        if err != nil </span><span class="cov0" title="0">{
                return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter id: %s", err))
        }</span>

        <span class="cov0" title="0">ctx.Set(BearerAuthScopes, []string{})

        // Invoke the callback with all the unmarshaled arguments
        err = w.Handler.CreatePipelineStep(ctx, id)
        return err</span>
}

// This is a simple interface which specifies echo.Route addition functions which
// are present on both echo.Echo and echo.Group, since we want to allow using
// either of them for path registration
type EchoRouter interface {
        CONNECT(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
        DELETE(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
        GET(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
        HEAD(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
        OPTIONS(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
        PATCH(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
        POST(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
        PUT(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
        TRACE(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
}

// RegisterHandlers adds each server route to the EchoRouter.
func RegisterHandlers(router EchoRouter, si ServerInterface) <span class="cov0" title="0">{
        RegisterHandlersWithBaseURL(router, si, "")
}</span>

// Registers handlers, and prepends BaseURL to the paths, so that the paths
// can be served under a prefix.
func RegisterHandlersWithBaseURL(router EchoRouter, si ServerInterface, baseURL string) <span class="cov0" title="0">{

        wrapper := ServerInterfaceWrapper{
                Handler: si,
        }

        router.GET(baseURL+"/workflows/pipelines", wrapper.FindManyPipelines)
        router.POST(baseURL+"/workflows/pipelines", wrapper.CreatePipeline)
        router.DELETE(baseURL+"/workflows/pipelines/:id", wrapper.DeletePipeline)
        router.GET(baseURL+"/workflows/pipelines/:id", wrapper.GetOnePipeline)
        router.PATCH(baseURL+"/workflows/pipelines/:id", wrapper.UpdatePipeline)
        router.GET(baseURL+"/workflows/pipelines/:id/execution-plans", wrapper.GetPipelineExecutionPlan)
        router.POST(baseURL+"/workflows/pipelines/:id/execution-plans", wrapper.ValidatePipelineExecutionPlan)
        router.GET(baseURL+"/workflows/pipelines/:id/steps", wrapper.GetPipelineSteps)
        router.POST(baseURL+"/workflows/pipelines/:id/steps", wrapper.CreatePipelineStep)

}</span>

type BadRequestApplicationProblemPlusJSONResponse Problem

type NotFoundApplicationProblemPlusJSONResponse Problem

type UnauthorizedApplicationProblemPlusJSONResponse Problem

type FindManyPipelinesRequestObject struct {
        Params FindManyPipelinesParams
}

type FindManyPipelinesResponseObject interface {
        VisitFindManyPipelinesResponse(w http.ResponseWriter) error
}

type FindManyPipelines200JSONResponse struct {
        Data []Pipeline `json:"data"`
        Meta struct {
                // Total Total number of items in the collection
                Total float32 `json:"total"`
        } `json:"meta"`
}

func (response FindManyPipelines200JSONResponse) VisitFindManyPipelinesResponse(w http.ResponseWriter) error <span class="cov0" title="0">{
        w.Header().Set("Content-Type", "application/json")
        w.WriteHeader(200)

        return json.NewEncoder(w).Encode(response)
}</span>

type FindManyPipelines400ApplicationProblemPlusJSONResponse struct {
        BadRequestApplicationProblemPlusJSONResponse
}

func (response FindManyPipelines400ApplicationProblemPlusJSONResponse) VisitFindManyPipelinesResponse(w http.ResponseWriter) error <span class="cov0" title="0">{
        w.Header().Set("Content-Type", "application/problem+json")
        w.WriteHeader(400)

        return json.NewEncoder(w).Encode(response)
}</span>

type FindManyPipelines401ApplicationProblemPlusJSONResponse struct {
        UnauthorizedApplicationProblemPlusJSONResponse
}

func (response FindManyPipelines401ApplicationProblemPlusJSONResponse) VisitFindManyPipelinesResponse(w http.ResponseWriter) error <span class="cov0" title="0">{
        w.Header().Set("Content-Type", "application/problem+json")
        w.WriteHeader(401)

        return json.NewEncoder(w).Encode(response)
}</span>

type CreatePipelineRequestObject struct {
        Body *CreatePipelineJSONRequestBody
}

type CreatePipelineResponseObject interface {
        VisitCreatePipelineResponse(w http.ResponseWriter) error
}

type CreatePipeline201JSONResponse struct {
        // Data Schema for Pipeline entity
        Data Pipeline `json:"data"`
}

func (response CreatePipeline201JSONResponse) VisitCreatePipelineResponse(w http.ResponseWriter) error <span class="cov0" title="0">{
        w.Header().Set("Content-Type", "application/json")
        w.WriteHeader(201)

        return json.NewEncoder(w).Encode(response)
}</span>

type CreatePipeline400ApplicationProblemPlusJSONResponse struct {
        BadRequestApplicationProblemPlusJSONResponse
}

func (response CreatePipeline400ApplicationProblemPlusJSONResponse) VisitCreatePipelineResponse(w http.ResponseWriter) error <span class="cov0" title="0">{
        w.Header().Set("Content-Type", "application/problem+json")
        w.WriteHeader(400)

        return json.NewEncoder(w).Encode(response)
}</span>

type CreatePipeline401ApplicationProblemPlusJSONResponse struct {
        UnauthorizedApplicationProblemPlusJSONResponse
}

func (response CreatePipeline401ApplicationProblemPlusJSONResponse) VisitCreatePipelineResponse(w http.ResponseWriter) error <span class="cov0" title="0">{
        w.Header().Set("Content-Type", "application/problem+json")
        w.WriteHeader(401)

        return json.NewEncoder(w).Encode(response)
}</span>

type DeletePipelineRequestObject struct {
        Id openapi_types.UUID `json:"id"`
}

type DeletePipelineResponseObject interface {
        VisitDeletePipelineResponse(w http.ResponseWriter) error
}

type DeletePipeline200JSONResponse struct {
        // Data Schema for Pipeline entity
        Data Pipeline `json:"data"`
}

func (response DeletePipeline200JSONResponse) VisitDeletePipelineResponse(w http.ResponseWriter) error <span class="cov0" title="0">{
        w.Header().Set("Content-Type", "application/json")
        w.WriteHeader(200)

        return json.NewEncoder(w).Encode(response)
}</span>

type DeletePipeline404ApplicationProblemPlusJSONResponse struct {
        NotFoundApplicationProblemPlusJSONResponse
}

func (response DeletePipeline404ApplicationProblemPlusJSONResponse) VisitDeletePipelineResponse(w http.ResponseWriter) error <span class="cov0" title="0">{
        w.Header().Set("Content-Type", "application/problem+json")
        w.WriteHeader(404)

        return json.NewEncoder(w).Encode(response)
}</span>

type GetOnePipelineRequestObject struct {
        Id openapi_types.UUID `json:"id"`
}

type GetOnePipelineResponseObject interface {
        VisitGetOnePipelineResponse(w http.ResponseWriter) error
}

type GetOnePipeline200JSONResponse struct {
        // Data Schema for Pipeline entity
        Data Pipeline `json:"data"`
}

func (response GetOnePipeline200JSONResponse) VisitGetOnePipelineResponse(w http.ResponseWriter) error <span class="cov0" title="0">{
        w.Header().Set("Content-Type", "application/json")
        w.WriteHeader(200)

        return json.NewEncoder(w).Encode(response)
}</span>

type GetOnePipeline404ApplicationProblemPlusJSONResponse struct {
        NotFoundApplicationProblemPlusJSONResponse
}

func (response GetOnePipeline404ApplicationProblemPlusJSONResponse) VisitGetOnePipelineResponse(w http.ResponseWriter) error <span class="cov0" title="0">{
        w.Header().Set("Content-Type", "application/problem+json")
        w.WriteHeader(404)

        return json.NewEncoder(w).Encode(response)
}</span>

type UpdatePipelineRequestObject struct {
        Id   openapi_types.UUID `json:"id"`
        Body *UpdatePipelineJSONRequestBody
}

type UpdatePipelineResponseObject interface {
        VisitUpdatePipelineResponse(w http.ResponseWriter) error
}

type UpdatePipeline200JSONResponse struct {
        // Data Schema for Pipeline entity
        Data Pipeline `json:"data"`
}

func (response UpdatePipeline200JSONResponse) VisitUpdatePipelineResponse(w http.ResponseWriter) error <span class="cov0" title="0">{
        w.Header().Set("Content-Type", "application/json")
        w.WriteHeader(200)

        return json.NewEncoder(w).Encode(response)
}</span>

type UpdatePipeline404ApplicationProblemPlusJSONResponse struct {
        NotFoundApplicationProblemPlusJSONResponse
}

func (response UpdatePipeline404ApplicationProblemPlusJSONResponse) VisitUpdatePipelineResponse(w http.ResponseWriter) error <span class="cov0" title="0">{
        w.Header().Set("Content-Type", "application/problem+json")
        w.WriteHeader(404)

        return json.NewEncoder(w).Encode(response)
}</span>

type GetPipelineExecutionPlanRequestObject struct {
        Id openapi_types.UUID `json:"id"`
}

type GetPipelineExecutionPlanResponseObject interface {
        VisitGetPipelineExecutionPlanResponse(w http.ResponseWriter) error
}

type GetPipelineExecutionPlan200JSONResponse struct {
        Data struct {
                // EstimatedDuration Estimated execution time in seconds
                EstimatedDuration *int `json:"estimatedDuration,omitempty"`

                // IsValid Whether the pipeline DAG is valid (no cycles)
                IsValid bool `json:"isValid"`
                Levels  []struct {
                        // Level Execution level (0-based)
                        Level int `json:"level"`

                        // Steps Step IDs that can run in parallel at this level
                        Steps []openapi_types.UUID `json:"steps"`
                } `json:"levels"`
                PipelineId openapi_types.UUID `json:"pipelineId"`

                // TotalSteps Total number of steps in the pipeline
                TotalSteps int `json:"totalSteps"`
        } `json:"data"`
}

func (response GetPipelineExecutionPlan200JSONResponse) VisitGetPipelineExecutionPlanResponse(w http.ResponseWriter) error <span class="cov0" title="0">{
        w.Header().Set("Content-Type", "application/json")
        w.WriteHeader(200)

        return json.NewEncoder(w).Encode(response)
}</span>

type GetPipelineExecutionPlan400ApplicationProblemPlusJSONResponse struct {
        BadRequestApplicationProblemPlusJSONResponse
}

func (response GetPipelineExecutionPlan400ApplicationProblemPlusJSONResponse) VisitGetPipelineExecutionPlanResponse(w http.ResponseWriter) error <span class="cov0" title="0">{
        w.Header().Set("Content-Type", "application/problem+json")
        w.WriteHeader(400)

        return json.NewEncoder(w).Encode(response)
}</span>

type GetPipelineExecutionPlan401ApplicationProblemPlusJSONResponse struct {
        UnauthorizedApplicationProblemPlusJSONResponse
}

func (response GetPipelineExecutionPlan401ApplicationProblemPlusJSONResponse) VisitGetPipelineExecutionPlanResponse(w http.ResponseWriter) error <span class="cov0" title="0">{
        w.Header().Set("Content-Type", "application/problem+json")
        w.WriteHeader(401)

        return json.NewEncoder(w).Encode(response)
}</span>

type GetPipelineExecutionPlan404ApplicationProblemPlusJSONResponse struct {
        NotFoundApplicationProblemPlusJSONResponse
}

func (response GetPipelineExecutionPlan404ApplicationProblemPlusJSONResponse) VisitGetPipelineExecutionPlanResponse(w http.ResponseWriter) error <span class="cov0" title="0">{
        w.Header().Set("Content-Type", "application/problem+json")
        w.WriteHeader(404)

        return json.NewEncoder(w).Encode(response)
}</span>

type ValidatePipelineExecutionPlanRequestObject struct {
        Id openapi_types.UUID `json:"id"`
}

type ValidatePipelineExecutionPlanResponseObject interface {
        VisitValidatePipelineExecutionPlanResponse(w http.ResponseWriter) error
}

type ValidatePipelineExecutionPlan200JSONResponse struct {
        Data struct {
                // Issues List of any warnings or non-critical issues
                Issues *[]string `json:"issues,omitempty"`
                Valid  bool      `json:"valid"`
        } `json:"data"`
}

func (response ValidatePipelineExecutionPlan200JSONResponse) VisitValidatePipelineExecutionPlanResponse(w http.ResponseWriter) error <span class="cov0" title="0">{
        w.Header().Set("Content-Type", "application/json")
        w.WriteHeader(200)

        return json.NewEncoder(w).Encode(response)
}</span>

type ValidatePipelineExecutionPlan400ApplicationProblemPlusJSONResponse struct {
        BadRequestApplicationProblemPlusJSONResponse
}

func (response ValidatePipelineExecutionPlan400ApplicationProblemPlusJSONResponse) VisitValidatePipelineExecutionPlanResponse(w http.ResponseWriter) error <span class="cov0" title="0">{
        w.Header().Set("Content-Type", "application/problem+json")
        w.WriteHeader(400)

        return json.NewEncoder(w).Encode(response)
}</span>

type ValidatePipelineExecutionPlan401ApplicationProblemPlusJSONResponse struct {
        UnauthorizedApplicationProblemPlusJSONResponse
}

func (response ValidatePipelineExecutionPlan401ApplicationProblemPlusJSONResponse) VisitValidatePipelineExecutionPlanResponse(w http.ResponseWriter) error <span class="cov0" title="0">{
        w.Header().Set("Content-Type", "application/problem+json")
        w.WriteHeader(401)

        return json.NewEncoder(w).Encode(response)
}</span>

type ValidatePipelineExecutionPlan404ApplicationProblemPlusJSONResponse struct {
        NotFoundApplicationProblemPlusJSONResponse
}

func (response ValidatePipelineExecutionPlan404ApplicationProblemPlusJSONResponse) VisitValidatePipelineExecutionPlanResponse(w http.ResponseWriter) error <span class="cov0" title="0">{
        w.Header().Set("Content-Type", "application/problem+json")
        w.WriteHeader(404)

        return json.NewEncoder(w).Encode(response)
}</span>

type GetPipelineStepsRequestObject struct {
        Id openapi_types.UUID `json:"id"`
}

type GetPipelineStepsResponseObject interface {
        VisitGetPipelineStepsResponse(w http.ResponseWriter) error
}

type GetPipelineSteps200JSONResponse struct {
        Data []PipelineStep `json:"data"`
}

func (response GetPipelineSteps200JSONResponse) VisitGetPipelineStepsResponse(w http.ResponseWriter) error <span class="cov0" title="0">{
        w.Header().Set("Content-Type", "application/json")
        w.WriteHeader(200)

        return json.NewEncoder(w).Encode(response)
}</span>

type GetPipelineSteps401ApplicationProblemPlusJSONResponse struct {
        UnauthorizedApplicationProblemPlusJSONResponse
}

func (response GetPipelineSteps401ApplicationProblemPlusJSONResponse) VisitGetPipelineStepsResponse(w http.ResponseWriter) error <span class="cov0" title="0">{
        w.Header().Set("Content-Type", "application/problem+json")
        w.WriteHeader(401)

        return json.NewEncoder(w).Encode(response)
}</span>

type GetPipelineSteps404ApplicationProblemPlusJSONResponse struct {
        NotFoundApplicationProblemPlusJSONResponse
}

func (response GetPipelineSteps404ApplicationProblemPlusJSONResponse) VisitGetPipelineStepsResponse(w http.ResponseWriter) error <span class="cov0" title="0">{
        w.Header().Set("Content-Type", "application/problem+json")
        w.WriteHeader(404)

        return json.NewEncoder(w).Encode(response)
}</span>

type CreatePipelineStepRequestObject struct {
        Id   openapi_types.UUID `json:"id"`
        Body *CreatePipelineStepJSONRequestBody
}

type CreatePipelineStepResponseObject interface {
        VisitCreatePipelineStepResponse(w http.ResponseWriter) error
}

type CreatePipelineStep201JSONResponse struct {
        // Data Schema for PipelineStep entity
        Data PipelineStep `json:"data"`
}

func (response CreatePipelineStep201JSONResponse) VisitCreatePipelineStepResponse(w http.ResponseWriter) error <span class="cov0" title="0">{
        w.Header().Set("Content-Type", "application/json")
        w.WriteHeader(201)

        return json.NewEncoder(w).Encode(response)
}</span>

type CreatePipelineStep400ApplicationProblemPlusJSONResponse struct {
        BadRequestApplicationProblemPlusJSONResponse
}

func (response CreatePipelineStep400ApplicationProblemPlusJSONResponse) VisitCreatePipelineStepResponse(w http.ResponseWriter) error <span class="cov0" title="0">{
        w.Header().Set("Content-Type", "application/problem+json")
        w.WriteHeader(400)

        return json.NewEncoder(w).Encode(response)
}</span>

type CreatePipelineStep401ApplicationProblemPlusJSONResponse struct {
        UnauthorizedApplicationProblemPlusJSONResponse
}

func (response CreatePipelineStep401ApplicationProblemPlusJSONResponse) VisitCreatePipelineStepResponse(w http.ResponseWriter) error <span class="cov0" title="0">{
        w.Header().Set("Content-Type", "application/problem+json")
        w.WriteHeader(401)

        return json.NewEncoder(w).Encode(response)
}</span>

type CreatePipelineStep404ApplicationProblemPlusJSONResponse struct {
        NotFoundApplicationProblemPlusJSONResponse
}

func (response CreatePipelineStep404ApplicationProblemPlusJSONResponse) VisitCreatePipelineStepResponse(w http.ResponseWriter) error <span class="cov0" title="0">{
        w.Header().Set("Content-Type", "application/problem+json")
        w.WriteHeader(404)

        return json.NewEncoder(w).Encode(response)
}</span>

// StrictServerInterface represents all server handlers.
type StrictServerInterface interface {
        // Find many pipelines
        // (GET /workflows/pipelines)
        FindManyPipelines(ctx context.Context, request FindManyPipelinesRequestObject) (FindManyPipelinesResponseObject, error)
        // Create a new pipeline
        // (POST /workflows/pipelines)
        CreatePipeline(ctx context.Context, request CreatePipelineRequestObject) (CreatePipelineResponseObject, error)
        // Delete a pipeline
        // (DELETE /workflows/pipelines/{id})
        DeletePipeline(ctx context.Context, request DeletePipelineRequestObject) (DeletePipelineResponseObject, error)
        // Find a pipeline
        // (GET /workflows/pipelines/{id})
        GetOnePipeline(ctx context.Context, request GetOnePipelineRequestObject) (GetOnePipelineResponseObject, error)
        // Update a pipeline
        // (PATCH /workflows/pipelines/{id})
        UpdatePipeline(ctx context.Context, request UpdatePipelineRequestObject) (UpdatePipelineResponseObject, error)
        // Get execution plan for a pipeline
        // (GET /workflows/pipelines/{id}/execution-plans)
        GetPipelineExecutionPlan(ctx context.Context, request GetPipelineExecutionPlanRequestObject) (GetPipelineExecutionPlanResponseObject, error)
        // Validate a pipeline configuration
        // (POST /workflows/pipelines/{id}/execution-plans)
        ValidatePipelineExecutionPlan(ctx context.Context, request ValidatePipelineExecutionPlanRequestObject) (ValidatePipelineExecutionPlanResponseObject, error)
        // Get all steps for a pipeline
        // (GET /workflows/pipelines/{id}/steps)
        GetPipelineSteps(ctx context.Context, request GetPipelineStepsRequestObject) (GetPipelineStepsResponseObject, error)
        // Add a step to a pipeline
        // (POST /workflows/pipelines/{id}/steps)
        CreatePipelineStep(ctx context.Context, request CreatePipelineStepRequestObject) (CreatePipelineStepResponseObject, error)
}

type StrictHandlerFunc = strictecho.StrictEchoHandlerFunc
type StrictMiddlewareFunc = strictecho.StrictEchoMiddlewareFunc

func NewStrictHandler(ssi StrictServerInterface, middlewares []StrictMiddlewareFunc) ServerInterface <span class="cov0" title="0">{
        return &amp;strictHandler{ssi: ssi, middlewares: middlewares}
}</span>

type strictHandler struct {
        ssi         StrictServerInterface
        middlewares []StrictMiddlewareFunc
}

// FindManyPipelines operation middleware
func (sh *strictHandler) FindManyPipelines(ctx echo.Context, params FindManyPipelinesParams) error <span class="cov0" title="0">{
        var request FindManyPipelinesRequestObject

        request.Params = params

        handler := func(ctx echo.Context, request interface{}) (interface{}, error) </span><span class="cov0" title="0">{
                return sh.ssi.FindManyPipelines(ctx.Request().Context(), request.(FindManyPipelinesRequestObject))
        }</span>
        <span class="cov0" title="0">for _, middleware := range sh.middlewares </span><span class="cov0" title="0">{
                handler = middleware(handler, "FindManyPipelines")
        }</span>

        <span class="cov0" title="0">response, err := handler(ctx, request)

        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span> else<span class="cov0" title="0"> if validResponse, ok := response.(FindManyPipelinesResponseObject); ok </span><span class="cov0" title="0">{
                return validResponse.VisitFindManyPipelinesResponse(ctx.Response())
        }</span> else<span class="cov0" title="0"> if response != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("unexpected response type: %T", response)
        }</span>
        <span class="cov0" title="0">return nil</span>
}

// CreatePipeline operation middleware
func (sh *strictHandler) CreatePipeline(ctx echo.Context) error <span class="cov0" title="0">{
        var request CreatePipelineRequestObject

        var body CreatePipelineJSONRequestBody
        if err := ctx.Bind(&amp;body); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov0" title="0">request.Body = &amp;body

        handler := func(ctx echo.Context, request interface{}) (interface{}, error) </span><span class="cov0" title="0">{
                return sh.ssi.CreatePipeline(ctx.Request().Context(), request.(CreatePipelineRequestObject))
        }</span>
        <span class="cov0" title="0">for _, middleware := range sh.middlewares </span><span class="cov0" title="0">{
                handler = middleware(handler, "CreatePipeline")
        }</span>

        <span class="cov0" title="0">response, err := handler(ctx, request)

        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span> else<span class="cov0" title="0"> if validResponse, ok := response.(CreatePipelineResponseObject); ok </span><span class="cov0" title="0">{
                return validResponse.VisitCreatePipelineResponse(ctx.Response())
        }</span> else<span class="cov0" title="0"> if response != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("unexpected response type: %T", response)
        }</span>
        <span class="cov0" title="0">return nil</span>
}

// DeletePipeline operation middleware
func (sh *strictHandler) DeletePipeline(ctx echo.Context, id openapi_types.UUID) error <span class="cov0" title="0">{
        var request DeletePipelineRequestObject

        request.Id = id

        handler := func(ctx echo.Context, request interface{}) (interface{}, error) </span><span class="cov0" title="0">{
                return sh.ssi.DeletePipeline(ctx.Request().Context(), request.(DeletePipelineRequestObject))
        }</span>
        <span class="cov0" title="0">for _, middleware := range sh.middlewares </span><span class="cov0" title="0">{
                handler = middleware(handler, "DeletePipeline")
        }</span>

        <span class="cov0" title="0">response, err := handler(ctx, request)

        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span> else<span class="cov0" title="0"> if validResponse, ok := response.(DeletePipelineResponseObject); ok </span><span class="cov0" title="0">{
                return validResponse.VisitDeletePipelineResponse(ctx.Response())
        }</span> else<span class="cov0" title="0"> if response != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("unexpected response type: %T", response)
        }</span>
        <span class="cov0" title="0">return nil</span>
}

// GetOnePipeline operation middleware
func (sh *strictHandler) GetOnePipeline(ctx echo.Context, id openapi_types.UUID) error <span class="cov0" title="0">{
        var request GetOnePipelineRequestObject

        request.Id = id

        handler := func(ctx echo.Context, request interface{}) (interface{}, error) </span><span class="cov0" title="0">{
                return sh.ssi.GetOnePipeline(ctx.Request().Context(), request.(GetOnePipelineRequestObject))
        }</span>
        <span class="cov0" title="0">for _, middleware := range sh.middlewares </span><span class="cov0" title="0">{
                handler = middleware(handler, "GetOnePipeline")
        }</span>

        <span class="cov0" title="0">response, err := handler(ctx, request)

        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span> else<span class="cov0" title="0"> if validResponse, ok := response.(GetOnePipelineResponseObject); ok </span><span class="cov0" title="0">{
                return validResponse.VisitGetOnePipelineResponse(ctx.Response())
        }</span> else<span class="cov0" title="0"> if response != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("unexpected response type: %T", response)
        }</span>
        <span class="cov0" title="0">return nil</span>
}

// UpdatePipeline operation middleware
func (sh *strictHandler) UpdatePipeline(ctx echo.Context, id openapi_types.UUID) error <span class="cov0" title="0">{
        var request UpdatePipelineRequestObject

        request.Id = id

        var body UpdatePipelineJSONRequestBody
        if err := ctx.Bind(&amp;body); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov0" title="0">request.Body = &amp;body

        handler := func(ctx echo.Context, request interface{}) (interface{}, error) </span><span class="cov0" title="0">{
                return sh.ssi.UpdatePipeline(ctx.Request().Context(), request.(UpdatePipelineRequestObject))
        }</span>
        <span class="cov0" title="0">for _, middleware := range sh.middlewares </span><span class="cov0" title="0">{
                handler = middleware(handler, "UpdatePipeline")
        }</span>

        <span class="cov0" title="0">response, err := handler(ctx, request)

        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span> else<span class="cov0" title="0"> if validResponse, ok := response.(UpdatePipelineResponseObject); ok </span><span class="cov0" title="0">{
                return validResponse.VisitUpdatePipelineResponse(ctx.Response())
        }</span> else<span class="cov0" title="0"> if response != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("unexpected response type: %T", response)
        }</span>
        <span class="cov0" title="0">return nil</span>
}

// GetPipelineExecutionPlan operation middleware
func (sh *strictHandler) GetPipelineExecutionPlan(ctx echo.Context, id openapi_types.UUID) error <span class="cov0" title="0">{
        var request GetPipelineExecutionPlanRequestObject

        request.Id = id

        handler := func(ctx echo.Context, request interface{}) (interface{}, error) </span><span class="cov0" title="0">{
                return sh.ssi.GetPipelineExecutionPlan(ctx.Request().Context(), request.(GetPipelineExecutionPlanRequestObject))
        }</span>
        <span class="cov0" title="0">for _, middleware := range sh.middlewares </span><span class="cov0" title="0">{
                handler = middleware(handler, "GetPipelineExecutionPlan")
        }</span>

        <span class="cov0" title="0">response, err := handler(ctx, request)

        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span> else<span class="cov0" title="0"> if validResponse, ok := response.(GetPipelineExecutionPlanResponseObject); ok </span><span class="cov0" title="0">{
                return validResponse.VisitGetPipelineExecutionPlanResponse(ctx.Response())
        }</span> else<span class="cov0" title="0"> if response != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("unexpected response type: %T", response)
        }</span>
        <span class="cov0" title="0">return nil</span>
}

// ValidatePipelineExecutionPlan operation middleware
func (sh *strictHandler) ValidatePipelineExecutionPlan(ctx echo.Context, id openapi_types.UUID) error <span class="cov0" title="0">{
        var request ValidatePipelineExecutionPlanRequestObject

        request.Id = id

        handler := func(ctx echo.Context, request interface{}) (interface{}, error) </span><span class="cov0" title="0">{
                return sh.ssi.ValidatePipelineExecutionPlan(ctx.Request().Context(), request.(ValidatePipelineExecutionPlanRequestObject))
        }</span>
        <span class="cov0" title="0">for _, middleware := range sh.middlewares </span><span class="cov0" title="0">{
                handler = middleware(handler, "ValidatePipelineExecutionPlan")
        }</span>

        <span class="cov0" title="0">response, err := handler(ctx, request)

        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span> else<span class="cov0" title="0"> if validResponse, ok := response.(ValidatePipelineExecutionPlanResponseObject); ok </span><span class="cov0" title="0">{
                return validResponse.VisitValidatePipelineExecutionPlanResponse(ctx.Response())
        }</span> else<span class="cov0" title="0"> if response != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("unexpected response type: %T", response)
        }</span>
        <span class="cov0" title="0">return nil</span>
}

// GetPipelineSteps operation middleware
func (sh *strictHandler) GetPipelineSteps(ctx echo.Context, id openapi_types.UUID) error <span class="cov0" title="0">{
        var request GetPipelineStepsRequestObject

        request.Id = id

        handler := func(ctx echo.Context, request interface{}) (interface{}, error) </span><span class="cov0" title="0">{
                return sh.ssi.GetPipelineSteps(ctx.Request().Context(), request.(GetPipelineStepsRequestObject))
        }</span>
        <span class="cov0" title="0">for _, middleware := range sh.middlewares </span><span class="cov0" title="0">{
                handler = middleware(handler, "GetPipelineSteps")
        }</span>

        <span class="cov0" title="0">response, err := handler(ctx, request)

        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span> else<span class="cov0" title="0"> if validResponse, ok := response.(GetPipelineStepsResponseObject); ok </span><span class="cov0" title="0">{
                return validResponse.VisitGetPipelineStepsResponse(ctx.Response())
        }</span> else<span class="cov0" title="0"> if response != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("unexpected response type: %T", response)
        }</span>
        <span class="cov0" title="0">return nil</span>
}

// CreatePipelineStep operation middleware
func (sh *strictHandler) CreatePipelineStep(ctx echo.Context, id openapi_types.UUID) error <span class="cov0" title="0">{
        var request CreatePipelineStepRequestObject

        request.Id = id

        var body CreatePipelineStepJSONRequestBody
        if err := ctx.Bind(&amp;body); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov0" title="0">request.Body = &amp;body

        handler := func(ctx echo.Context, request interface{}) (interface{}, error) </span><span class="cov0" title="0">{
                return sh.ssi.CreatePipelineStep(ctx.Request().Context(), request.(CreatePipelineStepRequestObject))
        }</span>
        <span class="cov0" title="0">for _, middleware := range sh.middlewares </span><span class="cov0" title="0">{
                handler = middleware(handler, "CreatePipelineStep")
        }</span>

        <span class="cov0" title="0">response, err := handler(ctx, request)

        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span> else<span class="cov0" title="0"> if validResponse, ok := response.(CreatePipelineStepResponseObject); ok </span><span class="cov0" title="0">{
                return validResponse.VisitCreatePipelineStepResponse(ctx.Response())
        }</span> else<span class="cov0" title="0"> if response != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("unexpected response type: %T", response)
        }</span>
        <span class="cov0" title="0">return nil</span>
}
</pre>
		
		<pre class="file" id="file119" style="display: none">package pipelines

import (
        "context"
        "fmt"
        "log/slog"

        "github.com/google/uuid"
        openapi_types "github.com/oapi-codegen/runtime/types"
)

// PipelineManager handles pipeline step operations with DAG support
type PipelineManager struct {
        pipelineRepository     Repository
        pipelineStepRepository PipelineStepRepository
        logger                 *slog.Logger
}

// NewPipelineManager creates a new pipeline manager
func NewPipelineManager(pipelineRepository Repository, pipelineStepRepository PipelineStepRepository, logger *slog.Logger) *PipelineManager <span class="cov0" title="0">{
        return &amp;PipelineManager{
                pipelineRepository:     pipelineRepository,
                pipelineStepRepository: pipelineStepRepository,
                logger:                 logger,
        }
}</span>

// CreatePipelineStep adds a new step to a pipeline
func (pm *PipelineManager) CreatePipelineStep(ctx context.Context, pipelineID, toolID uuid.UUID, config map[string]interface{}) (*PipelineStep, error) <span class="cov0" title="0">{
        step := &amp;PipelineStep{
                Id:         uuid.New(),
                PipelineId: pipelineID,
                ToolId:     toolID,
                Config:     config,
        }

        // Store the step using the step repository
        createdStep, err := pm.pipelineStepRepository.CreatePipelineStep(ctx, step)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to create pipeline step: %w", err)
        }</span>

        <span class="cov0" title="0">return createdStep, nil</span>
}

// AddStepDependency creates a dependency between two steps
func (pm *PipelineManager) AddStepDependency(ctx context.Context, stepID, dependsOnID uuid.UUID) error <span class="cov0" title="0">{
        // Create the dependency
        err := pm.pipelineStepRepository.CreateStepDependency(ctx, stepID, dependsOnID)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to create dependency: %w", err)
        }</span>

        // Validate no cycles were created by getting all steps for validation
        // For now, we'll skip cycle validation until we have pipeline ID context
        // TODO: Add proper cycle validation when we have pipeline context
        <span class="cov0" title="0">pm.logger.Info("Created step dependency", "stepId", stepID, "dependsOnId", dependsOnID)

        return nil</span>
}

// GetPipelineDAG retrieves all steps and dependencies for a pipeline
func (pm *PipelineManager) GetPipelineDAG(ctx context.Context, pipelineID uuid.UUID) ([]PipelineStep, map[uuid.UUID][]uuid.UUID, error) <span class="cov0" title="0">{
        // Get all steps for the pipeline
        steps, err := pm.pipelineStepRepository.GetPipelineSteps(ctx, pipelineID)
        if err != nil </span><span class="cov0" title="0">{
                return nil, nil, fmt.Errorf("failed to get pipeline steps: %w", err)
        }</span>

        // Get all dependencies for the pipeline
        <span class="cov0" title="0">dependencies, err := pm.pipelineStepRepository.GetPipelineDependencies(ctx, pipelineID)
        if err != nil </span><span class="cov0" title="0">{
                return nil, nil, fmt.Errorf("failed to get dependencies: %w", err)
        }</span>

        <span class="cov0" title="0">return steps, dependencies, nil</span>
}

// ValidatePipeline checks if a pipeline is valid for execution
func (pm *PipelineManager) ValidatePipeline(ctx context.Context, pipelineID uuid.UUID) error <span class="cov0" title="0">{
        steps, deps, err := pm.GetPipelineDAG(ctx, pipelineID)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov0" title="0">if len(steps) == 0 </span><span class="cov0" title="0">{
                return fmt.Errorf("pipeline has no steps")
        }</span>

        // Create DAG and validate
        <span class="cov0" title="0">dag, err := NewDAG(steps, deps)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("invalid pipeline: %w", err)
        }</span>

        // Check for unreachable nodes
        <span class="cov0" title="0">sorted, err := dag.TopologicalSort()
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("pipeline validation failed: %w", err)
        }</span>

        <span class="cov0" title="0">if len(sorted) != len(steps) </span><span class="cov0" title="0">{
                return fmt.Errorf("pipeline contains unreachable steps")
        }</span>

        <span class="cov0" title="0">return nil</span>
}

// GetExecutionPlan returns the execution plan for a pipeline
func (pm *PipelineManager) GetExecutionPlan(ctx context.Context, pipelineID uuid.UUID) ([][]uuid.UUID, error) <span class="cov0" title="0">{
        steps, deps, err := pm.GetPipelineDAG(ctx, pipelineID)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov0" title="0">dag, err := NewDAG(steps, deps)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to create DAG: %w", err)
        }</span>

        <span class="cov0" title="0">return dag.GetExecutionPlan()</span>
}

// PipelineStepResponse represents the API response for a pipeline step
type PipelineStepResponse struct {
        ID           openapi_types.UUID     `json:"id"`
        PipelineID   openapi_types.UUID     `json:"pipelineId"`
        ToolID       openapi_types.UUID     `json:"toolId"`
        Name         string                 `json:"name"`
        Description  string                 `json:"description"`
        Config       map[string]interface{} `json:"config"`
        Position     int                    `json:"position"`
        Dependencies []openapi_types.UUID   `json:"dependencies"`
}

// ConvertStepToResponse converts a domain step to API response
func ConvertStepToResponse(step *PipelineStep, dependencies []uuid.UUID) PipelineStepResponse <span class="cov0" title="0">{
        deps := make([]openapi_types.UUID, len(dependencies))
        copy(deps, dependencies)

        return PipelineStepResponse{
                ID:           step.Id,
                PipelineID:   step.PipelineId,
                ToolID:       step.ToolId,
                Name:         step.Name,
                Description:  step.Description,
                Config:       step.Config,
                Position:     step.Position,
                Dependencies: deps,
        }
}</span>

// ExecutionPlanResponse represents the execution plan for a pipeline
type ExecutionPlanResponse struct {
        PipelineID openapi_types.UUID `json:"pipelineId"`
        Levels     []ExecutionLevel   `json:"levels"`
        TotalSteps int                `json:"totalSteps"`
        IsValid    bool               `json:"isValid"`
}

// ExecutionLevel represents a level of parallel execution
type ExecutionLevel struct {
        Level int                  `json:"level"`
        Steps []openapi_types.UUID `json:"steps"`
}

// ConvertExecutionPlan converts internal execution plan to API response
func ConvertExecutionPlan(pipelineID uuid.UUID, plan [][]uuid.UUID) ExecutionPlanResponse <span class="cov0" title="0">{
        levels := make([]ExecutionLevel, len(plan))
        totalSteps := 0

        for i, level := range plan </span><span class="cov0" title="0">{
                steps := make([]openapi_types.UUID, len(level))
                copy(steps, level)
                levels[i] = ExecutionLevel{
                        Level: i,
                        Steps: steps,
                }
                totalSteps += len(level)
        }</span>

        <span class="cov0" title="0">return ExecutionPlanResponse{
                PipelineID: pipelineID,
                Levels:     levels,
                TotalSteps: totalSteps,
                IsValid:    true,
        }</span>
}
</pre>
		
		<pre class="file" id="file120" style="display: none">// Code generated by codegen repository. DO NOT EDIT.
package pipelines

import (
        "context"
        "errors"

        "github.com/archesai/archesai/internal/database/postgresql"
        "github.com/google/uuid"
        "github.com/jackc/pgx/v5/pgxpool"
)

// PostgresRepository implements Repository using PostgreSQL.
type PostgresRepository struct {
        db      *pgxpool.Pool
        queries *postgresql.Queries
}

// NewPostgresRepository creates a new PostgreSQL repository.
func NewPostgresRepository(db *pgxpool.Pool) Repository <span class="cov0" title="0">{
        return &amp;PostgresRepository{
                db:      db,
                queries: postgresql.New(db),
        }
}</span>

// Pipeline operations

func (r *PostgresRepository) Create(ctx context.Context, entity *Pipeline) (*Pipeline, error) <span class="cov0" title="0">{
        // Check if SQLC has the CreatePipeline method
        // For now, we'll generate a stub but with proper error handling
        // TODO: Parse SQLC to detect available queries

        // Example of what it should look like when SQLC query exists:
        // params := postgresql.CreatePipelineParams{
        //     Id: entity.Id,
        //     // ... map other fields
        // }
        // dbPipeline, err := r.queries.CreatePipeline(ctx, params)
        // if err != nil {
        //     return nil, NewRepositoryError("create", err)
        // }
        // return mapPipelineToDomain(&amp;dbPipeline), nil

        return nil, NewRepositoryError("create", errors.New("not implemented - SQLC query not found"))
}</span>

func (r *PostgresRepository) Get(ctx context.Context, id uuid.UUID) (*Pipeline, error) <span class="cov0" title="0">{
        // Try to call SQLC GetPipeline if it exists
        // For now, return not implemented
        return nil, NewRepositoryError("get", errors.New("not implemented - SQLC query not found"))
}</span>

func (r *PostgresRepository) Update(ctx context.Context, id uuid.UUID, entity *Pipeline) (*Pipeline, error) <span class="cov0" title="0">{
        // Update operations are often custom and may not have SQLC queries
        return nil, NewRepositoryError("update", errors.New("not implemented - SQLC query not found"))
}</span>

func (r *PostgresRepository) Delete(ctx context.Context, id uuid.UUID) error <span class="cov0" title="0">{
        // Try to call SQLC DeletePipeline if it exists
        // For now, return not implemented
        return NewRepositoryError("delete", errors.New("not implemented - SQLC query not found"))
}</span>

func (r *PostgresRepository) List(ctx context.Context, params ListPipelinesParams) ([]*Pipeline, int64, error) <span class="cov0" title="0">{
        // List operations need both List and Count queries from SQLC
        return nil, 0, NewRepositoryError("list", errors.New("not implemented - SQLC query not found"))
}</span>

// ListByOrganization retrieves multiple pipelines by organizationId
func (r *PostgresRepository) ListByOrganization(ctx context.Context, organizationId string) ([]*Pipeline, error) <span class="cov0" title="0">{

        // Try to call SQLC ListByOrganization if it exists
        // For now, return not implemented
        return nil, NewRepositoryError("listbyorganization", errors.New("not implemented - SQLC query not found"))

}</span>

// Mapper functions - Convert between domain types and database types
// These need to be customized based on the actual field mappings

func mapPipelineToDomain(db *postgresql.Pipeline) *Pipeline <span class="cov0" title="0">{
        if db == nil </span><span class="cov0" title="0">{
                return nil
        }</span>

        // This is a basic mapping - needs to be customized based on actual types
        // The challenge is that OpenAPI types and database types don't always match
        // For example:
        // - OpenAPI might use string, database uses *string
        // - OpenAPI might use custom UUID type, database uses uuid.UUID
        // - Field names might differ (Id vs ID)

        <span class="cov0" title="0">result := &amp;Pipeline{
                // TODO: Map fields properly based on actual type definitions
                // This requires parsing both OpenAPI types and SQLC types
        }

        // Basic field mapping - customize based on your entity structure
        // result.Id = db.Id
        // result.CreatedAt = db.CreatedAt
        // result.UpdatedAt = db.UpdatedAt
        // Add specific field mappings as needed

        return result</span>
}
</pre>
		
		<pre class="file" id="file121" style="display: none">// Package pipelines provides Redis-based adapters for pipelines
package pipelines

import (
        "encoding/json"
        "fmt"

        "github.com/archesai/archesai/internal/redis"
        "github.com/archesai/archesai/internal/runs"
)

// QueueAdapter handles job queueing in Redis
type QueueAdapter struct {
        client *redis.Client
}

// NewQueueAdapter creates a new Redis queue adapter
func NewQueueAdapter(client *redis.Client) *QueueAdapter <span class="cov0" title="0">{
        return &amp;QueueAdapter{
                client: client,
        }
}</span>

// EnqueueRun adds a run to the processing queue
func (q *QueueAdapter) EnqueueRun(run *runs.Run) error <span class="cov0" title="0">{
        queueName := fmt.Sprintf("workflows:runs:%s", run.Status)
        data, err := json.Marshal(run)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to marshal run: %w", err)
        }</span>
        <span class="cov0" title="0">return q.client.Queue.Push(queueName, data)</span>
}

// DequeueRun retrieves and removes a run from the queue
func (q *QueueAdapter) DequeueRun(status string, timeout int) (*runs.Run, error) <span class="cov0" title="0">{
        queueName := fmt.Sprintf("workflows:runs:%s", status)
        var run runs.Run
        err := q.client.Queue.PopBlocking(queueName, timeout, &amp;run)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">return &amp;run, nil</span>
}

// PeekQueue checks the next item without removing it
func (q *QueueAdapter) PeekQueue(status string) (*runs.Run, error) <span class="cov0" title="0">{
        queueName := fmt.Sprintf("workflows:runs:%s", status)
        var run runs.Run
        err := q.client.Queue.Peek(queueName, &amp;run)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">return &amp;run, nil</span>
}

// GetQueueLength returns the number of items in a queue
func (q *QueueAdapter) GetQueueLength(status string) (int64, error) <span class="cov0" title="0">{
        queueName := fmt.Sprintf("workflows:runs:%s", status)
        return q.client.Queue.Length(queueName)
}</span>

// MoveRun moves a run from one status queue to another
func (q *QueueAdapter) MoveRun(run *runs.Run, fromStatus, toStatus string) error <span class="cov0" title="0">{
        // Remove from old queue
        fromQueue := fmt.Sprintf("workflows:runs:%s", fromStatus)
        if err := q.client.Queue.Remove(fromQueue, run); err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to remove from %s queue: %w", fromStatus, err)
        }</span>

        // Add to new queue with updated status
        <span class="cov0" title="0">run.Status = runs.RunStatus(toStatus)
        return q.EnqueueRun(run)</span>
}
</pre>
		
		<pre class="file" id="file122" style="display: none">// Code generated by codegen repository. DO NOT EDIT.
package pipelines

import (
        "context"
        "fmt"
        "github.com/google/uuid"
)

// Repository handles pipeline persistence
type Repository interface {
        Create(ctx context.Context, entity *Pipeline) (*Pipeline, error)
        Get(ctx context.Context, id uuid.UUID) (*Pipeline, error)
        Update(ctx context.Context, id uuid.UUID, entity *Pipeline) (*Pipeline, error)
        Delete(ctx context.Context, id uuid.UUID) error
        List(ctx context.Context, params ListPipelinesParams) ([]*Pipeline, int64, error)

        // Additional operations
        ListByOrganization(ctx context.Context, organizationId string) ([]*Pipeline, error)
}

// ListPipelinesParams represents parameters for listing pipelines.
type ListPipelinesParams struct {
        Limit  int
        Offset int
}

// RepositoryError represents a repository error.
type RepositoryError struct {
        Operation string
        Err       error
}

func (e *RepositoryError) Error() string <span class="cov0" title="0">{
        return fmt.Sprintf("repository %s: %v", e.Operation, e.Err)
}</span>

func (e *RepositoryError) Unwrap() error <span class="cov0" title="0">{
        return e.Err
}</span>

// NewRepositoryError creates a new repository error.
func NewRepositoryError(operation string, err error) *RepositoryError <span class="cov0" title="0">{
        return &amp;RepositoryError{
                Operation: operation,
                Err:       err,
        }
}</span>
</pre>
		
		<pre class="file" id="file123" style="display: none">package pipelines

import (
        "context"
        "fmt"
        "log/slog"
        "time"

        "github.com/google/uuid"
)

// Service provides pipeline business logic
type Service struct {
        pipelineRepo Repository
        logger       *slog.Logger
}

// NewService creates a new pipeline service
func NewService(pipelineRepo Repository, logger *slog.Logger) *Service <span class="cov10" title="7">{
        return &amp;Service{
                pipelineRepo: pipelineRepo,
                logger:       logger,
        }
}</span>

// Create creates a new pipeline
func (s *Service) Create(ctx context.Context, req *CreatePipelineRequest, orgID string) (*Pipeline, error) <span class="cov1" title="1">{
        s.logger.Debug("creating pipeline", "name", req.Name, "org", orgID)

        pipeline := &amp;Pipeline{
                Id:             UUID{}, // Will be set by repository
                Name:           req.Name,
                Description:    req.Description,
                OrganizationId: UUID{}, // Convert orgID to UUID
                CreatedAt:      time.Now(),
                UpdatedAt:      time.Now(),
        }

        createdPipeline, err := s.pipelineRepo.Create(ctx, pipeline)
        if err != nil </span><span class="cov0" title="0">{
                s.logger.Error("failed to create pipeline", "error", err)
                return nil, fmt.Errorf("failed to create pipeline: %w", err)
        }</span>

        <span class="cov1" title="1">s.logger.Info("pipeline created successfully", "id", createdPipeline.Id, "name", createdPipeline.Name)
        return createdPipeline, nil</span>
}

// Get retrieves a pipeline by ID
func (s *Service) Get(ctx context.Context, id uuid.UUID) (*Pipeline, error) <span class="cov4" title="2">{
        pipeline, err := s.pipelineRepo.Get(ctx, id)
        if err != nil </span><span class="cov1" title="1">{
                return nil, fmt.Errorf("failed to get pipeline: %w", err)
        }</span>
        <span class="cov1" title="1">return pipeline, nil</span>
}

// Update updates a pipeline
func (s *Service) Update(ctx context.Context, id uuid.UUID, req *UpdatePipelineRequest) (*Pipeline, error) <span class="cov1" title="1">{
        pipeline, err := s.pipelineRepo.Get(ctx, id)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to get pipeline: %w", err)
        }</span>

        <span class="cov1" title="1">if req.Name != "" </span><span class="cov1" title="1">{
                pipeline.Name = req.Name
        }</span>
        <span class="cov1" title="1">if req.Description != "" </span><span class="cov1" title="1">{
                pipeline.Description = req.Description
        }</span>
        <span class="cov1" title="1">pipeline.UpdatedAt = time.Now()

        updatedPipeline, err := s.pipelineRepo.Update(ctx, id, pipeline)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to update pipeline: %w", err)
        }</span>

        <span class="cov1" title="1">return updatedPipeline, nil</span>
}

// Delete deletes a pipeline
func (s *Service) Delete(ctx context.Context, id uuid.UUID) error <span class="cov4" title="2">{
        // TODO: Add checks for active runs
        err := s.pipelineRepo.Delete(ctx, id)
        if err != nil </span><span class="cov1" title="1">{
                return fmt.Errorf("failed to delete pipeline: %w", err)
        }</span>
        <span class="cov1" title="1">return nil</span>
}

// List retrieves pipelines for an organization
func (s *Service) List(ctx context.Context, orgID string, limit, offset int) ([]*Pipeline, int, error) <span class="cov1" title="1">{
        // TODO: Add organization filtering to repository when available
        _ = orgID
        params := ListPipelinesParams{
                Limit:  limit,
                Offset: offset,
        }
        pipelines, total, err := s.pipelineRepo.List(ctx, params)
        if err != nil </span><span class="cov0" title="0">{
                return nil, 0, fmt.Errorf("failed to list pipelines: %w", err)
        }</span>
        <span class="cov1" title="1">return pipelines, int(total), nil</span>
}
</pre>
		
		<pre class="file" id="file124" style="display: none">// Code generated by codegen repository. DO NOT EDIT.
package pipelines

import (
        "context"
        "database/sql"
        "fmt"

        "github.com/archesai/archesai/internal/database/sqlite"
        "github.com/google/uuid"
)

// SQLiteRepository implements Repository using SQLite.
type SQLiteRepository struct {
        db      *sql.DB
        queries *sqlite.Queries
}

// NewSQLiteRepository creates a new SQLite repository.
func NewSQLiteRepository(db *sql.DB) Repository <span class="cov0" title="0">{
        return &amp;SQLiteRepository{
                db:      db,
                queries: sqlite.New(db),
        }
}</span>

// Pipeline operations

func (r *SQLiteRepository) Create(ctx context.Context, entity *Pipeline) (*Pipeline, error) <span class="cov0" title="0">{
        // For now, return a basic implementation
        // Actual implementation would need to be customized per entity
        return nil, fmt.Errorf("CreatePipeline not yet implemented - requires custom mapping")
}</span>

func (r *SQLiteRepository) Get(ctx context.Context, id uuid.UUID) (*Pipeline, error) <span class="cov0" title="0">{
        // For now, return a basic implementation
        // Actual implementation would need to be customized per entity
        return nil, fmt.Errorf("GetPipeline not yet implemented - requires custom mapping")
}</span>

func (r *SQLiteRepository) Update(ctx context.Context, id uuid.UUID, entity *Pipeline) (*Pipeline, error) <span class="cov0" title="0">{
        // For now, return a basic implementation
        // Actual implementation would need to be customized per entity
        return nil, fmt.Errorf("UpdatePipeline not yet implemented - requires custom mapping")
}</span>

func (r *SQLiteRepository) Delete(ctx context.Context, id uuid.UUID) error <span class="cov0" title="0">{
        // For now, return a basic implementation
        // Actual implementation would need to be customized per entity
        return fmt.Errorf("DeletePipeline not yet implemented - requires custom mapping")
}</span>

func (r *SQLiteRepository) List(ctx context.Context, params ListPipelinesParams) ([]*Pipeline, int64, error) <span class="cov0" title="0">{
        // For now, return a basic implementation
        // Actual implementation would need to be customized per entity
        return nil, 0, fmt.Errorf("ListPipelines not yet implemented - requires custom mapping")
}</span>

// ListByOrganization retrieves multiple pipelines by organizationId
func (r *SQLiteRepository) ListByOrganization(ctx context.Context, organizationId string) ([]*Pipeline, error) <span class="cov0" title="0">{

        // For now, return a basic implementation
        return nil, fmt.Errorf("ListByOrganization not yet implemented - requires custom mapping")

}</span>
</pre>
		
		<pre class="file" id="file125" style="display: none">// Package pipelines provides primitives to interact with the openapi HTTP API.
//
// Code generated by github.com/oapi-codegen/oapi-codegen/v2 version v2.5.0 DO NOT EDIT.
package pipelines

import (
        "encoding/json"
        "time"

        "github.com/google/uuid"
        "github.com/oapi-codegen/runtime"
        openapi_types "github.com/oapi-codegen/runtime/types"
)

const (
        BearerAuthScopes = "bearerAuth.Scopes"
)

// Defines values for PipelineStepStatus.
const (
        Completed PipelineStepStatus = "completed"
        Failed    PipelineStepStatus = "failed"
        Pending   PipelineStepStatus = "pending"
        Ready     PipelineStepStatus = "ready"
        Running   PipelineStepStatus = "running"
        Skipped   PipelineStepStatus = "skipped"
)

// Defines values for FindManyPipelinesParamsSortField.
const (
        CreatedAt      FindManyPipelinesParamsSortField = "createdAt"
        Description    FindManyPipelinesParamsSortField = "description"
        Id             FindManyPipelinesParamsSortField = "id"
        Name           FindManyPipelinesParamsSortField = "name"
        OrganizationId FindManyPipelinesParamsSortField = "organizationId"
        UpdatedAt      FindManyPipelinesParamsSortField = "updatedAt"
)

// Defines values for FindManyPipelinesParamsSortOrder.
const (
        Asc  FindManyPipelinesParamsSortOrder = "asc"
        Desc FindManyPipelinesParamsSortOrder = "desc"
)

// Base defines model for Base.
type Base struct {
        // CreatedAt The date and time when the resource was created
        CreatedAt time.Time `json:"createdAt" yaml:"createdAt"`

        // Id Universally Unique Identifier
        Id UUID `json:"id" yaml:"id"`

        // UpdatedAt The date and time when the resource was last updated
        UpdatedAt time.Time `json:"updatedAt" yaml:"updatedAt"`
}

// FilterNode A recursive filter node that can be a condition or group
type FilterNode = interface{}

// OrganizationReference defines model for OrganizationReference.
type OrganizationReference struct {
        // OrganizationId Universally Unique Identifier
        OrganizationId UUID `json:"organizationId" yaml:"organizationId"`
}

// Page Pagination (page number &amp; size)
type Page struct {
        Number int `json:"number,omitempty,omitzero" yaml:"number,omitempty"`
        Size   int `json:"size,omitempty,omitzero" yaml:"size,omitempty"`
}

// Pipeline defines model for Pipeline.
type Pipeline struct {
        // CreatedAt The date and time when the resource was created
        CreatedAt time.Time `json:"createdAt" yaml:"createdAt"`

        // Description Detailed description of the pipeline's purpose
        Description string `json:"description,omitempty,omitzero" yaml:"description,omitempty"`

        // Id Universally Unique Identifier
        Id UUID `json:"id" yaml:"id"`

        // Name The pipeline's display name
        Name string `json:"name" yaml:"name"`

        // OrganizationId Universally Unique Identifier
        OrganizationId UUID `json:"organizationId" yaml:"organizationId"`

        // UpdatedAt The date and time when the resource was last updated
        UpdatedAt time.Time `json:"updatedAt" yaml:"updatedAt"`
}

// PipelineStep defines model for PipelineStep.
type PipelineStep struct {
        // Config Configuration parameters for the tool
        Config map[string]interface{} `json:"config,omitempty,omitzero" yaml:"config,omitempty"`

        // CreatedAt The date and time when the resource was created
        CreatedAt time.Time `json:"createdAt" yaml:"createdAt"`

        // Dependencies IDs of steps this step depends on
        Dependencies []openapi_types.UUID `json:"dependencies,omitempty,omitzero" yaml:"dependencies,omitempty"`

        // Description Description of what this step does
        Description string `json:"description,omitempty,omitzero" yaml:"description,omitempty"`

        // Id Universally Unique Identifier
        Id UUID `json:"id" yaml:"id"`

        // Name Name of the step
        Name string `json:"name" yaml:"name"`

        // PipelineId The ID of the pipeline this step belongs to
        PipelineId openapi_types.UUID `json:"pipelineId" yaml:"pipelineId"`

        // Position Position in the pipeline for ordering
        Position int `json:"position,omitempty,omitzero" yaml:"position,omitempty"`

        // Retries Number of retries on failure
        Retries int `json:"retries,omitempty,omitzero" yaml:"retries,omitempty"`

        // Status Current status of the step
        Status PipelineStepStatus `json:"status,omitempty,omitzero" yaml:"status,omitempty"`

        // Timeout Timeout in seconds
        Timeout int `json:"timeout,omitempty,omitzero" yaml:"timeout,omitempty"`

        // ToolId The ID of the tool to execute
        ToolId openapi_types.UUID `json:"toolId" yaml:"toolId"`

        // UpdatedAt The date and time when the resource was last updated
        UpdatedAt time.Time `json:"updatedAt" yaml:"updatedAt"`
}

// PipelineStepStatus Current status of the step
type PipelineStepStatus string

// Problem RFC 7807 (Problem Details) compliant error response
type Problem struct {
        // Detail Human-readable explanation specific to this occurrence
        Detail string `json:"detail" yaml:"detail"`

        // Errors Additional validation errors for specific fields
        Errors []ValidationError `json:"errors,omitempty,omitzero" yaml:"errors,omitempty"`

        // Instance URI identifying the specific occurrence
        Instance string `json:"instance,omitempty,omitzero" yaml:"instance,omitempty"`

        // Status HTTP status code
        Status int `json:"status" yaml:"status"`

        // Title Short, human-readable summary
        Title string `json:"title" yaml:"title"`

        // Type URI identifying the problem type
        Type string `json:"type" yaml:"type"`
}

// UUID Universally Unique Identifier
type UUID = uuid.UUID

// ValidationError Individual field validation error
type ValidationError struct {
        // Field The field path that failed validation
        Field string `json:"field" yaml:"field"`

        // Message Human-readable error message
        Message string `json:"message" yaml:"message"`

        // Value The invalid value that was provided
        Value ValidationError_Value `json:"value,omitempty,omitzero" yaml:"value,omitempty"`
}

// ValidationErrorValue0 defines model for .
type ValidationErrorValue0 = string

// ValidationErrorValue1 defines model for .
type ValidationErrorValue1 = float32

// ValidationErrorValue2 defines model for .
type ValidationErrorValue2 = bool

// ValidationError_Value The invalid value that was provided
type ValidationError_Value struct {
        union json.RawMessage
}

// PageQuery Pagination (page number &amp; size)
type PageQuery = Page

// PipelinesFilter A recursive filter node that can be a condition or group
type PipelinesFilter = FilterNode

// PipelinesSort defines model for PipelinesSort.
type PipelinesSort = []struct {
        Field string `json:"field" yaml:"field"`
        Order string `json:"order" yaml:"order"`
}

// BadRequest RFC 7807 (Problem Details) compliant error response
type BadRequest = Problem

// NotFound RFC 7807 (Problem Details) compliant error response
type NotFound = Problem

// Unauthorized RFC 7807 (Problem Details) compliant error response
type Unauthorized = Problem

// FindManyPipelinesParams defines parameters for FindManyPipelines.
type FindManyPipelinesParams struct {
        // Filter Filter pipelines by field values. Supported fields:
        // - createdAt, id, updatedAt, description, name, organizationId
        Filter PipelinesFilter `json:"filter,omitempty,omitzero" yaml:"filter,omitempty"`

        // Page The page parameter
        Page PageQuery `form:"page,omitempty" json:"page,omitempty,omitzero" yaml:"page,omitempty"`

        // Sort The sort parameter
        Sort PipelinesSort `form:"sort,omitempty" json:"sort,omitempty,omitzero" yaml:"sort,omitempty"`
}

// FindManyPipelinesParamsSortField defines parameters for FindManyPipelines.
type FindManyPipelinesParamsSortField string

// FindManyPipelinesParamsSortOrder defines parameters for FindManyPipelines.
type FindManyPipelinesParamsSortOrder string

// CreatePipelineJSONBody defines parameters for CreatePipeline.
type CreatePipelineJSONBody struct {
        // Description The pipeline description
        Description string `json:"description,omitempty,omitzero" yaml:"description,omitempty"`

        // Name The pipeline name
        Name string `json:"name,omitempty,omitzero" yaml:"name,omitempty"`
}

// UpdatePipelineJSONBody defines parameters for UpdatePipeline.
type UpdatePipelineJSONBody struct {
        // Description The pipeline description
        Description string `json:"description,omitempty,omitzero" yaml:"description,omitempty"`

        // Name The pipeline name
        Name string `json:"name,omitempty,omitzero" yaml:"name,omitempty"`
}

// CreatePipelineStepJSONBody defines parameters for CreatePipelineStep.
type CreatePipelineStepJSONBody struct {
        // Config Configuration for the tool
        Config map[string]interface{} `json:"config,omitempty,omitzero" yaml:"config,omitempty"`

        // Dependencies IDs of steps this step depends on
        Dependencies []openapi_types.UUID `json:"dependencies,omitempty,omitzero" yaml:"dependencies,omitempty"`

        // Description Description of what this step does
        Description string `json:"description,omitempty,omitzero" yaml:"description,omitempty"`

        // Name Name of the step
        Name string `json:"name" yaml:"name"`

        // Position Position in the pipeline (for ordering)
        Position int `json:"position,omitempty,omitzero" yaml:"position,omitempty"`

        // ToolId The ID of the tool to use
        ToolId openapi_types.UUID `json:"toolId" yaml:"toolId"`
}

// CreatePipelineJSONRequestBody defines body for CreatePipeline for application/json ContentType.
type CreatePipelineJSONRequestBody CreatePipelineJSONBody

// UpdatePipelineJSONRequestBody defines body for UpdatePipeline for application/json ContentType.
type UpdatePipelineJSONRequestBody UpdatePipelineJSONBody

// CreatePipelineStepJSONRequestBody defines body for CreatePipelineStep for application/json ContentType.
type CreatePipelineStepJSONRequestBody CreatePipelineStepJSONBody

// AsValidationErrorValue0 returns the union data inside the ValidationError_Value as a ValidationErrorValue0
func (t ValidationError_Value) AsValidationErrorValue0() (ValidationErrorValue0, error) <span class="cov0" title="0">{
        var body ValidationErrorValue0
        err := json.Unmarshal(t.union, &amp;body)
        return body, err
}</span>

// FromValidationErrorValue0 overwrites any union data inside the ValidationError_Value as the provided ValidationErrorValue0
func (t *ValidationError_Value) FromValidationErrorValue0(v ValidationErrorValue0) error <span class="cov0" title="0">{
        b, err := json.Marshal(v)
        t.union = b
        return err
}</span>

// MergeValidationErrorValue0 performs a merge with any union data inside the ValidationError_Value, using the provided ValidationErrorValue0
func (t *ValidationError_Value) MergeValidationErrorValue0(v ValidationErrorValue0) error <span class="cov0" title="0">{
        b, err := json.Marshal(v)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov0" title="0">merged, err := runtime.JSONMerge(t.union, b)
        t.union = merged
        return err</span>
}

// AsValidationErrorValue1 returns the union data inside the ValidationError_Value as a ValidationErrorValue1
func (t ValidationError_Value) AsValidationErrorValue1() (ValidationErrorValue1, error) <span class="cov0" title="0">{
        var body ValidationErrorValue1
        err := json.Unmarshal(t.union, &amp;body)
        return body, err
}</span>

// FromValidationErrorValue1 overwrites any union data inside the ValidationError_Value as the provided ValidationErrorValue1
func (t *ValidationError_Value) FromValidationErrorValue1(v ValidationErrorValue1) error <span class="cov0" title="0">{
        b, err := json.Marshal(v)
        t.union = b
        return err
}</span>

// MergeValidationErrorValue1 performs a merge with any union data inside the ValidationError_Value, using the provided ValidationErrorValue1
func (t *ValidationError_Value) MergeValidationErrorValue1(v ValidationErrorValue1) error <span class="cov0" title="0">{
        b, err := json.Marshal(v)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov0" title="0">merged, err := runtime.JSONMerge(t.union, b)
        t.union = merged
        return err</span>
}

// AsValidationErrorValue2 returns the union data inside the ValidationError_Value as a ValidationErrorValue2
func (t ValidationError_Value) AsValidationErrorValue2() (ValidationErrorValue2, error) <span class="cov0" title="0">{
        var body ValidationErrorValue2
        err := json.Unmarshal(t.union, &amp;body)
        return body, err
}</span>

// FromValidationErrorValue2 overwrites any union data inside the ValidationError_Value as the provided ValidationErrorValue2
func (t *ValidationError_Value) FromValidationErrorValue2(v ValidationErrorValue2) error <span class="cov0" title="0">{
        b, err := json.Marshal(v)
        t.union = b
        return err
}</span>

// MergeValidationErrorValue2 performs a merge with any union data inside the ValidationError_Value, using the provided ValidationErrorValue2
func (t *ValidationError_Value) MergeValidationErrorValue2(v ValidationErrorValue2) error <span class="cov0" title="0">{
        b, err := json.Marshal(v)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov0" title="0">merged, err := runtime.JSONMerge(t.union, b)
        t.union = merged
        return err</span>
}

func (t ValidationError_Value) MarshalJSON() ([]byte, error) <span class="cov0" title="0">{
        b, err := t.union.MarshalJSON()
        return b, err
}</span>

func (t *ValidationError_Value) UnmarshalJSON(b []byte) error <span class="cov0" title="0">{
        err := t.union.UnmarshalJSON(b)
        return err
}</span>
</pre>
		
		<pre class="file" id="file126" style="display: none">package redis

import (
        "context"
        "fmt"
        "log/slog"

        "github.com/redis/go-redis/v9"
)

// Client wraps the Redis client with domain-specific functionality
type Client struct {
        redis  *redis.Client
        Queue  *Queue
        PubSub *PubSub
        config *Config
        logger *slog.Logger
}

// NewClient creates a new Redis client with all features
func NewClient(config *Config, logger *slog.Logger) (*Client, error) <span class="cov0" title="0">{
        if config == nil </span><span class="cov0" title="0">{
                config = DefaultConfig()
        }</span>

        <span class="cov0" title="0">if err := config.Validate(); err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("invalid Redis config: %w", err)
        }</span>

        // Create Redis options
        <span class="cov0" title="0">opts := &amp;redis.Options{
                DB:           config.DB,
                PoolSize:     config.PoolSize,
                MinIdleConns: config.MinIdleConns,
                MaxRetries:   config.MaxRetries,
                DialTimeout:  config.DialTimeout,
                ReadTimeout:  config.ReadTimeout,
                WriteTimeout: config.WriteTimeout,
                Password:     config.Password,
        }

        // Use URL if provided, otherwise use host:port
        if config.URL != "" </span><span class="cov0" title="0">{
                parsedOpts, err := redis.ParseURL(config.URL)
                if err != nil </span><span class="cov0" title="0">{
                        return nil, fmt.Errorf("failed to parse Redis URL: %w", err)
                }</span>
                <span class="cov0" title="0">opts = parsedOpts
                // Override with any explicitly set options
                if config.PoolSize &gt; 0 </span><span class="cov0" title="0">{
                        opts.PoolSize = config.PoolSize
                }</span>
                <span class="cov0" title="0">if config.MinIdleConns &gt; 0 </span><span class="cov0" title="0">{
                        opts.MinIdleConns = config.MinIdleConns
                }</span>
        } else<span class="cov0" title="0"> {
                opts.Addr = fmt.Sprintf("%s:%d", config.Host, config.Port)
        }</span>

        // Create Redis client
        <span class="cov0" title="0">redisClient := redis.NewClient(opts)

        // Test connection
        ctx := context.Background()
        if err := redisClient.Ping(ctx).Err(); err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to connect to Redis: %w", err)
        }</span>

        <span class="cov0" title="0">logger.Info("Connected to Redis",
                "addr", opts.Addr,
                "db", opts.DB,
                "pool_size", opts.PoolSize,
        )

        // Create the client with all features
        client := &amp;Client{
                redis:  redisClient,
                config: config,
                logger: logger,
        }

        // Initialize features based on config
        if config.EnableQueue </span><span class="cov0" title="0">{
                client.Queue = NewQueue(redisClient)
                logger.Info("Redis queue enabled")
        }</span>

        <span class="cov0" title="0">if config.EnablePubSub </span><span class="cov0" title="0">{
                client.PubSub = NewPubSub(redisClient)
                logger.Info("Redis pub/sub enabled")
        }</span>

        <span class="cov0" title="0">return client, nil</span>
}

// Close closes the Redis connection
func (c *Client) Close() error <span class="cov0" title="0">{
        if c.redis != nil </span><span class="cov0" title="0">{
                return c.redis.Close()
        }</span>
        <span class="cov0" title="0">return nil</span>
}

// Ping checks if Redis is reachable
func (c *Client) Ping(ctx context.Context) error <span class="cov0" title="0">{
        return c.redis.Ping(ctx).Err()
}</span>

// GetRedisClient returns the underlying Redis client for advanced usage
func (c *Client) GetRedisClient() *redis.Client <span class="cov0" title="0">{
        return c.redis
}</span>

// FlushDB flushes the current database (use with caution!)
func (c *Client) FlushDB(ctx context.Context) error <span class="cov0" title="0">{
        return c.redis.FlushDB(ctx).Err()
}</span>

// FlushAll flushes all databases (use with extreme caution!)
func (c *Client) FlushAll(ctx context.Context) error <span class="cov0" title="0">{
        return c.redis.FlushAll(ctx).Err()
}</span>

// Info returns Redis server information
func (c *Client) Info(ctx context.Context, sections ...string) (string, error) <span class="cov0" title="0">{
        var cmd *redis.StringCmd
        if len(sections) &gt; 0 </span><span class="cov0" title="0">{
                cmd = c.redis.Info(ctx, sections...)
        }</span> else<span class="cov0" title="0"> {
                cmd = c.redis.Info(ctx)
        }</span>
        <span class="cov0" title="0">return cmd.Result()</span>
}

// DBSize returns the number of keys in the current database
func (c *Client) DBSize(ctx context.Context) (int64, error) <span class="cov0" title="0">{
        return c.redis.DBSize(ctx).Result()
}</span>
</pre>
		
		<pre class="file" id="file127" style="display: none">package redis

import (
        "time"
)

// Config holds Redis-specific configuration
type Config struct {
        // Connection settings
        URL      string `mapstructure:"url" yaml:"url" env:"REDIS_URL"`
        Host     string `mapstructure:"host" yaml:"host" env:"REDIS_HOST"`
        Port     int    `mapstructure:"port" yaml:"port" env:"REDIS_PORT"`
        Password string `mapstructure:"password" yaml:"password" env:"REDIS_PASSWORD"`
        DB       int    `mapstructure:"db" yaml:"db" env:"REDIS_DB"`

        // Connection pool settings
        PoolSize     int           `mapstructure:"pool_size" yaml:"pool_size" env:"REDIS_POOL_SIZE"`
        MinIdleConns int           `mapstructure:"min_idle_conns" yaml:"min_idle_conns" env:"REDIS_MIN_IDLE_CONNS"`
        MaxRetries   int           `mapstructure:"max_retries" yaml:"max_retries" env:"REDIS_MAX_RETRIES"`
        DialTimeout  time.Duration `mapstructure:"dial_timeout" yaml:"dial_timeout" env:"REDIS_DIAL_TIMEOUT"`
        ReadTimeout  time.Duration `mapstructure:"read_timeout" yaml:"read_timeout" env:"REDIS_READ_TIMEOUT"`
        WriteTimeout time.Duration `mapstructure:"write_timeout" yaml:"write_timeout" env:"REDIS_WRITE_TIMEOUT"`

        // Feature flags
        EnableQueue  bool `mapstructure:"enable_queue" yaml:"enable_queue" env:"REDIS_ENABLE_QUEUE"`
        EnablePubSub bool `mapstructure:"enable_pubsub" yaml:"enable_pubsub" env:"REDIS_ENABLE_PUBSUB"`

        // Queue settings
        QueueBlockTimeout time.Duration `mapstructure:"queue_block_timeout" yaml:"queue_block_timeout" env:"REDIS_QUEUE_BLOCK_TIMEOUT"`
}

// DefaultConfig returns a Config with default values
func DefaultConfig() *Config <span class="cov0" title="0">{
        return &amp;Config{
                Host:         "localhost",
                Port:         6379,
                DB:           0,
                PoolSize:     10,
                MinIdleConns: 2,
                MaxRetries:   3,
                DialTimeout:  5 * time.Second,
                ReadTimeout:  3 * time.Second,
                WriteTimeout: 3 * time.Second,

                EnableQueue:  true,
                EnablePubSub: true,

                QueueBlockTimeout: 30 * time.Second,
        }
}</span>

// Validate checks if the configuration is valid
func (c *Config) Validate() error <span class="cov0" title="0">{
        if c.URL == "" &amp;&amp; c.Host == "" </span><span class="cov0" title="0">{
                return ErrNoRedisConfig
        }</span>

        <span class="cov0" title="0">if c.PoolSize &lt; 1 </span><span class="cov0" title="0">{
                c.PoolSize = 10
        }</span>

        <span class="cov0" title="0">if c.MinIdleConns &lt; 0 </span><span class="cov0" title="0">{
                c.MinIdleConns = 0
        }</span>

        <span class="cov0" title="0">if c.MaxRetries &lt; 0 </span><span class="cov0" title="0">{
                c.MaxRetries = 3
        }</span>

        <span class="cov0" title="0">return nil</span>
}
</pre>
		
		<pre class="file" id="file128" style="display: none">package redis

import (
        "context"
        "encoding/json"
        "fmt"

        "github.com/redis/go-redis/v9"
)

// PubSub provides pub/sub functionality using Redis
type PubSub struct {
        client *redis.Client
}

// NewPubSub creates a new PubSub instance
func NewPubSub(client *redis.Client) *PubSub <span class="cov0" title="0">{
        return &amp;PubSub{
                client: client,
        }
}</span>

// Publish publishes a message to a channel
func (p *PubSub) Publish(channel string, message interface{}) error <span class="cov0" title="0">{
        ctx := context.Background()

        data, err := json.Marshal(message)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to marshal message: %w", err)
        }</span>

        <span class="cov0" title="0">return p.client.Publish(ctx, channel, data).Err()</span>
}

// Subscribe subscribes to a channel and returns a subscription
func (p *PubSub) Subscribe(channels ...string) *Subscription <span class="cov0" title="0">{
        pubsub := p.client.Subscribe(context.Background(), channels...)
        return &amp;Subscription{
                pubsub: pubsub,
        }
}</span>

// Subscription represents an active subscription to Redis channels
type Subscription struct {
        pubsub *redis.PubSub
}

// Channel returns the channel for receiving messages
func (s *Subscription) Channel() &lt;-chan *redis.Message <span class="cov0" title="0">{
        return s.pubsub.Channel()
}</span>

// ReceiveMessage blocks and waits for a message
func (s *Subscription) ReceiveMessage(ctx context.Context) (*redis.Message, error) <span class="cov0" title="0">{
        return s.pubsub.ReceiveMessage(ctx)
}</span>

// Close closes the subscription
func (s *Subscription) Close() error <span class="cov0" title="0">{
        return s.pubsub.Close()
}</span>

// PublishJSON publishes a JSON message to a channel
func (p *PubSub) PublishJSON(channel string, v interface{}) error <span class="cov0" title="0">{
        return p.Publish(channel, v)
}</span>

// PSubscribe subscribes to patterns and returns a subscription
func (p *PubSub) PSubscribe(patterns ...string) *Subscription <span class="cov0" title="0">{
        pubsub := p.client.PSubscribe(context.Background(), patterns...)
        return &amp;Subscription{
                pubsub: pubsub,
        }
}</span>
</pre>
		
		<pre class="file" id="file129" style="display: none">package redis

import (
        "context"
        "encoding/json"
        "fmt"
        "time"

        "github.com/redis/go-redis/v9"
)

// Queue provides queue operations using Redis lists
type Queue struct {
        client *redis.Client
}

// NewQueue creates a new queue instance
func NewQueue(client *redis.Client) *Queue <span class="cov0" title="0">{
        return &amp;Queue{
                client: client,
        }
}</span>

// Push adds an item to the queue
func (q *Queue) Push(queueName string, item interface{}) error <span class="cov0" title="0">{
        ctx := context.Background()
        data, err := json.Marshal(item)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to marshal item: %w", err)
        }</span>

        <span class="cov0" title="0">return q.client.RPush(ctx, queueName, data).Err()</span>
}

// Pop removes and returns an item from the queue
func (q *Queue) Pop(queueName string, dest interface{}) error <span class="cov0" title="0">{
        ctx := context.Background()
        data, err := q.client.LPop(ctx, queueName).Result()
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov0" title="0">return json.Unmarshal([]byte(data), dest)</span>
}

// PopBlocking removes and returns an item from the queue, blocking if empty
func (q *Queue) PopBlocking(queueName string, timeout int, dest interface{}) error <span class="cov0" title="0">{
        ctx := context.Background()
        result, err := q.client.BLPop(ctx, time.Duration(timeout)*time.Second, queueName).Result()
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov0" title="0">if len(result) &lt; 2 </span><span class="cov0" title="0">{
                return fmt.Errorf("unexpected result from BLPop")
        }</span>

        <span class="cov0" title="0">return json.Unmarshal([]byte(result[1]), dest)</span>
}

// Peek returns the next item without removing it
func (q *Queue) Peek(queueName string, dest interface{}) error <span class="cov0" title="0">{
        ctx := context.Background()
        data, err := q.client.LIndex(ctx, queueName, 0).Result()
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov0" title="0">return json.Unmarshal([]byte(data), dest)</span>
}

// Length returns the queue length
func (q *Queue) Length(queueName string) (int64, error) <span class="cov0" title="0">{
        ctx := context.Background()
        return q.client.LLen(ctx, queueName).Result()
}</span>

// Clear removes all items from the queue
func (q *Queue) Clear(queueName string) error <span class="cov0" title="0">{
        ctx := context.Background()
        return q.client.Del(ctx, queueName).Err()
}</span>

// Remove removes a specific item from the queue
func (q *Queue) Remove(queueName string, item interface{}) error <span class="cov0" title="0">{
        ctx := context.Background()
        data, err := json.Marshal(item)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to marshal item: %w", err)
        }</span>

        // Remove 1 occurrence of the item
        <span class="cov0" title="0">removed, err := q.client.LRem(ctx, queueName, 1, string(data)).Result()
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov0" title="0">if removed == 0 </span><span class="cov0" title="0">{
                return fmt.Errorf("item not found in queue")
        }</span>
        <span class="cov0" title="0">return nil</span>
}
</pre>
		
		<pre class="file" id="file130" style="display: none">// Package runs provides HTTP handlers for run operations
package runs

import (
        "context"
        "log/slog"
)

const (
        // Placeholder constants for development
        orgPlaceholder = "org-placeholder"
)

// Handler handles HTTP requests for run operations
type Handler struct {
        service *Service
        logger  *slog.Logger
}

// NewHandler creates a new handler for run operations
func NewHandler(service *Service, logger *slog.Logger) *Handler <span class="cov0" title="0">{
        return &amp;Handler{
                service: service,
                logger:  logger,
        }
}</span>

// CreateRun creates a new run (implements StrictServerInterface)
func (h *Handler) CreateRun(ctx context.Context, req CreateRunRequestObject) (CreateRunResponseObject, error) <span class="cov0" title="0">{
        // TODO: Get organization ID from context
        orgID := orgPlaceholder

        // Create the run
        run, err := h.service.Create(ctx, req.Body, orgID)
        if err != nil </span><span class="cov0" title="0">{
                h.logger.Error("failed to create run", "error", err)
                return nil, err
        }</span>

        // Convert to API response
        <span class="cov0" title="0">return CreateRun201JSONResponse{
                Data: Run{
                        Id:             run.Id,
                        PipelineId:     run.PipelineId,
                        OrganizationId: run.OrganizationId,
                        Status:         run.Status,
                        Progress:       run.Progress,
                        StartedAt:      run.StartedAt,
                        CompletedAt:    run.CompletedAt,
                        CreatedAt:      run.CreatedAt,
                        UpdatedAt:      run.UpdatedAt,
                },
        }, nil</span>
}

// DeleteRun deletes a run (implements StrictServerInterface)
func (h *Handler) DeleteRun(ctx context.Context, req DeleteRunRequestObject) (DeleteRunResponseObject, error) <span class="cov0" title="0">{
        err := h.service.Delete(ctx, req.Id)
        if err != nil </span><span class="cov0" title="0">{
                if err == ErrRunNotFound </span><span class="cov0" title="0">{
                        return DeleteRun404ApplicationProblemPlusJSONResponse{}, nil
                }</span>
                <span class="cov0" title="0">h.logger.Error("failed to delete run", "error", err, "id", req.Id)
                return nil, err</span>
        }

        // For delete, we can return an empty response or a success message
        // Since the API expects a Data field, let's return nil for now
        <span class="cov0" title="0">return DeleteRun200JSONResponse{}, nil</span>
}

// GetOneRun retrieves a single run (implements StrictServerInterface)
func (h *Handler) GetOneRun(ctx context.Context, req GetOneRunRequestObject) (GetOneRunResponseObject, error) <span class="cov0" title="0">{
        run, err := h.service.Get(ctx, req.Id)
        if err != nil </span><span class="cov0" title="0">{
                if err == ErrRunNotFound </span><span class="cov0" title="0">{
                        return GetOneRun404ApplicationProblemPlusJSONResponse{}, nil
                }</span>
                <span class="cov0" title="0">h.logger.Error("failed to get run", "error", err, "id", req.Id)
                return nil, err</span>
        }

        // Convert to API response
        <span class="cov0" title="0">return GetOneRun200JSONResponse{
                Data: Run{
                        Id:             run.Id,
                        PipelineId:     run.PipelineId,
                        OrganizationId: run.OrganizationId,
                        Status:         run.Status,
                        Progress:       run.Progress,
                        StartedAt:      run.StartedAt,
                        CompletedAt:    run.CompletedAt,
                        CreatedAt:      run.CreatedAt,
                        UpdatedAt:      run.UpdatedAt,
                },
        }, nil</span>
}

// UpdateRun updates a run (implements StrictServerInterface)
func (h *Handler) UpdateRun(ctx context.Context, req UpdateRunRequestObject) (UpdateRunResponseObject, error) <span class="cov0" title="0">{
        run, err := h.service.Update(ctx, req.Id, req.Body)
        if err != nil </span><span class="cov0" title="0">{
                if err == ErrRunNotFound </span><span class="cov0" title="0">{
                        return UpdateRun404ApplicationProblemPlusJSONResponse{}, nil
                }</span>
                <span class="cov0" title="0">h.logger.Error("failed to update run", "error", err, "id", req.Id)
                return nil, err</span>
        }

        // Convert to API response
        <span class="cov0" title="0">return UpdateRun200JSONResponse{
                Data: Run{
                        Id:             run.Id,
                        PipelineId:     run.PipelineId,
                        OrganizationId: run.OrganizationId,
                        Status:         run.Status,
                        Progress:       run.Progress,
                        StartedAt:      run.StartedAt,
                        CompletedAt:    run.CompletedAt,
                        CreatedAt:      run.CreatedAt,
                        UpdatedAt:      run.UpdatedAt,
                },
        }, nil</span>
}

// FindManyRuns retrieves runs (implements StrictServerInterface)
func (h *Handler) FindManyRuns(ctx context.Context, req FindManyRunsRequestObject) (FindManyRunsResponseObject, error) <span class="cov0" title="0">{
        limit := 50
        offset := 0

        // Handle page-based pagination if provided
        if req.Params.Page.Number &gt; 0 &amp;&amp; req.Params.Page.Size &gt; 0 </span><span class="cov0" title="0">{
                limit = req.Params.Page.Size
                offset = (req.Params.Page.Number - 1) * req.Params.Page.Size
        }</span>

        // TODO: Get organization ID from context
        <span class="cov0" title="0">orgID := orgPlaceholder

        // TODO: Add filter support when service method is updated
        runs, total, err := h.service.List(ctx, orgID, limit, offset)
        if err != nil </span><span class="cov0" title="0">{
                h.logger.Error("failed to list runs", "error", err)
                return nil, err
        }</span>

        // Convert to API entities
        <span class="cov0" title="0">data := make([]Run, len(runs))
        for i, run := range runs </span><span class="cov0" title="0">{
                data[i] = *run
        }</span>

        <span class="cov0" title="0">totalFloat32 := float32(total)
        return FindManyRuns200JSONResponse{
                Data: data,
                Meta: struct {
                        Total float32 `json:"total"`
                }{
                        Total: totalFloat32,
                },
        }, nil</span>
}

// Create creates a new run (implements StrictServerInterface)
func (h *Handler) Create(ctx context.Context, req CreateRunRequestObject) (CreateRunResponseObject, error) <span class="cov0" title="0">{
        // TODO: Get organization ID from context
        orgID := orgPlaceholder

        run, err := h.service.Create(ctx, req.Body, orgID)
        if err != nil </span><span class="cov0" title="0">{
                h.logger.Error("failed to create run", "error", err)
                return nil, err
        }</span>

        <span class="cov0" title="0">return CreateRun201JSONResponse{
                Data: *run,
        }, nil</span>
}

// Get retrieves a run by ID (implements StrictServerInterface)
func (h *Handler) Get(ctx context.Context, req GetOneRunRequestObject) (GetOneRunResponseObject, error) <span class="cov0" title="0">{
        run, err := h.service.Get(ctx, req.Id)
        if err != nil </span><span class="cov0" title="0">{
                if err == ErrRunNotFound </span><span class="cov0" title="0">{
                        return GetOneRun404ApplicationProblemPlusJSONResponse{
                                NotFoundApplicationProblemPlusJSONResponse: NotFoundApplicationProblemPlusJSONResponse{
                                        Detail: "Run not found",
                                        Status: 404,
                                        Title:  "Run not found",
                                },
                        }, nil
                }</span>
                <span class="cov0" title="0">h.logger.Error("failed to get run", "error", err)
                return nil, err</span>
        }

        <span class="cov0" title="0">return GetOneRun200JSONResponse{
                Data: *run,
        }, nil</span>
}

// Update updates a run (implements StrictServerInterface)
func (h *Handler) Update(_ context.Context, _ UpdateRunRequestObject) (UpdateRunResponseObject, error) <span class="cov0" title="0">{
        // Runs are typically not directly updated - their status changes through state transitions
        // Return 404 since we don't support direct updates
        return UpdateRun404ApplicationProblemPlusJSONResponse{
                NotFoundApplicationProblemPlusJSONResponse: NotFoundApplicationProblemPlusJSONResponse{
                        Detail: "Run updates not implemented - use state transition endpoints",
                        Status: 404,
                        Title:  "Not Implemented",
                },
        }, nil
}</span>

// Delete deletes a run (implements StrictServerInterface)
func (h *Handler) Delete(ctx context.Context, req DeleteRunRequestObject) (DeleteRunResponseObject, error) <span class="cov0" title="0">{
        err := h.service.Delete(ctx, req.Id)
        if err != nil </span><span class="cov0" title="0">{
                if err == ErrRunNotFound </span><span class="cov0" title="0">{
                        return DeleteRun404ApplicationProblemPlusJSONResponse{
                                NotFoundApplicationProblemPlusJSONResponse: NotFoundApplicationProblemPlusJSONResponse{
                                        Detail: "Run not found",
                                        Status: 404,
                                        Title:  "Run not found",
                                },
                        }, nil
                }</span>
                <span class="cov0" title="0">h.logger.Error("failed to delete run", "error", err)
                return nil, err</span>
        }

        <span class="cov0" title="0">return DeleteRun200JSONResponse{}, nil</span>
}
</pre>
		
		<pre class="file" id="file131" style="display: none">// Package runs provides primitives to interact with the openapi HTTP API.
//
// Code generated by github.com/oapi-codegen/oapi-codegen/v2 version v2.5.0 DO NOT EDIT.
package runs

import (
        "context"
        "encoding/json"
        "fmt"
        "net/http"

        "github.com/labstack/echo/v4"
        "github.com/oapi-codegen/runtime"
        strictecho "github.com/oapi-codegen/runtime/strictmiddleware/echo"
        openapi_types "github.com/oapi-codegen/runtime/types"
)

// ServerInterface represents all server handlers.
type ServerInterface interface {
        // Find many runs
        // (GET /workflows/runs)
        FindManyRuns(ctx echo.Context, params FindManyRunsParams) error
        // Create a new run
        // (POST /workflows/runs)
        CreateRun(ctx echo.Context) error
        // Delete a run
        // (DELETE /workflows/runs/{id})
        DeleteRun(ctx echo.Context, id openapi_types.UUID) error
        // Find a run
        // (GET /workflows/runs/{id})
        GetOneRun(ctx echo.Context, id openapi_types.UUID) error
        // Update a run
        // (PATCH /workflows/runs/{id})
        UpdateRun(ctx echo.Context, id openapi_types.UUID) error
}

// ServerInterfaceWrapper converts echo contexts to parameters.
type ServerInterfaceWrapper struct {
        Handler ServerInterface
}

// FindManyRuns converts echo context to params.
func (w *ServerInterfaceWrapper) FindManyRuns(ctx echo.Context) error <span class="cov0" title="0">{
        var err error

        ctx.Set(BearerAuthScopes, []string{})

        // Parameter object where we will unmarshal all parameters from the context
        var params FindManyRunsParams
        // ------------- Optional query parameter "filter" -------------

        err = runtime.BindQueryParameter("deepObject", true, false, "filter", ctx.QueryParams(), &amp;params.Filter)
        if err != nil </span><span class="cov0" title="0">{
                return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter filter: %s", err))
        }</span>

        // ------------- Optional query parameter "page" -------------

        <span class="cov0" title="0">err = runtime.BindQueryParameter("form", true, false, "page", ctx.QueryParams(), &amp;params.Page)
        if err != nil </span><span class="cov0" title="0">{
                return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter page: %s", err))
        }</span>

        // ------------- Optional query parameter "sort" -------------

        <span class="cov0" title="0">err = runtime.BindQueryParameter("form", true, false, "sort", ctx.QueryParams(), &amp;params.Sort)
        if err != nil </span><span class="cov0" title="0">{
                return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter sort: %s", err))
        }</span>

        // Invoke the callback with all the unmarshaled arguments
        <span class="cov0" title="0">err = w.Handler.FindManyRuns(ctx, params)
        return err</span>
}

// CreateRun converts echo context to params.
func (w *ServerInterfaceWrapper) CreateRun(ctx echo.Context) error <span class="cov0" title="0">{
        var err error

        ctx.Set(BearerAuthScopes, []string{})

        // Invoke the callback with all the unmarshaled arguments
        err = w.Handler.CreateRun(ctx)
        return err
}</span>

// DeleteRun converts echo context to params.
func (w *ServerInterfaceWrapper) DeleteRun(ctx echo.Context) error <span class="cov0" title="0">{
        var err error
        // ------------- Path parameter "id" -------------
        var id openapi_types.UUID

        err = runtime.BindStyledParameterWithOptions("simple", "id", ctx.Param("id"), &amp;id, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
        if err != nil </span><span class="cov0" title="0">{
                return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter id: %s", err))
        }</span>

        <span class="cov0" title="0">ctx.Set(BearerAuthScopes, []string{})

        // Invoke the callback with all the unmarshaled arguments
        err = w.Handler.DeleteRun(ctx, id)
        return err</span>
}

// GetOneRun converts echo context to params.
func (w *ServerInterfaceWrapper) GetOneRun(ctx echo.Context) error <span class="cov0" title="0">{
        var err error
        // ------------- Path parameter "id" -------------
        var id openapi_types.UUID

        err = runtime.BindStyledParameterWithOptions("simple", "id", ctx.Param("id"), &amp;id, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
        if err != nil </span><span class="cov0" title="0">{
                return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter id: %s", err))
        }</span>

        <span class="cov0" title="0">ctx.Set(BearerAuthScopes, []string{})

        // Invoke the callback with all the unmarshaled arguments
        err = w.Handler.GetOneRun(ctx, id)
        return err</span>
}

// UpdateRun converts echo context to params.
func (w *ServerInterfaceWrapper) UpdateRun(ctx echo.Context) error <span class="cov0" title="0">{
        var err error
        // ------------- Path parameter "id" -------------
        var id openapi_types.UUID

        err = runtime.BindStyledParameterWithOptions("simple", "id", ctx.Param("id"), &amp;id, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
        if err != nil </span><span class="cov0" title="0">{
                return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter id: %s", err))
        }</span>

        <span class="cov0" title="0">ctx.Set(BearerAuthScopes, []string{})

        // Invoke the callback with all the unmarshaled arguments
        err = w.Handler.UpdateRun(ctx, id)
        return err</span>
}

// This is a simple interface which specifies echo.Route addition functions which
// are present on both echo.Echo and echo.Group, since we want to allow using
// either of them for path registration
type EchoRouter interface {
        CONNECT(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
        DELETE(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
        GET(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
        HEAD(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
        OPTIONS(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
        PATCH(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
        POST(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
        PUT(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
        TRACE(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
}

// RegisterHandlers adds each server route to the EchoRouter.
func RegisterHandlers(router EchoRouter, si ServerInterface) <span class="cov0" title="0">{
        RegisterHandlersWithBaseURL(router, si, "")
}</span>

// Registers handlers, and prepends BaseURL to the paths, so that the paths
// can be served under a prefix.
func RegisterHandlersWithBaseURL(router EchoRouter, si ServerInterface, baseURL string) <span class="cov0" title="0">{

        wrapper := ServerInterfaceWrapper{
                Handler: si,
        }

        router.GET(baseURL+"/workflows/runs", wrapper.FindManyRuns)
        router.POST(baseURL+"/workflows/runs", wrapper.CreateRun)
        router.DELETE(baseURL+"/workflows/runs/:id", wrapper.DeleteRun)
        router.GET(baseURL+"/workflows/runs/:id", wrapper.GetOneRun)
        router.PATCH(baseURL+"/workflows/runs/:id", wrapper.UpdateRun)

}</span>

type BadRequestApplicationProblemPlusJSONResponse Problem

type NotFoundApplicationProblemPlusJSONResponse Problem

type UnauthorizedApplicationProblemPlusJSONResponse Problem

type FindManyRunsRequestObject struct {
        Params FindManyRunsParams
}

type FindManyRunsResponseObject interface {
        VisitFindManyRunsResponse(w http.ResponseWriter) error
}

type FindManyRuns200JSONResponse struct {
        Data []Run `json:"data"`
        Meta struct {
                // Total Total number of items in the collection
                Total float32 `json:"total"`
        } `json:"meta"`
}

func (response FindManyRuns200JSONResponse) VisitFindManyRunsResponse(w http.ResponseWriter) error <span class="cov0" title="0">{
        w.Header().Set("Content-Type", "application/json")
        w.WriteHeader(200)

        return json.NewEncoder(w).Encode(response)
}</span>

type FindManyRuns400ApplicationProblemPlusJSONResponse struct {
        BadRequestApplicationProblemPlusJSONResponse
}

func (response FindManyRuns400ApplicationProblemPlusJSONResponse) VisitFindManyRunsResponse(w http.ResponseWriter) error <span class="cov0" title="0">{
        w.Header().Set("Content-Type", "application/problem+json")
        w.WriteHeader(400)

        return json.NewEncoder(w).Encode(response)
}</span>

type FindManyRuns401ApplicationProblemPlusJSONResponse struct {
        UnauthorizedApplicationProblemPlusJSONResponse
}

func (response FindManyRuns401ApplicationProblemPlusJSONResponse) VisitFindManyRunsResponse(w http.ResponseWriter) error <span class="cov0" title="0">{
        w.Header().Set("Content-Type", "application/problem+json")
        w.WriteHeader(401)

        return json.NewEncoder(w).Encode(response)
}</span>

type CreateRunRequestObject struct {
        Body *CreateRunJSONRequestBody
}

type CreateRunResponseObject interface {
        VisitCreateRunResponse(w http.ResponseWriter) error
}

type CreateRun201JSONResponse struct {
        // Data Schema for Run entity
        Data Run `json:"data"`
}

func (response CreateRun201JSONResponse) VisitCreateRunResponse(w http.ResponseWriter) error <span class="cov0" title="0">{
        w.Header().Set("Content-Type", "application/json")
        w.WriteHeader(201)

        return json.NewEncoder(w).Encode(response)
}</span>

type CreateRun400ApplicationProblemPlusJSONResponse struct {
        BadRequestApplicationProblemPlusJSONResponse
}

func (response CreateRun400ApplicationProblemPlusJSONResponse) VisitCreateRunResponse(w http.ResponseWriter) error <span class="cov0" title="0">{
        w.Header().Set("Content-Type", "application/problem+json")
        w.WriteHeader(400)

        return json.NewEncoder(w).Encode(response)
}</span>

type CreateRun401ApplicationProblemPlusJSONResponse struct {
        UnauthorizedApplicationProblemPlusJSONResponse
}

func (response CreateRun401ApplicationProblemPlusJSONResponse) VisitCreateRunResponse(w http.ResponseWriter) error <span class="cov0" title="0">{
        w.Header().Set("Content-Type", "application/problem+json")
        w.WriteHeader(401)

        return json.NewEncoder(w).Encode(response)
}</span>

type DeleteRunRequestObject struct {
        Id openapi_types.UUID `json:"id"`
}

type DeleteRunResponseObject interface {
        VisitDeleteRunResponse(w http.ResponseWriter) error
}

type DeleteRun200JSONResponse struct {
        // Data Schema for Run entity
        Data Run `json:"data"`
}

func (response DeleteRun200JSONResponse) VisitDeleteRunResponse(w http.ResponseWriter) error <span class="cov0" title="0">{
        w.Header().Set("Content-Type", "application/json")
        w.WriteHeader(200)

        return json.NewEncoder(w).Encode(response)
}</span>

type DeleteRun404ApplicationProblemPlusJSONResponse struct {
        NotFoundApplicationProblemPlusJSONResponse
}

func (response DeleteRun404ApplicationProblemPlusJSONResponse) VisitDeleteRunResponse(w http.ResponseWriter) error <span class="cov0" title="0">{
        w.Header().Set("Content-Type", "application/problem+json")
        w.WriteHeader(404)

        return json.NewEncoder(w).Encode(response)
}</span>

type GetOneRunRequestObject struct {
        Id openapi_types.UUID `json:"id"`
}

type GetOneRunResponseObject interface {
        VisitGetOneRunResponse(w http.ResponseWriter) error
}

type GetOneRun200JSONResponse struct {
        // Data Schema for Run entity
        Data Run `json:"data"`
}

func (response GetOneRun200JSONResponse) VisitGetOneRunResponse(w http.ResponseWriter) error <span class="cov0" title="0">{
        w.Header().Set("Content-Type", "application/json")
        w.WriteHeader(200)

        return json.NewEncoder(w).Encode(response)
}</span>

type GetOneRun404ApplicationProblemPlusJSONResponse struct {
        NotFoundApplicationProblemPlusJSONResponse
}

func (response GetOneRun404ApplicationProblemPlusJSONResponse) VisitGetOneRunResponse(w http.ResponseWriter) error <span class="cov0" title="0">{
        w.Header().Set("Content-Type", "application/problem+json")
        w.WriteHeader(404)

        return json.NewEncoder(w).Encode(response)
}</span>

type UpdateRunRequestObject struct {
        Id   openapi_types.UUID `json:"id"`
        Body *UpdateRunJSONRequestBody
}

type UpdateRunResponseObject interface {
        VisitUpdateRunResponse(w http.ResponseWriter) error
}

type UpdateRun200JSONResponse struct {
        // Data Schema for Run entity
        Data Run `json:"data"`
}

func (response UpdateRun200JSONResponse) VisitUpdateRunResponse(w http.ResponseWriter) error <span class="cov0" title="0">{
        w.Header().Set("Content-Type", "application/json")
        w.WriteHeader(200)

        return json.NewEncoder(w).Encode(response)
}</span>

type UpdateRun404ApplicationProblemPlusJSONResponse struct {
        NotFoundApplicationProblemPlusJSONResponse
}

func (response UpdateRun404ApplicationProblemPlusJSONResponse) VisitUpdateRunResponse(w http.ResponseWriter) error <span class="cov0" title="0">{
        w.Header().Set("Content-Type", "application/problem+json")
        w.WriteHeader(404)

        return json.NewEncoder(w).Encode(response)
}</span>

// StrictServerInterface represents all server handlers.
type StrictServerInterface interface {
        // Find many runs
        // (GET /workflows/runs)
        FindManyRuns(ctx context.Context, request FindManyRunsRequestObject) (FindManyRunsResponseObject, error)
        // Create a new run
        // (POST /workflows/runs)
        CreateRun(ctx context.Context, request CreateRunRequestObject) (CreateRunResponseObject, error)
        // Delete a run
        // (DELETE /workflows/runs/{id})
        DeleteRun(ctx context.Context, request DeleteRunRequestObject) (DeleteRunResponseObject, error)
        // Find a run
        // (GET /workflows/runs/{id})
        GetOneRun(ctx context.Context, request GetOneRunRequestObject) (GetOneRunResponseObject, error)
        // Update a run
        // (PATCH /workflows/runs/{id})
        UpdateRun(ctx context.Context, request UpdateRunRequestObject) (UpdateRunResponseObject, error)
}

type StrictHandlerFunc = strictecho.StrictEchoHandlerFunc
type StrictMiddlewareFunc = strictecho.StrictEchoMiddlewareFunc

func NewStrictHandler(ssi StrictServerInterface, middlewares []StrictMiddlewareFunc) ServerInterface <span class="cov0" title="0">{
        return &amp;strictHandler{ssi: ssi, middlewares: middlewares}
}</span>

type strictHandler struct {
        ssi         StrictServerInterface
        middlewares []StrictMiddlewareFunc
}

// FindManyRuns operation middleware
func (sh *strictHandler) FindManyRuns(ctx echo.Context, params FindManyRunsParams) error <span class="cov0" title="0">{
        var request FindManyRunsRequestObject

        request.Params = params

        handler := func(ctx echo.Context, request interface{}) (interface{}, error) </span><span class="cov0" title="0">{
                return sh.ssi.FindManyRuns(ctx.Request().Context(), request.(FindManyRunsRequestObject))
        }</span>
        <span class="cov0" title="0">for _, middleware := range sh.middlewares </span><span class="cov0" title="0">{
                handler = middleware(handler, "FindManyRuns")
        }</span>

        <span class="cov0" title="0">response, err := handler(ctx, request)

        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span> else<span class="cov0" title="0"> if validResponse, ok := response.(FindManyRunsResponseObject); ok </span><span class="cov0" title="0">{
                return validResponse.VisitFindManyRunsResponse(ctx.Response())
        }</span> else<span class="cov0" title="0"> if response != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("unexpected response type: %T", response)
        }</span>
        <span class="cov0" title="0">return nil</span>
}

// CreateRun operation middleware
func (sh *strictHandler) CreateRun(ctx echo.Context) error <span class="cov0" title="0">{
        var request CreateRunRequestObject

        var body CreateRunJSONRequestBody
        if err := ctx.Bind(&amp;body); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov0" title="0">request.Body = &amp;body

        handler := func(ctx echo.Context, request interface{}) (interface{}, error) </span><span class="cov0" title="0">{
                return sh.ssi.CreateRun(ctx.Request().Context(), request.(CreateRunRequestObject))
        }</span>
        <span class="cov0" title="0">for _, middleware := range sh.middlewares </span><span class="cov0" title="0">{
                handler = middleware(handler, "CreateRun")
        }</span>

        <span class="cov0" title="0">response, err := handler(ctx, request)

        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span> else<span class="cov0" title="0"> if validResponse, ok := response.(CreateRunResponseObject); ok </span><span class="cov0" title="0">{
                return validResponse.VisitCreateRunResponse(ctx.Response())
        }</span> else<span class="cov0" title="0"> if response != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("unexpected response type: %T", response)
        }</span>
        <span class="cov0" title="0">return nil</span>
}

// DeleteRun operation middleware
func (sh *strictHandler) DeleteRun(ctx echo.Context, id openapi_types.UUID) error <span class="cov0" title="0">{
        var request DeleteRunRequestObject

        request.Id = id

        handler := func(ctx echo.Context, request interface{}) (interface{}, error) </span><span class="cov0" title="0">{
                return sh.ssi.DeleteRun(ctx.Request().Context(), request.(DeleteRunRequestObject))
        }</span>
        <span class="cov0" title="0">for _, middleware := range sh.middlewares </span><span class="cov0" title="0">{
                handler = middleware(handler, "DeleteRun")
        }</span>

        <span class="cov0" title="0">response, err := handler(ctx, request)

        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span> else<span class="cov0" title="0"> if validResponse, ok := response.(DeleteRunResponseObject); ok </span><span class="cov0" title="0">{
                return validResponse.VisitDeleteRunResponse(ctx.Response())
        }</span> else<span class="cov0" title="0"> if response != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("unexpected response type: %T", response)
        }</span>
        <span class="cov0" title="0">return nil</span>
}

// GetOneRun operation middleware
func (sh *strictHandler) GetOneRun(ctx echo.Context, id openapi_types.UUID) error <span class="cov0" title="0">{
        var request GetOneRunRequestObject

        request.Id = id

        handler := func(ctx echo.Context, request interface{}) (interface{}, error) </span><span class="cov0" title="0">{
                return sh.ssi.GetOneRun(ctx.Request().Context(), request.(GetOneRunRequestObject))
        }</span>
        <span class="cov0" title="0">for _, middleware := range sh.middlewares </span><span class="cov0" title="0">{
                handler = middleware(handler, "GetOneRun")
        }</span>

        <span class="cov0" title="0">response, err := handler(ctx, request)

        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span> else<span class="cov0" title="0"> if validResponse, ok := response.(GetOneRunResponseObject); ok </span><span class="cov0" title="0">{
                return validResponse.VisitGetOneRunResponse(ctx.Response())
        }</span> else<span class="cov0" title="0"> if response != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("unexpected response type: %T", response)
        }</span>
        <span class="cov0" title="0">return nil</span>
}

// UpdateRun operation middleware
func (sh *strictHandler) UpdateRun(ctx echo.Context, id openapi_types.UUID) error <span class="cov0" title="0">{
        var request UpdateRunRequestObject

        request.Id = id

        var body UpdateRunJSONRequestBody
        if err := ctx.Bind(&amp;body); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov0" title="0">request.Body = &amp;body

        handler := func(ctx echo.Context, request interface{}) (interface{}, error) </span><span class="cov0" title="0">{
                return sh.ssi.UpdateRun(ctx.Request().Context(), request.(UpdateRunRequestObject))
        }</span>
        <span class="cov0" title="0">for _, middleware := range sh.middlewares </span><span class="cov0" title="0">{
                handler = middleware(handler, "UpdateRun")
        }</span>

        <span class="cov0" title="0">response, err := handler(ctx, request)

        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span> else<span class="cov0" title="0"> if validResponse, ok := response.(UpdateRunResponseObject); ok </span><span class="cov0" title="0">{
                return validResponse.VisitUpdateRunResponse(ctx.Response())
        }</span> else<span class="cov0" title="0"> if response != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("unexpected response type: %T", response)
        }</span>
        <span class="cov0" title="0">return nil</span>
}
</pre>
		
		<pre class="file" id="file132" style="display: none">// Code generated by codegen repository. DO NOT EDIT.
package runs

import (
        "context"
        "errors"

        "github.com/archesai/archesai/internal/database/postgresql"
        "github.com/google/uuid"
        "github.com/jackc/pgx/v5/pgxpool"
)

// PostgresRepository implements Repository using PostgreSQL.
type PostgresRepository struct {
        db      *pgxpool.Pool
        queries *postgresql.Queries
}

// NewPostgresRepository creates a new PostgreSQL repository.
func NewPostgresRepository(db *pgxpool.Pool) Repository <span class="cov0" title="0">{
        return &amp;PostgresRepository{
                db:      db,
                queries: postgresql.New(db),
        }
}</span>

// Run operations

func (r *PostgresRepository) Create(ctx context.Context, entity *Run) (*Run, error) <span class="cov0" title="0">{
        // Check if SQLC has the CreateRun method
        // For now, we'll generate a stub but with proper error handling
        // TODO: Parse SQLC to detect available queries

        // Example of what it should look like when SQLC query exists:
        // params := postgresql.CreateRunParams{
        //     Id: entity.Id,
        //     // ... map other fields
        // }
        // dbRun, err := r.queries.CreateRun(ctx, params)
        // if err != nil {
        //     return nil, NewRepositoryError("create", err)
        // }
        // return mapRunToDomain(&amp;dbRun), nil

        return nil, NewRepositoryError("create", errors.New("not implemented - SQLC query not found"))
}</span>

func (r *PostgresRepository) Get(ctx context.Context, id uuid.UUID) (*Run, error) <span class="cov0" title="0">{
        // Try to call SQLC GetRun if it exists
        // For now, return not implemented
        return nil, NewRepositoryError("get", errors.New("not implemented - SQLC query not found"))
}</span>

func (r *PostgresRepository) Update(ctx context.Context, id uuid.UUID, entity *Run) (*Run, error) <span class="cov0" title="0">{
        // Update operations are often custom and may not have SQLC queries
        return nil, NewRepositoryError("update", errors.New("not implemented - SQLC query not found"))
}</span>

func (r *PostgresRepository) Delete(ctx context.Context, id uuid.UUID) error <span class="cov0" title="0">{
        // Try to call SQLC DeleteRun if it exists
        // For now, return not implemented
        return NewRepositoryError("delete", errors.New("not implemented - SQLC query not found"))
}</span>

func (r *PostgresRepository) List(ctx context.Context, params ListRunsParams) ([]*Run, int64, error) <span class="cov0" title="0">{
        // List operations need both List and Count queries from SQLC
        return nil, 0, NewRepositoryError("list", errors.New("not implemented - SQLC query not found"))
}</span>

// ListByPipeline retrieves multiple runs by pipelineId
func (r *PostgresRepository) ListByPipeline(ctx context.Context, pipelineId string) ([]*Run, error) <span class="cov0" title="0">{

        // Try to call SQLC ListByPipeline if it exists
        // For now, return not implemented
        return nil, NewRepositoryError("listbypipeline", errors.New("not implemented - SQLC query not found"))

}</span>

// ListByOrganization retrieves multiple runs by organizationId
func (r *PostgresRepository) ListByOrganization(ctx context.Context, organizationId string) ([]*Run, error) <span class="cov0" title="0">{

        // Try to call SQLC ListByOrganization if it exists
        // For now, return not implemented
        return nil, NewRepositoryError("listbyorganization", errors.New("not implemented - SQLC query not found"))

}</span>

// ListByTool retrieves multiple runs by toolId
func (r *PostgresRepository) ListByTool(ctx context.Context, toolId string) ([]*Run, error) <span class="cov0" title="0">{

        // Try to call SQLC ListByTool if it exists
        // For now, return not implemented
        return nil, NewRepositoryError("listbytool", errors.New("not implemented - SQLC query not found"))

}</span>

// Mapper functions - Convert between domain types and database types
// These need to be customized based on the actual field mappings

func mapRunToDomain(db *postgresql.Run) *Run <span class="cov0" title="0">{
        if db == nil </span><span class="cov0" title="0">{
                return nil
        }</span>

        // This is a basic mapping - needs to be customized based on actual types
        // The challenge is that OpenAPI types and database types don't always match
        // For example:
        // - OpenAPI might use string, database uses *string
        // - OpenAPI might use custom UUID type, database uses uuid.UUID
        // - Field names might differ (Id vs ID)

        <span class="cov0" title="0">result := &amp;Run{
                // TODO: Map fields properly based on actual type definitions
                // This requires parsing both OpenAPI types and SQLC types
        }

        // Basic field mapping - customize based on your entity structure
        // result.Id = db.Id
        // result.CreatedAt = db.CreatedAt
        // result.UpdatedAt = db.UpdatedAt
        // Add specific field mappings as needed

        return result</span>
}
</pre>
		
		<pre class="file" id="file133" style="display: none">// Code generated by codegen repository. DO NOT EDIT.
package runs

import (
        "context"
        "fmt"
        "github.com/google/uuid"
)

// Repository handles run persistence
type Repository interface {
        Create(ctx context.Context, entity *Run) (*Run, error)
        Get(ctx context.Context, id uuid.UUID) (*Run, error)
        Update(ctx context.Context, id uuid.UUID, entity *Run) (*Run, error)
        Delete(ctx context.Context, id uuid.UUID) error
        List(ctx context.Context, params ListRunsParams) ([]*Run, int64, error)

        // Additional operations
        ListByPipeline(ctx context.Context, pipelineId string) ([]*Run, error)
        ListByOrganization(ctx context.Context, organizationId string) ([]*Run, error)
        ListByTool(ctx context.Context, toolId string) ([]*Run, error)
}

// ListRunsParams represents parameters for listing runs.
type ListRunsParams struct {
        Limit  int
        Offset int
}

// RepositoryError represents a repository error.
type RepositoryError struct {
        Operation string
        Err       error
}

func (e *RepositoryError) Error() string <span class="cov0" title="0">{
        return fmt.Sprintf("repository %s: %v", e.Operation, e.Err)
}</span>

func (e *RepositoryError) Unwrap() error <span class="cov0" title="0">{
        return e.Err
}</span>

// NewRepositoryError creates a new repository error.
func NewRepositoryError(operation string, err error) *RepositoryError <span class="cov0" title="0">{
        return &amp;RepositoryError{
                Operation: operation,
                Err:       err,
        }
}</span>
</pre>
		
		<pre class="file" id="file134" style="display: none">package runs

import (
        "context"
        "log/slog"

        "github.com/google/uuid"
)

// Service implements the Service interface for run operations
type Service struct {
        repo   Repository
        logger *slog.Logger
}

// NewService creates a new run service
func NewService(repo Repository, logger *slog.Logger) *Service <span class="cov10" title="8">{
        return &amp;Service{
                repo:   repo,
                logger: logger,
        }
}</span>

// List retrieves runs for an organization
func (s *Service) List(ctx context.Context, _ string, limit, offset int) ([]*Run, int64, error) <span class="cov4" title="2">{
        params := ListRunsParams{
                Limit:  limit,
                Offset: offset,
        }

        runs, total, err := s.repo.List(ctx, params)
        if err != nil </span><span class="cov0" title="0">{
                s.logger.Error("failed to list runs", "error", err)
                return nil, 0, err
        }</span>

        <span class="cov4" title="2">return runs, total, nil</span>
}

// Create creates a new run
func (s *Service) Create(ctx context.Context, req *CreateRunJSONRequestBody, orgID string) (*Run, error) <span class="cov4" title="2">{
        run := &amp;Run{
                Id:             uuid.New(),
                OrganizationId: orgID,
                PipelineId:     req.PipelineId,
                Status:         QUEUED,
                Progress:       0,
        }

        createdRun, err := s.repo.Create(ctx, run)
        if err != nil </span><span class="cov1" title="1">{
                s.logger.Error("failed to create run", "error", err)
                return nil, err
        }</span>

        <span class="cov1" title="1">return createdRun, nil</span>
}

// Get retrieves a run by ID
func (s *Service) Get(ctx context.Context, id uuid.UUID) (*Run, error) <span class="cov4" title="2">{
        run, err := s.repo.Get(ctx, id)
        if err != nil </span><span class="cov1" title="1">{
                s.logger.Error("failed to get run", "id", id, "error", err)
                return nil, err
        }</span>

        <span class="cov1" title="1">return run, nil</span>
}

// Update updates a run by ID
func (s *Service) Update(ctx context.Context, id uuid.UUID, req *UpdateRunJSONRequestBody) (*Run, error) <span class="cov0" title="0">{
        // Get existing run
        run, err := s.repo.Get(ctx, id)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        // Update fields if provided
        <span class="cov0" title="0">if req.PipelineId != "" </span><span class="cov0" title="0">{
                run.PipelineId = req.PipelineId
        }</span>

        // Update the run in repository
        <span class="cov0" title="0">updated, err := s.repo.Update(ctx, id, run)
        if err != nil </span><span class="cov0" title="0">{
                s.logger.Error("failed to update run", "id", id, "error", err)
                return nil, err
        }</span>

        <span class="cov0" title="0">return updated, nil</span>
}

// Delete deletes a run by ID
func (s *Service) Delete(ctx context.Context, id uuid.UUID) error <span class="cov4" title="2">{
        err := s.repo.Delete(ctx, id)
        if err != nil </span><span class="cov1" title="1">{
                s.logger.Error("failed to delete run", "id", id, "error", err)
                return err
        }</span>

        <span class="cov1" title="1">return nil</span>
}

// Domain constants
const (
        // MaxRunsToKeep defines how many completed runs to keep per pipeline
        MaxRunsToKeep = 100
)

// Domain type aliases
type (
        // CreateRunRequest represents a request to create a run
        CreateRunRequest = CreateRunJSONBody

        // UpdateRunRequest represents a request to update a run
        UpdateRunRequest = UpdateRunJSONBody
)

// CanStart checks if the run can be started
func (r *Run) CanStart() bool <span class="cov0" title="0">{
        return r.Status == QUEUED
}</span>

// IsRunning checks if the run is currently running
func (r *Run) IsRunning() bool <span class="cov0" title="0">{
        return r.Status == PROCESSING
}</span>

// CanCancel checks if the run can be cancelled
func (r *Run) CanCancel() bool <span class="cov0" title="0">{
        return r.Status == PROCESSING || r.Status == QUEUED
}</span>

// UpdateProgress updates the run's progress
func (r *Run) UpdateProgress(progress float32) <span class="cov0" title="0">{
        r.Progress = progress
}</span>
</pre>
		
		<pre class="file" id="file135" style="display: none">// Code generated by codegen repository. DO NOT EDIT.
package runs

import (
        "context"
        "database/sql"
        "fmt"

        "github.com/archesai/archesai/internal/database/sqlite"
        "github.com/google/uuid"
)

// SQLiteRepository implements Repository using SQLite.
type SQLiteRepository struct {
        db      *sql.DB
        queries *sqlite.Queries
}

// NewSQLiteRepository creates a new SQLite repository.
func NewSQLiteRepository(db *sql.DB) Repository <span class="cov0" title="0">{
        return &amp;SQLiteRepository{
                db:      db,
                queries: sqlite.New(db),
        }
}</span>

// Run operations

func (r *SQLiteRepository) Create(ctx context.Context, entity *Run) (*Run, error) <span class="cov0" title="0">{
        // For now, return a basic implementation
        // Actual implementation would need to be customized per entity
        return nil, fmt.Errorf("CreateRun not yet implemented - requires custom mapping")
}</span>

func (r *SQLiteRepository) Get(ctx context.Context, id uuid.UUID) (*Run, error) <span class="cov0" title="0">{
        // For now, return a basic implementation
        // Actual implementation would need to be customized per entity
        return nil, fmt.Errorf("GetRun not yet implemented - requires custom mapping")
}</span>

func (r *SQLiteRepository) Update(ctx context.Context, id uuid.UUID, entity *Run) (*Run, error) <span class="cov0" title="0">{
        // For now, return a basic implementation
        // Actual implementation would need to be customized per entity
        return nil, fmt.Errorf("UpdateRun not yet implemented - requires custom mapping")
}</span>

func (r *SQLiteRepository) Delete(ctx context.Context, id uuid.UUID) error <span class="cov0" title="0">{
        // For now, return a basic implementation
        // Actual implementation would need to be customized per entity
        return fmt.Errorf("DeleteRun not yet implemented - requires custom mapping")
}</span>

func (r *SQLiteRepository) List(ctx context.Context, params ListRunsParams) ([]*Run, int64, error) <span class="cov0" title="0">{
        // For now, return a basic implementation
        // Actual implementation would need to be customized per entity
        return nil, 0, fmt.Errorf("ListRuns not yet implemented - requires custom mapping")
}</span>

// ListByPipeline retrieves multiple runs by pipelineId
func (r *SQLiteRepository) ListByPipeline(ctx context.Context, pipelineId string) ([]*Run, error) <span class="cov0" title="0">{

        // For now, return a basic implementation
        return nil, fmt.Errorf("ListByPipeline not yet implemented - requires custom mapping")

}</span>

// ListByOrganization retrieves multiple runs by organizationId
func (r *SQLiteRepository) ListByOrganization(ctx context.Context, organizationId string) ([]*Run, error) <span class="cov0" title="0">{

        // For now, return a basic implementation
        return nil, fmt.Errorf("ListByOrganization not yet implemented - requires custom mapping")

}</span>

// ListByTool retrieves multiple runs by toolId
func (r *SQLiteRepository) ListByTool(ctx context.Context, toolId string) ([]*Run, error) <span class="cov0" title="0">{

        // For now, return a basic implementation
        return nil, fmt.Errorf("ListByTool not yet implemented - requires custom mapping")

}</span>
</pre>
		
		<pre class="file" id="file136" style="display: none">// Package runs provides primitives to interact with the openapi HTTP API.
//
// Code generated by github.com/oapi-codegen/oapi-codegen/v2 version v2.5.0 DO NOT EDIT.
package runs

import (
        "encoding/json"
        "time"

        "github.com/oapi-codegen/runtime"
        openapi_types "github.com/oapi-codegen/runtime/types"
)

const (
        BearerAuthScopes = "bearerAuth.Scopes"
)

// Defines values for RunStatus.
const (
        COMPLETED  RunStatus = "COMPLETED"
        FAILED     RunStatus = "FAILED"
        PROCESSING RunStatus = "PROCESSING"
        QUEUED     RunStatus = "QUEUED"
)

// Defines values for FindManyRunsParamsSortField.
const (
        CompletedAt    FindManyRunsParamsSortField = "completedAt"
        CreatedAt      FindManyRunsParamsSortField = "createdAt"
        Error          FindManyRunsParamsSortField = "error"
        Id             FindManyRunsParamsSortField = "id"
        OrganizationId FindManyRunsParamsSortField = "organizationId"
        PipelineId     FindManyRunsParamsSortField = "pipelineId"
        Progress       FindManyRunsParamsSortField = "progress"
        StartedAt      FindManyRunsParamsSortField = "startedAt"
        Status         FindManyRunsParamsSortField = "status"
        ToolId         FindManyRunsParamsSortField = "toolId"
        UpdatedAt      FindManyRunsParamsSortField = "updatedAt"
)

// Defines values for FindManyRunsParamsSortOrder.
const (
        Asc  FindManyRunsParamsSortOrder = "asc"
        Desc FindManyRunsParamsSortOrder = "desc"
)

// FilterNode A recursive filter node that can be a condition or group
type FilterNode = interface{}

// Page Pagination (page number &amp; size)
type Page struct {
        Number int `json:"number,omitempty,omitzero" yaml:"number,omitempty"`
        Size   int `json:"size,omitempty,omitzero" yaml:"size,omitempty"`
}

// Problem RFC 7807 (Problem Details) compliant error response
type Problem struct {
        // Detail Human-readable explanation specific to this occurrence
        Detail string `json:"detail" yaml:"detail"`

        // Errors Additional validation errors for specific fields
        Errors []ValidationError `json:"errors,omitempty,omitzero" yaml:"errors,omitempty"`

        // Instance URI identifying the specific occurrence
        Instance string `json:"instance,omitempty,omitzero" yaml:"instance,omitempty"`

        // Status HTTP status code
        Status int `json:"status" yaml:"status"`

        // Title Short, human-readable summary
        Title string `json:"title" yaml:"title"`

        // Type URI identifying the problem type
        Type string `json:"type" yaml:"type"`
}

// Run Schema for Run entity
type Run struct {
        // CompletedAt The timestamp when the run completed
        CompletedAt time.Time `json:"completedAt,omitempty,omitzero" yaml:"completedAt,omitempty"`

        // CreatedAt The date this item was created
        CreatedAt time.Time `json:"createdAt" yaml:"createdAt"`

        // Error The error message
        Error string `json:"error,omitempty,omitzero" yaml:"error,omitempty"`

        // Id The ID of the item
        Id openapi_types.UUID `json:"id" yaml:"id"`

        // OrganizationId The organization name
        OrganizationId string `json:"organizationId" yaml:"organizationId"`

        // PipelineId The pipeline ID associated with the run
        PipelineId string `json:"pipelineId" yaml:"pipelineId"`

        // Progress The percent progress of the run
        Progress float32 `json:"progress" yaml:"progress"`

        // StartedAt The timestamp when the run started
        StartedAt time.Time `json:"startedAt,omitempty,omitzero" yaml:"startedAt,omitempty"`
        Status    RunStatus `json:"status" yaml:"status"`

        // ToolId The tool ID associated with the run
        ToolId string `json:"toolId" yaml:"toolId"`

        // UpdatedAt The date this item was last updated
        UpdatedAt time.Time `json:"updatedAt" yaml:"updatedAt"`
}

// RunStatus defines model for Run.Status.
type RunStatus string

// ValidationError Individual field validation error
type ValidationError struct {
        // Field The field path that failed validation
        Field string `json:"field" yaml:"field"`

        // Message Human-readable error message
        Message string `json:"message" yaml:"message"`

        // Value The invalid value that was provided
        Value ValidationError_Value `json:"value,omitempty,omitzero" yaml:"value,omitempty"`
}

// ValidationErrorValue0 defines model for .
type ValidationErrorValue0 = string

// ValidationErrorValue1 defines model for .
type ValidationErrorValue1 = float32

// ValidationErrorValue2 defines model for .
type ValidationErrorValue2 = bool

// ValidationError_Value The invalid value that was provided
type ValidationError_Value struct {
        union json.RawMessage
}

// PageQuery Pagination (page number &amp; size)
type PageQuery = Page

// RunsFilter A recursive filter node that can be a condition or group
type RunsFilter = FilterNode

// RunsSort defines model for RunsSort.
type RunsSort = []struct {
        Field string `json:"field" yaml:"field"`
        Order string `json:"order" yaml:"order"`
}

// BadRequest RFC 7807 (Problem Details) compliant error response
type BadRequest = Problem

// NotFound RFC 7807 (Problem Details) compliant error response
type NotFound = Problem

// Unauthorized RFC 7807 (Problem Details) compliant error response
type Unauthorized = Problem

// FindManyRunsParams defines parameters for FindManyRuns.
type FindManyRunsParams struct {
        // Filter Filter runs by field values. Supported fields:
        // - createdAt, id, updatedAt, completedAt, error, organizationId
        // - pipelineId, progress, startedAt, status, toolId
        Filter RunsFilter `json:"filter,omitempty,omitzero" yaml:"filter,omitempty"`

        // Page The page parameter
        Page PageQuery `form:"page,omitempty" json:"page,omitempty,omitzero" yaml:"page,omitempty"`

        // Sort The sort parameter
        Sort RunsSort `form:"sort,omitempty" json:"sort,omitempty,omitzero" yaml:"sort,omitempty"`
}

// FindManyRunsParamsSortField defines parameters for FindManyRuns.
type FindManyRunsParamsSortField string

// FindManyRunsParamsSortOrder defines parameters for FindManyRuns.
type FindManyRunsParamsSortOrder string

// CreateRunJSONBody defines parameters for CreateRun.
type CreateRunJSONBody struct {
        // PipelineId The pipeline ID associated with the run
        PipelineId string `json:"pipelineId" yaml:"pipelineId"`
}

// UpdateRunJSONBody defines parameters for UpdateRun.
type UpdateRunJSONBody struct {
        // PipelineId The pipeline ID associated with the run
        PipelineId string `json:"pipelineId,omitempty,omitzero" yaml:"pipelineId,omitempty"`
}

// CreateRunJSONRequestBody defines body for CreateRun for application/json ContentType.
type CreateRunJSONRequestBody CreateRunJSONBody

// UpdateRunJSONRequestBody defines body for UpdateRun for application/json ContentType.
type UpdateRunJSONRequestBody UpdateRunJSONBody

// AsValidationErrorValue0 returns the union data inside the ValidationError_Value as a ValidationErrorValue0
func (t ValidationError_Value) AsValidationErrorValue0() (ValidationErrorValue0, error) <span class="cov0" title="0">{
        var body ValidationErrorValue0
        err := json.Unmarshal(t.union, &amp;body)
        return body, err
}</span>

// FromValidationErrorValue0 overwrites any union data inside the ValidationError_Value as the provided ValidationErrorValue0
func (t *ValidationError_Value) FromValidationErrorValue0(v ValidationErrorValue0) error <span class="cov0" title="0">{
        b, err := json.Marshal(v)
        t.union = b
        return err
}</span>

// MergeValidationErrorValue0 performs a merge with any union data inside the ValidationError_Value, using the provided ValidationErrorValue0
func (t *ValidationError_Value) MergeValidationErrorValue0(v ValidationErrorValue0) error <span class="cov0" title="0">{
        b, err := json.Marshal(v)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov0" title="0">merged, err := runtime.JSONMerge(t.union, b)
        t.union = merged
        return err</span>
}

// AsValidationErrorValue1 returns the union data inside the ValidationError_Value as a ValidationErrorValue1
func (t ValidationError_Value) AsValidationErrorValue1() (ValidationErrorValue1, error) <span class="cov0" title="0">{
        var body ValidationErrorValue1
        err := json.Unmarshal(t.union, &amp;body)
        return body, err
}</span>

// FromValidationErrorValue1 overwrites any union data inside the ValidationError_Value as the provided ValidationErrorValue1
func (t *ValidationError_Value) FromValidationErrorValue1(v ValidationErrorValue1) error <span class="cov0" title="0">{
        b, err := json.Marshal(v)
        t.union = b
        return err
}</span>

// MergeValidationErrorValue1 performs a merge with any union data inside the ValidationError_Value, using the provided ValidationErrorValue1
func (t *ValidationError_Value) MergeValidationErrorValue1(v ValidationErrorValue1) error <span class="cov0" title="0">{
        b, err := json.Marshal(v)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov0" title="0">merged, err := runtime.JSONMerge(t.union, b)
        t.union = merged
        return err</span>
}

// AsValidationErrorValue2 returns the union data inside the ValidationError_Value as a ValidationErrorValue2
func (t ValidationError_Value) AsValidationErrorValue2() (ValidationErrorValue2, error) <span class="cov0" title="0">{
        var body ValidationErrorValue2
        err := json.Unmarshal(t.union, &amp;body)
        return body, err
}</span>

// FromValidationErrorValue2 overwrites any union data inside the ValidationError_Value as the provided ValidationErrorValue2
func (t *ValidationError_Value) FromValidationErrorValue2(v ValidationErrorValue2) error <span class="cov0" title="0">{
        b, err := json.Marshal(v)
        t.union = b
        return err
}</span>

// MergeValidationErrorValue2 performs a merge with any union data inside the ValidationError_Value, using the provided ValidationErrorValue2
func (t *ValidationError_Value) MergeValidationErrorValue2(v ValidationErrorValue2) error <span class="cov0" title="0">{
        b, err := json.Marshal(v)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov0" title="0">merged, err := runtime.JSONMerge(t.union, b)
        t.union = merged
        return err</span>
}

func (t ValidationError_Value) MarshalJSON() ([]byte, error) <span class="cov0" title="0">{
        b, err := t.union.MarshalJSON()
        return b, err
}</span>

func (t *ValidationError_Value) UnmarshalJSON(b []byte) error <span class="cov0" title="0">{
        err := t.union.UnmarshalJSON(b)
        return err
}</span>
</pre>
		
		<pre class="file" id="file137" style="display: none">// Package server provides HTTP server implementation and middleware
package server

import (
        _ "embed"
        "net/http"
        "os"
        "path/filepath"

        "github.com/labstack/echo/v4"
        "gopkg.in/yaml.v3"
)

//go:embed assets/docs.html
var docsHTML []byte

// SetupDocs configures API documentation endpoints
func (s *Server) SetupDocs() error <span class="cov0" title="0">{
        if !s.config.Docs </span><span class="cov0" title="0">{
                s.logger.Info("API documentation disabled")
                return nil
        }</span>

        // Determine the OpenAPI spec path
        // Try relative to current working directory first
        <span class="cov0" title="0">specPath := "api/openapi.bundled.yaml"
        if _, err := os.Stat(specPath); os.IsNotExist(err) </span><span class="cov0" title="0">{
                // Try relative to executable
                exePath, _ := os.Executable()
                specPath = filepath.Join(filepath.Dir(exePath), "../api/openapi.bundled.yaml")
                if _, err := os.Stat(specPath); os.IsNotExist(err) </span><span class="cov0" title="0">{
                        // Fallback to absolute path
                        specPath = "/home/jonathan/Projects/archesai/api/openapi.bundled.yaml"
                }</span>
        }

        // Read the OpenAPI spec file
        <span class="cov0" title="0">openapiYAML, err := os.ReadFile(specPath)
        if err != nil </span><span class="cov0" title="0">{
                s.logger.Error("Failed to read OpenAPI spec", "error", err, "path", specPath)
                return err
        }</span>

        // Serve OpenAPI spec as YAML
        <span class="cov0" title="0">s.echo.GET("/openapi.yaml", func(c echo.Context) error </span><span class="cov0" title="0">{
                c.Response().Header().Set("Content-Type", "application/x-yaml")
                return c.Blob(http.StatusOK, "application/x-yaml", openapiYAML)
        }</span>)

        // Serve OpenAPI spec as JSON (convert YAML to JSON)
        <span class="cov0" title="0">s.echo.GET("/openapi.json", func(c echo.Context) error </span><span class="cov0" title="0">{
                var spec map[string]interface{}
                if err := yaml.Unmarshal(openapiYAML, &amp;spec); err != nil </span><span class="cov0" title="0">{
                        s.logger.Error("Failed to parse OpenAPI YAML", "error", err)
                        return c.JSON(http.StatusInternalServerError, map[string]string{
                                "error": "Failed to parse OpenAPI specification",
                        })
                }</span>
                <span class="cov0" title="0">return c.JSON(http.StatusOK, spec)</span>
        })

        // Serve the Scalar documentation UI
        <span class="cov0" title="0">s.echo.GET("/docs", func(c echo.Context) error </span><span class="cov0" title="0">{
                return c.HTMLBlob(http.StatusOK, docsHTML)
        }</span>)

        // Redirect root /docs/ to /docs
        <span class="cov0" title="0">s.echo.GET("/docs/", func(c echo.Context) error </span><span class="cov0" title="0">{
                return c.Redirect(http.StatusMovedPermanently, "/docs")
        }</span>)

        <span class="cov0" title="0">s.logger.Info("API documentation enabled",
                "docs_url", "/docs",
                "openapi_yaml", "/openapi.yaml",
                "openapi_json", "/openapi.json",
        )

        return nil</span>
}
</pre>
		
		<pre class="file" id="file138" style="display: none">package server

import (
        "net/http"
        "time"

        "github.com/labstack/echo/v4"
)

// SetupInfrastructureRoutes configures infrastructure routes only
func (s *Server) SetupInfrastructureRoutes() <span class="cov0" title="0">{
        // Health check - simple liveness probe
        s.echo.GET("/health", func(c echo.Context) error </span><span class="cov0" title="0">{
                return c.JSON(http.StatusOK, map[string]interface{}{
                        "status":    "healthy",
                        "timestamp": time.Now().Unix(),
                })
        }</span>)

        // API version endpoint
        <span class="cov0" title="0">s.echo.GET("/version", func(c echo.Context) error </span><span class="cov0" title="0">{
                return c.JSON(http.StatusOK, map[string]string{
                        "version": "1.0.0",
                        "build":   "development",
                })
        }</span>)

        // 404 handler - must be registered last (will be overridden when container registers routes)
        <span class="cov0" title="0">s.echo.RouteNotFound("/*", func(_ echo.Context) error </span><span class="cov0" title="0">{
                return echo.NewHTTPError(http.StatusNotFound, "route not found")
        }</span>)
}

// SetReadinessCheck allows the container to provide a readiness check function
func (s *Server) SetReadinessCheck(checkFunc func(echo.Context) error) <span class="cov0" title="0">{
        s.echo.GET("/ready", checkFunc)
}</span>
</pre>
		
		<pre class="file" id="file139" style="display: none">package server

import (
        "net/http"
        "strings"
        "time"

        "github.com/labstack/echo/v4"
        "github.com/labstack/echo/v4/middleware"
)

// SetupMiddleware configures all middleware for the server
func (s *Server) SetupMiddleware() <span class="cov0" title="0">{
        // Request ID middleware
        s.echo.Use(middleware.RequestID())

        // Logger middleware
        s.echo.Use(middleware.RequestLoggerWithConfig(middleware.RequestLoggerConfig{
                LogURI:    true,
                LogStatus: true,
                LogError:  true,
                LogValuesFunc: func(c echo.Context, v middleware.RequestLoggerValues) error </span><span class="cov0" title="0">{
                        s.logger.Info("request",
                                "id", v.RequestID,
                                "method", c.Request().Method,
                                "uri", v.URI,
                                "status", v.Status,
                                "latency", v.Latency,
                                "remote_ip", c.RealIP(),
                                "error", v.Error,
                        )
                        return nil
                }</span>,
        }))

        // TODO: Update to use domain-scoped validation middleware
        // Use our validation middleware to check all requests against the
        // OpenAPI schema.
        // swagger, err := api.GetSwagger()
        // if err != nil {
        //         fmt.Fprintf(os.Stderr, "Error loading swagger spec\n: %s", err)
        //         os.Exit(1)
        // }
        // s.echo.Use(echomiddleware.OapiRequestValidator(swagger))

        // Recover middleware
        <span class="cov0" title="0">s.echo.Use(middleware.RecoverWithConfig(middleware.RecoverConfig{
                LogErrorFunc: func(c echo.Context, err error, stack []byte) error </span><span class="cov0" title="0">{
                        s.logger.Error("panic recovered",
                                "id", c.Response().Header().Get(echo.HeaderXRequestID),
                                "error", err,
                                "stack", string(stack),
                        )
                        return nil
                }</span>,
        }))

        // CORS middleware
        <span class="cov0" title="0">s.echo.Use(middleware.CORSWithConfig(middleware.CORSConfig{
                AllowOrigins:     strings.Split(s.config.Cors.Origins, ","),
                AllowMethods:     []string{http.MethodGet, http.MethodHead, http.MethodPut, http.MethodPatch, http.MethodPost, http.MethodDelete, http.MethodOptions},
                AllowHeaders:     []string{echo.HeaderOrigin, echo.HeaderContentType, echo.HeaderAccept, echo.HeaderAuthorization, "X-Request-ID", "X-Requested-With"},
                AllowCredentials: true,
                ExposeHeaders:    []string{"X-Request-ID"},
                MaxAge:           86400,
        }))

        // Compression middleware
        s.echo.Use(middleware.GzipWithConfig(middleware.GzipConfig{
                Level: 5,
                Skipper: func(c echo.Context) bool </span><span class="cov0" title="0">{
                        return c.Path() == "/health"
                }</span>,
        }))

        // Security middleware
        <span class="cov0" title="0">s.echo.Use(middleware.SecureWithConfig(middleware.SecureConfig{
                XSSProtection:         "1; mode=block",
                ContentTypeNosniff:    "nosniff",
                XFrameOptions:         "SAMEORIGIN",
                HSTSMaxAge:            31536000,
                HSTSExcludeSubdomains: false,
                ContentSecurityPolicy: "default-src 'self'",
                // FIXME - adjust ContentSecurityPolicy as needed
                //     directives: {
                //       defaultSrc: [`'self'`],
                //       fontSrc: [`'self'`, 'fonts.scalar.com', 'data:'],
                //       imgSrc: [`'self'`, 'data:'],
                //       scriptSrc: [`'self'`, `https: 'unsafe-inline'`, `'unsafe-eval'`],
                //       styleSrc: [`'self'`, `'unsafe-inline'`, 'fonts.scalar.com']
                //     }
                //   }
                ReferrerPolicy: "strict-origin-when-cross-origin",
        }))

        // Rate limiting (basic example - consider using a Redis-based solution in production)
        s.echo.Use(middleware.RateLimiterWithConfig(middleware.RateLimiterConfig{
                Store: middleware.NewRateLimiterMemoryStoreWithConfig(
                        middleware.RateLimiterMemoryStoreConfig{
                                Rate:      10,
                                Burst:     30,
                                ExpiresIn: 3 * time.Minute,
                        },
                ),
                IdentifierExtractor: func(c echo.Context) (string, error) </span><span class="cov0" title="0">{
                        // Use IP address as identifier
                        return c.RealIP(), nil
                }</span>,
                ErrorHandler: func(c echo.Context, err error) error <span class="cov0" title="0">{
                        s.logger.Warn("rate limiter error", "error", err, "ip", c.RealIP())
                        return c.JSON(http.StatusTooManyRequests, map[string]string{
                                "error": "Too many requests",
                        })
                }</span>,
                DenyHandler: func(c echo.Context, identifier string, err error) error <span class="cov0" title="0">{
                        s.logger.Info("rate limit exceeded", "identifier", identifier, "path", c.Request().URL.Path, "error", err)
                        return c.JSON(http.StatusTooManyRequests, map[string]string{
                                "error": "Rate limit exceeded",
                        })
                }</span>,
        }))

        // Body limit middleware
        <span class="cov0" title="0">s.echo.Use(middleware.BodyLimit("10M"))

        // Timeout middleware
        s.echo.Use(middleware.TimeoutWithConfig(middleware.TimeoutConfig{
                Timeout:      30 * time.Second,
                ErrorMessage: "Request timeout",
        }))</span>
}
</pre>
		
		<pre class="file" id="file140" style="display: none">// Package server provides HTTP server infrastructure for the API.
//
// The package includes:
// - HTTP server setup with Echo framework
// - Middleware configuration (CORS, logging, recovery)
// - WebSocket support for real-time communication
// - OpenAPI documentation serving
// - Graceful shutdown handling
package server

import (
        "context"
        "fmt"
        "log/slog"
        "net/http"
        "os"
        "os/signal"
        "time"

        "github.com/archesai/archesai/internal/config"
        "github.com/labstack/echo/v4"
)

// Server configuration constants
const (
        // DefaultPort is the default server port
        DefaultPort = "8080"

        // DefaultReadTimeout is the default read timeout
        DefaultReadTimeout = 30 * time.Second

        // DefaultWriteTimeout is the default write timeout
        DefaultWriteTimeout = 30 * time.Second

        // DefaultIdleTimeout is the default idle timeout
        DefaultIdleTimeout = 120 * time.Second

        // DefaultShutdownTimeout is the timeout for graceful shutdown
        DefaultShutdownTimeout = 10 * time.Second

        // DefaultMaxHeaderBytes is the maximum header size
        DefaultMaxHeaderBytes = 1 &lt;&lt; 20 // 1 MB
)

// WebSocket constants
const (
        // WebSocketReadBufferSize is the WebSocket read buffer size
        WebSocketReadBufferSize = 1024

        // WebSocketWriteBufferSize is the WebSocket write buffer size
        WebSocketWriteBufferSize = 1024

        // WebSocketHandshakeTimeout is the WebSocket handshake timeout
        WebSocketHandshakeTimeout = 10 * time.Second

        // WebSocketPingPeriod is the WebSocket ping period
        WebSocketPingPeriod = 54 * time.Second

        // WebSocketPongTimeout is the WebSocket pong timeout
        WebSocketPongTimeout = 60 * time.Second
)

// Middleware priority constants (lower number = higher priority)
const (
        // MiddlewarePriorityRecover runs first to catch panics
        MiddlewarePriorityRecover = 1

        // MiddlewarePriorityLogger logs all requests
        MiddlewarePriorityLogger = 2

        // MiddlewarePriorityCORS handles CORS headers
        MiddlewarePriorityCORS = 3

        // MiddlewarePriorityAuth handles authentication
        MiddlewarePriorityAuth = 10
)

// Server represents the API server
type Server struct {
        echo   *echo.Echo
        config *config.APIConfig
        logger *slog.Logger
}

// NewServer creates a new API server
func NewServer(config *config.APIConfig, logger *slog.Logger) *Server <span class="cov0" title="0">{
        e := echo.New()
        e.HideBanner = true
        e.HidePort = true

        server := &amp;Server{
                echo:   e,
                config: config,
                logger: logger,
        }

        server.SetupMiddleware()
        server.SetupInfrastructureRoutes()

        return server
}</span>

// Echo returns the underlying echo instance for route registration
func (s *Server) Echo() *echo.Echo <span class="cov0" title="0">{
        return s.echo
}</span>

// ListenAndServe starts the server without signal handling
// This is useful when the caller wants to manage the server lifecycle
func (s *Server) ListenAndServe() error <span class="cov0" title="0">{
        addr := fmt.Sprintf(":%d", int(s.config.Port))
        s.logger.Info("starting server", "address", addr)
        return s.echo.Start(addr)
}</span>

// Start starts the server with built-in signal handling
// This is a convenience method for simple use cases
func (s *Server) Start() error <span class="cov0" title="0">{
        // Start server in goroutine
        go func() </span><span class="cov0" title="0">{
                if err := s.ListenAndServe(); err != nil &amp;&amp; err != http.ErrServerClosed </span><span class="cov0" title="0">{
                        s.logger.Error("failed to start server", "error", err)
                        os.Exit(1)
                }</span>
        }()

        // Wait for interrupt signal
        <span class="cov0" title="0">quit := make(chan os.Signal, 1)
        signal.Notify(quit, os.Interrupt)
        &lt;-quit

        s.logger.Info("shutting down server...")

        // Graceful shutdown
        ctx, cancel := context.WithTimeout(context.Background(), 10*time.Second)
        defer cancel()

        if err := s.echo.Shutdown(ctx); err != nil </span><span class="cov0" title="0">{
                s.logger.Error("server forced to shutdown", "error", err)
                return err
        }</span>

        <span class="cov0" title="0">s.logger.Info("server shutdown complete")
        return nil</span>
}

// Shutdown shuts down the server gracefully
func (s *Server) Shutdown(ctx context.Context) error <span class="cov0" title="0">{
        return s.echo.Shutdown(ctx)
}</span>
</pre>
		
		<pre class="file" id="file141" style="display: none">package server

import (
        "fmt"
        "log"
        "net/http"
        "time"

        "github.com/coder/websocket"
        "github.com/labstack/echo/v4"
)

// WebsocketHandler handles WebSocket connections (currently unused)
// TODO: Remove if not needed or implement WebSocket functionality
// nolint:unused // Preserved for future WebSocket implementation
func (s *Server) WebsocketHandler(c echo.Context) error <span class="cov0" title="0">{
        w := c.Response().Writer
        r := c.Request()
        socket, err := websocket.Accept(w, r, nil)

        if err != nil </span><span class="cov0" title="0">{
                log.Printf("could not open websocket: %v", err)
                _, _ = w.Write([]byte("could not open websocket"))
                w.WriteHeader(http.StatusInternalServerError)
                return nil
        }</span>

        <span class="cov0" title="0">defer func() </span><span class="cov0" title="0">{
                if err := socket.Close(websocket.StatusGoingAway, "server closing websocket"); err != nil </span><span class="cov0" title="0">{
                        log.Printf("error closing websocket: %v", err)
                }</span>
        }()

        <span class="cov0" title="0">ctx := r.Context()
        socketCtx := socket.CloseRead(ctx)

        for </span><span class="cov0" title="0">{
                payload := fmt.Sprintf("server timestamp: %d", time.Now().UnixNano())
                err := socket.Write(socketCtx, websocket.MessageText, []byte(payload))
                if err != nil </span><span class="cov0" title="0">{
                        break</span>
                }
                <span class="cov0" title="0">time.Sleep(time.Second * 2)</span>
        }
        <span class="cov0" title="0">return nil</span>
}
</pre>
		
		<pre class="file" id="file142" style="display: none">// Code generated by codegen cache. DO NOT EDIT.
package sessions

import (
        "context"
        "time"

        genericcache "github.com/archesai/archesai/internal/cache"
        "github.com/google/uuid"
)

// ErrCacheMiss re-exported from generic cache package
var ErrCacheMiss = genericcache.ErrCacheMiss

// Cache provides caching operations for sessions domain.
type Cache interface {

        // Session caching
        Get(ctx context.Context, id uuid.UUID) (*Session, error)
        Set(ctx context.Context, entity *Session, ttl time.Duration) error
        Delete(ctx context.Context, id uuid.UUID) error
        GetByToken(ctx context.Context, token string) (*Session, error)
        DeleteByToken(ctx context.Context, token string) error
        DeleteByUser(ctx context.Context, userId uuid.UUID) error
        DeleteExpired(ctx context.Context) error

        // Batch operations
        FlushAll(ctx context.Context) error
}

// NewNoOpCache creates a no-op cache using the generic NoOpCache with the adapter
func NewNoOpCache() Cache <span class="cov10" title="26">{
        return NewCacheAdapter(genericcache.NewNoOpCache[Session]())
}</span>

// CacheAdapter adapts generic cache implementations to the domain Cache interface
type CacheAdapter struct {
        sessionCache genericcache.Cache[Session]
}

// NewCacheAdapter creates a new cache adapter using generic caches
func NewCacheAdapter(sessionCache genericcache.Cache[Session]) Cache <span class="cov10" title="26">{
        return &amp;CacheAdapter{
                sessionCache: sessionCache,
        }
}</span>

// Get retrieves session from cache by ID
func (a *CacheAdapter) Get(ctx context.Context, id uuid.UUID) (*Session, error) <span class="cov5" title="5">{
        entity, err := a.sessionCache.Get(ctx, id.String())
        if err != nil </span><span class="cov5" title="5">{
                return nil, err
        }</span>
        <span class="cov0" title="0">if entity == nil </span><span class="cov0" title="0">{
                return nil, ErrCacheMiss
        }</span>
        <span class="cov0" title="0">return entity, nil</span>
}

// Set stores session in cache with TTL
func (a *CacheAdapter) Set(ctx context.Context, entity *Session, ttl time.Duration) error <span class="cov8" title="15">{
        if entity == nil </span><span class="cov0" title="0">{
                return nil
        }</span>
        <span class="cov8" title="15">return a.sessionCache.Set(ctx, entity.Id.String(), entity, ttl)</span>
}

// Delete removes session from cache
func (a *CacheAdapter) Delete(ctx context.Context, id uuid.UUID) error <span class="cov1" title="1">{
        return a.sessionCache.Delete(ctx, id.String())
}</span>

// GetByToken retrieves session from cache by token
func (a *CacheAdapter) GetByToken(ctx context.Context, token string) (*Session, error) <span class="cov0" title="0">{
        key := "token:" + token
        entity, err := a.sessionCache.Get(ctx, key)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">if entity == nil </span><span class="cov0" title="0">{
                return nil, ErrCacheMiss
        }</span>
        <span class="cov0" title="0">return entity, nil</span>
}

// DeleteByToken removes cache entries by token
func (a *CacheAdapter) DeleteByToken(ctx context.Context, token string) error <span class="cov0" title="0">{
        key := "token:" + token
        return a.sessionCache.Delete(ctx, key)
}</span>

// DeleteByUser removes cache entries by userId
func (a *CacheAdapter) DeleteByUser(ctx context.Context, userId uuid.UUID) error <span class="cov2" title="2">{
        key := "userId:" + userId.String()
        return a.sessionCache.Delete(ctx, key)
}</span>

// DeleteExpired removes cache entries
func (a *CacheAdapter) DeleteExpired(ctx context.Context) error <span class="cov0" title="0">{
        // This would require a more complex implementation
        // For now, returning nil as it's best-effort cleanup
        return nil
}</span>

// FlushAll clears all cached data
func (a *CacheAdapter) FlushAll(ctx context.Context) error <span class="cov0" title="0">{
        if err := a.sessionCache.Clear(ctx); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov0" title="0">return nil</span>
}

// Ensure CacheAdapter implements Cache interface
var _ Cache = (*CacheAdapter)(nil)
</pre>
		
		<pre class="file" id="file143" style="display: none">// Code generated by codegen events. DO NOT EDIT.
package sessions

import (
        "context"
        "github.com/archesai/archesai/internal/events"
)

// Event type constants for sessions domain.
const (
        EventSessionCreated   = "session.created"
        EventSessionRefreshed = "session.refreshed"
        EventSessionExpired   = "session.expired"
        EventSessionDeleted   = "session.deleted"
)

// SessionCreatedEvent represents a created event event for Session.
type SessionCreatedEvent struct {
        events.BaseEvent
        Session *Session `json:"session"`
}

// NewSessionCreatedEvent creates a new Session created event.
func NewSessionCreatedEvent(entity *Session) *SessionCreatedEvent <span class="cov0" title="0">{
        return &amp;SessionCreatedEvent{
                BaseEvent: events.NewBaseEvent("sessions", EventSessionCreated),
                Session:   entity,
        }
}</span>

// EventType returns the event type string.
func (e *SessionCreatedEvent) EventType() string <span class="cov0" title="0">{
        return EventSessionCreated
}</span>

// EventDomain returns the domain this event belongs to.
func (e *SessionCreatedEvent) EventDomain() string <span class="cov0" title="0">{
        return "sessions"
}</span>

// EventData returns the actual event data.
func (e *SessionCreatedEvent) EventData() interface{} <span class="cov0" title="0">{
        return e.Session
}</span>

// SessionRefreshedEvent represents a refreshed event event for Session.
type SessionRefreshedEvent struct {
        events.BaseEvent
        Session *Session `json:"session"`
}

// NewSessionRefreshedEvent creates a new Session refreshed event.
func NewSessionRefreshedEvent(entity *Session) *SessionRefreshedEvent <span class="cov0" title="0">{
        return &amp;SessionRefreshedEvent{
                BaseEvent: events.NewBaseEvent("sessions", EventSessionRefreshed),
                Session:   entity,
        }
}</span>

// EventType returns the event type string.
func (e *SessionRefreshedEvent) EventType() string <span class="cov0" title="0">{
        return EventSessionRefreshed
}</span>

// EventDomain returns the domain this event belongs to.
func (e *SessionRefreshedEvent) EventDomain() string <span class="cov0" title="0">{
        return "sessions"
}</span>

// EventData returns the actual event data.
func (e *SessionRefreshedEvent) EventData() interface{} <span class="cov0" title="0">{
        return e.Session
}</span>

// SessionExpiredEvent represents a expired event event for Session.
type SessionExpiredEvent struct {
        events.BaseEvent
        Session *Session `json:"session"`
}

// NewSessionExpiredEvent creates a new Session expired event.
func NewSessionExpiredEvent(entity *Session) *SessionExpiredEvent <span class="cov0" title="0">{
        return &amp;SessionExpiredEvent{
                BaseEvent: events.NewBaseEvent("sessions", EventSessionExpired),
                Session:   entity,
        }
}</span>

// EventType returns the event type string.
func (e *SessionExpiredEvent) EventType() string <span class="cov0" title="0">{
        return EventSessionExpired
}</span>

// EventDomain returns the domain this event belongs to.
func (e *SessionExpiredEvent) EventDomain() string <span class="cov0" title="0">{
        return "sessions"
}</span>

// EventData returns the actual event data.
func (e *SessionExpiredEvent) EventData() interface{} <span class="cov0" title="0">{
        return e.Session
}</span>

// SessionDeletedEvent represents a deleted event event for Session.
type SessionDeletedEvent struct {
        events.BaseEvent
        Session *Session `json:"session"`
}

// NewSessionDeletedEvent creates a new Session deleted event.
func NewSessionDeletedEvent(entity *Session) *SessionDeletedEvent <span class="cov0" title="0">{
        return &amp;SessionDeletedEvent{
                BaseEvent: events.NewBaseEvent("sessions", EventSessionDeleted),
                Session:   entity,
        }
}</span>

// EventType returns the event type string.
func (e *SessionDeletedEvent) EventType() string <span class="cov0" title="0">{
        return EventSessionDeleted
}</span>

// EventDomain returns the domain this event belongs to.
func (e *SessionDeletedEvent) EventDomain() string <span class="cov0" title="0">{
        return "sessions"
}</span>

// EventData returns the actual event data.
func (e *SessionDeletedEvent) EventData() interface{} <span class="cov0" title="0">{
        return e.Session
}</span>

// EventPublisher publishes domain events for sessions.
type EventPublisher interface {
        PublishSessionCreated(ctx context.Context, entity *Session) error
        PublishSessionRefreshed(ctx context.Context, entity *Session) error
        PublishSessionExpired(ctx context.Context, entity *Session) error
        PublishSessionDeleted(ctx context.Context, entity *Session) error
}

// eventPublisher implements EventPublisher for sessions domain.
type eventPublisher struct {
        publisher events.Publisher
}

// NewEventPublisher creates a new event publisher for sessions domain.
func NewEventPublisher(publisher events.Publisher) EventPublisher <span class="cov0" title="0">{
        return &amp;eventPublisher{
                publisher: publisher,
        }
}</span>

// PublishSessionCreated publishes a created event event for Session.
func (p *eventPublisher) PublishSessionCreated(ctx context.Context, entity *Session) error <span class="cov0" title="0">{
        event := NewSessionCreatedEvent(entity)
        return events.PublishDomainEvent(ctx, p.publisher, event)
}</span>

// PublishSessionRefreshed publishes a refreshed event event for Session.
func (p *eventPublisher) PublishSessionRefreshed(ctx context.Context, entity *Session) error <span class="cov0" title="0">{
        event := NewSessionRefreshedEvent(entity)
        return events.PublishDomainEvent(ctx, p.publisher, event)
}</span>

// PublishSessionExpired publishes a expired event event for Session.
func (p *eventPublisher) PublishSessionExpired(ctx context.Context, entity *Session) error <span class="cov0" title="0">{
        event := NewSessionExpiredEvent(entity)
        return events.PublishDomainEvent(ctx, p.publisher, event)
}</span>

// PublishSessionDeleted publishes a deleted event event for Session.
func (p *eventPublisher) PublishSessionDeleted(ctx context.Context, entity *Session) error <span class="cov0" title="0">{
        event := NewSessionDeletedEvent(entity)
        return events.PublishDomainEvent(ctx, p.publisher, event)
}</span>

// NewNoOpEventPublisher creates a new no-op event publisher for testing.
func NewNoOpEventPublisher() EventPublisher <span class="cov0" title="0">{
        return NewEventPublisher(events.NewNoOpPublisher())
}</span>
</pre>
		
		<pre class="file" id="file144" style="display: none">// Package sessions provides primitives to interact with the openapi HTTP API.
//
// Code generated by github.com/oapi-codegen/oapi-codegen/v2 version v2.5.0 DO NOT EDIT.
package sessions

import (
        "context"
        "encoding/json"
        "fmt"
        "net/http"

        "github.com/labstack/echo/v4"
        "github.com/oapi-codegen/runtime"
        strictecho "github.com/oapi-codegen/runtime/strictmiddleware/echo"
        openapi_types "github.com/oapi-codegen/runtime/types"
)

// ServerInterface represents all server handlers.
type ServerInterface interface {
        // Find many sessions
        // (GET /auth/sessions)
        FindManySessions(ctx echo.Context, params FindManySessionsParams) error
        // Delete a session
        // (DELETE /auth/sessions/{id})
        DeleteSession(ctx echo.Context, id openapi_types.UUID) error
        // Find a session
        // (GET /auth/sessions/{id})
        GetOneSession(ctx echo.Context, id openapi_types.UUID) error
        // Update Session
        // (PATCH /auth/sessions/{id})
        UpdateSession(ctx echo.Context, id openapi_types.UUID) error
}

// ServerInterfaceWrapper converts echo contexts to parameters.
type ServerInterfaceWrapper struct {
        Handler ServerInterface
}

// FindManySessions converts echo context to params.
func (w *ServerInterfaceWrapper) FindManySessions(ctx echo.Context) error <span class="cov0" title="0">{
        var err error

        ctx.Set(BearerAuthScopes, []string{})

        // Parameter object where we will unmarshal all parameters from the context
        var params FindManySessionsParams
        // ------------- Optional query parameter "filter" -------------

        err = runtime.BindQueryParameter("deepObject", true, false, "filter", ctx.QueryParams(), &amp;params.Filter)
        if err != nil </span><span class="cov0" title="0">{
                return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter filter: %s", err))
        }</span>

        // ------------- Optional query parameter "page" -------------

        <span class="cov0" title="0">err = runtime.BindQueryParameter("form", true, false, "page", ctx.QueryParams(), &amp;params.Page)
        if err != nil </span><span class="cov0" title="0">{
                return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter page: %s", err))
        }</span>

        // ------------- Optional query parameter "sort" -------------

        <span class="cov0" title="0">err = runtime.BindQueryParameter("form", true, false, "sort", ctx.QueryParams(), &amp;params.Sort)
        if err != nil </span><span class="cov0" title="0">{
                return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter sort: %s", err))
        }</span>

        // Invoke the callback with all the unmarshaled arguments
        <span class="cov0" title="0">err = w.Handler.FindManySessions(ctx, params)
        return err</span>
}

// DeleteSession converts echo context to params.
func (w *ServerInterfaceWrapper) DeleteSession(ctx echo.Context) error <span class="cov0" title="0">{
        var err error
        // ------------- Path parameter "id" -------------
        var id openapi_types.UUID

        err = runtime.BindStyledParameterWithOptions("simple", "id", ctx.Param("id"), &amp;id, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
        if err != nil </span><span class="cov0" title="0">{
                return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter id: %s", err))
        }</span>

        <span class="cov0" title="0">ctx.Set(BearerAuthScopes, []string{})

        // Invoke the callback with all the unmarshaled arguments
        err = w.Handler.DeleteSession(ctx, id)
        return err</span>
}

// GetOneSession converts echo context to params.
func (w *ServerInterfaceWrapper) GetOneSession(ctx echo.Context) error <span class="cov0" title="0">{
        var err error
        // ------------- Path parameter "id" -------------
        var id openapi_types.UUID

        err = runtime.BindStyledParameterWithOptions("simple", "id", ctx.Param("id"), &amp;id, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
        if err != nil </span><span class="cov0" title="0">{
                return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter id: %s", err))
        }</span>

        <span class="cov0" title="0">ctx.Set(BearerAuthScopes, []string{})

        // Invoke the callback with all the unmarshaled arguments
        err = w.Handler.GetOneSession(ctx, id)
        return err</span>
}

// UpdateSession converts echo context to params.
func (w *ServerInterfaceWrapper) UpdateSession(ctx echo.Context) error <span class="cov0" title="0">{
        var err error
        // ------------- Path parameter "id" -------------
        var id openapi_types.UUID

        err = runtime.BindStyledParameterWithOptions("simple", "id", ctx.Param("id"), &amp;id, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
        if err != nil </span><span class="cov0" title="0">{
                return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter id: %s", err))
        }</span>

        <span class="cov0" title="0">ctx.Set(BearerAuthScopes, []string{})

        ctx.Set(SessionCookieScopes, []string{})

        // Invoke the callback with all the unmarshaled arguments
        err = w.Handler.UpdateSession(ctx, id)
        return err</span>
}

// This is a simple interface which specifies echo.Route addition functions which
// are present on both echo.Echo and echo.Group, since we want to allow using
// either of them for path registration
type EchoRouter interface {
        CONNECT(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
        DELETE(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
        GET(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
        HEAD(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
        OPTIONS(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
        PATCH(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
        POST(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
        PUT(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
        TRACE(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
}

// RegisterHandlers adds each server route to the EchoRouter.
func RegisterHandlers(router EchoRouter, si ServerInterface) <span class="cov0" title="0">{
        RegisterHandlersWithBaseURL(router, si, "")
}</span>

// Registers handlers, and prepends BaseURL to the paths, so that the paths
// can be served under a prefix.
func RegisterHandlersWithBaseURL(router EchoRouter, si ServerInterface, baseURL string) <span class="cov0" title="0">{

        wrapper := ServerInterfaceWrapper{
                Handler: si,
        }

        router.GET(baseURL+"/auth/sessions", wrapper.FindManySessions)
        router.DELETE(baseURL+"/auth/sessions/:id", wrapper.DeleteSession)
        router.GET(baseURL+"/auth/sessions/:id", wrapper.GetOneSession)
        router.PATCH(baseURL+"/auth/sessions/:id", wrapper.UpdateSession)

}</span>

type BadRequestApplicationProblemPlusJSONResponse Problem

type NotFoundApplicationProblemPlusJSONResponse Problem

type UnauthorizedApplicationProblemPlusJSONResponse Problem

type FindManySessionsRequestObject struct {
        Params FindManySessionsParams
}

type FindManySessionsResponseObject interface {
        VisitFindManySessionsResponse(w http.ResponseWriter) error
}

type FindManySessions200JSONResponse struct {
        Data []Session `json:"data"`
        Meta struct {
                // Total Total number of items in the collection
                Total float32 `json:"total"`
        } `json:"meta"`
}

func (response FindManySessions200JSONResponse) VisitFindManySessionsResponse(w http.ResponseWriter) error <span class="cov0" title="0">{
        w.Header().Set("Content-Type", "application/json")
        w.WriteHeader(200)

        return json.NewEncoder(w).Encode(response)
}</span>

type FindManySessions400ApplicationProblemPlusJSONResponse struct {
        BadRequestApplicationProblemPlusJSONResponse
}

func (response FindManySessions400ApplicationProblemPlusJSONResponse) VisitFindManySessionsResponse(w http.ResponseWriter) error <span class="cov0" title="0">{
        w.Header().Set("Content-Type", "application/problem+json")
        w.WriteHeader(400)

        return json.NewEncoder(w).Encode(response)
}</span>

type FindManySessions401ApplicationProblemPlusJSONResponse struct {
        UnauthorizedApplicationProblemPlusJSONResponse
}

func (response FindManySessions401ApplicationProblemPlusJSONResponse) VisitFindManySessionsResponse(w http.ResponseWriter) error <span class="cov0" title="0">{
        w.Header().Set("Content-Type", "application/problem+json")
        w.WriteHeader(401)

        return json.NewEncoder(w).Encode(response)
}</span>

type DeleteSessionRequestObject struct {
        Id openapi_types.UUID `json:"id"`
}

type DeleteSessionResponseObject interface {
        VisitDeleteSessionResponse(w http.ResponseWriter) error
}

type DeleteSession200JSONResponse struct {
        // Data Schema for Session entity
        Data Session `json:"data"`
}

func (response DeleteSession200JSONResponse) VisitDeleteSessionResponse(w http.ResponseWriter) error <span class="cov0" title="0">{
        w.Header().Set("Content-Type", "application/json")
        w.WriteHeader(200)

        return json.NewEncoder(w).Encode(response)
}</span>

type DeleteSession404ApplicationProblemPlusJSONResponse struct {
        NotFoundApplicationProblemPlusJSONResponse
}

func (response DeleteSession404ApplicationProblemPlusJSONResponse) VisitDeleteSessionResponse(w http.ResponseWriter) error <span class="cov0" title="0">{
        w.Header().Set("Content-Type", "application/problem+json")
        w.WriteHeader(404)

        return json.NewEncoder(w).Encode(response)
}</span>

type GetOneSessionRequestObject struct {
        Id openapi_types.UUID `json:"id"`
}

type GetOneSessionResponseObject interface {
        VisitGetOneSessionResponse(w http.ResponseWriter) error
}

type GetOneSession200JSONResponse struct {
        // Data Schema for Session entity
        Data Session `json:"data"`
}

func (response GetOneSession200JSONResponse) VisitGetOneSessionResponse(w http.ResponseWriter) error <span class="cov0" title="0">{
        w.Header().Set("Content-Type", "application/json")
        w.WriteHeader(200)

        return json.NewEncoder(w).Encode(response)
}</span>

type GetOneSession404ApplicationProblemPlusJSONResponse struct {
        NotFoundApplicationProblemPlusJSONResponse
}

func (response GetOneSession404ApplicationProblemPlusJSONResponse) VisitGetOneSessionResponse(w http.ResponseWriter) error <span class="cov0" title="0">{
        w.Header().Set("Content-Type", "application/problem+json")
        w.WriteHeader(404)

        return json.NewEncoder(w).Encode(response)
}</span>

type UpdateSessionRequestObject struct {
        Id   openapi_types.UUID `json:"id"`
        Body *UpdateSessionJSONRequestBody
}

type UpdateSessionResponseObject interface {
        VisitUpdateSessionResponse(w http.ResponseWriter) error
}

type UpdateSession200JSONResponse struct {
        // Data Schema for Session entity
        Data Session `json:"data"`
}

func (response UpdateSession200JSONResponse) VisitUpdateSessionResponse(w http.ResponseWriter) error <span class="cov0" title="0">{
        w.Header().Set("Content-Type", "application/json")
        w.WriteHeader(200)

        return json.NewEncoder(w).Encode(response)
}</span>

type UpdateSession401ApplicationProblemPlusJSONResponse struct {
        UnauthorizedApplicationProblemPlusJSONResponse
}

func (response UpdateSession401ApplicationProblemPlusJSONResponse) VisitUpdateSessionResponse(w http.ResponseWriter) error <span class="cov0" title="0">{
        w.Header().Set("Content-Type", "application/problem+json")
        w.WriteHeader(401)

        return json.NewEncoder(w).Encode(response)
}</span>

// StrictServerInterface represents all server handlers.
type StrictServerInterface interface {
        // Find many sessions
        // (GET /auth/sessions)
        FindManySessions(ctx context.Context, request FindManySessionsRequestObject) (FindManySessionsResponseObject, error)
        // Delete a session
        // (DELETE /auth/sessions/{id})
        DeleteSession(ctx context.Context, request DeleteSessionRequestObject) (DeleteSessionResponseObject, error)
        // Find a session
        // (GET /auth/sessions/{id})
        GetOneSession(ctx context.Context, request GetOneSessionRequestObject) (GetOneSessionResponseObject, error)
        // Update Session
        // (PATCH /auth/sessions/{id})
        UpdateSession(ctx context.Context, request UpdateSessionRequestObject) (UpdateSessionResponseObject, error)
}

type StrictHandlerFunc = strictecho.StrictEchoHandlerFunc
type StrictMiddlewareFunc = strictecho.StrictEchoMiddlewareFunc

func NewStrictHandler(ssi StrictServerInterface, middlewares []StrictMiddlewareFunc) ServerInterface <span class="cov0" title="0">{
        return &amp;strictHandler{ssi: ssi, middlewares: middlewares}
}</span>

type strictHandler struct {
        ssi         StrictServerInterface
        middlewares []StrictMiddlewareFunc
}

// FindManySessions operation middleware
func (sh *strictHandler) FindManySessions(ctx echo.Context, params FindManySessionsParams) error <span class="cov0" title="0">{
        var request FindManySessionsRequestObject

        request.Params = params

        handler := func(ctx echo.Context, request interface{}) (interface{}, error) </span><span class="cov0" title="0">{
                return sh.ssi.FindManySessions(ctx.Request().Context(), request.(FindManySessionsRequestObject))
        }</span>
        <span class="cov0" title="0">for _, middleware := range sh.middlewares </span><span class="cov0" title="0">{
                handler = middleware(handler, "FindManySessions")
        }</span>

        <span class="cov0" title="0">response, err := handler(ctx, request)

        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span> else<span class="cov0" title="0"> if validResponse, ok := response.(FindManySessionsResponseObject); ok </span><span class="cov0" title="0">{
                return validResponse.VisitFindManySessionsResponse(ctx.Response())
        }</span> else<span class="cov0" title="0"> if response != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("unexpected response type: %T", response)
        }</span>
        <span class="cov0" title="0">return nil</span>
}

// DeleteSession operation middleware
func (sh *strictHandler) DeleteSession(ctx echo.Context, id openapi_types.UUID) error <span class="cov0" title="0">{
        var request DeleteSessionRequestObject

        request.Id = id

        handler := func(ctx echo.Context, request interface{}) (interface{}, error) </span><span class="cov0" title="0">{
                return sh.ssi.DeleteSession(ctx.Request().Context(), request.(DeleteSessionRequestObject))
        }</span>
        <span class="cov0" title="0">for _, middleware := range sh.middlewares </span><span class="cov0" title="0">{
                handler = middleware(handler, "DeleteSession")
        }</span>

        <span class="cov0" title="0">response, err := handler(ctx, request)

        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span> else<span class="cov0" title="0"> if validResponse, ok := response.(DeleteSessionResponseObject); ok </span><span class="cov0" title="0">{
                return validResponse.VisitDeleteSessionResponse(ctx.Response())
        }</span> else<span class="cov0" title="0"> if response != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("unexpected response type: %T", response)
        }</span>
        <span class="cov0" title="0">return nil</span>
}

// GetOneSession operation middleware
func (sh *strictHandler) GetOneSession(ctx echo.Context, id openapi_types.UUID) error <span class="cov0" title="0">{
        var request GetOneSessionRequestObject

        request.Id = id

        handler := func(ctx echo.Context, request interface{}) (interface{}, error) </span><span class="cov0" title="0">{
                return sh.ssi.GetOneSession(ctx.Request().Context(), request.(GetOneSessionRequestObject))
        }</span>
        <span class="cov0" title="0">for _, middleware := range sh.middlewares </span><span class="cov0" title="0">{
                handler = middleware(handler, "GetOneSession")
        }</span>

        <span class="cov0" title="0">response, err := handler(ctx, request)

        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span> else<span class="cov0" title="0"> if validResponse, ok := response.(GetOneSessionResponseObject); ok </span><span class="cov0" title="0">{
                return validResponse.VisitGetOneSessionResponse(ctx.Response())
        }</span> else<span class="cov0" title="0"> if response != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("unexpected response type: %T", response)
        }</span>
        <span class="cov0" title="0">return nil</span>
}

// UpdateSession operation middleware
func (sh *strictHandler) UpdateSession(ctx echo.Context, id openapi_types.UUID) error <span class="cov0" title="0">{
        var request UpdateSessionRequestObject

        request.Id = id

        var body UpdateSessionJSONRequestBody
        if err := ctx.Bind(&amp;body); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov0" title="0">request.Body = &amp;body

        handler := func(ctx echo.Context, request interface{}) (interface{}, error) </span><span class="cov0" title="0">{
                return sh.ssi.UpdateSession(ctx.Request().Context(), request.(UpdateSessionRequestObject))
        }</span>
        <span class="cov0" title="0">for _, middleware := range sh.middlewares </span><span class="cov0" title="0">{
                handler = middleware(handler, "UpdateSession")
        }</span>

        <span class="cov0" title="0">response, err := handler(ctx, request)

        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span> else<span class="cov0" title="0"> if validResponse, ok := response.(UpdateSessionResponseObject); ok </span><span class="cov0" title="0">{
                return validResponse.VisitUpdateSessionResponse(ctx.Response())
        }</span> else<span class="cov0" title="0"> if response != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("unexpected response type: %T", response)
        }</span>
        <span class="cov0" title="0">return nil</span>
}
</pre>
		
		<pre class="file" id="file145" style="display: none">// Code generated by codegen repository. DO NOT EDIT.
package sessions

import (
        "context"
        "errors"

        "github.com/archesai/archesai/internal/database/postgresql"
        "github.com/google/uuid"
        "github.com/jackc/pgx/v5/pgxpool"
)

// PostgresRepository implements Repository using PostgreSQL.
type PostgresRepository struct {
        db      *pgxpool.Pool
        queries *postgresql.Queries
}

// NewPostgresRepository creates a new PostgreSQL repository.
func NewPostgresRepository(db *pgxpool.Pool) Repository <span class="cov0" title="0">{
        return &amp;PostgresRepository{
                db:      db,
                queries: postgresql.New(db),
        }
}</span>

// Session operations

func (r *PostgresRepository) Create(ctx context.Context, entity *Session) (*Session, error) <span class="cov0" title="0">{
        // Check if SQLC has the CreateSession method
        // For now, we'll generate a stub but with proper error handling
        // TODO: Parse SQLC to detect available queries

        // Example of what it should look like when SQLC query exists:
        // params := postgresql.CreateSessionParams{
        //     Id: entity.Id,
        //     // ... map other fields
        // }
        // dbSession, err := r.queries.CreateSession(ctx, params)
        // if err != nil {
        //     return nil, NewRepositoryError("create", err)
        // }
        // return mapSessionToDomain(&amp;dbSession), nil

        return nil, NewRepositoryError("create", errors.New("not implemented - SQLC query not found"))
}</span>

func (r *PostgresRepository) Get(ctx context.Context, id uuid.UUID) (*Session, error) <span class="cov0" title="0">{
        // Try to call SQLC GetSession if it exists
        // For now, return not implemented
        return nil, NewRepositoryError("get", errors.New("not implemented - SQLC query not found"))
}</span>

func (r *PostgresRepository) Update(ctx context.Context, id uuid.UUID, entity *Session) (*Session, error) <span class="cov0" title="0">{
        // Update operations are often custom and may not have SQLC queries
        return nil, NewRepositoryError("update", errors.New("not implemented - SQLC query not found"))
}</span>

func (r *PostgresRepository) Delete(ctx context.Context, id uuid.UUID) error <span class="cov0" title="0">{
        // Try to call SQLC DeleteSession if it exists
        // For now, return not implemented
        return NewRepositoryError("delete", errors.New("not implemented - SQLC query not found"))
}</span>

func (r *PostgresRepository) List(ctx context.Context, params ListSessionsParams) ([]*Session, int64, error) <span class="cov0" title="0">{
        // List operations need both List and Count queries from SQLC
        return nil, 0, NewRepositoryError("list", errors.New("not implemented - SQLC query not found"))
}</span>

// GetByToken retrieves session by token
func (r *PostgresRepository) GetByToken(ctx context.Context, token string) (*Session, error) <span class="cov0" title="0">{

        // Try to call SQLC GetByToken if it exists
        // For now, return not implemented
        return nil, NewRepositoryError("getbytoken", errors.New("not implemented - SQLC query not found"))

}</span>

// DeleteByToken deletes session by token
func (r *PostgresRepository) DeleteByToken(ctx context.Context, token string) error <span class="cov0" title="0">{

        // Try to call SQLC DeleteByToken if it exists
        // For now, return not implemented
        return NewRepositoryError("deletebytoken", errors.New("not implemented - SQLC query not found"))

}</span>

// DeleteByUser deletes session by userId
func (r *PostgresRepository) DeleteByUser(ctx context.Context, userId uuid.UUID) error <span class="cov0" title="0">{

        // Try to call SQLC DeleteByUser if it exists
        // For now, return not implemented
        return NewRepositoryError("deletebyuser", errors.New("not implemented - SQLC query not found"))

}</span>

// DeleteExpired deletes session by
func (r *PostgresRepository) DeleteExpired(ctx context.Context) error <span class="cov0" title="0">{

        // Try to call SQLC DeleteExpired if it exists
        // For now, return not implemented
        return NewRepositoryError("deleteexpired", errors.New("not implemented - SQLC query not found"))

}</span>

// Mapper functions - Convert between domain types and database types
// These need to be customized based on the actual field mappings

func mapSessionToDomain(db *postgresql.Session) *Session <span class="cov0" title="0">{
        if db == nil </span><span class="cov0" title="0">{
                return nil
        }</span>

        // This is a basic mapping - needs to be customized based on actual types
        // The challenge is that OpenAPI types and database types don't always match
        // For example:
        // - OpenAPI might use string, database uses *string
        // - OpenAPI might use custom UUID type, database uses uuid.UUID
        // - Field names might differ (Id vs ID)

        <span class="cov0" title="0">result := &amp;Session{
                // TODO: Map fields properly based on actual type definitions
                // This requires parsing both OpenAPI types and SQLC types
        }

        // Basic field mapping - customize based on your entity structure
        // result.Id = db.Id
        // result.CreatedAt = db.CreatedAt
        // result.UpdatedAt = db.UpdatedAt
        // Add specific field mappings as needed

        return result</span>
}
</pre>
		
		<pre class="file" id="file146" style="display: none">// Code generated by codegen repository. DO NOT EDIT.
package sessions

import (
        "context"
        "fmt"
        "github.com/google/uuid"
)

// Repository handles session persistence
type Repository interface {
        Create(ctx context.Context, entity *Session) (*Session, error)
        Get(ctx context.Context, id uuid.UUID) (*Session, error)
        Update(ctx context.Context, id uuid.UUID, entity *Session) (*Session, error)
        Delete(ctx context.Context, id uuid.UUID) error
        List(ctx context.Context, params ListSessionsParams) ([]*Session, int64, error)

        // Additional operations
        GetByToken(ctx context.Context, token string) (*Session, error)
        DeleteByToken(ctx context.Context, token string) error
        DeleteByUser(ctx context.Context, userId uuid.UUID) error
        DeleteExpired(ctx context.Context) error
}

// ListSessionsParams represents parameters for listing sessions.
type ListSessionsParams struct {
        Limit  int
        Offset int

        UserID *string
}

// RepositoryError represents a repository error.
type RepositoryError struct {
        Operation string
        Err       error
}

func (e *RepositoryError) Error() string <span class="cov0" title="0">{
        return fmt.Sprintf("repository %s: %v", e.Operation, e.Err)
}</span>

func (e *RepositoryError) Unwrap() error <span class="cov0" title="0">{
        return e.Err
}</span>

// NewRepositoryError creates a new repository error.
func NewRepositoryError(operation string, err error) *RepositoryError <span class="cov0" title="0">{
        return &amp;RepositoryError{
                Operation: operation,
                Err:       err,
        }
}</span>
</pre>
		
		<pre class="file" id="file147" style="display: none">package sessions

import (
        "log/slog"
)

// Service provides session business logic
type Service struct {
        repo           Repository
        cache          Cache
        sessionManager *SessionManager
        logger         *slog.Logger
}

// NewService creates a new session service
func NewService(repo Repository, cache Cache, logger *slog.Logger) *Service <span class="cov10" title="14">{
        sessionManager := NewSessionManager(repo, cache, 0) // Use default TTL
        return &amp;Service{
                repo:           repo,
                cache:          cache,
                sessionManager: sessionManager,
                logger:         logger,
        }
}</span>
</pre>
		
		<pre class="file" id="file148" style="display: none">package sessions

import (
        "context"
        "fmt"
        "time"

        "github.com/google/uuid"
)

// RevokeSession revokes a specific session
func (s *Service) RevokeSession(ctx context.Context, sessionID uuid.UUID) error <span class="cov5" title="2">{
        return s.repo.Delete(ctx, sessionID)
}</span>

// CleanupExpiredSessions removes all expired sessions
func (s *Service) CleanupExpiredSessions(ctx context.Context) error <span class="cov5" title="2">{
        // Use SessionManager if available
        if s.sessionManager != nil </span><span class="cov5" title="2">{
                return s.sessionManager.CleanupExpiredSessions(ctx)
        }</span>

        // Fallback to direct repository
        <span class="cov0" title="0">return s.repo.DeleteExpired(ctx)</span>
}

// ValidateSession validates a session token
func (s *Service) ValidateSession(ctx context.Context, token string) (*Session, error) <span class="cov10" title="4">{
        // Use SessionManager if available
        if s.sessionManager != nil </span><span class="cov10" title="4">{
                return s.sessionManager.ValidateSession(ctx, token)
        }</span>

        // Fallback to direct repository
        <span class="cov0" title="0">session, err := s.repo.GetByToken(ctx, token)
        if err != nil </span><span class="cov0" title="0">{
                return nil, ErrSessionNotFound
        }</span>

        // Check if session is expired
        <span class="cov0" title="0">if session.ExpiresAt != "" </span><span class="cov0" title="0">{
                expiresAt, err := time.Parse(time.RFC3339, session.ExpiresAt)
                if err == nil &amp;&amp; time.Now().After(expiresAt) </span><span class="cov0" title="0">{
                        return nil, ErrSessionExpired
                }</span>
        }

        <span class="cov0" title="0">return session, nil</span>
}

// DeleteUserSessions deletes all sessions for a user
func (s *Service) DeleteUserSessions(ctx context.Context, userID uuid.UUID) error <span class="cov1" title="1">{
        // Use SessionManager if available
        if s.sessionManager != nil </span><span class="cov1" title="1">{
                return s.sessionManager.DeleteByUser(ctx, userID)
        }</span>

        // Fallback to direct repository
        <span class="cov0" title="0">return s.repo.DeleteByUser(ctx, userID)</span>
}

// ListUserSessions lists all sessions for a user
func (s *Service) ListUserSessions(ctx context.Context, userID uuid.UUID) ([]*Session, error) <span class="cov8" title="3">{
        // Use SessionManager if available
        if s.sessionManager != nil </span><span class="cov8" title="3">{
                return s.sessionManager.ListUserSessions(ctx, userID)
        }</span>

        // Fallback to direct repository
        <span class="cov0" title="0">userIDStr := userID.String()
        sessions, _, err := s.repo.List(ctx, ListSessionsParams{
                UserID: &amp;userIDStr,
                Limit:  100,
        })
        if err != nil </span><span class="cov0" title="0">{
                s.logger.Error("failed to list user sessions", "user_id", userID, "error", err)
                return nil, fmt.Errorf("failed to list sessions: %w", err)
        }</span>

        // Filter out expired sessions
        <span class="cov0" title="0">var activeSessions []*Session
        now := time.Now()
        for _, session := range sessions </span><span class="cov0" title="0">{
                if session.ExpiresAt != "" </span><span class="cov0" title="0">{
                        expiresAt, err := time.Parse(time.RFC3339, session.ExpiresAt)
                        if err == nil &amp;&amp; now.After(expiresAt) </span><span class="cov0" title="0">{
                                // Skip expired session
                                continue</span>
                        }
                }
                <span class="cov0" title="0">activeSessions = append(activeSessions, session)</span>
        }

        <span class="cov0" title="0">return activeSessions, nil</span>
}
</pre>
		
		<pre class="file" id="file149" style="display: none">package sessions

import (
        "context"
        "crypto/rand"
        "encoding/base64"
        "fmt"
        "time"

        "github.com/google/uuid"
)

// SessionManager handles session operations with Redis caching
type SessionManager struct {
        repo  Repository
        cache Cache
        ttl   time.Duration
}

// NewSessionManager creates a new session manager
func NewSessionManager(repo Repository, cache Cache, ttl time.Duration) *SessionManager <span class="cov10" title="28">{
        if ttl == 0 </span><span class="cov8" title="14">{
                ttl = 30 * 24 * time.Hour // 30 days default
        }</span>
        <span class="cov10" title="28">return &amp;SessionManager{
                repo:  repo,
                cache: cache,
                ttl:   ttl,
        }</span>
}

// Create creates a new session and stores it in both database and Redis
func (sm *SessionManager) Create(ctx context.Context, userID, orgID uuid.UUID, ipAddress, userAgent string) (*Session, error) <span class="cov2" title="2">{
        // Generate secure session token
        token, err := generateSecureToken()
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("generate session token: %w", err)
        }</span>

        // Create session entity
        <span class="cov2" title="2">session := &amp;Session{
                Id:                   uuid.New(),
                UserId:               userID,
                Token:                token,
                ActiveOrganizationId: orgID,
                ExpiresAt:            time.Now().Add(sm.ttl).Format(time.RFC3339),
                IpAddress:            ipAddress,
                UserAgent:            userAgent,
                CreatedAt:            time.Now(),
                UpdatedAt:            time.Now(),
        }

        // Store in database first
        created, err := sm.repo.Create(ctx, session)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("create session in db: %w", err)
        }</span>

        // Store in Redis cache with TTL
        <span class="cov2" title="2">if sm.cache != nil </span><span class="cov1" title="1">{
                // Store by ID
                _ = sm.cache.Set(ctx, created, sm.ttl)

                // Note: Token-based cache lookup not supported by current cache interface

                // Store user session index for listing
                userSessionKey := fmt.Sprintf("user:%s:session:%s", userID.String(), created.Id.String())
                _ = sm.storeUserSessionIndex(ctx, userSessionKey, created.Id, sm.ttl)
        }</span>

        <span class="cov2" title="2">return created, nil</span>
}

// Get retrieves a session by ID, checking cache first
func (sm *SessionManager) Get(ctx context.Context, sessionID uuid.UUID) (*Session, error) <span class="cov5" title="6">{
        // Try cache first
        if sm.cache != nil </span><span class="cov5" title="5">{
                cached, err := sm.cache.Get(ctx, sessionID)
                if err == nil &amp;&amp; cached != nil </span><span class="cov0" title="0">{
                        // Validate expiry
                        if !sm.isSessionExpired(cached) </span><span class="cov0" title="0">{
                                return cached, nil
                        }</span>
                        // If expired, delete from cache
                        <span class="cov0" title="0">_ = sm.cache.Delete(ctx, sessionID)</span>
                }
        }

        // Fallback to database
        <span class="cov5" title="6">session, err := sm.repo.Get(ctx, sessionID)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        // Validate expiry
        <span class="cov5" title="6">if sm.isSessionExpired(session) </span><span class="cov1" title="1">{
                // Clean up expired session
                _ = sm.repo.Delete(ctx, sessionID)
                return nil, ErrSessionExpired
        }</span>

        // Update cache
        <span class="cov5" title="5">if sm.cache != nil &amp;&amp; session != nil </span><span class="cov4" title="4">{
                _ = sm.cache.Set(ctx, session, sm.ttl)
        }</span>

        <span class="cov5" title="5">return session, nil</span>
}

// GetSessionByToken retrieves a session by token, checking cache first
func (sm *SessionManager) GetSessionByToken(ctx context.Context, token string) (*Session, error) <span class="cov6" title="8">{
        // Cache doesn't support token-based lookup, use database directly
        session, err := sm.repo.GetByToken(ctx, token)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        // Validate expiry
        <span class="cov6" title="8">if sm.isSessionExpired(session) </span><span class="cov3" title="3">{
                // Clean up expired session
                _ = sm.repo.Delete(ctx, session.Id)
                return nil, ErrSessionExpired
        }</span>

        // Update cache by ID
        <span class="cov5" title="5">if sm.cache != nil &amp;&amp; session != nil </span><span class="cov5" title="5">{
                _ = sm.cache.Set(ctx, session, sm.ttl)
        }</span>

        <span class="cov5" title="5">return session, nil</span>
}

// Update updates session metadata (like last activity)
func (sm *SessionManager) Update(ctx context.Context, sessionID uuid.UUID, updates *Session) (*Session, error) <span class="cov4" title="4">{
        // Update in database
        updated, err := sm.repo.Update(ctx, sessionID, updates)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        // Update cache
        <span class="cov4" title="4">if sm.cache != nil &amp;&amp; updated != nil </span><span class="cov4" title="4">{
                _ = sm.cache.Set(ctx, updated, sm.ttl)
        }</span>

        <span class="cov4" title="4">return updated, nil</span>
}

// Delete removes a session from both database and cache
func (sm *SessionManager) Delete(ctx context.Context, sessionID uuid.UUID) error <span class="cov2" title="2">{
        // Get session first to get the token
        session, _ := sm.Get(ctx, sessionID)

        // Delete from database
        if err := sm.repo.Delete(ctx, sessionID); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        // Delete from cache
        <span class="cov2" title="2">if sm.cache != nil </span><span class="cov1" title="1">{
                _ = sm.cache.Delete(ctx, sessionID)
                if session != nil </span><span class="cov1" title="1">{
                        // Remove from user session index
                        userSessionKey := fmt.Sprintf("user:%s:session:%s", session.UserId.String(), sessionID.String())
                        _ = sm.removeUserSessionIndex(ctx, userSessionKey)
                }</span>
        }

        <span class="cov2" title="2">return nil</span>
}

// DeleteSessionByToken removes a session by token
func (sm *SessionManager) DeleteSessionByToken(ctx context.Context, token string) error <span class="cov0" title="0">{
        // Get session first
        session, err := sm.GetSessionByToken(ctx, token)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        // Delete by ID
        <span class="cov0" title="0">return sm.Delete(ctx, session.Id)</span>
}

// DeleteByUser removes all sessions for a user
func (sm *SessionManager) DeleteByUser(ctx context.Context, userID uuid.UUID) error <span class="cov2" title="2">{
        // Delete from database
        if err := sm.repo.DeleteByUser(ctx, userID); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        // Delete from cache
        <span class="cov2" title="2">if sm.cache != nil </span><span class="cov2" title="2">{
                _ = sm.cache.DeleteByUser(ctx, userID)
        }</span>

        <span class="cov2" title="2">return nil</span>
}

// ListUserSessions returns all active sessions for a user
func (sm *SessionManager) ListUserSessions(ctx context.Context, userID uuid.UUID) ([]*Session, error) <span class="cov4" title="4">{
        // For now, use database directly
        // In a future enhancement, we could maintain a session index in Redis
        userIDStr := userID.String()
        params := ListSessionsParams{
                UserID: &amp;userIDStr,
                Limit:  100,
        }
        sessions, _, err := sm.repo.List(ctx, params)
        if err != nil </span><span class="cov1" title="1">{
                return nil, err
        }</span>

        // Filter out expired sessions
        <span class="cov3" title="3">var activeSessions []*Session
        for _, session := range sessions </span><span class="cov5" title="6">{
                if !sm.isSessionExpired(session) </span><span class="cov5" title="5">{
                        activeSessions = append(activeSessions, session)
                }</span>
        }

        <span class="cov3" title="3">return activeSessions, nil</span>
}

// RefreshSession extends the expiry of a session
func (sm *SessionManager) RefreshSession(ctx context.Context, sessionID uuid.UUID) (*Session, error) <span class="cov1" title="1">{
        session, err := sm.Get(ctx, sessionID)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        // Update expiry
        <span class="cov1" title="1">newExpiry := time.Now().Add(sm.ttl)
        session.ExpiresAt = newExpiry.Format(time.RFC3339)
        session.UpdatedAt = time.Now()

        // Update in database
        updated, err := sm.repo.Update(ctx, sessionID, session)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        // Update cache with new TTL
        <span class="cov1" title="1">if sm.cache != nil &amp;&amp; updated != nil </span><span class="cov1" title="1">{
                _ = sm.cache.Set(ctx, updated, sm.ttl)
        }</span>

        <span class="cov1" title="1">return updated, nil</span>
}

// CleanupExpiredSessions removes all expired sessions
func (sm *SessionManager) CleanupExpiredSessions(ctx context.Context) error <span class="cov2" title="2">{
        return sm.repo.DeleteExpired(ctx)
}</span>

// ValidateSession checks if a session is valid and not expired
func (sm *SessionManager) ValidateSession(ctx context.Context, token string) (*Session, error) <span class="cov5" title="6">{
        session, err := sm.GetSessionByToken(ctx, token)
        if err != nil </span><span class="cov3" title="3">{
                return nil, err
        }</span>

        <span class="cov3" title="3">if sm.isSessionExpired(session) </span><span class="cov0" title="0">{
                _ = sm.Delete(ctx, session.Id)
                return nil, ErrSessionExpired
        }</span>

        // Update last activity by updating the UpdatedAt field
        <span class="cov3" title="3">session.UpdatedAt = time.Now()
        updated, err := sm.Update(ctx, session.Id, session)
        if err != nil </span><span class="cov0" title="0">{
                // Log error but don't fail validation
                return session, nil
        }</span>

        <span class="cov3" title="3">return updated, nil</span>
}

// Helper methods

func (sm *SessionManager) isSessionExpired(session *Session) bool <span class="cov9" title="23">{
        if session == nil </span><span class="cov0" title="0">{
                return true
        }</span>

        <span class="cov9" title="23">expiresAt, err := time.Parse(time.RFC3339, session.ExpiresAt)
        if err != nil </span><span class="cov0" title="0">{
                return true
        }</span>

        <span class="cov9" title="23">return time.Now().After(expiresAt)</span>
}

func (sm *SessionManager) storeUserSessionIndex(_ context.Context, _ string, _ uuid.UUID, _ time.Duration) error <span class="cov1" title="1">{
        // This would need a custom Redis implementation to maintain a set of session IDs per user
        // For now, we'll rely on the database for listing
        return nil
}</span>

func (sm *SessionManager) removeUserSessionIndex(_ context.Context, _ string) error <span class="cov1" title="1">{
        // This would need a custom Redis implementation
        return nil
}</span>

// generateSecureToken generates a cryptographically secure random token
func generateSecureToken() (string, error) <span class="cov2" title="2">{
        b := make([]byte, 32)
        if _, err := rand.Read(b); err != nil </span><span class="cov0" title="0">{
                return "", err
        }</span>
        <span class="cov2" title="2">return base64.URLEncoding.EncodeToString(b), nil</span>
}
</pre>
		
		<pre class="file" id="file150" style="display: none">// Code generated by codegen repository. DO NOT EDIT.
package sessions

import (
        "context"
        "database/sql"
        "fmt"

        "github.com/archesai/archesai/internal/database/sqlite"
        "github.com/google/uuid"
)

// SQLiteRepository implements Repository using SQLite.
type SQLiteRepository struct {
        db      *sql.DB
        queries *sqlite.Queries
}

// NewSQLiteRepository creates a new SQLite repository.
func NewSQLiteRepository(db *sql.DB) Repository <span class="cov0" title="0">{
        return &amp;SQLiteRepository{
                db:      db,
                queries: sqlite.New(db),
        }
}</span>

// Session operations

func (r *SQLiteRepository) Create(ctx context.Context, entity *Session) (*Session, error) <span class="cov0" title="0">{
        // For now, return a basic implementation
        // Actual implementation would need to be customized per entity
        return nil, fmt.Errorf("CreateSession not yet implemented - requires custom mapping")
}</span>

func (r *SQLiteRepository) Get(ctx context.Context, id uuid.UUID) (*Session, error) <span class="cov0" title="0">{
        // For now, return a basic implementation
        // Actual implementation would need to be customized per entity
        return nil, fmt.Errorf("GetSession not yet implemented - requires custom mapping")
}</span>

func (r *SQLiteRepository) Update(ctx context.Context, id uuid.UUID, entity *Session) (*Session, error) <span class="cov0" title="0">{
        // For now, return a basic implementation
        // Actual implementation would need to be customized per entity
        return nil, fmt.Errorf("UpdateSession not yet implemented - requires custom mapping")
}</span>

func (r *SQLiteRepository) Delete(ctx context.Context, id uuid.UUID) error <span class="cov0" title="0">{
        // For now, return a basic implementation
        // Actual implementation would need to be customized per entity
        return fmt.Errorf("DeleteSession not yet implemented - requires custom mapping")
}</span>

func (r *SQLiteRepository) List(ctx context.Context, params ListSessionsParams) ([]*Session, int64, error) <span class="cov0" title="0">{
        // For now, return a basic implementation
        // Actual implementation would need to be customized per entity
        return nil, 0, fmt.Errorf("ListSessions not yet implemented - requires custom mapping")
}</span>

// GetByToken retrieves session by token
func (r *SQLiteRepository) GetByToken(ctx context.Context, token string) (*Session, error) <span class="cov0" title="0">{

        // For now, return a basic implementation
        return nil, fmt.Errorf("GetByToken not yet implemented - requires custom mapping")

}</span>

// DeleteByToken deletes session by token
func (r *SQLiteRepository) DeleteByToken(ctx context.Context, token string) error <span class="cov0" title="0">{

        // For now, return a basic implementation
        return fmt.Errorf("DeleteByToken not yet implemented - requires custom mapping")

}</span>

// DeleteByUser deletes session by userId
func (r *SQLiteRepository) DeleteByUser(ctx context.Context, userId uuid.UUID) error <span class="cov0" title="0">{

        // For now, return a basic implementation
        return fmt.Errorf("DeleteByUser not yet implemented - requires custom mapping")

}</span>

// DeleteExpired deletes session by
func (r *SQLiteRepository) DeleteExpired(ctx context.Context) error <span class="cov0" title="0">{

        // For now, return a basic implementation
        return fmt.Errorf("DeleteExpired not yet implemented - requires custom mapping")

}</span>
</pre>
		
		<pre class="file" id="file151" style="display: none">// Package sessions provides primitives to interact with the openapi HTTP API.
//
// Code generated by github.com/oapi-codegen/oapi-codegen/v2 version v2.5.0 DO NOT EDIT.
package sessions

import (
        "encoding/json"
        "time"

        "github.com/oapi-codegen/runtime"
        openapi_types "github.com/oapi-codegen/runtime/types"
)

const (
        BearerAuthScopes    = "bearerAuth.Scopes"
        SessionCookieScopes = "sessionCookie.Scopes"
)

// Defines values for FindManySessionsParamsSortField.
const (
        ActiveOrganizationId FindManySessionsParamsSortField = "activeOrganizationId"
        CreatedAt            FindManySessionsParamsSortField = "createdAt"
        ExpiresAt            FindManySessionsParamsSortField = "expiresAt"
        Id                   FindManySessionsParamsSortField = "id"
        IpAddress            FindManySessionsParamsSortField = "ipAddress"
        Token                FindManySessionsParamsSortField = "token"
        UpdatedAt            FindManySessionsParamsSortField = "updatedAt"
        UserAgent            FindManySessionsParamsSortField = "userAgent"
        UserId               FindManySessionsParamsSortField = "userId"
)

// Defines values for FindManySessionsParamsSortOrder.
const (
        Asc  FindManySessionsParamsSortOrder = "asc"
        Desc FindManySessionsParamsSortOrder = "desc"
)

// FilterNode A recursive filter node that can be a condition or group
type FilterNode = interface{}

// Page Pagination (page number &amp; size)
type Page struct {
        Number int `json:"number,omitempty,omitzero" yaml:"number,omitempty"`
        Size   int `json:"size,omitempty,omitzero" yaml:"size,omitempty"`
}

// Problem RFC 7807 (Problem Details) compliant error response
type Problem struct {
        // Detail Human-readable explanation specific to this occurrence
        Detail string `json:"detail" yaml:"detail"`

        // Errors Additional validation errors for specific fields
        Errors []ValidationError `json:"errors,omitempty,omitzero" yaml:"errors,omitempty"`

        // Instance URI identifying the specific occurrence
        Instance string `json:"instance,omitempty,omitzero" yaml:"instance,omitempty"`

        // Status HTTP status code
        Status int `json:"status" yaml:"status"`

        // Title Short, human-readable summary
        Title string `json:"title" yaml:"title"`

        // Type URI identifying the problem type
        Type string `json:"type" yaml:"type"`
}

// Session Schema for Session entity
type Session struct {
        // ActiveOrganizationId The active organization ID
        ActiveOrganizationId openapi_types.UUID `json:"activeOrganizationId" yaml:"activeOrganizationId"`

        // CreatedAt The date this item was created
        CreatedAt time.Time `json:"createdAt" yaml:"createdAt"`

        // ExpiresAt The expiration date of the session
        ExpiresAt string `json:"expiresAt" yaml:"expiresAt"`

        // Id The ID of the item
        Id openapi_types.UUID `json:"id" yaml:"id"`

        // IpAddress The IP address of the session
        IpAddress string `json:"ipAddress" yaml:"ipAddress"`

        // Token The session token
        Token string `json:"token" yaml:"token"`

        // UpdatedAt The date this item was last updated
        UpdatedAt time.Time `json:"updatedAt" yaml:"updatedAt"`

        // UserAgent The user agent of the session
        UserAgent string `json:"userAgent" yaml:"userAgent"`

        // UserId The ID of the user associated with the session
        UserId openapi_types.UUID `json:"userId" yaml:"userId"`
}

// ValidationError Individual field validation error
type ValidationError struct {
        // Field The field path that failed validation
        Field string `json:"field" yaml:"field"`

        // Message Human-readable error message
        Message string `json:"message" yaml:"message"`

        // Value The invalid value that was provided
        Value ValidationError_Value `json:"value,omitempty,omitzero" yaml:"value,omitempty"`
}

// ValidationErrorValue0 defines model for .
type ValidationErrorValue0 = string

// ValidationErrorValue1 defines model for .
type ValidationErrorValue1 = float32

// ValidationErrorValue2 defines model for .
type ValidationErrorValue2 = bool

// ValidationError_Value The invalid value that was provided
type ValidationError_Value struct {
        union json.RawMessage
}

// PageQuery Pagination (page number &amp; size)
type PageQuery = Page

// SessionsFilter A recursive filter node that can be a condition or group
type SessionsFilter = FilterNode

// SessionsSort defines model for SessionsSort.
type SessionsSort = []struct {
        Field string `json:"field" yaml:"field"`
        Order string `json:"order" yaml:"order"`
}

// BadRequest RFC 7807 (Problem Details) compliant error response
type BadRequest = Problem

// NotFound RFC 7807 (Problem Details) compliant error response
type NotFound = Problem

// Unauthorized RFC 7807 (Problem Details) compliant error response
type Unauthorized = Problem

// FindManySessionsParams defines parameters for FindManySessions.
type FindManySessionsParams struct {
        // Filter Filter sessions by field values. Supported fields:
        // - createdAt, id, updatedAt, activeOrganizationId, expiresAt
        // - ipAddress, token, userAgent, userId
        Filter SessionsFilter `json:"filter,omitempty,omitzero" yaml:"filter,omitempty"`

        // Page The page parameter
        Page PageQuery `form:"page,omitempty" json:"page,omitempty,omitzero" yaml:"page,omitempty"`

        // Sort The sort parameter
        Sort SessionsSort `form:"sort,omitempty" json:"sort,omitempty,omitzero" yaml:"sort,omitempty"`
}

// FindManySessionsParamsSortField defines parameters for FindManySessions.
type FindManySessionsParamsSortField string

// FindManySessionsParamsSortOrder defines parameters for FindManySessions.
type FindManySessionsParamsSortOrder string

// UpdateSessionJSONBody defines parameters for UpdateSession.
type UpdateSessionJSONBody struct {
        // ActiveOrganizationId The active organization ID
        ActiveOrganizationId string `json:"activeOrganizationId" yaml:"activeOrganizationId"`
}

// UpdateSessionJSONRequestBody defines body for UpdateSession for application/json ContentType.
type UpdateSessionJSONRequestBody UpdateSessionJSONBody

// AsValidationErrorValue0 returns the union data inside the ValidationError_Value as a ValidationErrorValue0
func (t ValidationError_Value) AsValidationErrorValue0() (ValidationErrorValue0, error) <span class="cov0" title="0">{
        var body ValidationErrorValue0
        err := json.Unmarshal(t.union, &amp;body)
        return body, err
}</span>

// FromValidationErrorValue0 overwrites any union data inside the ValidationError_Value as the provided ValidationErrorValue0
func (t *ValidationError_Value) FromValidationErrorValue0(v ValidationErrorValue0) error <span class="cov0" title="0">{
        b, err := json.Marshal(v)
        t.union = b
        return err
}</span>

// MergeValidationErrorValue0 performs a merge with any union data inside the ValidationError_Value, using the provided ValidationErrorValue0
func (t *ValidationError_Value) MergeValidationErrorValue0(v ValidationErrorValue0) error <span class="cov0" title="0">{
        b, err := json.Marshal(v)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov0" title="0">merged, err := runtime.JSONMerge(t.union, b)
        t.union = merged
        return err</span>
}

// AsValidationErrorValue1 returns the union data inside the ValidationError_Value as a ValidationErrorValue1
func (t ValidationError_Value) AsValidationErrorValue1() (ValidationErrorValue1, error) <span class="cov0" title="0">{
        var body ValidationErrorValue1
        err := json.Unmarshal(t.union, &amp;body)
        return body, err
}</span>

// FromValidationErrorValue1 overwrites any union data inside the ValidationError_Value as the provided ValidationErrorValue1
func (t *ValidationError_Value) FromValidationErrorValue1(v ValidationErrorValue1) error <span class="cov0" title="0">{
        b, err := json.Marshal(v)
        t.union = b
        return err
}</span>

// MergeValidationErrorValue1 performs a merge with any union data inside the ValidationError_Value, using the provided ValidationErrorValue1
func (t *ValidationError_Value) MergeValidationErrorValue1(v ValidationErrorValue1) error <span class="cov0" title="0">{
        b, err := json.Marshal(v)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov0" title="0">merged, err := runtime.JSONMerge(t.union, b)
        t.union = merged
        return err</span>
}

// AsValidationErrorValue2 returns the union data inside the ValidationError_Value as a ValidationErrorValue2
func (t ValidationError_Value) AsValidationErrorValue2() (ValidationErrorValue2, error) <span class="cov0" title="0">{
        var body ValidationErrorValue2
        err := json.Unmarshal(t.union, &amp;body)
        return body, err
}</span>

// FromValidationErrorValue2 overwrites any union data inside the ValidationError_Value as the provided ValidationErrorValue2
func (t *ValidationError_Value) FromValidationErrorValue2(v ValidationErrorValue2) error <span class="cov0" title="0">{
        b, err := json.Marshal(v)
        t.union = b
        return err
}</span>

// MergeValidationErrorValue2 performs a merge with any union data inside the ValidationError_Value, using the provided ValidationErrorValue2
func (t *ValidationError_Value) MergeValidationErrorValue2(v ValidationErrorValue2) error <span class="cov0" title="0">{
        b, err := json.Marshal(v)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov0" title="0">merged, err := runtime.JSONMerge(t.union, b)
        t.union = merged
        return err</span>
}

func (t ValidationError_Value) MarshalJSON() ([]byte, error) <span class="cov0" title="0">{
        b, err := t.union.MarshalJSON()
        return b, err
}</span>

func (t *ValidationError_Value) UnmarshalJSON(b []byte) error <span class="cov0" title="0">{
        err := t.union.UnmarshalJSON(b)
        return err
}</span>
</pre>
		
		<pre class="file" id="file152" style="display: none">// Package testutil provides testing utilities for integration tests
package testutil

import (
        "context"
        "database/sql"
        "fmt"
        "os"
        "path/filepath"
        "testing"
        "time"

        "github.com/jackc/pgx/v5/pgxpool"
        _ "github.com/jackc/pgx/v5/stdlib" // PostgreSQL driver for database/sql
        "github.com/pressly/goose/v3"
        "github.com/redis/go-redis/v9"
        "github.com/testcontainers/testcontainers-go"
        tcpostgres "github.com/testcontainers/testcontainers-go/modules/postgres"
        tcredis "github.com/testcontainers/testcontainers-go/modules/redis"
        "github.com/testcontainers/testcontainers-go/wait"
)

// PostgresContainer wraps a PostgreSQL test container
type PostgresContainer struct {
        container testcontainers.Container
        DSN       string
        Pool      *pgxpool.Pool
}

// StartPostgresContainer starts a PostgreSQL container for testing
func StartPostgresContainer(ctx context.Context, t *testing.T) *PostgresContainer <span class="cov0" title="0">{
        t.Helper()

        container, err := tcpostgres.Run(ctx,
                "pgvector/pgvector:pg16",
                tcpostgres.WithDatabase("testdb"),
                tcpostgres.WithUsername("testuser"),
                tcpostgres.WithPassword("testpass"),
                testcontainers.WithWaitStrategy(
                        wait.ForLog("database system is ready to accept connections").
                                WithOccurrence(2).
                                WithStartupTimeout(30*time.Second),
                ),
        )
        if err != nil </span><span class="cov0" title="0">{
                t.Fatalf("Failed to start PostgreSQL container: %v", err)
        }</span>

        <span class="cov0" title="0">host, err := container.Host(ctx)
        if err != nil </span><span class="cov0" title="0">{
                t.Fatalf("Failed to get container host: %v", err)
        }</span>

        <span class="cov0" title="0">port, err := container.MappedPort(ctx, "5432")
        if err != nil </span><span class="cov0" title="0">{
                t.Fatalf("Failed to get container port: %v", err)
        }</span>

        <span class="cov0" title="0">dsn := fmt.Sprintf("postgresql://testuser:testpass@%s:%s/testdb?sslmode=disable", host, port.Port())

        pool, err := pgxpool.New(ctx, dsn)
        if err != nil </span><span class="cov0" title="0">{
                t.Fatalf("Failed to connect to PostgreSQL: %v", err)
        }</span>

        <span class="cov0" title="0">pc := &amp;PostgresContainer{
                container: container,
                DSN:       dsn,
                Pool:      pool,
        }

        // Register cleanup
        t.Cleanup(func() </span><span class="cov0" title="0">{
                _ = pc.Stop(context.Background())
        }</span>)

        <span class="cov0" title="0">return pc</span>
}

// RunMigrations runs database migrations on the test database
func (pc *PostgresContainer) RunMigrations(migrationsPath string) error <span class="cov0" title="0">{
        db, err := sql.Open("pgx", pc.DSN)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to open database: %w", err)
        }</span>
        <span class="cov0" title="0">defer func() </span><span class="cov0" title="0">{ _ = db.Close() }</span>()

        // Set environment variables for PostgreSQL
        <span class="cov0" title="0">_ = os.Setenv("TIMESTAMP_TYPE", "TIMESTAMPTZ")
        _ = os.Setenv("TIMESTAMP_DEFAULT", "CURRENT_TIMESTAMP")
        _ = os.Setenv("REAL_TYPE", "DOUBLE PRECISION")

        // Set goose dialect
        if err := goose.SetDialect("postgres"); err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to set dialect: %w", err)
        }</span>

        // Run migrations
        <span class="cov0" title="0">if err := goose.Up(db, migrationsPath); err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to run migrations: %w", err)
        }</span>

        <span class="cov0" title="0">return nil</span>
}

// Stop stops the PostgreSQL container
func (pc *PostgresContainer) Stop(ctx context.Context) error <span class="cov0" title="0">{
        if pc.Pool != nil </span><span class="cov0" title="0">{
                pc.Pool.Close()
        }</span>
        <span class="cov0" title="0">if pc.container != nil </span><span class="cov0" title="0">{
                return pc.container.Terminate(ctx)
        }</span>
        <span class="cov0" title="0">return nil</span>
}

// RedisContainer wraps a Redis test container
type RedisContainer struct {
        container testcontainers.Container
        Client    *redis.Client
        Address   string
}

// StartRedisContainer starts a Redis container for testing
func StartRedisContainer(ctx context.Context, t *testing.T) *RedisContainer <span class="cov0" title="0">{
        t.Helper()

        container, err := tcredis.Run(ctx,
                "redis:7-alpine",
                tcredis.WithConfigFile(filepath.Join("testdata", "redis.conf")),
                testcontainers.WithWaitStrategy(
                        wait.ForLog("Ready to accept connections").
                                WithStartupTimeout(30*time.Second),
                ),
        )
        if err != nil </span><span class="cov0" title="0">{
                // Try without config file if it doesn't exist
                container, err = tcredis.Run(ctx,
                        "redis:7-alpine",
                        testcontainers.WithWaitStrategy(
                                wait.ForLog("Ready to accept connections").
                                        WithStartupTimeout(30*time.Second),
                        ),
                )
                if err != nil </span><span class="cov0" title="0">{
                        t.Fatalf("Failed to start Redis container: %v", err)
                }</span>
        }

        <span class="cov0" title="0">host, err := container.Host(ctx)
        if err != nil </span><span class="cov0" title="0">{
                t.Fatalf("Failed to get container host: %v", err)
        }</span>

        <span class="cov0" title="0">port, err := container.MappedPort(ctx, "6379")
        if err != nil </span><span class="cov0" title="0">{
                t.Fatalf("Failed to get container port: %v", err)
        }</span>

        <span class="cov0" title="0">address := fmt.Sprintf("%s:%s", host, port.Port())

        client := redis.NewClient(&amp;redis.Options{
                Addr: address,
        })

        // Test connection
        if err := client.Ping(ctx).Err(); err != nil </span><span class="cov0" title="0">{
                t.Fatalf("Failed to connect to Redis: %v", err)
        }</span>

        <span class="cov0" title="0">rc := &amp;RedisContainer{
                container: container,
                Client:    client,
                Address:   address,
        }

        // Register cleanup
        t.Cleanup(func() </span><span class="cov0" title="0">{
                _ = rc.Stop(context.Background())
        }</span>)

        <span class="cov0" title="0">return rc</span>
}

// Stop stops the Redis container
func (rc *RedisContainer) Stop(ctx context.Context) error <span class="cov0" title="0">{
        if rc.Client != nil </span><span class="cov0" title="0">{
                if err := rc.Client.Close(); err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>
        }
        <span class="cov0" title="0">if rc.container != nil </span><span class="cov0" title="0">{
                return rc.container.Terminate(ctx)
        }</span>
        <span class="cov0" title="0">return nil</span>
}
</pre>
		
		<pre class="file" id="file153" style="display: none">// Package tools provides HTTP handlers for tool operations
package tools

import (
        "context"
        "log/slog"
)

const (
        // Placeholder constants for development
        orgPlaceholder = "org-placeholder"
)

// Handler handles HTTP requests for tool operations
type Handler struct {
        service *Service
        logger  *slog.Logger
}

// NewHandler creates a new handler for tool operations
func NewHandler(service *Service, logger *slog.Logger) *Handler <span class="cov0" title="0">{
        return &amp;Handler{
                service: service,
                logger:  logger,
        }
}</span>

// FindManyTools retrieves tools (implements StrictServerInterface)
func (h *Handler) FindManyTools(ctx context.Context, req FindManyToolsRequestObject) (FindManyToolsResponseObject, error) <span class="cov0" title="0">{
        limit := 50
        offset := 0

        // Handle page-based pagination if provided
        if req.Params.Page.Number &gt; 0 &amp;&amp; req.Params.Page.Size &gt; 0 </span><span class="cov0" title="0">{
                limit = req.Params.Page.Size
                offset = (req.Params.Page.Number - 1) * req.Params.Page.Size
        }</span>

        // TODO: Get organization ID from context
        <span class="cov0" title="0">orgID := orgPlaceholder

        tools, total, err := h.service.List(ctx, orgID, limit, offset)
        if err != nil </span><span class="cov0" title="0">{
                h.logger.Error("failed to list tools", "error", err)
                return nil, err
        }</span>

        // Convert to API entities
        <span class="cov0" title="0">data := make([]Tool, len(tools))
        for i, tool := range tools </span><span class="cov0" title="0">{
                data[i] = *tool
        }</span>

        <span class="cov0" title="0">totalFloat32 := float32(total)
        return FindManyTools200JSONResponse{
                Data: data,
                Meta: struct {
                        Total float32 `json:"total"`
                }{
                        Total: totalFloat32,
                },
        }, nil</span>
}

// CreateTool creates a new tool (implements StrictServerInterface)
func (h *Handler) CreateTool(ctx context.Context, req CreateToolRequestObject) (CreateToolResponseObject, error) <span class="cov0" title="0">{
        // TODO: Get organization ID from context
        orgID := orgPlaceholder

        tool, err := h.service.Create(ctx, req.Body, orgID)
        if err != nil </span><span class="cov0" title="0">{
                h.logger.Error("failed to create tool", "error", err)
                return CreateTool400ApplicationProblemPlusJSONResponse{
                        BadRequestApplicationProblemPlusJSONResponse: BadRequestApplicationProblemPlusJSONResponse{
                                Detail: "Failed to create tool",
                                Status: 400,
                                Title:  "Bad Request",
                        },
                }, nil
        }</span>

        <span class="cov0" title="0">return CreateTool201JSONResponse{
                Data: *tool,
        }, nil</span>
}

// GetOneTool retrieves a tool by ID (implements StrictServerInterface)
func (h *Handler) GetOneTool(ctx context.Context, req GetOneToolRequestObject) (GetOneToolResponseObject, error) <span class="cov0" title="0">{
        tool, err := h.service.Get(ctx, req.Id)
        if err != nil </span><span class="cov0" title="0">{
                if err == ErrToolNotFound </span><span class="cov0" title="0">{
                        return GetOneTool404ApplicationProblemPlusJSONResponse{
                                NotFoundApplicationProblemPlusJSONResponse: NotFoundApplicationProblemPlusJSONResponse{
                                        Detail: "Tool not found",
                                        Status: 404,
                                        Title:  "Tool not found",
                                },
                        }, nil
                }</span>
                <span class="cov0" title="0">h.logger.Error("failed to get tool", "error", err)
                return nil, err</span>
        }

        <span class="cov0" title="0">return GetOneTool200JSONResponse{
                Data: *tool,
        }, nil</span>
}

// UpdateTool updates a tool (implements StrictServerInterface)
func (h *Handler) UpdateTool(ctx context.Context, req UpdateToolRequestObject) (UpdateToolResponseObject, error) <span class="cov0" title="0">{
        tool, err := h.service.Update(ctx, req.Id, req.Body)
        if err != nil </span><span class="cov0" title="0">{
                if err == ErrToolNotFound </span><span class="cov0" title="0">{
                        return UpdateTool404ApplicationProblemPlusJSONResponse{
                                NotFoundApplicationProblemPlusJSONResponse: NotFoundApplicationProblemPlusJSONResponse{
                                        Detail: "Tool not found",
                                        Status: 404,
                                        Title:  "Tool not found",
                                },
                        }, nil
                }</span>
                <span class="cov0" title="0">h.logger.Error("failed to update tool", "error", err)
                return nil, err</span>
        }

        <span class="cov0" title="0">return UpdateTool200JSONResponse{
                Data: *tool,
        }, nil</span>
}

// DeleteTool deletes a tool (implements StrictServerInterface)
func (h *Handler) DeleteTool(ctx context.Context, req DeleteToolRequestObject) (DeleteToolResponseObject, error) <span class="cov0" title="0">{
        err := h.service.Delete(ctx, req.Id)
        if err != nil </span><span class="cov0" title="0">{
                if err == ErrToolNotFound </span><span class="cov0" title="0">{
                        return DeleteTool404ApplicationProblemPlusJSONResponse{
                                NotFoundApplicationProblemPlusJSONResponse: NotFoundApplicationProblemPlusJSONResponse{
                                        Detail: "Tool not found",
                                        Status: 404,
                                        Title:  "Tool not found",
                                },
                        }, nil
                }</span>
                <span class="cov0" title="0">h.logger.Error("failed to delete tool", "error", err)
                return nil, err</span>
        }

        <span class="cov0" title="0">return DeleteTool200JSONResponse{}, nil</span>
}
</pre>
		
		<pre class="file" id="file154" style="display: none">// Package tools provides primitives to interact with the openapi HTTP API.
//
// Code generated by github.com/oapi-codegen/oapi-codegen/v2 version v2.5.0 DO NOT EDIT.
package tools

import (
        "context"
        "encoding/json"
        "fmt"
        "net/http"

        "github.com/labstack/echo/v4"
        "github.com/oapi-codegen/runtime"
        strictecho "github.com/oapi-codegen/runtime/strictmiddleware/echo"
        openapi_types "github.com/oapi-codegen/runtime/types"
)

// ServerInterface represents all server handlers.
type ServerInterface interface {
        // Find many tools
        // (GET /workflows/tools)
        FindManyTools(ctx echo.Context, params FindManyToolsParams) error
        // Create a new tool
        // (POST /workflows/tools)
        CreateTool(ctx echo.Context) error
        // Delete a tool
        // (DELETE /workflows/tools/{id})
        DeleteTool(ctx echo.Context, id openapi_types.UUID) error
        // Find a tool
        // (GET /workflows/tools/{id})
        GetOneTool(ctx echo.Context, id openapi_types.UUID) error
        // Update a tool
        // (PATCH /workflows/tools/{id})
        UpdateTool(ctx echo.Context, id openapi_types.UUID) error
}

// ServerInterfaceWrapper converts echo contexts to parameters.
type ServerInterfaceWrapper struct {
        Handler ServerInterface
}

// FindManyTools converts echo context to params.
func (w *ServerInterfaceWrapper) FindManyTools(ctx echo.Context) error <span class="cov0" title="0">{
        var err error

        ctx.Set(BearerAuthScopes, []string{})

        // Parameter object where we will unmarshal all parameters from the context
        var params FindManyToolsParams
        // ------------- Optional query parameter "filter" -------------

        err = runtime.BindQueryParameter("deepObject", true, false, "filter", ctx.QueryParams(), &amp;params.Filter)
        if err != nil </span><span class="cov0" title="0">{
                return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter filter: %s", err))
        }</span>

        // ------------- Optional query parameter "page" -------------

        <span class="cov0" title="0">err = runtime.BindQueryParameter("form", true, false, "page", ctx.QueryParams(), &amp;params.Page)
        if err != nil </span><span class="cov0" title="0">{
                return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter page: %s", err))
        }</span>

        // ------------- Optional query parameter "sort" -------------

        <span class="cov0" title="0">err = runtime.BindQueryParameter("form", true, false, "sort", ctx.QueryParams(), &amp;params.Sort)
        if err != nil </span><span class="cov0" title="0">{
                return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter sort: %s", err))
        }</span>

        // Invoke the callback with all the unmarshaled arguments
        <span class="cov0" title="0">err = w.Handler.FindManyTools(ctx, params)
        return err</span>
}

// CreateTool converts echo context to params.
func (w *ServerInterfaceWrapper) CreateTool(ctx echo.Context) error <span class="cov0" title="0">{
        var err error

        ctx.Set(BearerAuthScopes, []string{})

        // Invoke the callback with all the unmarshaled arguments
        err = w.Handler.CreateTool(ctx)
        return err
}</span>

// DeleteTool converts echo context to params.
func (w *ServerInterfaceWrapper) DeleteTool(ctx echo.Context) error <span class="cov0" title="0">{
        var err error
        // ------------- Path parameter "id" -------------
        var id openapi_types.UUID

        err = runtime.BindStyledParameterWithOptions("simple", "id", ctx.Param("id"), &amp;id, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
        if err != nil </span><span class="cov0" title="0">{
                return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter id: %s", err))
        }</span>

        <span class="cov0" title="0">ctx.Set(BearerAuthScopes, []string{})

        // Invoke the callback with all the unmarshaled arguments
        err = w.Handler.DeleteTool(ctx, id)
        return err</span>
}

// GetOneTool converts echo context to params.
func (w *ServerInterfaceWrapper) GetOneTool(ctx echo.Context) error <span class="cov0" title="0">{
        var err error
        // ------------- Path parameter "id" -------------
        var id openapi_types.UUID

        err = runtime.BindStyledParameterWithOptions("simple", "id", ctx.Param("id"), &amp;id, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
        if err != nil </span><span class="cov0" title="0">{
                return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter id: %s", err))
        }</span>

        <span class="cov0" title="0">ctx.Set(BearerAuthScopes, []string{})

        // Invoke the callback with all the unmarshaled arguments
        err = w.Handler.GetOneTool(ctx, id)
        return err</span>
}

// UpdateTool converts echo context to params.
func (w *ServerInterfaceWrapper) UpdateTool(ctx echo.Context) error <span class="cov0" title="0">{
        var err error
        // ------------- Path parameter "id" -------------
        var id openapi_types.UUID

        err = runtime.BindStyledParameterWithOptions("simple", "id", ctx.Param("id"), &amp;id, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
        if err != nil </span><span class="cov0" title="0">{
                return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter id: %s", err))
        }</span>

        <span class="cov0" title="0">ctx.Set(BearerAuthScopes, []string{})

        // Invoke the callback with all the unmarshaled arguments
        err = w.Handler.UpdateTool(ctx, id)
        return err</span>
}

// This is a simple interface which specifies echo.Route addition functions which
// are present on both echo.Echo and echo.Group, since we want to allow using
// either of them for path registration
type EchoRouter interface {
        CONNECT(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
        DELETE(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
        GET(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
        HEAD(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
        OPTIONS(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
        PATCH(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
        POST(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
        PUT(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
        TRACE(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
}

// RegisterHandlers adds each server route to the EchoRouter.
func RegisterHandlers(router EchoRouter, si ServerInterface) <span class="cov0" title="0">{
        RegisterHandlersWithBaseURL(router, si, "")
}</span>

// Registers handlers, and prepends BaseURL to the paths, so that the paths
// can be served under a prefix.
func RegisterHandlersWithBaseURL(router EchoRouter, si ServerInterface, baseURL string) <span class="cov0" title="0">{

        wrapper := ServerInterfaceWrapper{
                Handler: si,
        }

        router.GET(baseURL+"/workflows/tools", wrapper.FindManyTools)
        router.POST(baseURL+"/workflows/tools", wrapper.CreateTool)
        router.DELETE(baseURL+"/workflows/tools/:id", wrapper.DeleteTool)
        router.GET(baseURL+"/workflows/tools/:id", wrapper.GetOneTool)
        router.PATCH(baseURL+"/workflows/tools/:id", wrapper.UpdateTool)

}</span>

type BadRequestApplicationProblemPlusJSONResponse Problem

type NotFoundApplicationProblemPlusJSONResponse Problem

type UnauthorizedApplicationProblemPlusJSONResponse Problem

type FindManyToolsRequestObject struct {
        Params FindManyToolsParams
}

type FindManyToolsResponseObject interface {
        VisitFindManyToolsResponse(w http.ResponseWriter) error
}

type FindManyTools200JSONResponse struct {
        Data []Tool `json:"data"`
        Meta struct {
                // Total Total number of items in the collection
                Total float32 `json:"total"`
        } `json:"meta"`
}

func (response FindManyTools200JSONResponse) VisitFindManyToolsResponse(w http.ResponseWriter) error <span class="cov0" title="0">{
        w.Header().Set("Content-Type", "application/json")
        w.WriteHeader(200)

        return json.NewEncoder(w).Encode(response)
}</span>

type FindManyTools400ApplicationProblemPlusJSONResponse struct {
        BadRequestApplicationProblemPlusJSONResponse
}

func (response FindManyTools400ApplicationProblemPlusJSONResponse) VisitFindManyToolsResponse(w http.ResponseWriter) error <span class="cov0" title="0">{
        w.Header().Set("Content-Type", "application/problem+json")
        w.WriteHeader(400)

        return json.NewEncoder(w).Encode(response)
}</span>

type FindManyTools401ApplicationProblemPlusJSONResponse struct {
        UnauthorizedApplicationProblemPlusJSONResponse
}

func (response FindManyTools401ApplicationProblemPlusJSONResponse) VisitFindManyToolsResponse(w http.ResponseWriter) error <span class="cov0" title="0">{
        w.Header().Set("Content-Type", "application/problem+json")
        w.WriteHeader(401)

        return json.NewEncoder(w).Encode(response)
}</span>

type CreateToolRequestObject struct {
        Body *CreateToolJSONRequestBody
}

type CreateToolResponseObject interface {
        VisitCreateToolResponse(w http.ResponseWriter) error
}

type CreateTool201JSONResponse struct {
        // Data Schema for Tool entity
        Data Tool `json:"data"`
}

func (response CreateTool201JSONResponse) VisitCreateToolResponse(w http.ResponseWriter) error <span class="cov0" title="0">{
        w.Header().Set("Content-Type", "application/json")
        w.WriteHeader(201)

        return json.NewEncoder(w).Encode(response)
}</span>

type CreateTool400ApplicationProblemPlusJSONResponse struct {
        BadRequestApplicationProblemPlusJSONResponse
}

func (response CreateTool400ApplicationProblemPlusJSONResponse) VisitCreateToolResponse(w http.ResponseWriter) error <span class="cov0" title="0">{
        w.Header().Set("Content-Type", "application/problem+json")
        w.WriteHeader(400)

        return json.NewEncoder(w).Encode(response)
}</span>

type CreateTool401ApplicationProblemPlusJSONResponse struct {
        UnauthorizedApplicationProblemPlusJSONResponse
}

func (response CreateTool401ApplicationProblemPlusJSONResponse) VisitCreateToolResponse(w http.ResponseWriter) error <span class="cov0" title="0">{
        w.Header().Set("Content-Type", "application/problem+json")
        w.WriteHeader(401)

        return json.NewEncoder(w).Encode(response)
}</span>

type DeleteToolRequestObject struct {
        Id openapi_types.UUID `json:"id"`
}

type DeleteToolResponseObject interface {
        VisitDeleteToolResponse(w http.ResponseWriter) error
}

type DeleteTool200JSONResponse struct {
        // Data Schema for Tool entity
        Data Tool `json:"data"`
}

func (response DeleteTool200JSONResponse) VisitDeleteToolResponse(w http.ResponseWriter) error <span class="cov0" title="0">{
        w.Header().Set("Content-Type", "application/json")
        w.WriteHeader(200)

        return json.NewEncoder(w).Encode(response)
}</span>

type DeleteTool404ApplicationProblemPlusJSONResponse struct {
        NotFoundApplicationProblemPlusJSONResponse
}

func (response DeleteTool404ApplicationProblemPlusJSONResponse) VisitDeleteToolResponse(w http.ResponseWriter) error <span class="cov0" title="0">{
        w.Header().Set("Content-Type", "application/problem+json")
        w.WriteHeader(404)

        return json.NewEncoder(w).Encode(response)
}</span>

type GetOneToolRequestObject struct {
        Id openapi_types.UUID `json:"id"`
}

type GetOneToolResponseObject interface {
        VisitGetOneToolResponse(w http.ResponseWriter) error
}

type GetOneTool200JSONResponse struct {
        // Data Schema for Tool entity
        Data Tool `json:"data"`
}

func (response GetOneTool200JSONResponse) VisitGetOneToolResponse(w http.ResponseWriter) error <span class="cov0" title="0">{
        w.Header().Set("Content-Type", "application/json")
        w.WriteHeader(200)

        return json.NewEncoder(w).Encode(response)
}</span>

type GetOneTool404ApplicationProblemPlusJSONResponse struct {
        NotFoundApplicationProblemPlusJSONResponse
}

func (response GetOneTool404ApplicationProblemPlusJSONResponse) VisitGetOneToolResponse(w http.ResponseWriter) error <span class="cov0" title="0">{
        w.Header().Set("Content-Type", "application/problem+json")
        w.WriteHeader(404)

        return json.NewEncoder(w).Encode(response)
}</span>

type UpdateToolRequestObject struct {
        Id   openapi_types.UUID `json:"id"`
        Body *UpdateToolJSONRequestBody
}

type UpdateToolResponseObject interface {
        VisitUpdateToolResponse(w http.ResponseWriter) error
}

type UpdateTool200JSONResponse struct {
        // Data Schema for Tool entity
        Data Tool `json:"data"`
}

func (response UpdateTool200JSONResponse) VisitUpdateToolResponse(w http.ResponseWriter) error <span class="cov0" title="0">{
        w.Header().Set("Content-Type", "application/json")
        w.WriteHeader(200)

        return json.NewEncoder(w).Encode(response)
}</span>

type UpdateTool404ApplicationProblemPlusJSONResponse struct {
        NotFoundApplicationProblemPlusJSONResponse
}

func (response UpdateTool404ApplicationProblemPlusJSONResponse) VisitUpdateToolResponse(w http.ResponseWriter) error <span class="cov0" title="0">{
        w.Header().Set("Content-Type", "application/problem+json")
        w.WriteHeader(404)

        return json.NewEncoder(w).Encode(response)
}</span>

// StrictServerInterface represents all server handlers.
type StrictServerInterface interface {
        // Find many tools
        // (GET /workflows/tools)
        FindManyTools(ctx context.Context, request FindManyToolsRequestObject) (FindManyToolsResponseObject, error)
        // Create a new tool
        // (POST /workflows/tools)
        CreateTool(ctx context.Context, request CreateToolRequestObject) (CreateToolResponseObject, error)
        // Delete a tool
        // (DELETE /workflows/tools/{id})
        DeleteTool(ctx context.Context, request DeleteToolRequestObject) (DeleteToolResponseObject, error)
        // Find a tool
        // (GET /workflows/tools/{id})
        GetOneTool(ctx context.Context, request GetOneToolRequestObject) (GetOneToolResponseObject, error)
        // Update a tool
        // (PATCH /workflows/tools/{id})
        UpdateTool(ctx context.Context, request UpdateToolRequestObject) (UpdateToolResponseObject, error)
}

type StrictHandlerFunc = strictecho.StrictEchoHandlerFunc
type StrictMiddlewareFunc = strictecho.StrictEchoMiddlewareFunc

func NewStrictHandler(ssi StrictServerInterface, middlewares []StrictMiddlewareFunc) ServerInterface <span class="cov0" title="0">{
        return &amp;strictHandler{ssi: ssi, middlewares: middlewares}
}</span>

type strictHandler struct {
        ssi         StrictServerInterface
        middlewares []StrictMiddlewareFunc
}

// FindManyTools operation middleware
func (sh *strictHandler) FindManyTools(ctx echo.Context, params FindManyToolsParams) error <span class="cov0" title="0">{
        var request FindManyToolsRequestObject

        request.Params = params

        handler := func(ctx echo.Context, request interface{}) (interface{}, error) </span><span class="cov0" title="0">{
                return sh.ssi.FindManyTools(ctx.Request().Context(), request.(FindManyToolsRequestObject))
        }</span>
        <span class="cov0" title="0">for _, middleware := range sh.middlewares </span><span class="cov0" title="0">{
                handler = middleware(handler, "FindManyTools")
        }</span>

        <span class="cov0" title="0">response, err := handler(ctx, request)

        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span> else<span class="cov0" title="0"> if validResponse, ok := response.(FindManyToolsResponseObject); ok </span><span class="cov0" title="0">{
                return validResponse.VisitFindManyToolsResponse(ctx.Response())
        }</span> else<span class="cov0" title="0"> if response != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("unexpected response type: %T", response)
        }</span>
        <span class="cov0" title="0">return nil</span>
}

// CreateTool operation middleware
func (sh *strictHandler) CreateTool(ctx echo.Context) error <span class="cov0" title="0">{
        var request CreateToolRequestObject

        var body CreateToolJSONRequestBody
        if err := ctx.Bind(&amp;body); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov0" title="0">request.Body = &amp;body

        handler := func(ctx echo.Context, request interface{}) (interface{}, error) </span><span class="cov0" title="0">{
                return sh.ssi.CreateTool(ctx.Request().Context(), request.(CreateToolRequestObject))
        }</span>
        <span class="cov0" title="0">for _, middleware := range sh.middlewares </span><span class="cov0" title="0">{
                handler = middleware(handler, "CreateTool")
        }</span>

        <span class="cov0" title="0">response, err := handler(ctx, request)

        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span> else<span class="cov0" title="0"> if validResponse, ok := response.(CreateToolResponseObject); ok </span><span class="cov0" title="0">{
                return validResponse.VisitCreateToolResponse(ctx.Response())
        }</span> else<span class="cov0" title="0"> if response != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("unexpected response type: %T", response)
        }</span>
        <span class="cov0" title="0">return nil</span>
}

// DeleteTool operation middleware
func (sh *strictHandler) DeleteTool(ctx echo.Context, id openapi_types.UUID) error <span class="cov0" title="0">{
        var request DeleteToolRequestObject

        request.Id = id

        handler := func(ctx echo.Context, request interface{}) (interface{}, error) </span><span class="cov0" title="0">{
                return sh.ssi.DeleteTool(ctx.Request().Context(), request.(DeleteToolRequestObject))
        }</span>
        <span class="cov0" title="0">for _, middleware := range sh.middlewares </span><span class="cov0" title="0">{
                handler = middleware(handler, "DeleteTool")
        }</span>

        <span class="cov0" title="0">response, err := handler(ctx, request)

        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span> else<span class="cov0" title="0"> if validResponse, ok := response.(DeleteToolResponseObject); ok </span><span class="cov0" title="0">{
                return validResponse.VisitDeleteToolResponse(ctx.Response())
        }</span> else<span class="cov0" title="0"> if response != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("unexpected response type: %T", response)
        }</span>
        <span class="cov0" title="0">return nil</span>
}

// GetOneTool operation middleware
func (sh *strictHandler) GetOneTool(ctx echo.Context, id openapi_types.UUID) error <span class="cov0" title="0">{
        var request GetOneToolRequestObject

        request.Id = id

        handler := func(ctx echo.Context, request interface{}) (interface{}, error) </span><span class="cov0" title="0">{
                return sh.ssi.GetOneTool(ctx.Request().Context(), request.(GetOneToolRequestObject))
        }</span>
        <span class="cov0" title="0">for _, middleware := range sh.middlewares </span><span class="cov0" title="0">{
                handler = middleware(handler, "GetOneTool")
        }</span>

        <span class="cov0" title="0">response, err := handler(ctx, request)

        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span> else<span class="cov0" title="0"> if validResponse, ok := response.(GetOneToolResponseObject); ok </span><span class="cov0" title="0">{
                return validResponse.VisitGetOneToolResponse(ctx.Response())
        }</span> else<span class="cov0" title="0"> if response != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("unexpected response type: %T", response)
        }</span>
        <span class="cov0" title="0">return nil</span>
}

// UpdateTool operation middleware
func (sh *strictHandler) UpdateTool(ctx echo.Context, id openapi_types.UUID) error <span class="cov0" title="0">{
        var request UpdateToolRequestObject

        request.Id = id

        var body UpdateToolJSONRequestBody
        if err := ctx.Bind(&amp;body); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov0" title="0">request.Body = &amp;body

        handler := func(ctx echo.Context, request interface{}) (interface{}, error) </span><span class="cov0" title="0">{
                return sh.ssi.UpdateTool(ctx.Request().Context(), request.(UpdateToolRequestObject))
        }</span>
        <span class="cov0" title="0">for _, middleware := range sh.middlewares </span><span class="cov0" title="0">{
                handler = middleware(handler, "UpdateTool")
        }</span>

        <span class="cov0" title="0">response, err := handler(ctx, request)

        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span> else<span class="cov0" title="0"> if validResponse, ok := response.(UpdateToolResponseObject); ok </span><span class="cov0" title="0">{
                return validResponse.VisitUpdateToolResponse(ctx.Response())
        }</span> else<span class="cov0" title="0"> if response != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("unexpected response type: %T", response)
        }</span>
        <span class="cov0" title="0">return nil</span>
}
</pre>
		
		<pre class="file" id="file155" style="display: none">// Code generated by codegen repository. DO NOT EDIT.
package tools

import (
        "context"
        "errors"

        "github.com/archesai/archesai/internal/database/postgresql"
        "github.com/google/uuid"
        "github.com/jackc/pgx/v5/pgxpool"
)

// PostgresRepository implements Repository using PostgreSQL.
type PostgresRepository struct {
        db      *pgxpool.Pool
        queries *postgresql.Queries
}

// NewPostgresRepository creates a new PostgreSQL repository.
func NewPostgresRepository(db *pgxpool.Pool) Repository <span class="cov0" title="0">{
        return &amp;PostgresRepository{
                db:      db,
                queries: postgresql.New(db),
        }
}</span>

// Tool operations

func (r *PostgresRepository) Create(ctx context.Context, entity *Tool) (*Tool, error) <span class="cov0" title="0">{
        // Check if SQLC has the CreateTool method
        // For now, we'll generate a stub but with proper error handling
        // TODO: Parse SQLC to detect available queries

        // Example of what it should look like when SQLC query exists:
        // params := postgresql.CreateToolParams{
        //     Id: entity.Id,
        //     // ... map other fields
        // }
        // dbTool, err := r.queries.CreateTool(ctx, params)
        // if err != nil {
        //     return nil, NewRepositoryError("create", err)
        // }
        // return mapToolToDomain(&amp;dbTool), nil

        return nil, NewRepositoryError("create", errors.New("not implemented - SQLC query not found"))
}</span>

func (r *PostgresRepository) Get(ctx context.Context, id uuid.UUID) (*Tool, error) <span class="cov0" title="0">{
        // Try to call SQLC GetTool if it exists
        // For now, return not implemented
        return nil, NewRepositoryError("get", errors.New("not implemented - SQLC query not found"))
}</span>

func (r *PostgresRepository) Update(ctx context.Context, id uuid.UUID, entity *Tool) (*Tool, error) <span class="cov0" title="0">{
        // Update operations are often custom and may not have SQLC queries
        return nil, NewRepositoryError("update", errors.New("not implemented - SQLC query not found"))
}</span>

func (r *PostgresRepository) Delete(ctx context.Context, id uuid.UUID) error <span class="cov0" title="0">{
        // Try to call SQLC DeleteTool if it exists
        // For now, return not implemented
        return NewRepositoryError("delete", errors.New("not implemented - SQLC query not found"))
}</span>

func (r *PostgresRepository) List(ctx context.Context, params ListToolsParams) ([]*Tool, int64, error) <span class="cov0" title="0">{
        // List operations need both List and Count queries from SQLC
        return nil, 0, NewRepositoryError("list", errors.New("not implemented - SQLC query not found"))
}</span>

// ListByOrganization retrieves multiple tools by organizationId
func (r *PostgresRepository) ListByOrganization(ctx context.Context, organizationId string) ([]*Tool, error) <span class="cov0" title="0">{

        // Try to call SQLC ListByOrganization if it exists
        // For now, return not implemented
        return nil, NewRepositoryError("listbyorganization", errors.New("not implemented - SQLC query not found"))

}</span>

// Mapper functions - Convert between domain types and database types
// These need to be customized based on the actual field mappings

func mapToolToDomain(db *postgresql.Tool) *Tool <span class="cov0" title="0">{
        if db == nil </span><span class="cov0" title="0">{
                return nil
        }</span>

        // This is a basic mapping - needs to be customized based on actual types
        // The challenge is that OpenAPI types and database types don't always match
        // For example:
        // - OpenAPI might use string, database uses *string
        // - OpenAPI might use custom UUID type, database uses uuid.UUID
        // - Field names might differ (Id vs ID)

        <span class="cov0" title="0">result := &amp;Tool{
                // TODO: Map fields properly based on actual type definitions
                // This requires parsing both OpenAPI types and SQLC types
        }

        // Basic field mapping - customize based on your entity structure
        // result.Id = db.Id
        // result.CreatedAt = db.CreatedAt
        // result.UpdatedAt = db.UpdatedAt
        // Add specific field mappings as needed

        return result</span>
}
</pre>
		
		<pre class="file" id="file156" style="display: none">// Code generated by codegen repository. DO NOT EDIT.
package tools

import (
        "context"
        "fmt"
        "github.com/google/uuid"
)

// Repository handles tool persistence
type Repository interface {
        Create(ctx context.Context, entity *Tool) (*Tool, error)
        Get(ctx context.Context, id uuid.UUID) (*Tool, error)
        Update(ctx context.Context, id uuid.UUID, entity *Tool) (*Tool, error)
        Delete(ctx context.Context, id uuid.UUID) error
        List(ctx context.Context, params ListToolsParams) ([]*Tool, int64, error)

        // Additional operations
        ListByOrganization(ctx context.Context, organizationId string) ([]*Tool, error)
}

// ListToolsParams represents parameters for listing tools.
type ListToolsParams struct {
        Limit  int
        Offset int
}

// RepositoryError represents a repository error.
type RepositoryError struct {
        Operation string
        Err       error
}

func (e *RepositoryError) Error() string <span class="cov0" title="0">{
        return fmt.Sprintf("repository %s: %v", e.Operation, e.Err)
}</span>

func (e *RepositoryError) Unwrap() error <span class="cov0" title="0">{
        return e.Err
}</span>

// NewRepositoryError creates a new repository error.
func NewRepositoryError(operation string, err error) *RepositoryError <span class="cov0" title="0">{
        return &amp;RepositoryError{
                Operation: operation,
                Err:       err,
        }
}</span>
</pre>
		
		<pre class="file" id="file157" style="display: none">package tools

import (
        "context"
        "log/slog"

        "github.com/google/uuid"
)

// Service implements the Service interface for tool operations
type Service struct {
        repo   Repository
        logger *slog.Logger
}

// NewService creates a new tool service
func NewService(repo Repository, logger *slog.Logger) *Service <span class="cov10" title="14">{
        return &amp;Service{
                repo:   repo,
                logger: logger,
        }
}</span>

// List retrieves tools for an organization
func (s *Service) List(ctx context.Context, _ string, limit, offset int) ([]*Tool, int64, error) <span class="cov4" title="3">{
        params := ListToolsParams{
                Limit:  limit,
                Offset: offset,
        }

        tools, total, err := s.repo.List(ctx, params)
        if err != nil </span><span class="cov1" title="1">{
                s.logger.Error("failed to list tools", "error", err)
                return nil, 0, err
        }</span>

        <span class="cov3" title="2">return tools, total, nil</span>
}

// Create creates a new tool
func (s *Service) Create(ctx context.Context, req *CreateToolJSONRequestBody, orgID string) (*Tool, error) <span class="cov3" title="2">{
        tool := &amp;Tool{
                Id:             uuid.New(),
                OrganizationId: orgID,
                Name:           req.Name,
                Description:    req.Description,
        }

        createdTool, err := s.repo.Create(ctx, tool)
        if err != nil </span><span class="cov1" title="1">{
                s.logger.Error("failed to create tool", "error", err)
                return nil, err
        }</span>

        <span class="cov1" title="1">return createdTool, nil</span>
}

// Get retrieves a tool by ID
func (s *Service) Get(ctx context.Context, id uuid.UUID) (*Tool, error) <span class="cov3" title="2">{
        tool, err := s.repo.Get(ctx, id)
        if err != nil </span><span class="cov1" title="1">{
                s.logger.Error("failed to get tool", "id", id, "error", err)
                return nil, err
        }</span>

        <span class="cov1" title="1">return tool, nil</span>
}

// Update updates a tool
func (s *Service) Update(ctx context.Context, id uuid.UUID, req *UpdateToolJSONRequestBody) (*Tool, error) <span class="cov6" title="5">{
        tool, err := s.repo.Get(ctx, id)
        if err != nil </span><span class="cov1" title="1">{
                s.logger.Error("failed to get tool for update", "id", id, "error", err)
                return nil, err
        }</span>

        <span class="cov5" title="4">if req.Name != "" </span><span class="cov4" title="3">{
                tool.Name = req.Name
        }</span>
        <span class="cov5" title="4">if req.Description != "" </span><span class="cov3" title="2">{
                tool.Description = req.Description
        }</span>

        <span class="cov5" title="4">updatedTool, err := s.repo.Update(ctx, id, tool)
        if err != nil </span><span class="cov1" title="1">{
                s.logger.Error("failed to update tool", "id", id, "error", err)
                return nil, err
        }</span>

        <span class="cov4" title="3">return updatedTool, nil</span>
}

// Delete deletes a tool by ID
func (s *Service) Delete(ctx context.Context, id uuid.UUID) error <span class="cov3" title="2">{
        err := s.repo.Delete(ctx, id)
        if err != nil </span><span class="cov1" title="1">{
                s.logger.Error("failed to delete tool", "id", id, "error", err)
                return err
        }</span>

        <span class="cov1" title="1">return nil</span>
}

// Domain type aliases
type (
        // CreateToolRequest represents a request to create a tool
        CreateToolRequest = CreateToolJSONBody

        // UpdateToolRequest represents a request to update a tool
        UpdateToolRequest = UpdateToolJSONBody
)
</pre>
		
		<pre class="file" id="file158" style="display: none">// Code generated by codegen repository. DO NOT EDIT.
package tools

import (
        "context"
        "database/sql"
        "fmt"

        "github.com/archesai/archesai/internal/database/sqlite"
        "github.com/google/uuid"
)

// SQLiteRepository implements Repository using SQLite.
type SQLiteRepository struct {
        db      *sql.DB
        queries *sqlite.Queries
}

// NewSQLiteRepository creates a new SQLite repository.
func NewSQLiteRepository(db *sql.DB) Repository <span class="cov0" title="0">{
        return &amp;SQLiteRepository{
                db:      db,
                queries: sqlite.New(db),
        }
}</span>

// Tool operations

func (r *SQLiteRepository) Create(ctx context.Context, entity *Tool) (*Tool, error) <span class="cov0" title="0">{
        // For now, return a basic implementation
        // Actual implementation would need to be customized per entity
        return nil, fmt.Errorf("CreateTool not yet implemented - requires custom mapping")
}</span>

func (r *SQLiteRepository) Get(ctx context.Context, id uuid.UUID) (*Tool, error) <span class="cov0" title="0">{
        // For now, return a basic implementation
        // Actual implementation would need to be customized per entity
        return nil, fmt.Errorf("GetTool not yet implemented - requires custom mapping")
}</span>

func (r *SQLiteRepository) Update(ctx context.Context, id uuid.UUID, entity *Tool) (*Tool, error) <span class="cov0" title="0">{
        // For now, return a basic implementation
        // Actual implementation would need to be customized per entity
        return nil, fmt.Errorf("UpdateTool not yet implemented - requires custom mapping")
}</span>

func (r *SQLiteRepository) Delete(ctx context.Context, id uuid.UUID) error <span class="cov0" title="0">{
        // For now, return a basic implementation
        // Actual implementation would need to be customized per entity
        return fmt.Errorf("DeleteTool not yet implemented - requires custom mapping")
}</span>

func (r *SQLiteRepository) List(ctx context.Context, params ListToolsParams) ([]*Tool, int64, error) <span class="cov0" title="0">{
        // For now, return a basic implementation
        // Actual implementation would need to be customized per entity
        return nil, 0, fmt.Errorf("ListTools not yet implemented - requires custom mapping")
}</span>

// ListByOrganization retrieves multiple tools by organizationId
func (r *SQLiteRepository) ListByOrganization(ctx context.Context, organizationId string) ([]*Tool, error) <span class="cov0" title="0">{

        // For now, return a basic implementation
        return nil, fmt.Errorf("ListByOrganization not yet implemented - requires custom mapping")

}</span>
</pre>
		
		<pre class="file" id="file159" style="display: none">// Package tools provides primitives to interact with the openapi HTTP API.
//
// Code generated by github.com/oapi-codegen/oapi-codegen/v2 version v2.5.0 DO NOT EDIT.
package tools

import (
        "encoding/json"
        "time"

        "github.com/oapi-codegen/runtime"
        openapi_types "github.com/oapi-codegen/runtime/types"
)

const (
        BearerAuthScopes = "bearerAuth.Scopes"
)

// Defines values for FindManyToolsParamsSortField.
const (
        CreatedAt      FindManyToolsParamsSortField = "createdAt"
        Description    FindManyToolsParamsSortField = "description"
        Id             FindManyToolsParamsSortField = "id"
        InputMimeType  FindManyToolsParamsSortField = "inputMimeType"
        Name           FindManyToolsParamsSortField = "name"
        OrganizationId FindManyToolsParamsSortField = "organizationId"
        OutputMimeType FindManyToolsParamsSortField = "outputMimeType"
        UpdatedAt      FindManyToolsParamsSortField = "updatedAt"
)

// Defines values for FindManyToolsParamsSortOrder.
const (
        Asc  FindManyToolsParamsSortOrder = "asc"
        Desc FindManyToolsParamsSortOrder = "desc"
)

// FilterNode A recursive filter node that can be a condition or group
type FilterNode = interface{}

// Page Pagination (page number &amp; size)
type Page struct {
        Number int `json:"number,omitempty,omitzero" yaml:"number,omitempty"`
        Size   int `json:"size,omitempty,omitzero" yaml:"size,omitempty"`
}

// Problem RFC 7807 (Problem Details) compliant error response
type Problem struct {
        // Detail Human-readable explanation specific to this occurrence
        Detail string `json:"detail" yaml:"detail"`

        // Errors Additional validation errors for specific fields
        Errors []ValidationError `json:"errors,omitempty,omitzero" yaml:"errors,omitempty"`

        // Instance URI identifying the specific occurrence
        Instance string `json:"instance,omitempty,omitzero" yaml:"instance,omitempty"`

        // Status HTTP status code
        Status int `json:"status" yaml:"status"`

        // Title Short, human-readable summary
        Title string `json:"title" yaml:"title"`

        // Type URI identifying the problem type
        Type string `json:"type" yaml:"type"`
}

// Tool Schema for Tool entity
type Tool struct {
        // CreatedAt The date this item was created
        CreatedAt time.Time `json:"createdAt" yaml:"createdAt"`

        // Description The tool description
        Description string `json:"description" yaml:"description"`

        // Id The ID of the item
        Id openapi_types.UUID `json:"id" yaml:"id"`

        // InputMimeType The MIME type of the input for the tool, e.g. text/plain
        InputMimeType string `json:"inputMimeType" yaml:"inputMimeType"`

        // Name The name of the tool
        Name string `json:"name" yaml:"name"`

        // OrganizationId The organization name
        OrganizationId string `json:"organizationId" yaml:"organizationId"`

        // OutputMimeType The MIME type of the output for the tool, e.g. text/plain
        OutputMimeType string `json:"outputMimeType" yaml:"outputMimeType"`

        // UpdatedAt The date this item was last updated
        UpdatedAt time.Time `json:"updatedAt" yaml:"updatedAt"`
}

// ValidationError Individual field validation error
type ValidationError struct {
        // Field The field path that failed validation
        Field string `json:"field" yaml:"field"`

        // Message Human-readable error message
        Message string `json:"message" yaml:"message"`

        // Value The invalid value that was provided
        Value ValidationError_Value `json:"value,omitempty,omitzero" yaml:"value,omitempty"`
}

// ValidationErrorValue0 defines model for .
type ValidationErrorValue0 = string

// ValidationErrorValue1 defines model for .
type ValidationErrorValue1 = float32

// ValidationErrorValue2 defines model for .
type ValidationErrorValue2 = bool

// ValidationError_Value The invalid value that was provided
type ValidationError_Value struct {
        union json.RawMessage
}

// PageQuery Pagination (page number &amp; size)
type PageQuery = Page

// ToolsFilter A recursive filter node that can be a condition or group
type ToolsFilter = FilterNode

// ToolsSort defines model for ToolsSort.
type ToolsSort = []struct {
        Field string `json:"field" yaml:"field"`
        Order string `json:"order" yaml:"order"`
}

// BadRequest RFC 7807 (Problem Details) compliant error response
type BadRequest = Problem

// NotFound RFC 7807 (Problem Details) compliant error response
type NotFound = Problem

// Unauthorized RFC 7807 (Problem Details) compliant error response
type Unauthorized = Problem

// FindManyToolsParams defines parameters for FindManyTools.
type FindManyToolsParams struct {
        // Filter Filter tools by field values. Supported fields:
        // - createdAt, id, updatedAt, description, inputMimeType
        // - name, organizationId, outputMimeType
        Filter ToolsFilter `json:"filter,omitempty,omitzero" yaml:"filter,omitempty"`

        // Page The page parameter
        Page PageQuery `form:"page,omitempty" json:"page,omitempty,omitzero" yaml:"page,omitempty"`

        // Sort The sort parameter
        Sort ToolsSort `form:"sort,omitempty" json:"sort,omitempty,omitzero" yaml:"sort,omitempty"`
}

// FindManyToolsParamsSortField defines parameters for FindManyTools.
type FindManyToolsParamsSortField string

// FindManyToolsParamsSortOrder defines parameters for FindManyTools.
type FindManyToolsParamsSortOrder string

// CreateToolJSONBody defines parameters for CreateTool.
type CreateToolJSONBody struct {
        // Description The tool description
        Description string `json:"description" yaml:"description"`

        // Name The name of the tool
        Name string `json:"name" yaml:"name"`
}

// UpdateToolJSONBody defines parameters for UpdateTool.
type UpdateToolJSONBody struct {
        // Description The tool description
        Description string `json:"description,omitempty,omitzero" yaml:"description,omitempty"`

        // Name The name of the tool
        Name string `json:"name,omitempty,omitzero" yaml:"name,omitempty"`
}

// CreateToolJSONRequestBody defines body for CreateTool for application/json ContentType.
type CreateToolJSONRequestBody CreateToolJSONBody

// UpdateToolJSONRequestBody defines body for UpdateTool for application/json ContentType.
type UpdateToolJSONRequestBody UpdateToolJSONBody

// AsValidationErrorValue0 returns the union data inside the ValidationError_Value as a ValidationErrorValue0
func (t ValidationError_Value) AsValidationErrorValue0() (ValidationErrorValue0, error) <span class="cov0" title="0">{
        var body ValidationErrorValue0
        err := json.Unmarshal(t.union, &amp;body)
        return body, err
}</span>

// FromValidationErrorValue0 overwrites any union data inside the ValidationError_Value as the provided ValidationErrorValue0
func (t *ValidationError_Value) FromValidationErrorValue0(v ValidationErrorValue0) error <span class="cov0" title="0">{
        b, err := json.Marshal(v)
        t.union = b
        return err
}</span>

// MergeValidationErrorValue0 performs a merge with any union data inside the ValidationError_Value, using the provided ValidationErrorValue0
func (t *ValidationError_Value) MergeValidationErrorValue0(v ValidationErrorValue0) error <span class="cov0" title="0">{
        b, err := json.Marshal(v)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov0" title="0">merged, err := runtime.JSONMerge(t.union, b)
        t.union = merged
        return err</span>
}

// AsValidationErrorValue1 returns the union data inside the ValidationError_Value as a ValidationErrorValue1
func (t ValidationError_Value) AsValidationErrorValue1() (ValidationErrorValue1, error) <span class="cov0" title="0">{
        var body ValidationErrorValue1
        err := json.Unmarshal(t.union, &amp;body)
        return body, err
}</span>

// FromValidationErrorValue1 overwrites any union data inside the ValidationError_Value as the provided ValidationErrorValue1
func (t *ValidationError_Value) FromValidationErrorValue1(v ValidationErrorValue1) error <span class="cov0" title="0">{
        b, err := json.Marshal(v)
        t.union = b
        return err
}</span>

// MergeValidationErrorValue1 performs a merge with any union data inside the ValidationError_Value, using the provided ValidationErrorValue1
func (t *ValidationError_Value) MergeValidationErrorValue1(v ValidationErrorValue1) error <span class="cov0" title="0">{
        b, err := json.Marshal(v)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov0" title="0">merged, err := runtime.JSONMerge(t.union, b)
        t.union = merged
        return err</span>
}

// AsValidationErrorValue2 returns the union data inside the ValidationError_Value as a ValidationErrorValue2
func (t ValidationError_Value) AsValidationErrorValue2() (ValidationErrorValue2, error) <span class="cov0" title="0">{
        var body ValidationErrorValue2
        err := json.Unmarshal(t.union, &amp;body)
        return body, err
}</span>

// FromValidationErrorValue2 overwrites any union data inside the ValidationError_Value as the provided ValidationErrorValue2
func (t *ValidationError_Value) FromValidationErrorValue2(v ValidationErrorValue2) error <span class="cov0" title="0">{
        b, err := json.Marshal(v)
        t.union = b
        return err
}</span>

// MergeValidationErrorValue2 performs a merge with any union data inside the ValidationError_Value, using the provided ValidationErrorValue2
func (t *ValidationError_Value) MergeValidationErrorValue2(v ValidationErrorValue2) error <span class="cov0" title="0">{
        b, err := json.Marshal(v)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov0" title="0">merged, err := runtime.JSONMerge(t.union, b)
        t.union = merged
        return err</span>
}

func (t ValidationError_Value) MarshalJSON() ([]byte, error) <span class="cov0" title="0">{
        b, err := t.union.MarshalJSON()
        return b, err
}</span>

func (t *ValidationError_Value) UnmarshalJSON(b []byte) error <span class="cov0" title="0">{
        err := t.union.UnmarshalJSON(b)
        return err
}</span>
</pre>
		
		<pre class="file" id="file160" style="display: none">// Package tui provides terminal user interface components for ArchesAI.
package tui

import (
        "fmt"
        "strings"

        tea "github.com/charmbracelet/bubbletea"
        "github.com/charmbracelet/lipgloss"
        "github.com/spf13/viper"
)

const (
        viewMenu = "menu"
)

// ConfigModel represents the configuration TUI
type ConfigModel struct {
        sections     []string
        selectedItem int
        currentView  string // viewMenu, "database", "server", "auth", "redis", "storage", "agents"
        width        int
        height       int
        styles       *ConfigStyles
}

// ConfigStyles holds styling for the config viewer
type ConfigStyles struct {
        Title    lipgloss.Style
        Menu     lipgloss.Style
        Selected lipgloss.Style
        Key      lipgloss.Style
        Value    lipgloss.Style
        Section  lipgloss.Style
        Help     lipgloss.Style
        Success  lipgloss.Style
        Warning  lipgloss.Style
        Error    lipgloss.Style
}

// NewConfigStyles creates the config viewer styles
func NewConfigStyles() *ConfigStyles <span class="cov0" title="0">{
        return &amp;ConfigStyles{
                Title: lipgloss.NewStyle().
                        Bold(true).
                        Foreground(lipgloss.Color("15")).
                        Background(lipgloss.AdaptiveColor{Light: "63", Dark: "57"}).
                        Padding(0, 3).
                        MarginTop(1).
                        MarginBottom(1).
                        Align(lipgloss.Center),

                Menu: lipgloss.NewStyle().
                        BorderStyle(lipgloss.RoundedBorder()).
                        BorderForeground(lipgloss.Color("62")).
                        Padding(1, 2).
                        MarginTop(1).
                        MarginBottom(1),

                Selected: lipgloss.NewStyle().
                        Foreground(lipgloss.Color("226")).
                        Background(lipgloss.Color("235")).
                        Bold(true).
                        PaddingLeft(1).
                        PaddingRight(2),

                Key: lipgloss.NewStyle().
                        Foreground(lipgloss.Color("86")).
                        Bold(true).
                        Width(20),

                Value: lipgloss.NewStyle().
                        Foreground(lipgloss.Color("252")),

                Section: lipgloss.NewStyle().
                        Bold(true).
                        Foreground(lipgloss.Color("213")).
                        BorderStyle(lipgloss.NormalBorder()).
                        BorderBottom(true).
                        BorderForeground(lipgloss.Color("238")).
                        MarginBottom(1).
                        PaddingBottom(1),

                Help: lipgloss.NewStyle().
                        Foreground(lipgloss.Color("241")).
                        Italic(true).
                        BorderStyle(lipgloss.RoundedBorder()).
                        BorderForeground(lipgloss.Color("238")).
                        Padding(0, 1).
                        MarginTop(1),

                Success: lipgloss.NewStyle().
                        Foreground(lipgloss.Color("82")).
                        Bold(true),

                Warning: lipgloss.NewStyle().
                        Foreground(lipgloss.Color("214")).
                        Bold(true),

                Error: lipgloss.NewStyle().
                        Foreground(lipgloss.Color("196")).
                        Bold(true),
        }
}</span>

// NewConfigModel creates a new configuration viewer
func NewConfigModel() ConfigModel <span class="cov0" title="0">{
        // Initialize viper to load config
        viper.SetConfigName("config")
        viper.SetConfigType("yaml")
        viper.AddConfigPath(".")
        viper.AddConfigPath("$HOME/.archesai")
        viper.SetEnvPrefix("ARCHESAI")
        viper.AutomaticEnv()

        // Try to read config file (ignore errors if not found)
        _ = viper.ReadInConfig()

        return ConfigModel{
                sections: []string{
                        "🗄️  Database Configuration",
                        "🌐 Server Configuration",
                        "🔐 Authentication Settings",
                        "📦 Redis Configuration",
                        "💾 Storage Settings",
                        "🤖 AI Agents &amp; LLM Providers",
                        "📊 System Status",
                        "🔧 Environment Variables",
                },
                currentView: viewMenu,
                styles:      NewConfigStyles(),
        }
}</span>

// Init initializes the config model
func (m ConfigModel) Init() tea.Cmd <span class="cov0" title="0">{
        return tea.EnterAltScreen
}</span>

// Update handles messages
func (m ConfigModel) Update(msg tea.Msg) (tea.Model, tea.Cmd) <span class="cov0" title="0">{
        switch msg := msg.(type) </span>{
        case tea.KeyMsg:<span class="cov0" title="0">
                switch msg.Type </span>{
                case tea.KeyCtrlC, tea.KeyEsc:<span class="cov0" title="0">
                        if m.currentView != viewMenu </span><span class="cov0" title="0">{
                                m.currentView = viewMenu
                                return m, nil
                        }</span>
                        <span class="cov0" title="0">return m, tea.Quit</span>

                case tea.KeyUp:<span class="cov0" title="0">
                        if m.currentView == viewMenu &amp;&amp; m.selectedItem &gt; 0 </span><span class="cov0" title="0">{
                                m.selectedItem--
                        }</span>

                case tea.KeyDown:<span class="cov0" title="0">
                        if m.currentView == viewMenu &amp;&amp; m.selectedItem &lt; len(m.sections)-1 </span><span class="cov0" title="0">{
                                m.selectedItem++
                        }</span>

                case tea.KeyEnter:<span class="cov0" title="0">
                        if m.currentView == viewMenu </span><span class="cov0" title="0">{
                                switch m.selectedItem </span>{
                                case 0:<span class="cov0" title="0">
                                        m.currentView = "database"</span>
                                case 1:<span class="cov0" title="0">
                                        m.currentView = "server"</span>
                                case 2:<span class="cov0" title="0">
                                        m.currentView = "auth"</span>
                                case 3:<span class="cov0" title="0">
                                        m.currentView = "redis"</span>
                                case 4:<span class="cov0" title="0">
                                        m.currentView = "storage"</span>
                                case 5:<span class="cov0" title="0">
                                        m.currentView = "agents"</span>
                                case 6:<span class="cov0" title="0">
                                        m.currentView = "status"</span>
                                case 7:<span class="cov0" title="0">
                                        m.currentView = "env"</span>
                                }
                        }
                }

        case tea.WindowSizeMsg:<span class="cov0" title="0">
                m.width = msg.Width
                m.height = msg.Height</span>
        }

        <span class="cov0" title="0">return m, nil</span>
}

// View renders the TUI
func (m ConfigModel) View() string <span class="cov0" title="0">{
        if m.width == 0 || m.height == 0 </span><span class="cov0" title="0">{
                return "Initializing..."
        }</span>

        <span class="cov0" title="0">var sections []string

        // Title - make it smaller and centered
        title := m.styles.Title.Render("⚙️  ArchesAI Configuration Viewer")
        titleLine := lipgloss.PlaceHorizontal(m.width, lipgloss.Center, title)
        sections = append(sections, titleLine)

        // Main content - center it
        var mainContent string
        switch m.currentView </span>{
        case viewMenu:<span class="cov0" title="0">
                mainContent = m.renderMenu()</span>
        case "database":<span class="cov0" title="0">
                mainContent = m.renderDatabase()</span>
        case "server":<span class="cov0" title="0">
                mainContent = m.renderServer()</span>
        case "auth":<span class="cov0" title="0">
                mainContent = m.renderAuth()</span>
        case "redis":<span class="cov0" title="0">
                mainContent = m.renderRedis()</span>
        case "storage":<span class="cov0" title="0">
                mainContent = m.renderStorage()</span>
        case "agents":<span class="cov0" title="0">
                mainContent = m.renderAgents()</span>
        case "status":<span class="cov0" title="0">
                mainContent = m.renderStatus()</span>
        case "env":<span class="cov0" title="0">
                mainContent = m.renderEnv()</span>
        }

        // Center the main content horizontally
        <span class="cov0" title="0">centeredContent := lipgloss.PlaceHorizontal(m.width, lipgloss.Center, mainContent)
        sections = append(sections, centeredContent)

        // Help text at bottom
        helpText := "↑/↓: Navigate │ Enter: Select │ ESC: Back │ Ctrl+C: Quit"
        help := m.styles.Help.Render(helpText)

        // Calculate remaining height and add spacer
        usedHeight := lipgloss.Height(strings.Join(sections, "\n")) + lipgloss.Height(help) + 2
        if remainingHeight := m.height - usedHeight; remainingHeight &gt; 0 </span><span class="cov0" title="0">{
                sections = append(sections, strings.Repeat("\n", remainingHeight))
        }</span>

        <span class="cov0" title="0">sections = append(sections, lipgloss.PlaceHorizontal(m.width, lipgloss.Center, help))

        return lipgloss.JoinVertical(lipgloss.Center, sections...)</span>
}

// renderMenu renders the main menu
func (m ConfigModel) renderMenu() string <span class="cov0" title="0">{
        var items []string

        // Add a header
        header := lipgloss.NewStyle().
                Foreground(lipgloss.Color("245")).
                Italic(true).
                Render("Select a configuration section to view:")
        items = append(items, header)
        items = append(items, "") // Empty line for spacing

        for i, section := range m.sections </span><span class="cov0" title="0">{
                var item string
                if i == m.selectedItem </span><span class="cov0" title="0">{
                        // Selected item with arrow and highlighting
                        item = m.styles.Selected.Render(fmt.Sprintf("  ▸ %s", section))
                }</span> else<span class="cov0" title="0"> {
                        // Normal item with proper indentation
                        item = fmt.Sprintf("    %s", section)
                }</span>
                <span class="cov0" title="0">items = append(items, item)

                // Add spacing between items for better readability
                if i &lt; len(m.sections)-1 </span><span class="cov0" title="0">{
                        items = append(items, "")
                }</span>
        }

        <span class="cov0" title="0">menu := strings.Join(items, "\n")

        // Use fixed width for better centering
        menuWidth := 60
        if m.width &lt; 65 </span><span class="cov0" title="0">{
                menuWidth = m.width - 5
        }</span>

        <span class="cov0" title="0">return m.styles.Menu.
                Width(menuWidth).
                Render(menu)</span>
}

// renderDatabase renders database configuration
func (m ConfigModel) renderDatabase() string <span class="cov0" title="0">{
        var content strings.Builder

        content.WriteString(m.styles.Section.Render("📊 Database Configuration") + "\n\n")

        // PostgreSQL settings
        content.WriteString(m.styles.Key.Render("PostgreSQL") + "\n")
        content.WriteString(m.renderConfigItem("Host", viper.GetString("database.postgres.host"), false))
        content.WriteString(m.renderConfigItem("Port", fmt.Sprintf("%d", viper.GetInt("database.postgres.port")), false))
        content.WriteString(m.renderConfigItem("Database", viper.GetString("database.postgres.database"), false))
        content.WriteString(m.renderConfigItem("User", viper.GetString("database.postgres.user"), false))
        content.WriteString(m.renderConfigItem("SSL Mode", viper.GetString("database.postgres.sslmode"), false))

        // Connection pool settings
        content.WriteString("\n" + m.styles.Key.Render("Connection Pool") + "\n")
        content.WriteString(m.renderConfigItem("Max Open", fmt.Sprintf("%d", viper.GetInt("database.postgres.max_open_conns")), false))
        content.WriteString(m.renderConfigItem("Max Idle", fmt.Sprintf("%d", viper.GetInt("database.postgres.max_idle_conns")), false))

        // SQLite settings
        content.WriteString("\n" + m.styles.Key.Render("SQLite") + "\n")
        sqlitePath := viper.GetString("database.sqlite.path")
        if sqlitePath == "" </span><span class="cov0" title="0">{
                sqlitePath = "Not configured"
        }</span>
        <span class="cov0" title="0">content.WriteString(m.renderConfigItem("Path", sqlitePath, false))

        // Current driver
        content.WriteString("\n" + m.styles.Key.Render("Active Driver") + "\n")
        driver := viper.GetString("database.driver")
        switch driver </span>{
        case "postgres":<span class="cov0" title="0">
                content.WriteString("  " + m.styles.Success.Render("● PostgreSQL") + "\n")</span>
        case "sqlite":<span class="cov0" title="0">
                content.WriteString("  " + m.styles.Warning.Render("● SQLite") + "\n")</span>
        default:<span class="cov0" title="0">
                content.WriteString("  " + m.styles.Error.Render("○ Not configured") + "\n")</span>
        }

        // Use fixed width for better centering
        <span class="cov0" title="0">contentWidth := 60
        if m.width &lt; 65 </span><span class="cov0" title="0">{
                contentWidth = m.width - 5
        }</span>

        <span class="cov0" title="0">return m.styles.Menu.Width(contentWidth).Render(content.String())</span>
}

// renderConfigItem renders a configuration key-value pair with consistent formatting
func (m ConfigModel) renderConfigItem(key, value string, _ bool) string <span class="cov0" title="0">{
        if value == "" || value == "0" </span><span class="cov0" title="0">{
                value = lipgloss.NewStyle().Foreground(lipgloss.Color("245")).Italic(true).Render("not set")
        }</span> else<span class="cov0" title="0"> {
                value = m.styles.Value.Render(value)
        }</span>

        <span class="cov0" title="0">keyStyle := lipgloss.NewStyle().
                Foreground(lipgloss.Color("245")).
                Width(20).
                Render("  " + key + ":")

        return fmt.Sprintf("%s %s\n", keyStyle, value)</span>
}

// renderServer renders server configuration
func (m ConfigModel) renderServer() string <span class="cov0" title="0">{
        var content strings.Builder

        content.WriteString(m.styles.Section.Render("🌐 Server Configuration") + "\n\n")

        content.WriteString(m.styles.Key.Render("API Server") + "\n")
        content.WriteString(m.renderConfigItem("Host", viper.GetString("server.host"), false))
        content.WriteString(m.renderConfigItem("Port", fmt.Sprintf("%d", viper.GetInt("server.port")), false))
        content.WriteString(m.renderConfigItem("Mode", viper.GetString("server.mode"), false))

        content.WriteString("\n" + m.styles.Key.Render("CORS Settings") + "\n")
        origins := viper.GetStringSlice("server.cors.allowed_origins")
        if len(origins) &gt; 0 </span><span class="cov0" title="0">{
                for i, origin := range origins </span><span class="cov0" title="0">{
                        if i == 0 </span><span class="cov0" title="0">{
                                content.WriteString(m.renderConfigItem("Allowed Origins", origin, false))
                        }</span> else<span class="cov0" title="0"> {
                                content.WriteString(m.renderConfigItem("", origin, false))
                        }</span>
                }
        } else<span class="cov0" title="0"> {
                content.WriteString(m.renderConfigItem("Allowed Origins", "none configured", false))
        }</span>

        <span class="cov0" title="0">content.WriteString("\n" + m.styles.Key.Render("Rate Limiting") + "\n")
        enabled := viper.GetBool("server.rate_limit.enabled")
        if enabled </span><span class="cov0" title="0">{
                content.WriteString(m.renderConfigItem("Status", m.styles.Success.Render("Enabled"), false))
        }</span> else<span class="cov0" title="0"> {
                content.WriteString(m.renderConfigItem("Status", m.styles.Warning.Render("Disabled"), false))
        }</span>
        <span class="cov0" title="0">content.WriteString(m.renderConfigItem("Requests/Min", fmt.Sprintf("%d", viper.GetInt("server.rate_limit.requests_per_minute")), false))

        // Use fixed width for better centering
        contentWidth := 60
        if m.width &lt; 65 </span><span class="cov0" title="0">{
                contentWidth = m.width - 5
        }</span>

        <span class="cov0" title="0">return m.styles.Menu.Width(contentWidth).Render(content.String())</span>
}

// renderAuth renders authentication configuration
func (m ConfigModel) renderAuth() string <span class="cov0" title="0">{
        var content strings.Builder

        content.WriteString(m.styles.Section.Render("Authentication Settings") + "\n\n")

        content.WriteString(m.styles.Key.Render("JWT Configuration:") + "\n")
        secretSet := viper.GetString("auth.jwt.secret") != ""
        if secretSet </span><span class="cov0" title="0">{
                content.WriteString("  Secret: " + m.styles.Success.Render("✓ Configured") + "\n")
        }</span> else<span class="cov0" title="0"> {
                content.WriteString("  Secret: " + m.styles.Error.Render("✗ Not Set") + "\n")
        }</span>
        <span class="cov0" title="0">content.WriteString(fmt.Sprintf("  Expiry: %s\n", m.styles.Value.Render(viper.GetString("auth.jwt.expiry"))))

        content.WriteString("\n" + m.styles.Key.Render("OAuth Providers:") + "\n")

        // Google OAuth
        googleEnabled := viper.GetString("auth.oauth.google.client_id") != ""
        if googleEnabled </span><span class="cov0" title="0">{
                content.WriteString("  Google: " + m.styles.Success.Render("✓ Configured") + "\n")
        }</span> else<span class="cov0" title="0"> {
                content.WriteString("  Google: " + m.styles.Warning.Render("○ Not Configured") + "\n")
        }</span>

        // GitHub OAuth
        <span class="cov0" title="0">githubEnabled := viper.GetString("auth.oauth.github.client_id") != ""
        if githubEnabled </span><span class="cov0" title="0">{
                content.WriteString("  GitHub: " + m.styles.Success.Render("✓ Configured") + "\n")
        }</span> else<span class="cov0" title="0"> {
                content.WriteString("  GitHub: " + m.styles.Warning.Render("○ Not Configured") + "\n")
        }</span>

        // Use fixed width for better centering
        <span class="cov0" title="0">contentWidth := 60
        if m.width &lt; 65 </span><span class="cov0" title="0">{
                contentWidth = m.width - 5
        }</span>

        <span class="cov0" title="0">return m.styles.Menu.Width(contentWidth).Render(content.String())</span>
}

// renderRedis renders Redis configuration
func (m ConfigModel) renderRedis() string <span class="cov0" title="0">{
        var content strings.Builder

        content.WriteString(m.styles.Section.Render("Redis Configuration") + "\n\n")

        content.WriteString(m.styles.Key.Render("Connection:") + "\n")
        content.WriteString(fmt.Sprintf("  Host: %s\n", m.styles.Value.Render(viper.GetString("redis.host"))))
        content.WriteString(fmt.Sprintf("  Port: %s\n", m.styles.Value.Render(fmt.Sprintf("%d", viper.GetInt("redis.port")))))
        content.WriteString(fmt.Sprintf("  Database: %s\n", m.styles.Value.Render(fmt.Sprintf("%d", viper.GetInt("redis.db")))))

        passwordSet := viper.GetString("redis.password") != ""
        if passwordSet </span><span class="cov0" title="0">{
                content.WriteString("  Password: " + m.styles.Success.Render("✓ Set") + "\n")
        }</span> else<span class="cov0" title="0"> {
                content.WriteString("  Password: " + m.styles.Warning.Render("○ Not Set") + "\n")
        }</span>

        <span class="cov0" title="0">content.WriteString("\n" + m.styles.Key.Render("Pool Settings:") + "\n")
        content.WriteString(fmt.Sprintf("  Max Retries: %s\n", m.styles.Value.Render(fmt.Sprintf("%d", viper.GetInt("redis.max_retries")))))
        content.WriteString(fmt.Sprintf("  Pool Size: %s\n", m.styles.Value.Render(fmt.Sprintf("%d", viper.GetInt("redis.pool_size")))))

        // Use fixed width for better centering
        contentWidth := 60
        if m.width &lt; 65 </span><span class="cov0" title="0">{
                contentWidth = m.width - 5
        }</span>

        <span class="cov0" title="0">return m.styles.Menu.Width(contentWidth).Render(content.String())</span>
}

// renderStorage renders storage configuration
func (m ConfigModel) renderStorage() string <span class="cov0" title="0">{
        var content strings.Builder

        content.WriteString(m.styles.Section.Render("Storage Settings") + "\n\n")

        content.WriteString(m.styles.Key.Render("Local Storage:") + "\n")
        content.WriteString(fmt.Sprintf("  Upload Dir: %s\n", m.styles.Value.Render(viper.GetString("storage.local.upload_dir"))))
        content.WriteString(fmt.Sprintf("  Max File Size: %s MB\n", m.styles.Value.Render(fmt.Sprintf("%d", viper.GetInt("storage.local.max_file_size_mb")))))

        content.WriteString("\n" + m.styles.Key.Render("S3 Storage:") + "\n")
        s3Enabled := viper.GetString("storage.s3.bucket") != ""
        if s3Enabled </span><span class="cov0" title="0">{
                content.WriteString("  Status: " + m.styles.Success.Render("✓ Configured") + "\n")
                content.WriteString(fmt.Sprintf("  Bucket: %s\n", m.styles.Value.Render(viper.GetString("storage.s3.bucket"))))
                content.WriteString(fmt.Sprintf("  Region: %s\n", m.styles.Value.Render(viper.GetString("storage.s3.region"))))
        }</span> else<span class="cov0" title="0"> {
                content.WriteString("  Status: " + m.styles.Warning.Render("○ Not Configured") + "\n")
        }</span>

        // Use fixed width for better centering
        <span class="cov0" title="0">contentWidth := 60
        if m.width &lt; 65 </span><span class="cov0" title="0">{
                contentWidth = m.width - 5
        }</span>

        <span class="cov0" title="0">return m.styles.Menu.Width(contentWidth).Render(content.String())</span>
}

// renderAgents renders AI agents configuration
func (m ConfigModel) renderAgents() string <span class="cov0" title="0">{
        var content strings.Builder

        content.WriteString(m.styles.Section.Render("AI Agents &amp; LLM Providers") + "\n\n")

        // Check for API keys
        content.WriteString(m.styles.Key.Render("OpenAI:") + "\n")
        openaiKey := viper.GetString("llm.openai.api_key")
        if openaiKey != "" </span><span class="cov0" title="0">{
                content.WriteString("  API Key: " + m.styles.Success.Render("✓ Configured") + "\n")
                content.WriteString(fmt.Sprintf("  Model: %s\n", m.styles.Value.Render(viper.GetString("llm.openai.model"))))
        }</span> else<span class="cov0" title="0"> {
                content.WriteString("  API Key: " + m.styles.Warning.Render("○ Not Set") + "\n")
        }</span>

        <span class="cov0" title="0">content.WriteString("\n" + m.styles.Key.Render("Anthropic (Claude):") + "\n")
        claudeKey := viper.GetString("llm.anthropic.api_key")
        if claudeKey != "" </span><span class="cov0" title="0">{
                content.WriteString("  API Key: " + m.styles.Success.Render("✓ Configured") + "\n")
                content.WriteString(fmt.Sprintf("  Model: %s\n", m.styles.Value.Render(viper.GetString("llm.anthropic.model"))))
        }</span> else<span class="cov0" title="0"> {
                content.WriteString("  API Key: " + m.styles.Warning.Render("○ Not Set") + "\n")
        }</span>

        <span class="cov0" title="0">content.WriteString("\n" + m.styles.Key.Render("Google (Gemini):") + "\n")
        geminiKey := viper.GetString("llm.gemini.api_key")
        if geminiKey != "" </span><span class="cov0" title="0">{
                content.WriteString("  API Key: " + m.styles.Success.Render("✓ Configured") + "\n")
        }</span> else<span class="cov0" title="0"> {
                content.WriteString("  API Key: " + m.styles.Warning.Render("○ Not Set") + "\n")
        }</span>

        <span class="cov0" title="0">content.WriteString("\n" + m.styles.Key.Render("Ollama (Local):") + "\n")
        ollamaHost := viper.GetString("llm.ollama.host")
        if ollamaHost != "" </span><span class="cov0" title="0">{
                content.WriteString(fmt.Sprintf("  Host: %s\n", m.styles.Value.Render(ollamaHost)))
                content.WriteString("  Status: " + m.styles.Success.Render("✓ Available") + "\n")
        }</span> else<span class="cov0" title="0"> {
                content.WriteString("  Status: " + m.styles.Warning.Render("○ Not Configured") + "\n")
        }</span>

        // SwarmGo agents status
        <span class="cov0" title="0">content.WriteString("\n" + m.styles.Key.Render("SwarmGo Agents:") + "\n")
        content.WriteString("  Status: " + m.styles.Success.Render("✓ Integrated") + "\n")
        content.WriteString("  Available Agents:\n")
        content.WriteString("    - Assistant (General Purpose)\n")
        content.WriteString("    - CodeHelper (Programming)\n")
        content.WriteString("    - CreativeWriter (Content)\n")
        content.WriteString("    - DataAnalyst (Analysis)\n")
        content.WriteString("    - Researcher (Information)\n")

        // Use fixed width for better centering
        contentWidth := 60
        if m.width &lt; 65 </span><span class="cov0" title="0">{
                contentWidth = m.width - 5
        }</span>

        <span class="cov0" title="0">return m.styles.Menu.Width(contentWidth).Render(content.String())</span>
}

// renderStatus renders system status
func (m ConfigModel) renderStatus() string <span class="cov0" title="0">{
        var content strings.Builder

        content.WriteString(m.styles.Section.Render("System Status") + "\n\n")

        // Environment
        content.WriteString(m.styles.Key.Render("Environment:") + "\n")
        env := viper.GetString("environment")
        switch env </span>{
        case "production":<span class="cov0" title="0">
                content.WriteString("  Mode: " + m.styles.Error.Render("Production") + "\n")</span>
        case "development":<span class="cov0" title="0">
                content.WriteString("  Mode: " + m.styles.Warning.Render("Development") + "\n")</span>
        default:<span class="cov0" title="0">
                content.WriteString(fmt.Sprintf("  Mode: %s\n", m.styles.Value.Render(env)))</span>
        }

        // Debug mode
        <span class="cov0" title="0">debugMode := viper.GetBool("debug")
        if debugMode </span><span class="cov0" title="0">{
                content.WriteString("  Debug: " + m.styles.Warning.Render("✓ Enabled") + "\n")
        }</span> else<span class="cov0" title="0"> {
                content.WriteString("  Debug: " + m.styles.Value.Render("○ Disabled") + "\n")
        }</span>

        // Config file
        <span class="cov0" title="0">content.WriteString("\n" + m.styles.Key.Render("Configuration:") + "\n")
        configFile := viper.ConfigFileUsed()
        if configFile != "" </span><span class="cov0" title="0">{
                content.WriteString(fmt.Sprintf("  Config File: %s\n", m.styles.Value.Render(configFile)))
        }</span> else<span class="cov0" title="0"> {
                content.WriteString("  Config File: " + m.styles.Warning.Render("Using defaults") + "\n")
        }</span>

        // Feature flags
        <span class="cov0" title="0">content.WriteString("\n" + m.styles.Key.Render("Features:") + "\n")
        content.WriteString("  TUI: " + m.styles.Success.Render("✓ Enabled") + "\n")
        content.WriteString("  SwarmGo: " + m.styles.Success.Render("✓ Integrated") + "\n")
        content.WriteString("  Multi-Agent: " + m.styles.Success.Render("✓ Available") + "\n")

        // Use fixed width for better centering
        contentWidth := 60
        if m.width &lt; 65 </span><span class="cov0" title="0">{
                contentWidth = m.width - 5
        }</span>

        <span class="cov0" title="0">return m.styles.Menu.Width(contentWidth).Render(content.String())</span>
}

// renderEnv renders environment variables
func (m ConfigModel) renderEnv() string <span class="cov0" title="0">{
        var content strings.Builder

        content.WriteString(m.styles.Section.Render("Environment Variables") + "\n\n")

        // Database
        content.WriteString(m.styles.Key.Render("Database:") + "\n")
        dbURL := viper.GetString("DATABASE_URL")
        if dbURL != "" </span><span class="cov0" title="0">{
                content.WriteString("  DATABASE_URL: " + m.styles.Success.Render("✓ Set") + "\n")
        }</span> else<span class="cov0" title="0"> {
                content.WriteString("  DATABASE_URL: " + m.styles.Warning.Render("○ Not Set") + "\n")
        }</span>

        // API Keys
        <span class="cov0" title="0">content.WriteString("\n" + m.styles.Key.Render("API Keys:") + "\n")

        envVars := map[string]string{
                "OPENAI_API_KEY":        "OpenAI",
                "ANTHROPIC_API_KEY":     "Anthropic",
                "GEMINI_API_KEY":        "Gemini",
                "REDIS_URL":             "Redis URL",
                "JWT_SECRET":            "JWT Secret",
                "AWS_ACCESS_KEY_ID":     "AWS Access Key",
                "AWS_SECRET_ACCESS_KEY": "AWS Secret Key",
        }

        for env, name := range envVars </span><span class="cov0" title="0">{
                value := viper.GetString(env)
                if value != "" </span><span class="cov0" title="0">{
                        content.WriteString(fmt.Sprintf("  %s: %s\n", name, m.styles.Success.Render("✓ Set")))
                }</span> else<span class="cov0" title="0"> {
                        content.WriteString(fmt.Sprintf("  %s: %s\n", name, m.styles.Warning.Render("○ Not Set")))
                }</span>
        }

        // Server
        <span class="cov0" title="0">content.WriteString("\n" + m.styles.Key.Render("Server:") + "\n")
        content.WriteString(fmt.Sprintf("  PORT: %s\n", m.styles.Value.Render(viper.GetString("PORT"))))
        content.WriteString(fmt.Sprintf("  HOST: %s\n", m.styles.Value.Render(viper.GetString("HOST"))))

        // Use fixed width for better centering
        contentWidth := 60
        if m.width &lt; 65 </span><span class="cov0" title="0">{
                contentWidth = m.width - 5
        }</span>

        <span class="cov0" title="0">return m.styles.Menu.Width(contentWidth).Render(content.String())</span>
}
</pre>
		
		<pre class="file" id="file161" style="display: none">package tui

import (
        "context"
        "fmt"
        "strings"

        "github.com/archesai/archesai/internal/llm"
        tea "github.com/charmbracelet/bubbletea"
        "github.com/charmbracelet/lipgloss"
)

// Model represents the TUI application state
type Model struct {
        chatClient    llm.ChatClient
        session       *llm.ChatSession
        messages      []Message
        input         string
        width         int
        height        int
        isProcessing  bool
        err           error
        selectedAgent int
        personas      []*llm.ChatPersona
        showAgentList bool
        style         *Styles
}

// Message represents a chat message
type Message struct {
        Role    string
        Content string
        Agent   string
}

// Styles holds all the styling configurations
type Styles struct {
        Title      lipgloss.Style
        Agent      lipgloss.Style
        User       lipgloss.Style
        Assistant  lipgloss.Style
        System     lipgloss.Style
        Input      lipgloss.Style
        Error      lipgloss.Style
        Processing lipgloss.Style
        Border     lipgloss.Style
        AgentList  lipgloss.Style
        Selected   lipgloss.Style
}

// NewStyles creates default styles
func NewStyles() *Styles <span class="cov0" title="0">{
        return &amp;Styles{
                Title: lipgloss.NewStyle().
                        Bold(true).
                        Foreground(lipgloss.Color("99")).
                        Background(lipgloss.Color("63")).
                        Padding(0, 2).
                        Margin(1),

                Agent: lipgloss.NewStyle().
                        Foreground(lipgloss.Color("86")).
                        Bold(true),

                User: lipgloss.NewStyle().
                        Foreground(lipgloss.Color("33")).
                        Bold(true).
                        Align(lipgloss.Right),

                Assistant: lipgloss.NewStyle().
                        Foreground(lipgloss.Color("212")),

                System: lipgloss.NewStyle().
                        Foreground(lipgloss.Color("241")).
                        Italic(true),

                Input: lipgloss.NewStyle().
                        BorderStyle(lipgloss.RoundedBorder()).
                        BorderForeground(lipgloss.Color("62")).
                        Padding(0, 1),

                Error: lipgloss.NewStyle().
                        Foreground(lipgloss.Color("196")).
                        Bold(true),

                Processing: lipgloss.NewStyle().
                        Foreground(lipgloss.Color("226")).
                        Italic(true),

                Border: lipgloss.NewStyle().
                        BorderStyle(lipgloss.NormalBorder()).
                        BorderForeground(lipgloss.Color("240")),

                AgentList: lipgloss.NewStyle().
                        BorderStyle(lipgloss.RoundedBorder()).
                        BorderForeground(lipgloss.Color("99")).
                        Padding(1),

                Selected: lipgloss.NewStyle().
                        Foreground(lipgloss.Color("226")).
                        Background(lipgloss.Color("235")).
                        Bold(true),
        }
}</span>

// New creates a new TUI model
func New(chatClient llm.ChatClient, personas []*llm.ChatPersona) Model <span class="cov0" title="0">{
        var session *llm.ChatSession
        if len(personas) &gt; 0 </span><span class="cov0" title="0">{
                session = chatClient.NewSession(personas[0])
        }</span>

        <span class="cov0" title="0">return Model{
                chatClient: chatClient,
                session:    session,
                personas:   personas,
                messages:   []Message{},
                style:      NewStyles(),
        }</span>
}

// Init initializes the model
func (m Model) Init() tea.Cmd <span class="cov0" title="0">{
        return tea.Batch(
                tea.EnterAltScreen,
                m.addSystemMessage("Welcome to ArchesAI TUI! Press Tab to switch agents, Ctrl+C to quit."),
        )
}</span>

// Update handles messages and updates the model
func (m Model) Update(msg tea.Msg) (tea.Model, tea.Cmd) <span class="cov0" title="0">{
        switch msg := msg.(type) </span>{
        case tea.KeyMsg:<span class="cov0" title="0">
                return m.handleKeyPress(msg)</span>

        case tea.WindowSizeMsg:<span class="cov0" title="0">
                m.width = msg.Width
                m.height = msg.Height
                return m, nil</span>

        case responseMsg:<span class="cov0" title="0">
                m.isProcessing = false
                if msg.err != nil </span><span class="cov0" title="0">{
                        m.err = msg.err
                        return m, nil
                }</span>
                <span class="cov0" title="0">agentName := ""
                if m.session != nil &amp;&amp; m.session.Persona != nil </span><span class="cov0" title="0">{
                        agentName = m.session.Persona.Name
                }</span>
                <span class="cov0" title="0">m.messages = append(m.messages, Message{
                        Role:    "assistant",
                        Content: msg.content,
                        Agent:   agentName,
                })
                return m, nil</span>

        case systemMsg:<span class="cov0" title="0">
                m.messages = append(m.messages, Message{
                        Role:    "system",
                        Content: msg.content,
                })
                return m, nil</span>
        }

        <span class="cov0" title="0">return m, nil</span>
}

// View renders the TUI
func (m Model) View() string <span class="cov0" title="0">{
        if m.width == 0 || m.height == 0 </span><span class="cov0" title="0">{
                return "Initializing..."
        }</span>

        <span class="cov0" title="0">var sections []string

        // Title
        title := m.style.Title.Render("🤖 ArchesAI Agent TUI")
        sections = append(sections, lipgloss.PlaceHorizontal(m.width, lipgloss.Center, title))

        // Current persona indicator
        if m.session != nil &amp;&amp; m.session.Persona != nil </span><span class="cov0" title="0">{
                agentInfo := m.style.Agent.Render(fmt.Sprintf("Current Agent: %s", m.session.Persona.Name))
                sections = append(sections, agentInfo)
        }</span>

        // Agent list (if showing)
        <span class="cov0" title="0">if m.showAgentList </span><span class="cov0" title="0">{
                sections = append(sections, m.renderAgentList())
        }</span>

        // Messages area
        <span class="cov0" title="0">messagesView := m.renderMessages()
        sections = append(sections, messagesView)

        // Error display
        if m.err != nil </span><span class="cov0" title="0">{
                errorMsg := m.style.Error.Render(fmt.Sprintf("Error: %v", m.err))
                sections = append(sections, errorMsg)
        }</span>

        // Processing indicator
        <span class="cov0" title="0">if m.isProcessing </span><span class="cov0" title="0">{
                processing := m.style.Processing.Render("🔄 Processing...")
                sections = append(sections, processing)
        }</span>

        // Input area
        <span class="cov0" title="0">inputPrompt := m.style.User.Render("You: ")
        inputBox := m.style.Input.Render(m.input)
        inputArea := lipgloss.JoinHorizontal(lipgloss.Left, inputPrompt, inputBox)
        sections = append(sections, inputArea)

        // Help text
        help := m.style.System.Render("Tab: Switch Agent | Enter: Send | Ctrl+C: Quit")
        sections = append(sections, help)

        return lipgloss.JoinVertical(lipgloss.Left, sections...)</span>
}

// handleKeyPress processes keyboard input
func (m Model) handleKeyPress(msg tea.KeyMsg) (tea.Model, tea.Cmd) <span class="cov0" title="0">{
        switch msg.Type </span>{
        case tea.KeyCtrlC:<span class="cov0" title="0">
                return m, tea.Quit</span>

        case tea.KeyTab:<span class="cov0" title="0">
                m.showAgentList = !m.showAgentList
                return m, nil</span>

        case tea.KeyUp:<span class="cov0" title="0">
                if m.showAgentList &amp;&amp; m.selectedAgent &gt; 0 </span><span class="cov0" title="0">{
                        m.selectedAgent--
                }</span>
                <span class="cov0" title="0">return m, nil</span>

        case tea.KeyDown:<span class="cov0" title="0">
                if m.showAgentList &amp;&amp; m.selectedAgent &lt; len(m.personas)-1 </span><span class="cov0" title="0">{
                        m.selectedAgent++
                }</span>
                <span class="cov0" title="0">return m, nil</span>

        case tea.KeyEnter:<span class="cov0" title="0">
                if m.showAgentList </span><span class="cov0" title="0">{
                        // Select persona
                        if m.selectedAgent &lt; len(m.personas) </span><span class="cov0" title="0">{
                                m.session = m.chatClient.NewSession(m.personas[m.selectedAgent])
                                m.showAgentList = false
                                return m, m.addSystemMessage(fmt.Sprintf("Switched to agent: %s", m.personas[m.selectedAgent].Name))
                        }</span>
                } else<span class="cov0" title="0"> if m.input != "" &amp;&amp; !m.isProcessing </span><span class="cov0" title="0">{
                        // Send message
                        m.messages = append(m.messages, Message{
                                Role:    "user",
                                Content: m.input,
                        })
                        m.isProcessing = true
                        cmd := m.sendMessage(m.input)
                        m.input = ""
                        return m, cmd
                }</span>
                <span class="cov0" title="0">return m, nil</span>

        case tea.KeyBackspace:<span class="cov0" title="0">
                if len(m.input) &gt; 0 </span><span class="cov0" title="0">{
                        m.input = m.input[:len(m.input)-1]
                }</span>
                <span class="cov0" title="0">return m, nil</span>

        default:<span class="cov0" title="0">
                if msg.Type == tea.KeyRunes </span><span class="cov0" title="0">{
                        m.input += string(msg.Runes)
                }</span>
        }

        <span class="cov0" title="0">return m, nil</span>
}

// renderMessages renders the message history
func (m Model) renderMessages() string <span class="cov0" title="0">{
        var messages []string

        availableHeight := m.height - 10 // Reserve space for UI elements
        if availableHeight &lt; 5 </span><span class="cov0" title="0">{
                availableHeight = 5
        }</span>

        <span class="cov0" title="0">for _, msg := range m.messages </span><span class="cov0" title="0">{
                var styled string
                switch msg.Role </span>{
                case "user":<span class="cov0" title="0">
                        styled = m.style.User.Render("You: ") + msg.Content</span>
                case "assistant":<span class="cov0" title="0">
                        agentLabel := ""
                        if msg.Agent != "" </span><span class="cov0" title="0">{
                                agentLabel = fmt.Sprintf("[%s] ", msg.Agent)
                        }</span>
                        <span class="cov0" title="0">styled = m.style.Agent.Render(agentLabel+"Assistant: ") +
                                m.style.Assistant.Render(msg.Content)</span>
                case "system":<span class="cov0" title="0">
                        styled = m.style.System.Render("System: " + msg.Content)</span>
                }
                <span class="cov0" title="0">messages = append(messages, styled)</span>
        }

        <span class="cov0" title="0">content := strings.Join(messages, "\n")

        // Create a bordered box for messages
        messageBox := m.style.Border.
                Width(m.width - 4).
                Height(availableHeight).
                Render(content)

        return messageBox</span>
}

// renderAgentList renders the list of available personas
func (m Model) renderAgentList() string <span class="cov0" title="0">{
        var items []string
        for i, persona := range m.personas </span><span class="cov0" title="0">{
                item := fmt.Sprintf("%d. %s", i+1, persona.Name)
                if i == m.selectedAgent </span><span class="cov0" title="0">{
                        item = m.style.Selected.Render(item)
                }</span>
                <span class="cov0" title="0">items = append(items, item)</span>
        }

        <span class="cov0" title="0">list := strings.Join(items, "\n")
        return m.style.AgentList.Render("Select Agent:\n" + list)</span>
}

// sendMessage sends a message to the current chat session
func (m Model) sendMessage(content string) tea.Cmd <span class="cov0" title="0">{
        return func() tea.Msg </span><span class="cov0" title="0">{
                if m.session == nil || m.chatClient == nil </span><span class="cov0" title="0">{
                        return responseMsg{
                                err: fmt.Errorf("no chat session or client initialized"),
                        }
                }</span>

                // Send message to chat client
                <span class="cov0" title="0">response, err := m.chatClient.SendMessage(context.Background(), m.session, content)
                if err != nil </span><span class="cov0" title="0">{
                        return responseMsg{err: err}
                }</span>

                <span class="cov0" title="0">return responseMsg{content: response.Content}</span>
        }
}

// addSystemMessage adds a system message
func (m Model) addSystemMessage(content string) tea.Cmd <span class="cov0" title="0">{
        return func() tea.Msg </span><span class="cov0" title="0">{
                return systemMsg{content: content}
        }</span>
}

// Message types for tea.Cmd
type responseMsg struct {
        content string
        err     error
}

type systemMsg struct {
        content string
}
</pre>
		
		<pre class="file" id="file162" style="display: none">// Code generated by codegen cache. DO NOT EDIT.
package users

import (
        "context"
        "time"

        genericcache "github.com/archesai/archesai/internal/cache"
        "github.com/google/uuid"
)

// ErrCacheMiss re-exported from generic cache package
var ErrCacheMiss = genericcache.ErrCacheMiss

// Cache provides caching operations for users domain.
type Cache interface {

        // User caching
        Get(ctx context.Context, id uuid.UUID) (*User, error)
        Set(ctx context.Context, entity *User, ttl time.Duration) error
        Delete(ctx context.Context, id uuid.UUID) error
        GetByEmail(ctx context.Context, email string) (*User, error)

        // Batch operations
        FlushAll(ctx context.Context) error
}

// NewNoOpCache creates a no-op cache using the generic NoOpCache with the adapter
func NewNoOpCache() Cache <span class="cov0" title="0">{
        return NewCacheAdapter(genericcache.NewNoOpCache[User]())
}</span>

// CacheAdapter adapts generic cache implementations to the domain Cache interface
type CacheAdapter struct {
        userCache genericcache.Cache[User]
}

// NewCacheAdapter creates a new cache adapter using generic caches
func NewCacheAdapter(userCache genericcache.Cache[User]) Cache <span class="cov0" title="0">{
        return &amp;CacheAdapter{
                userCache: userCache,
        }
}</span>

// Get retrieves user from cache by ID
func (a *CacheAdapter) Get(ctx context.Context, id uuid.UUID) (*User, error) <span class="cov0" title="0">{
        entity, err := a.userCache.Get(ctx, id.String())
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">if entity == nil </span><span class="cov0" title="0">{
                return nil, ErrCacheMiss
        }</span>
        <span class="cov0" title="0">return entity, nil</span>
}

// Set stores user in cache with TTL
func (a *CacheAdapter) Set(ctx context.Context, entity *User, ttl time.Duration) error <span class="cov0" title="0">{
        if entity == nil </span><span class="cov0" title="0">{
                return nil
        }</span>
        <span class="cov0" title="0">return a.userCache.Set(ctx, entity.Id.String(), entity, ttl)</span>
}

// Delete removes user from cache
func (a *CacheAdapter) Delete(ctx context.Context, id uuid.UUID) error <span class="cov0" title="0">{
        return a.userCache.Delete(ctx, id.String())
}</span>

// GetByEmail retrieves user from cache by email
func (a *CacheAdapter) GetByEmail(ctx context.Context, email string) (*User, error) <span class="cov0" title="0">{
        key := "email:" + email
        entity, err := a.userCache.Get(ctx, key)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">if entity == nil </span><span class="cov0" title="0">{
                return nil, ErrCacheMiss
        }</span>
        <span class="cov0" title="0">return entity, nil</span>
}

// FlushAll clears all cached data
func (a *CacheAdapter) FlushAll(ctx context.Context) error <span class="cov0" title="0">{
        if err := a.userCache.Clear(ctx); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov0" title="0">return nil</span>
}

// Ensure CacheAdapter implements Cache interface
var _ Cache = (*CacheAdapter)(nil)
</pre>
		
		<pre class="file" id="file163" style="display: none">// Code generated by codegen events. DO NOT EDIT.
package users

import (
        "context"
        "github.com/archesai/archesai/internal/events"
)

// Event type constants for users domain.
const (
        EventUserCreated        = "user.created"
        EventUserUpdated        = "user.updated"
        EventUserDeleted        = "user.deleted"
        EventUserEmail_verified = "user.email-verified"
)

// UserCreatedEvent represents a created event event for User.
type UserCreatedEvent struct {
        events.BaseEvent
        User *User `json:"user"`
}

// NewUserCreatedEvent creates a new User created event.
func NewUserCreatedEvent(entity *User) *UserCreatedEvent <span class="cov0" title="0">{
        return &amp;UserCreatedEvent{
                BaseEvent: events.NewBaseEvent("users", EventUserCreated),
                User:      entity,
        }
}</span>

// EventType returns the event type string.
func (e *UserCreatedEvent) EventType() string <span class="cov0" title="0">{
        return EventUserCreated
}</span>

// EventDomain returns the domain this event belongs to.
func (e *UserCreatedEvent) EventDomain() string <span class="cov0" title="0">{
        return "users"
}</span>

// EventData returns the actual event data.
func (e *UserCreatedEvent) EventData() interface{} <span class="cov0" title="0">{
        return e.User
}</span>

// UserUpdatedEvent represents a updated event event for User.
type UserUpdatedEvent struct {
        events.BaseEvent
        User *User `json:"user"`
}

// NewUserUpdatedEvent creates a new User updated event.
func NewUserUpdatedEvent(entity *User) *UserUpdatedEvent <span class="cov0" title="0">{
        return &amp;UserUpdatedEvent{
                BaseEvent: events.NewBaseEvent("users", EventUserUpdated),
                User:      entity,
        }
}</span>

// EventType returns the event type string.
func (e *UserUpdatedEvent) EventType() string <span class="cov0" title="0">{
        return EventUserUpdated
}</span>

// EventDomain returns the domain this event belongs to.
func (e *UserUpdatedEvent) EventDomain() string <span class="cov0" title="0">{
        return "users"
}</span>

// EventData returns the actual event data.
func (e *UserUpdatedEvent) EventData() interface{} <span class="cov0" title="0">{
        return e.User
}</span>

// UserDeletedEvent represents a deleted event event for User.
type UserDeletedEvent struct {
        events.BaseEvent
        User *User `json:"user"`
}

// NewUserDeletedEvent creates a new User deleted event.
func NewUserDeletedEvent(entity *User) *UserDeletedEvent <span class="cov0" title="0">{
        return &amp;UserDeletedEvent{
                BaseEvent: events.NewBaseEvent("users", EventUserDeleted),
                User:      entity,
        }
}</span>

// EventType returns the event type string.
func (e *UserDeletedEvent) EventType() string <span class="cov0" title="0">{
        return EventUserDeleted
}</span>

// EventDomain returns the domain this event belongs to.
func (e *UserDeletedEvent) EventDomain() string <span class="cov0" title="0">{
        return "users"
}</span>

// EventData returns the actual event data.
func (e *UserDeletedEvent) EventData() interface{} <span class="cov0" title="0">{
        return e.User
}</span>

// UserEmail_verifiedEvent represents a email_verified event event for User.
type UserEmail_verifiedEvent struct {
        events.BaseEvent
        User *User `json:"user"`
}

// NewUserEmail_verifiedEvent creates a new User email_verified event.
func NewUserEmail_verifiedEvent(entity *User) *UserEmail_verifiedEvent <span class="cov0" title="0">{
        return &amp;UserEmail_verifiedEvent{
                BaseEvent: events.NewBaseEvent("users", EventUserEmail_verified),
                User:      entity,
        }
}</span>

// EventType returns the event type string.
func (e *UserEmail_verifiedEvent) EventType() string <span class="cov0" title="0">{
        return EventUserEmail_verified
}</span>

// EventDomain returns the domain this event belongs to.
func (e *UserEmail_verifiedEvent) EventDomain() string <span class="cov0" title="0">{
        return "users"
}</span>

// EventData returns the actual event data.
func (e *UserEmail_verifiedEvent) EventData() interface{} <span class="cov0" title="0">{
        return e.User
}</span>

// EventPublisher publishes domain events for users.
type EventPublisher interface {
        PublishUserCreated(ctx context.Context, entity *User) error
        PublishUserUpdated(ctx context.Context, entity *User) error
        PublishUserDeleted(ctx context.Context, entity *User) error
        PublishUserEmail_verified(ctx context.Context, entity *User) error
}

// eventPublisher implements EventPublisher for users domain.
type eventPublisher struct {
        publisher events.Publisher
}

// NewEventPublisher creates a new event publisher for users domain.
func NewEventPublisher(publisher events.Publisher) EventPublisher <span class="cov0" title="0">{
        return &amp;eventPublisher{
                publisher: publisher,
        }
}</span>

// PublishUserCreated publishes a created event event for User.
func (p *eventPublisher) PublishUserCreated(ctx context.Context, entity *User) error <span class="cov0" title="0">{
        event := NewUserCreatedEvent(entity)
        return events.PublishDomainEvent(ctx, p.publisher, event)
}</span>

// PublishUserUpdated publishes a updated event event for User.
func (p *eventPublisher) PublishUserUpdated(ctx context.Context, entity *User) error <span class="cov0" title="0">{
        event := NewUserUpdatedEvent(entity)
        return events.PublishDomainEvent(ctx, p.publisher, event)
}</span>

// PublishUserDeleted publishes a deleted event event for User.
func (p *eventPublisher) PublishUserDeleted(ctx context.Context, entity *User) error <span class="cov0" title="0">{
        event := NewUserDeletedEvent(entity)
        return events.PublishDomainEvent(ctx, p.publisher, event)
}</span>

// PublishUserEmail_verified publishes a email_verified event event for User.
func (p *eventPublisher) PublishUserEmail_verified(ctx context.Context, entity *User) error <span class="cov0" title="0">{
        event := NewUserEmail_verifiedEvent(entity)
        return events.PublishDomainEvent(ctx, p.publisher, event)
}</span>

// NewNoOpEventPublisher creates a new no-op event publisher for testing.
func NewNoOpEventPublisher() EventPublisher <span class="cov0" title="0">{
        return NewEventPublisher(events.NewNoOpPublisher())
}</span>
</pre>
		
		<pre class="file" id="file164" style="display: none">package users

import (
        "context"
        "log/slog"

        "github.com/google/uuid"
)

// Handler provides HTTP handlers for user operations
type Handler struct {
        service *Service
        logger  *slog.Logger
}

// Ensure Handler implements StrictServerInterface
var _ StrictServerInterface = (*Handler)(nil)

// NewHandler creates a new user handler
func NewHandler(service *Service, logger *slog.Logger) *Handler <span class="cov0" title="0">{
        return &amp;Handler{
                service: service,
                logger:  logger,
        }
}</span>

// NewUserStrictHandler creates a StrictHandler with middleware
func NewUserStrictHandler(handler StrictServerInterface) ServerInterface <span class="cov0" title="0">{
        return NewStrictHandler(handler, nil)
}</span>

// GetOneUser handles getting a single user
func (h *Handler) GetOneUser(ctx context.Context, req GetOneUserRequestObject) (GetOneUserResponseObject, error) <span class="cov0" title="0">{
        userID, err := uuid.Parse(req.Id.String())
        if err != nil </span><span class="cov0" title="0">{
                return GetOneUser404ApplicationProblemPlusJSONResponse{
                        NotFoundApplicationProblemPlusJSONResponse: NotFoundApplicationProblemPlusJSONResponse{
                                Title:  "Invalid user ID",
                                Status: 400,
                                Type:   "invalid-user-id",
                                Detail: "The provided user ID is not a valid UUID",
                        },
                }, nil
        }</span>

        <span class="cov0" title="0">user, err := h.service.Get(ctx, userID)
        if err != nil </span><span class="cov0" title="0">{
                switch err </span>{
                case ErrUserNotFound:<span class="cov0" title="0">
                        return GetOneUser404ApplicationProblemPlusJSONResponse{
                                NotFoundApplicationProblemPlusJSONResponse: NotFoundApplicationProblemPlusJSONResponse{
                                        Title:  "User not found",
                                        Status: 404,
                                        Type:   "user-not-found",
                                        Detail: "The requested user could not be found",
                                },
                        }, nil</span>
                default:<span class="cov0" title="0">
                        h.logger.Error("failed to get user", "error", err)
                        return GetOneUser404ApplicationProblemPlusJSONResponse{
                                NotFoundApplicationProblemPlusJSONResponse: NotFoundApplicationProblemPlusJSONResponse{
                                        Title:  "Internal server error",
                                        Status: 500,
                                        Type:   "internal-error",
                                        Detail: "An internal error occurred while retrieving the user",
                                },
                        }, nil</span>
                }
        }

        <span class="cov0" title="0">return GetOneUser200JSONResponse{
                Data: *user,
        }, nil</span>
}

// UpdateUser handles updating a user
func (h *Handler) UpdateUser(ctx context.Context, req UpdateUserRequestObject) (UpdateUserResponseObject, error) <span class="cov0" title="0">{
        userID, err := uuid.Parse(req.Id.String())
        if err != nil </span><span class="cov0" title="0">{
                return UpdateUser404ApplicationProblemPlusJSONResponse{
                        NotFoundApplicationProblemPlusJSONResponse: NotFoundApplicationProblemPlusJSONResponse{
                                Title:  "Invalid user ID",
                                Status: 400,
                                Type:   "invalid-user-id",
                                Detail: "The provided user ID is not a valid UUID",
                        },
                }, nil
        }</span>

        <span class="cov0" title="0">updateReq := &amp;UpdateUserJSONBody{}
        if req.Body != nil </span><span class="cov0" title="0">{
                updateReq.Email = req.Body.Email
                updateReq.Image = req.Body.Image
        }</span>

        <span class="cov0" title="0">user, err := h.service.Update(ctx, userID, updateReq)
        if err != nil </span><span class="cov0" title="0">{
                switch err </span>{
                case ErrUserNotFound:<span class="cov0" title="0">
                        return UpdateUser404ApplicationProblemPlusJSONResponse{
                                NotFoundApplicationProblemPlusJSONResponse: NotFoundApplicationProblemPlusJSONResponse{
                                        Title:  "User not found",
                                        Status: 404,
                                        Type:   "user-not-found",
                                        Detail: "The requested user could not be found",
                                },
                        }, nil</span>
                default:<span class="cov0" title="0">
                        h.logger.Error("failed to update user", "error", err)
                        return UpdateUser404ApplicationProblemPlusJSONResponse{
                                NotFoundApplicationProblemPlusJSONResponse: NotFoundApplicationProblemPlusJSONResponse{
                                        Title:  "Internal server error",
                                        Status: 500,
                                        Type:   "internal-error",
                                        Detail: "An internal error occurred while updating the user",
                                },
                        }, nil</span>
                }
        }

        <span class="cov0" title="0">return UpdateUser200JSONResponse{
                Data: *user,
        }, nil</span>
}

// DeleteUser handles deleting a user
func (h *Handler) DeleteUser(ctx context.Context, req DeleteUserRequestObject) (DeleteUserResponseObject, error) <span class="cov0" title="0">{
        userID, err := uuid.Parse(req.Id.String())
        if err != nil </span><span class="cov0" title="0">{
                return DeleteUser404ApplicationProblemPlusJSONResponse{
                        NotFoundApplicationProblemPlusJSONResponse: NotFoundApplicationProblemPlusJSONResponse{
                                Title:  "Invalid user ID",
                                Status: 400,
                                Type:   "invalid-user-id",
                                Detail: "The provided user ID is not a valid UUID",
                        },
                }, nil
        }</span>

        // Get the user first for the response
        <span class="cov0" title="0">user, err := h.service.Get(ctx, userID)
        if err != nil </span><span class="cov0" title="0">{
                switch err </span>{
                case ErrUserNotFound:<span class="cov0" title="0">
                        return DeleteUser404ApplicationProblemPlusJSONResponse{
                                NotFoundApplicationProblemPlusJSONResponse: NotFoundApplicationProblemPlusJSONResponse{
                                        Title:  "User not found",
                                        Status: 404,
                                        Type:   "user-not-found",
                                        Detail: "The requested user could not be found",
                                },
                        }, nil</span>
                default:<span class="cov0" title="0">
                        h.logger.Error("failed to get user for deletion", "error", err)
                        return DeleteUser404ApplicationProblemPlusJSONResponse{
                                NotFoundApplicationProblemPlusJSONResponse: NotFoundApplicationProblemPlusJSONResponse{
                                        Title:  "Internal server error",
                                        Status: 500,
                                        Type:   "internal-error",
                                        Detail: "An internal error occurred while retrieving the user",
                                },
                        }, nil</span>
                }
        }

        <span class="cov0" title="0">err = h.service.Delete(ctx, userID)
        if err != nil </span><span class="cov0" title="0">{
                h.logger.Error("failed to delete user", "error", err)
                return DeleteUser404ApplicationProblemPlusJSONResponse{
                        NotFoundApplicationProblemPlusJSONResponse: NotFoundApplicationProblemPlusJSONResponse{
                                Title:  "Internal server error",
                                Status: 500,
                                Type:   "internal-error",
                                Detail: "An internal error occurred while deleting the user",
                        },
                }, nil
        }</span>

        <span class="cov0" title="0">return DeleteUser200JSONResponse{
                Data: *user,
        }, nil</span>
}

// FindManyUsers handles listing multiple users
func (h *Handler) FindManyUsers(ctx context.Context, req FindManyUsersRequestObject) (FindManyUsersResponseObject, error) <span class="cov0" title="0">{
        limit := int32(50) // Default limit
        offset := int32(0) // Default offset

        // Extract pagination from request if provided
        if req.Params.Page.Size &gt; 0 </span><span class="cov0" title="0">{
                limit = int32(req.Params.Page.Size)
        }</span>
        <span class="cov0" title="0">if req.Params.Page.Number &gt; 0 </span><span class="cov0" title="0">{
                offset = int32((req.Params.Page.Number - 1) * int(limit))
        }</span>

        <span class="cov0" title="0">users, err := h.service.List(ctx, limit, offset)
        if err != nil </span><span class="cov0" title="0">{
                h.logger.Error("failed to list users", "error", err)
                return FindManyUsers400ApplicationProblemPlusJSONResponse{
                        BadRequestApplicationProblemPlusJSONResponse: BadRequestApplicationProblemPlusJSONResponse{
                                Title:  "Internal server error",
                                Status: 500,
                                Type:   "internal-error",
                                Detail: "An internal error occurred while retrieving users",
                        },
                }, nil
        }</span>

        // Convert to response format
        <span class="cov0" title="0">responseUsers := make([]User, len(users))
        for i, user := range users </span><span class="cov0" title="0">{
                responseUsers[i] = *user
        }</span>

        <span class="cov0" title="0">response := FindManyUsers200JSONResponse{
                Data: responseUsers,
        }
        response.Meta.Total = float32(len(responseUsers)) // In a real implementation, this would be the total count

        return response, nil</span>
}
</pre>
		
		<pre class="file" id="file165" style="display: none">// Package users provides primitives to interact with the openapi HTTP API.
//
// Code generated by github.com/oapi-codegen/oapi-codegen/v2 version v2.5.0 DO NOT EDIT.
package users

import (
        "context"
        "encoding/json"
        "fmt"
        "net/http"

        "github.com/labstack/echo/v4"
        "github.com/oapi-codegen/runtime"
        strictecho "github.com/oapi-codegen/runtime/strictmiddleware/echo"
        openapi_types "github.com/oapi-codegen/runtime/types"
)

// ServerInterface represents all server handlers.
type ServerInterface interface {
        // Find many users
        // (GET /auth/users)
        FindManyUsers(ctx echo.Context, params FindManyUsersParams) error
        // Delete an user
        // (DELETE /auth/users/{id})
        DeleteUser(ctx echo.Context, id openapi_types.UUID) error
        // Find an user
        // (GET /auth/users/{id})
        GetOneUser(ctx echo.Context, id openapi_types.UUID) error
        // Update an user
        // (PATCH /auth/users/{id})
        UpdateUser(ctx echo.Context, id openapi_types.UUID) error
}

// ServerInterfaceWrapper converts echo contexts to parameters.
type ServerInterfaceWrapper struct {
        Handler ServerInterface
}

// FindManyUsers converts echo context to params.
func (w *ServerInterfaceWrapper) FindManyUsers(ctx echo.Context) error <span class="cov0" title="0">{
        var err error

        ctx.Set(BearerAuthScopes, []string{})

        // Parameter object where we will unmarshal all parameters from the context
        var params FindManyUsersParams
        // ------------- Optional query parameter "filter" -------------

        err = runtime.BindQueryParameter("deepObject", true, false, "filter", ctx.QueryParams(), &amp;params.Filter)
        if err != nil </span><span class="cov0" title="0">{
                return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter filter: %s", err))
        }</span>

        // ------------- Optional query parameter "page" -------------

        <span class="cov0" title="0">err = runtime.BindQueryParameter("form", true, false, "page", ctx.QueryParams(), &amp;params.Page)
        if err != nil </span><span class="cov0" title="0">{
                return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter page: %s", err))
        }</span>

        // ------------- Optional query parameter "sort" -------------

        <span class="cov0" title="0">err = runtime.BindQueryParameter("form", true, false, "sort", ctx.QueryParams(), &amp;params.Sort)
        if err != nil </span><span class="cov0" title="0">{
                return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter sort: %s", err))
        }</span>

        // Invoke the callback with all the unmarshaled arguments
        <span class="cov0" title="0">err = w.Handler.FindManyUsers(ctx, params)
        return err</span>
}

// DeleteUser converts echo context to params.
func (w *ServerInterfaceWrapper) DeleteUser(ctx echo.Context) error <span class="cov0" title="0">{
        var err error
        // ------------- Path parameter "id" -------------
        var id openapi_types.UUID

        err = runtime.BindStyledParameterWithOptions("simple", "id", ctx.Param("id"), &amp;id, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
        if err != nil </span><span class="cov0" title="0">{
                return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter id: %s", err))
        }</span>

        <span class="cov0" title="0">ctx.Set(BearerAuthScopes, []string{})

        // Invoke the callback with all the unmarshaled arguments
        err = w.Handler.DeleteUser(ctx, id)
        return err</span>
}

// GetOneUser converts echo context to params.
func (w *ServerInterfaceWrapper) GetOneUser(ctx echo.Context) error <span class="cov0" title="0">{
        var err error
        // ------------- Path parameter "id" -------------
        var id openapi_types.UUID

        err = runtime.BindStyledParameterWithOptions("simple", "id", ctx.Param("id"), &amp;id, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
        if err != nil </span><span class="cov0" title="0">{
                return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter id: %s", err))
        }</span>

        <span class="cov0" title="0">ctx.Set(BearerAuthScopes, []string{})

        // Invoke the callback with all the unmarshaled arguments
        err = w.Handler.GetOneUser(ctx, id)
        return err</span>
}

// UpdateUser converts echo context to params.
func (w *ServerInterfaceWrapper) UpdateUser(ctx echo.Context) error <span class="cov0" title="0">{
        var err error
        // ------------- Path parameter "id" -------------
        var id openapi_types.UUID

        err = runtime.BindStyledParameterWithOptions("simple", "id", ctx.Param("id"), &amp;id, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
        if err != nil </span><span class="cov0" title="0">{
                return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter id: %s", err))
        }</span>

        <span class="cov0" title="0">ctx.Set(BearerAuthScopes, []string{})

        // Invoke the callback with all the unmarshaled arguments
        err = w.Handler.UpdateUser(ctx, id)
        return err</span>
}

// This is a simple interface which specifies echo.Route addition functions which
// are present on both echo.Echo and echo.Group, since we want to allow using
// either of them for path registration
type EchoRouter interface {
        CONNECT(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
        DELETE(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
        GET(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
        HEAD(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
        OPTIONS(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
        PATCH(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
        POST(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
        PUT(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
        TRACE(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
}

// RegisterHandlers adds each server route to the EchoRouter.
func RegisterHandlers(router EchoRouter, si ServerInterface) <span class="cov0" title="0">{
        RegisterHandlersWithBaseURL(router, si, "")
}</span>

// Registers handlers, and prepends BaseURL to the paths, so that the paths
// can be served under a prefix.
func RegisterHandlersWithBaseURL(router EchoRouter, si ServerInterface, baseURL string) <span class="cov0" title="0">{

        wrapper := ServerInterfaceWrapper{
                Handler: si,
        }

        router.GET(baseURL+"/auth/users", wrapper.FindManyUsers)
        router.DELETE(baseURL+"/auth/users/:id", wrapper.DeleteUser)
        router.GET(baseURL+"/auth/users/:id", wrapper.GetOneUser)
        router.PATCH(baseURL+"/auth/users/:id", wrapper.UpdateUser)

}</span>

type BadRequestApplicationProblemPlusJSONResponse Problem

type NotFoundApplicationProblemPlusJSONResponse Problem

type UnauthorizedApplicationProblemPlusJSONResponse Problem

type FindManyUsersRequestObject struct {
        Params FindManyUsersParams
}

type FindManyUsersResponseObject interface {
        VisitFindManyUsersResponse(w http.ResponseWriter) error
}

type FindManyUsers200JSONResponse struct {
        Data []User `json:"data"`
        Meta struct {
                // Total Total number of items in the collection
                Total float32 `json:"total"`
        } `json:"meta"`
}

func (response FindManyUsers200JSONResponse) VisitFindManyUsersResponse(w http.ResponseWriter) error <span class="cov0" title="0">{
        w.Header().Set("Content-Type", "application/json")
        w.WriteHeader(200)

        return json.NewEncoder(w).Encode(response)
}</span>

type FindManyUsers400ApplicationProblemPlusJSONResponse struct {
        BadRequestApplicationProblemPlusJSONResponse
}

func (response FindManyUsers400ApplicationProblemPlusJSONResponse) VisitFindManyUsersResponse(w http.ResponseWriter) error <span class="cov0" title="0">{
        w.Header().Set("Content-Type", "application/problem+json")
        w.WriteHeader(400)

        return json.NewEncoder(w).Encode(response)
}</span>

type FindManyUsers401ApplicationProblemPlusJSONResponse struct {
        UnauthorizedApplicationProblemPlusJSONResponse
}

func (response FindManyUsers401ApplicationProblemPlusJSONResponse) VisitFindManyUsersResponse(w http.ResponseWriter) error <span class="cov0" title="0">{
        w.Header().Set("Content-Type", "application/problem+json")
        w.WriteHeader(401)

        return json.NewEncoder(w).Encode(response)
}</span>

type DeleteUserRequestObject struct {
        Id openapi_types.UUID `json:"id"`
}

type DeleteUserResponseObject interface {
        VisitDeleteUserResponse(w http.ResponseWriter) error
}

type DeleteUser200JSONResponse struct {
        // Data Schema for User entity
        Data User `json:"data"`
}

func (response DeleteUser200JSONResponse) VisitDeleteUserResponse(w http.ResponseWriter) error <span class="cov0" title="0">{
        w.Header().Set("Content-Type", "application/json")
        w.WriteHeader(200)

        return json.NewEncoder(w).Encode(response)
}</span>

type DeleteUser404ApplicationProblemPlusJSONResponse struct {
        NotFoundApplicationProblemPlusJSONResponse
}

func (response DeleteUser404ApplicationProblemPlusJSONResponse) VisitDeleteUserResponse(w http.ResponseWriter) error <span class="cov0" title="0">{
        w.Header().Set("Content-Type", "application/problem+json")
        w.WriteHeader(404)

        return json.NewEncoder(w).Encode(response)
}</span>

type GetOneUserRequestObject struct {
        Id openapi_types.UUID `json:"id"`
}

type GetOneUserResponseObject interface {
        VisitGetOneUserResponse(w http.ResponseWriter) error
}

type GetOneUser200JSONResponse struct {
        // Data Schema for User entity
        Data User `json:"data"`
}

func (response GetOneUser200JSONResponse) VisitGetOneUserResponse(w http.ResponseWriter) error <span class="cov0" title="0">{
        w.Header().Set("Content-Type", "application/json")
        w.WriteHeader(200)

        return json.NewEncoder(w).Encode(response)
}</span>

type GetOneUser404ApplicationProblemPlusJSONResponse struct {
        NotFoundApplicationProblemPlusJSONResponse
}

func (response GetOneUser404ApplicationProblemPlusJSONResponse) VisitGetOneUserResponse(w http.ResponseWriter) error <span class="cov0" title="0">{
        w.Header().Set("Content-Type", "application/problem+json")
        w.WriteHeader(404)

        return json.NewEncoder(w).Encode(response)
}</span>

type UpdateUserRequestObject struct {
        Id   openapi_types.UUID `json:"id"`
        Body *UpdateUserJSONRequestBody
}

type UpdateUserResponseObject interface {
        VisitUpdateUserResponse(w http.ResponseWriter) error
}

type UpdateUser200JSONResponse struct {
        // Data Schema for User entity
        Data User `json:"data"`
}

func (response UpdateUser200JSONResponse) VisitUpdateUserResponse(w http.ResponseWriter) error <span class="cov0" title="0">{
        w.Header().Set("Content-Type", "application/json")
        w.WriteHeader(200)

        return json.NewEncoder(w).Encode(response)
}</span>

type UpdateUser404ApplicationProblemPlusJSONResponse struct {
        NotFoundApplicationProblemPlusJSONResponse
}

func (response UpdateUser404ApplicationProblemPlusJSONResponse) VisitUpdateUserResponse(w http.ResponseWriter) error <span class="cov0" title="0">{
        w.Header().Set("Content-Type", "application/problem+json")
        w.WriteHeader(404)

        return json.NewEncoder(w).Encode(response)
}</span>

// StrictServerInterface represents all server handlers.
type StrictServerInterface interface {
        // Find many users
        // (GET /auth/users)
        FindManyUsers(ctx context.Context, request FindManyUsersRequestObject) (FindManyUsersResponseObject, error)
        // Delete an user
        // (DELETE /auth/users/{id})
        DeleteUser(ctx context.Context, request DeleteUserRequestObject) (DeleteUserResponseObject, error)
        // Find an user
        // (GET /auth/users/{id})
        GetOneUser(ctx context.Context, request GetOneUserRequestObject) (GetOneUserResponseObject, error)
        // Update an user
        // (PATCH /auth/users/{id})
        UpdateUser(ctx context.Context, request UpdateUserRequestObject) (UpdateUserResponseObject, error)
}

type StrictHandlerFunc = strictecho.StrictEchoHandlerFunc
type StrictMiddlewareFunc = strictecho.StrictEchoMiddlewareFunc

func NewStrictHandler(ssi StrictServerInterface, middlewares []StrictMiddlewareFunc) ServerInterface <span class="cov0" title="0">{
        return &amp;strictHandler{ssi: ssi, middlewares: middlewares}
}</span>

type strictHandler struct {
        ssi         StrictServerInterface
        middlewares []StrictMiddlewareFunc
}

// FindManyUsers operation middleware
func (sh *strictHandler) FindManyUsers(ctx echo.Context, params FindManyUsersParams) error <span class="cov0" title="0">{
        var request FindManyUsersRequestObject

        request.Params = params

        handler := func(ctx echo.Context, request interface{}) (interface{}, error) </span><span class="cov0" title="0">{
                return sh.ssi.FindManyUsers(ctx.Request().Context(), request.(FindManyUsersRequestObject))
        }</span>
        <span class="cov0" title="0">for _, middleware := range sh.middlewares </span><span class="cov0" title="0">{
                handler = middleware(handler, "FindManyUsers")
        }</span>

        <span class="cov0" title="0">response, err := handler(ctx, request)

        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span> else<span class="cov0" title="0"> if validResponse, ok := response.(FindManyUsersResponseObject); ok </span><span class="cov0" title="0">{
                return validResponse.VisitFindManyUsersResponse(ctx.Response())
        }</span> else<span class="cov0" title="0"> if response != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("unexpected response type: %T", response)
        }</span>
        <span class="cov0" title="0">return nil</span>
}

// DeleteUser operation middleware
func (sh *strictHandler) DeleteUser(ctx echo.Context, id openapi_types.UUID) error <span class="cov0" title="0">{
        var request DeleteUserRequestObject

        request.Id = id

        handler := func(ctx echo.Context, request interface{}) (interface{}, error) </span><span class="cov0" title="0">{
                return sh.ssi.DeleteUser(ctx.Request().Context(), request.(DeleteUserRequestObject))
        }</span>
        <span class="cov0" title="0">for _, middleware := range sh.middlewares </span><span class="cov0" title="0">{
                handler = middleware(handler, "DeleteUser")
        }</span>

        <span class="cov0" title="0">response, err := handler(ctx, request)

        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span> else<span class="cov0" title="0"> if validResponse, ok := response.(DeleteUserResponseObject); ok </span><span class="cov0" title="0">{
                return validResponse.VisitDeleteUserResponse(ctx.Response())
        }</span> else<span class="cov0" title="0"> if response != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("unexpected response type: %T", response)
        }</span>
        <span class="cov0" title="0">return nil</span>
}

// GetOneUser operation middleware
func (sh *strictHandler) GetOneUser(ctx echo.Context, id openapi_types.UUID) error <span class="cov0" title="0">{
        var request GetOneUserRequestObject

        request.Id = id

        handler := func(ctx echo.Context, request interface{}) (interface{}, error) </span><span class="cov0" title="0">{
                return sh.ssi.GetOneUser(ctx.Request().Context(), request.(GetOneUserRequestObject))
        }</span>
        <span class="cov0" title="0">for _, middleware := range sh.middlewares </span><span class="cov0" title="0">{
                handler = middleware(handler, "GetOneUser")
        }</span>

        <span class="cov0" title="0">response, err := handler(ctx, request)

        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span> else<span class="cov0" title="0"> if validResponse, ok := response.(GetOneUserResponseObject); ok </span><span class="cov0" title="0">{
                return validResponse.VisitGetOneUserResponse(ctx.Response())
        }</span> else<span class="cov0" title="0"> if response != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("unexpected response type: %T", response)
        }</span>
        <span class="cov0" title="0">return nil</span>
}

// UpdateUser operation middleware
func (sh *strictHandler) UpdateUser(ctx echo.Context, id openapi_types.UUID) error <span class="cov0" title="0">{
        var request UpdateUserRequestObject

        request.Id = id

        var body UpdateUserJSONRequestBody
        if err := ctx.Bind(&amp;body); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov0" title="0">request.Body = &amp;body

        handler := func(ctx echo.Context, request interface{}) (interface{}, error) </span><span class="cov0" title="0">{
                return sh.ssi.UpdateUser(ctx.Request().Context(), request.(UpdateUserRequestObject))
        }</span>
        <span class="cov0" title="0">for _, middleware := range sh.middlewares </span><span class="cov0" title="0">{
                handler = middleware(handler, "UpdateUser")
        }</span>

        <span class="cov0" title="0">response, err := handler(ctx, request)

        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span> else<span class="cov0" title="0"> if validResponse, ok := response.(UpdateUserResponseObject); ok </span><span class="cov0" title="0">{
                return validResponse.VisitUpdateUserResponse(ctx.Response())
        }</span> else<span class="cov0" title="0"> if response != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("unexpected response type: %T", response)
        }</span>
        <span class="cov0" title="0">return nil</span>
}
</pre>
		
		<pre class="file" id="file166" style="display: none">// Code generated by codegen repository. DO NOT EDIT.
package users

import (
        "context"
        "errors"

        "github.com/archesai/archesai/internal/database/postgresql"
        "github.com/google/uuid"
        "github.com/jackc/pgx/v5/pgxpool"
)

// PostgresRepository implements Repository using PostgreSQL.
type PostgresRepository struct {
        db      *pgxpool.Pool
        queries *postgresql.Queries
}

// NewPostgresRepository creates a new PostgreSQL repository.
func NewPostgresRepository(db *pgxpool.Pool) Repository <span class="cov0" title="0">{
        return &amp;PostgresRepository{
                db:      db,
                queries: postgresql.New(db),
        }
}</span>

// User operations

func (r *PostgresRepository) Create(ctx context.Context, entity *User) (*User, error) <span class="cov0" title="0">{
        // Check if SQLC has the CreateUser method
        // For now, we'll generate a stub but with proper error handling
        // TODO: Parse SQLC to detect available queries

        // Example of what it should look like when SQLC query exists:
        // params := postgresql.CreateUserParams{
        //     Id: entity.Id,
        //     // ... map other fields
        // }
        // dbUser, err := r.queries.CreateUser(ctx, params)
        // if err != nil {
        //     return nil, NewRepositoryError("create", err)
        // }
        // return mapUserToDomain(&amp;dbUser), nil

        return nil, NewRepositoryError("create", errors.New("not implemented - SQLC query not found"))
}</span>

func (r *PostgresRepository) Get(ctx context.Context, id uuid.UUID) (*User, error) <span class="cov0" title="0">{
        // Try to call SQLC GetUser if it exists
        // For now, return not implemented
        return nil, NewRepositoryError("get", errors.New("not implemented - SQLC query not found"))
}</span>

func (r *PostgresRepository) Update(ctx context.Context, id uuid.UUID, entity *User) (*User, error) <span class="cov0" title="0">{
        // Update operations are often custom and may not have SQLC queries
        return nil, NewRepositoryError("update", errors.New("not implemented - SQLC query not found"))
}</span>

func (r *PostgresRepository) Delete(ctx context.Context, id uuid.UUID) error <span class="cov0" title="0">{
        // Try to call SQLC DeleteUser if it exists
        // For now, return not implemented
        return NewRepositoryError("delete", errors.New("not implemented - SQLC query not found"))
}</span>

func (r *PostgresRepository) List(ctx context.Context, params ListUsersParams) ([]*User, int64, error) <span class="cov0" title="0">{
        // List operations need both List and Count queries from SQLC
        return nil, 0, NewRepositoryError("list", errors.New("not implemented - SQLC query not found"))
}</span>

// GetByEmail retrieves user by email
func (r *PostgresRepository) GetByEmail(ctx context.Context, email string) (*User, error) <span class="cov0" title="0">{

        // Try to call SQLC GetByEmail if it exists
        // For now, return not implemented
        return nil, NewRepositoryError("getbyemail", errors.New("not implemented - SQLC query not found"))

}</span>

// Mapper functions - Convert between domain types and database types
// These need to be customized based on the actual field mappings

func mapUserToDomain(db *postgresql.User) *User <span class="cov0" title="0">{
        if db == nil </span><span class="cov0" title="0">{
                return nil
        }</span>

        // This is a basic mapping - needs to be customized based on actual types
        // The challenge is that OpenAPI types and database types don't always match
        // For example:
        // - OpenAPI might use string, database uses *string
        // - OpenAPI might use custom UUID type, database uses uuid.UUID
        // - Field names might differ (Id vs ID)

        <span class="cov0" title="0">result := &amp;User{
                // TODO: Map fields properly based on actual type definitions
                // This requires parsing both OpenAPI types and SQLC types
        }

        // Basic field mapping - customize based on your entity structure
        // result.Id = db.Id
        // result.CreatedAt = db.CreatedAt
        // result.UpdatedAt = db.UpdatedAt
        // Add specific field mappings as needed

        return result</span>
}
</pre>
		
		<pre class="file" id="file167" style="display: none">// Code generated by codegen repository. DO NOT EDIT.
package users

import (
        "context"
        "fmt"
        "github.com/google/uuid"
)

// Repository handles user persistence
type Repository interface {
        Create(ctx context.Context, entity *User) (*User, error)
        Get(ctx context.Context, id uuid.UUID) (*User, error)
        Update(ctx context.Context, id uuid.UUID, entity *User) (*User, error)
        Delete(ctx context.Context, id uuid.UUID) error
        List(ctx context.Context, params ListUsersParams) ([]*User, int64, error)

        // Additional operations
        GetByEmail(ctx context.Context, email string) (*User, error)
}

// ListUsersParams represents parameters for listing users.
type ListUsersParams struct {
        Limit  int
        Offset int
        Email  *string
        Name   *string
}

// RepositoryError represents a repository error.
type RepositoryError struct {
        Operation string
        Err       error
}

func (e *RepositoryError) Error() string <span class="cov0" title="0">{
        return fmt.Sprintf("repository %s: %v", e.Operation, e.Err)
}</span>

func (e *RepositoryError) Unwrap() error <span class="cov0" title="0">{
        return e.Err
}</span>

// NewRepositoryError creates a new repository error.
func NewRepositoryError(operation string, err error) *RepositoryError <span class="cov0" title="0">{
        return &amp;RepositoryError{
                Operation: operation,
                Err:       err,
        }
}</span>
</pre>
		
		<pre class="file" id="file168" style="display: none">package users

import (
        "context"
        "log/slog"
        "time"

        "github.com/google/uuid"
)

// Service provides user management business logic
type Service struct {
        repo   Repository
        cache  Cache
        events EventPublisher
        logger *slog.Logger
}

// NewService creates a new user service
func NewService(repo Repository, cache Cache, events EventPublisher, logger *slog.Logger) *Service <span class="cov10" title="14">{
        return &amp;Service{
                repo:   repo,
                cache:  cache,
                events: events,
                logger: logger,
        }
}</span>

// Get retrieves a user by ID
func (s *Service) Get(ctx context.Context, id uuid.UUID) (*User, error) <span class="cov5" title="4">{
        // Try cache first
        user, err := s.cache.Get(ctx, id)
        if err == nil &amp;&amp; user != nil </span><span class="cov1" title="1">{
                return user, nil
        }</span>

        // Cache miss - get from database
        <span class="cov4" title="3">entity, err := s.repo.Get(ctx, id)
        if err != nil </span><span class="cov3" title="2">{
                return nil, err
        }</span>

        // Update cache for next time
        <span class="cov1" title="1">_ = s.cache.Set(ctx, entity, 5*time.Minute)

        return entity, nil</span>
}

// Update updates user information
func (s *Service) Update(ctx context.Context, id uuid.UUID, req *UpdateUserJSONBody) (*User, error) <span class="cov3" title="2">{
        // Get existing user
        entity, err := s.repo.Get(ctx, id)
        if err != nil </span><span class="cov1" title="1">{
                return nil, err
        }</span>

        // Update fields if provided
        <span class="cov1" title="1">if req.Email != "" </span><span class="cov1" title="1">{
                entity.Email = Email(req.Email)
        }</span>
        <span class="cov1" title="1">if req.Image != "" </span><span class="cov0" title="0">{
                entity.Image = req.Image
        }</span>
        <span class="cov1" title="1">entity.UpdatedAt = time.Now()

        // Save changes
        updatedEntity, err := s.repo.Update(ctx, id, entity)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        // Update cache
        <span class="cov1" title="1">_ = s.cache.Set(ctx, updatedEntity, 5*time.Minute)

        // Publish event
        _ = s.events.PublishUserUpdated(ctx, updatedEntity)

        return updatedEntity, nil</span>
}

// Delete deletes a user
func (s *Service) Delete(ctx context.Context, id uuid.UUID) error <span class="cov3" title="2">{
        // Get user first for event publishing
        user, err := s.repo.Get(ctx, id)
        if err != nil </span><span class="cov1" title="1">{
                return err
        }</span>

        // Delete from repository
        <span class="cov1" title="1">err = s.repo.Delete(ctx, id)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        // Remove from cache
        <span class="cov1" title="1">_ = s.cache.Delete(ctx, id)

        // Publish event
        _ = s.events.PublishUserDeleted(ctx, user)

        return nil</span>
}

// List lists users with pagination
func (s *Service) List(ctx context.Context, limit, offset int32) ([]*User, error) <span class="cov3" title="2">{
        params := ListUsersParams{
                Limit:  int(limit),
                Offset: int(offset),
        }
        entities, _, err := s.repo.List(ctx, params)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov3" title="2">users := make([]*User, len(entities))
        copy(users, entities)
        return users, nil</span>
}

// GetByEmail retrieves a user by email address
func (s *Service) GetByEmail(ctx context.Context, email string) (*User, error) <span class="cov4" title="3">{
        // Try cache first
        user, err := s.cache.GetByEmail(ctx, email)
        if err == nil &amp;&amp; user != nil </span><span class="cov0" title="0">{
                return user, nil
        }</span>

        // Cache miss - get from database
        <span class="cov4" title="3">entity, err := s.repo.GetByEmail(ctx, email)
        if err != nil </span><span class="cov3" title="2">{
                return nil, err
        }</span>

        // Update cache for next time
        <span class="cov1" title="1">_ = s.cache.Set(ctx, entity, 5*time.Minute)

        return entity, nil</span>
}
</pre>
		
		<pre class="file" id="file169" style="display: none">// Code generated by codegen repository. DO NOT EDIT.
package users

import (
        "context"
        "database/sql"
        "fmt"

        "github.com/archesai/archesai/internal/database/sqlite"
        "github.com/google/uuid"
)

// SQLiteRepository implements Repository using SQLite.
type SQLiteRepository struct {
        db      *sql.DB
        queries *sqlite.Queries
}

// NewSQLiteRepository creates a new SQLite repository.
func NewSQLiteRepository(db *sql.DB) Repository <span class="cov0" title="0">{
        return &amp;SQLiteRepository{
                db:      db,
                queries: sqlite.New(db),
        }
}</span>

// User operations

func (r *SQLiteRepository) Create(ctx context.Context, entity *User) (*User, error) <span class="cov0" title="0">{
        // For now, return a basic implementation
        // Actual implementation would need to be customized per entity
        return nil, fmt.Errorf("CreateUser not yet implemented - requires custom mapping")
}</span>

func (r *SQLiteRepository) Get(ctx context.Context, id uuid.UUID) (*User, error) <span class="cov0" title="0">{
        // For now, return a basic implementation
        // Actual implementation would need to be customized per entity
        return nil, fmt.Errorf("GetUser not yet implemented - requires custom mapping")
}</span>

func (r *SQLiteRepository) Update(ctx context.Context, id uuid.UUID, entity *User) (*User, error) <span class="cov0" title="0">{
        // For now, return a basic implementation
        // Actual implementation would need to be customized per entity
        return nil, fmt.Errorf("UpdateUser not yet implemented - requires custom mapping")
}</span>

func (r *SQLiteRepository) Delete(ctx context.Context, id uuid.UUID) error <span class="cov0" title="0">{
        // For now, return a basic implementation
        // Actual implementation would need to be customized per entity
        return fmt.Errorf("DeleteUser not yet implemented - requires custom mapping")
}</span>

func (r *SQLiteRepository) List(ctx context.Context, params ListUsersParams) ([]*User, int64, error) <span class="cov0" title="0">{
        // For now, return a basic implementation
        // Actual implementation would need to be customized per entity
        return nil, 0, fmt.Errorf("ListUsers not yet implemented - requires custom mapping")
}</span>

// GetByEmail retrieves user by email
func (r *SQLiteRepository) GetByEmail(ctx context.Context, email string) (*User, error) <span class="cov0" title="0">{

        // For now, return a basic implementation
        return nil, fmt.Errorf("GetByEmail not yet implemented - requires custom mapping")

}</span>
</pre>
		
		<pre class="file" id="file170" style="display: none">// Package users provides primitives to interact with the openapi HTTP API.
//
// Code generated by github.com/oapi-codegen/oapi-codegen/v2 version v2.5.0 DO NOT EDIT.
package users

import (
        "encoding/json"
        "time"

        "github.com/google/uuid"
        "github.com/oapi-codegen/runtime"
        openapi_types "github.com/oapi-codegen/runtime/types"
)

const (
        BearerAuthScopes = "bearerAuth.Scopes"
)

// Defines values for FindManyUsersParamsSortField.
const (
        FindManyUsersParamsSortFieldCreatedAt     FindManyUsersParamsSortField = "createdAt"
        FindManyUsersParamsSortFieldEmail         FindManyUsersParamsSortField = "email"
        FindManyUsersParamsSortFieldEmailVerified FindManyUsersParamsSortField = "emailVerified"
        FindManyUsersParamsSortFieldId            FindManyUsersParamsSortField = "id"
        FindManyUsersParamsSortFieldImage         FindManyUsersParamsSortField = "image"
        FindManyUsersParamsSortFieldName          FindManyUsersParamsSortField = "name"
        FindManyUsersParamsSortFieldUpdatedAt     FindManyUsersParamsSortField = "updatedAt"
)

// Defines values for FindManyUsersParamsSortOrder.
const (
        Asc  FindManyUsersParamsSortOrder = "asc"
        Desc FindManyUsersParamsSortOrder = "desc"
)

// Base defines model for Base.
type Base struct {
        // CreatedAt The date and time when the resource was created
        CreatedAt time.Time `json:"createdAt" yaml:"createdAt"`

        // Id Universally Unique Identifier
        Id UUID `json:"id" yaml:"id"`

        // UpdatedAt The date and time when the resource was last updated
        UpdatedAt time.Time `json:"updatedAt" yaml:"updatedAt"`
}

// Email defines model for Email.
type Email = openapi_types.Email

// FilterNode A recursive filter node that can be a condition or group
type FilterNode = interface{}

// Page Pagination (page number &amp; size)
type Page struct {
        Number int `json:"number,omitempty,omitzero" yaml:"number,omitempty"`
        Size   int `json:"size,omitempty,omitzero" yaml:"size,omitempty"`
}

// Problem RFC 7807 (Problem Details) compliant error response
type Problem struct {
        // Detail Human-readable explanation specific to this occurrence
        Detail string `json:"detail" yaml:"detail"`

        // Errors Additional validation errors for specific fields
        Errors []ValidationError `json:"errors,omitempty,omitzero" yaml:"errors,omitempty"`

        // Instance URI identifying the specific occurrence
        Instance string `json:"instance,omitempty,omitzero" yaml:"instance,omitempty"`

        // Status HTTP status code
        Status int `json:"status" yaml:"status"`

        // Title Short, human-readable summary
        Title string `json:"title" yaml:"title"`

        // Type URI identifying the problem type
        Type string `json:"type" yaml:"type"`
}

// UUID Universally Unique Identifier
type UUID = uuid.UUID

// User defines model for User.
type User struct {
        // CreatedAt The date and time when the resource was created
        CreatedAt time.Time `json:"createdAt" yaml:"createdAt"`

        // Email The user's email address
        Email Email `json:"email" yaml:"email"`

        // EmailVerified Whether the user's email has been verified
        EmailVerified bool `json:"emailVerified" yaml:"emailVerified"`

        // Id Universally Unique Identifier
        Id UUID `json:"id" yaml:"id"`

        // Image The user's avatar image URL
        Image string `json:"image,omitempty,omitzero" yaml:"image,omitempty"`

        // Name The user's display name
        Name string `json:"name" yaml:"name"`

        // UpdatedAt The date and time when the resource was last updated
        UpdatedAt time.Time `json:"updatedAt" yaml:"updatedAt"`
}

// ValidationError Individual field validation error
type ValidationError struct {
        // Field The field path that failed validation
        Field string `json:"field" yaml:"field"`

        // Message Human-readable error message
        Message string `json:"message" yaml:"message"`

        // Value The invalid value that was provided
        Value ValidationError_Value `json:"value,omitempty,omitzero" yaml:"value,omitempty"`
}

// ValidationErrorValue0 defines model for .
type ValidationErrorValue0 = string

// ValidationErrorValue1 defines model for .
type ValidationErrorValue1 = float32

// ValidationErrorValue2 defines model for .
type ValidationErrorValue2 = bool

// ValidationError_Value The invalid value that was provided
type ValidationError_Value struct {
        union json.RawMessage
}

// PageQuery Pagination (page number &amp; size)
type PageQuery = Page

// UsersFilter A recursive filter node that can be a condition or group
type UsersFilter = FilterNode

// UsersSort defines model for UsersSort.
type UsersSort = []struct {
        Field string `json:"field" yaml:"field"`
        Order string `json:"order" yaml:"order"`
}

// BadRequest RFC 7807 (Problem Details) compliant error response
type BadRequest = Problem

// NotFound RFC 7807 (Problem Details) compliant error response
type NotFound = Problem

// Unauthorized RFC 7807 (Problem Details) compliant error response
type Unauthorized = Problem

// FindManyUsersParams defines parameters for FindManyUsers.
type FindManyUsersParams struct {
        // Filter Filter users by field values. Supported fields:
        // - createdAt, id, updatedAt, email, emailVerified, image, name
        Filter UsersFilter `json:"filter,omitempty,omitzero" yaml:"filter,omitempty"`

        // Page The page parameter
        Page PageQuery `form:"page,omitempty" json:"page,omitempty,omitzero" yaml:"page,omitempty"`

        // Sort The sort parameter
        Sort UsersSort `form:"sort,omitempty" json:"sort,omitempty,omitzero" yaml:"sort,omitempty"`
}

// FindManyUsersParamsSortField defines parameters for FindManyUsers.
type FindManyUsersParamsSortField string

// FindManyUsersParamsSortOrder defines parameters for FindManyUsers.
type FindManyUsersParamsSortOrder string

// UpdateUserJSONBody defines parameters for UpdateUser.
type UpdateUserJSONBody struct {
        // Email The user's e-mail
        Email string `json:"email,omitempty,omitzero" yaml:"email,omitempty"`

        // Image The user's avatar image URL
        Image string `json:"image,omitempty,omitzero" yaml:"image,omitempty"`
}

// UpdateUserJSONRequestBody defines body for UpdateUser for application/json ContentType.
type UpdateUserJSONRequestBody UpdateUserJSONBody

// AsValidationErrorValue0 returns the union data inside the ValidationError_Value as a ValidationErrorValue0
func (t ValidationError_Value) AsValidationErrorValue0() (ValidationErrorValue0, error) <span class="cov0" title="0">{
        var body ValidationErrorValue0
        err := json.Unmarshal(t.union, &amp;body)
        return body, err
}</span>

// FromValidationErrorValue0 overwrites any union data inside the ValidationError_Value as the provided ValidationErrorValue0
func (t *ValidationError_Value) FromValidationErrorValue0(v ValidationErrorValue0) error <span class="cov0" title="0">{
        b, err := json.Marshal(v)
        t.union = b
        return err
}</span>

// MergeValidationErrorValue0 performs a merge with any union data inside the ValidationError_Value, using the provided ValidationErrorValue0
func (t *ValidationError_Value) MergeValidationErrorValue0(v ValidationErrorValue0) error <span class="cov0" title="0">{
        b, err := json.Marshal(v)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov0" title="0">merged, err := runtime.JSONMerge(t.union, b)
        t.union = merged
        return err</span>
}

// AsValidationErrorValue1 returns the union data inside the ValidationError_Value as a ValidationErrorValue1
func (t ValidationError_Value) AsValidationErrorValue1() (ValidationErrorValue1, error) <span class="cov0" title="0">{
        var body ValidationErrorValue1
        err := json.Unmarshal(t.union, &amp;body)
        return body, err
}</span>

// FromValidationErrorValue1 overwrites any union data inside the ValidationError_Value as the provided ValidationErrorValue1
func (t *ValidationError_Value) FromValidationErrorValue1(v ValidationErrorValue1) error <span class="cov0" title="0">{
        b, err := json.Marshal(v)
        t.union = b
        return err
}</span>

// MergeValidationErrorValue1 performs a merge with any union data inside the ValidationError_Value, using the provided ValidationErrorValue1
func (t *ValidationError_Value) MergeValidationErrorValue1(v ValidationErrorValue1) error <span class="cov0" title="0">{
        b, err := json.Marshal(v)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov0" title="0">merged, err := runtime.JSONMerge(t.union, b)
        t.union = merged
        return err</span>
}

// AsValidationErrorValue2 returns the union data inside the ValidationError_Value as a ValidationErrorValue2
func (t ValidationError_Value) AsValidationErrorValue2() (ValidationErrorValue2, error) <span class="cov0" title="0">{
        var body ValidationErrorValue2
        err := json.Unmarshal(t.union, &amp;body)
        return body, err
}</span>

// FromValidationErrorValue2 overwrites any union data inside the ValidationError_Value as the provided ValidationErrorValue2
func (t *ValidationError_Value) FromValidationErrorValue2(v ValidationErrorValue2) error <span class="cov0" title="0">{
        b, err := json.Marshal(v)
        t.union = b
        return err
}</span>

// MergeValidationErrorValue2 performs a merge with any union data inside the ValidationError_Value, using the provided ValidationErrorValue2
func (t *ValidationError_Value) MergeValidationErrorValue2(v ValidationErrorValue2) error <span class="cov0" title="0">{
        b, err := json.Marshal(v)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov0" title="0">merged, err := runtime.JSONMerge(t.union, b)
        t.union = merged
        return err</span>
}

func (t ValidationError_Value) MarshalJSON() ([]byte, error) <span class="cov0" title="0">{
        b, err := t.union.MarshalJSON()
        return b, err
}</span>

func (t *ValidationError_Value) UnmarshalJSON(b []byte) error <span class="cov0" title="0">{
        err := t.union.UnmarshalJSON(b)
        return err
}</span>
</pre>
		
		<pre class="file" id="file171" style="display: none">// Package main provides the entry point for the codegen tool
package main

import (
        "flag"
        "fmt"
        "log"
        "os"

        "github.com/archesai/archesai/internal/codegen"
)

func main() <span class="cov0" title="0">{
        var configPath string
        var verbose bool

        flag.StringVar(&amp;configPath, "config", "archesai.codegen.yaml", "Config file path")
        flag.StringVar(&amp;configPath, "c", "archesai.codegen.yaml", "Config file path (shorthand)")
        flag.BoolVar(&amp;verbose, "verbose", false, "Verbose output")
        flag.BoolVar(&amp;verbose, "v", false, "Verbose output (shorthand)")
        flag.Parse()

        if verbose </span><span class="cov0" title="0">{
                log.SetFlags(log.Ldate | log.Ltime | log.Lshortfile)
        }</span> else<span class="cov0" title="0"> {
                log.SetFlags(0)
        }</span>

        // Always use config file
        <span class="cov0" title="0">if err := codegen.Run(configPath); err != nil </span><span class="cov0" title="0">{
                fmt.Fprintf(os.Stderr, "Error: %v\n", err)
                os.Exit(1)
        }</span>
}
</pre>
		
		<pre class="file" id="file172" style="display: none">// Package main converts PostgreSQL migration files to SQLite format
package main

import (
        "fmt"
        "log"
        "os"
        "path/filepath"
        "strings"
)

func main() <span class="cov0" title="0">{
        postgresDir := filepath.Join("internal", "migrations", "postgresql")
        sqliteDir := filepath.Join("internal", "migrations", "sqlite")

        // Ensure SQLite directory exists
        if err := os.MkdirAll(sqliteDir, 0755); err != nil </span><span class="cov0" title="0">{
                log.Fatalf("Error creating SQLite directory: %v", err)
        }</span>

        // Read all SQL files from PostgreSQL directory
        <span class="cov0" title="0">files, err := os.ReadDir(postgresDir)
        if err != nil </span><span class="cov0" title="0">{
                log.Fatalf("Error reading PostgreSQL directory: %v", err)
        }</span>

        <span class="cov0" title="0">convertedCount := 0
        for _, file := range files </span><span class="cov0" title="0">{
                if !strings.HasSuffix(file.Name(), ".sql") </span><span class="cov0" title="0">{
                        continue</span>
                }

                <span class="cov0" title="0">postgresPath := filepath.Join(postgresDir, file.Name())
                sqlitePath := filepath.Join(sqliteDir, file.Name())

                // Read PostgreSQL file
                content, err := os.ReadFile(postgresPath)
                if err != nil </span><span class="cov0" title="0">{
                        log.Printf("Error reading %s: %v", postgresPath, err)
                        continue</span>
                }

                // Convert PostgreSQL to SQLite
                <span class="cov0" title="0">sqliteContent := convertToSQLite(string(content))

                // Write SQLite file
                if err := os.WriteFile(sqlitePath, []byte(sqliteContent), 0644); err != nil </span><span class="cov0" title="0">{
                        log.Printf("Error writing %s: %v", sqlitePath, err)
                        continue</span>
                }

                <span class="cov0" title="0">fmt.Printf("Converted: %s -&gt; %s\n", file.Name(), file.Name())
                convertedCount++</span>
        }
}

func convertToSQLite(content string) string <span class="cov0" title="0">{
        // Replace UUID with TEXT (SQLite doesn't have native UUID type)
        content = strings.ReplaceAll(content, "UUID", "TEXT")

        // Remove DEFAULT gen_random_uuid() as SQLite doesn't support it
        // We'll generate UUIDs in the application layer
        content = strings.ReplaceAll(content, " DEFAULT gen_random_uuid()", "")

        // Replace TIMESTAMPTZ with TEXT
        content = strings.ReplaceAll(content, "TIMESTAMPTZ", "TEXT")

        // Replace CURRENT_TIMESTAMP with SQLite datetime function
        content = strings.ReplaceAll(content, "DEFAULT CURRENT_TIMESTAMP", "DEFAULT (strftime('%Y-%m-%d %H:%M:%f', 'now'))")

        // Replace DOUBLE PRECISION with REAL
        content = strings.ReplaceAll(content, "DOUBLE PRECISION", "REAL")

        // Remove ON DELETE CASCADE and ON UPDATE CASCADE from foreign keys
        // SQLite supports these but they need to be enabled with PRAGMA foreign_keys = ON
        // For simplicity, we'll keep them as they work in SQLite 3.6.19+

        // Handle BOOLEAN type (SQLite uses INTEGER for boolean)
        content = strings.ReplaceAll(content, "BOOLEAN", "INTEGER")

        // Fix boolean defaults
        content = strings.ReplaceAll(content, "DEFAULT false", "DEFAULT 0")
        content = strings.ReplaceAll(content, "DEFAULT true", "DEFAULT 1")

        // Add header comment
        header := `-- SQLite schema (auto-generated from PostgreSQL)
-- Generated by internal/database/migrations/convert.go
-- DO NOT EDIT MANUALLY - Edit PostgreSQL schema and regenerate

`

        return header + content
}</span>
</pre>
		
		</div>
	</body>
	<script>
	(function() {
		var files = document.getElementById('files');
		var visible;
		files.addEventListener('change', onChange, false);
		function select(part) {
			if (visible)
				visible.style.display = 'none';
			visible = document.getElementById(part);
			if (!visible)
				return;
			files.value = part;
			visible.style.display = 'block';
			location.hash = part;
		}
		function onChange() {
			select(files.value);
			window.scrollTo(0, 0);
		}
		if (location.hash != "") {
			select(location.hash.substr(1));
		}
		if (!visible) {
			select("file0");
		}
	})();
	</script>
</html>
