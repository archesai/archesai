{
  "main": {
    "metadata": {
      "created": "2025-09-25T05:02:25.596Z",
      "description": "Tasks for main context",
      "updated": "2025-09-29T05:31:07.864Z"
    },
    "tasks": [
      {
        "dependencies": [],
        "description": "Build a robust OpenAPI parser that validates specs and extracts schema information for code generation",
        "details": "Leverage existing parsers/openapi_schema.go and extend it to handle x-codegen extensions. Use speakeasy-api/openapi library for parsing. Implement validation for OpenAPI 3.1.1 specs, extract component schemas, paths, and operations. Handle refs resolution and schema inheritance. Store parsed data in structured format for template consumption.",
        "id": 1,
        "priority": "high",
        "status": "pending",
        "subtasks": [
          {
            "dependencies": [],
            "description": "Refactor and enhance the existing speakeasy-api/openapi integration in parsers/openapi_schema.go to support advanced parsing features",
            "details": "Review current implementation in parsers/openapi_schema.go. Upgrade speakeasy-api/openapi to latest version if needed. Add support for OpenAPI 3.1.1 specific features (webhooks, license object, JSON Schema 2020-12). Implement proper error handling with detailed validation messages. Create parser configuration options for strict/lenient modes.\n<info added on 2025-09-25T05:37:22.233Z>\nI'll analyze the codebase to understand the current implementation and the compilation errors in ref_resolver.go.Now let me check the errors.go file to understand the ParseError type:Now let me check the openapi_schema.go file to understand how these are being used:Now let me check how the speakeasy library defines the Paths type:Let me check the go.mod to see what version of speakeasy we're using:Now let me understand how the speakeasy library structures these types by looking at usage:Let me check how Paths is used in the OpenAPI struct:Now let me look at how GetOrZero is used with Paths and what the actual types involved are:Let me now check what the actual return type is from GetOrZero on paths:Now let me check ReferencedPathItem:Now I understand the issue. The `paths.GetOrZero()` returns a `*ReferencedPathItem` (which is an alias for `Reference[PathItem, *PathItem, *core.PathItem]`), not a `*PathItem`. Let me check the proper way to get the actual PathItem from it:Perfect! Now I understand. The issue is:\n1. Line 72: `err` is a `*ParseError` but we're trying to append it to `ParseErrors` which expects `*ParseError`\n2. Line 120: `doc.Paths` is already a `*openapi.Paths`, not a value, so we don't need to dereference it\n3. Line 275: `pathItem` from `GetOrZero` returns `*ReferencedPathItem`, but we need to get the actual `*PathItem` from it using `GetResolvedObject()` or similar method\n\nLet me check how other parts of the code handle ReferencedPathItem:Now I understand how to fix the compilation errors. Let me also check line 72 more closely:I see - the issue at line 72 is that `err` is already a `*ParseError`, and `r.errors` is `ParseErrors` which is `[]*ParseError`. The append is correct. The issue is the error type declaration at line 68 should be `*ParseError` but it's declared as `error`. Let me verify the actual variable declaration for `err`:\n\nLooking at line 58, `err` is declared as `error` interface. But then at line 68-71, we're assigning a `*ParseError` to it. The issue is that while a `*ParseError` satisfies the `error` interface, when we try to append `err` (which is typed as `error`) to `r.errors` (which expects `*ParseError`), Go sees a type mismatch.\n\nFix compilation errors in ref_resolver.go:\n\n**Line 72 & similar locations**: The variable `err` is declared as `error` interface but needs to be cast to `*ParseError` when appending to `r.errors`. Change pattern from `err = NewParseError(...)` and `r.errors = append(r.errors, err)` to either use a separate variable like `parseErr := NewParseError(...)` and append that, or type assert `err.(*ParseError)`.\n\n**Line 120**: The `doc.Paths` parameter is already a pointer (`*openapi.Paths`), but `resolvePathRef` expects `openapi.Paths` (value type). Need to dereference with `*doc.Paths` when passing to the function.\n\n**Line 275**: The `pathItem` returned from `paths.GetOrZero()` is a `*ReferencedPathItem` (which is `Reference[PathItem, *PathItem, *core.PathItem]`), not a `*PathItem`. Need to call `GetResolvedObject()` on the ReferencedPathItem to get the actual `*PathItem`: `pathItem.GetResolvedObject()`.\n\nAdditional fixes needed:\n- Update `resolvePathItemRef` function signature to accept `*ReferencedPathItem` instead of `*PathItem`, then call `GetResolvedObject()` inside the function\n- Or extract the PathItem before calling the function using `GetResolvedObject()`\n</info added on 2025-09-25T05:37:22.233Z>",
            "id": 1,
            "status": "in-progress",
            "testStrategy": "",
            "title": "Enhance Speakeasy Parser Integration"
          },
          {
            "dependencies": ["1.1"],
            "description": "Build specialized parser for x-codegen extensions that extracts code generation metadata from OpenAPI specs",
            "details": "Parse x-codegen extensions from components/schemas (repository type, indexes, relations). Extract x-codegen-config from info section for global settings. Handle x-codegen annotations on paths/operations for handler generation. Validate extension schema against api/components/schemas/xcodegen/CodegenConfig.yaml. Map extensions to internal codegen.TemplateInputs structure.",
            "id": 2,
            "status": "pending",
            "testStrategy": "",
            "title": "Implement x-codegen Extension Parser"
          },
          {
            "dependencies": ["1.1"],
            "description": "Implement comprehensive $ref resolution with circular reference detection and external reference support",
            "details": "Build ref resolver that handles local refs (#/components/schemas/User). Implement circular reference detection using visited node tracking. Support external file references (./external.yaml#/definitions/Model). Create ref cache to avoid repeated resolution. Generate dependency graph for schema relationships.",
            "id": 3,
            "status": "pending",
            "testStrategy": "",
            "title": "Add Reference Resolution System"
          },
          {
            "dependencies": ["1.3"],
            "description": "Build system to handle schema inheritance through allOf, oneOf, anyOf, and discriminator patterns",
            "details": "Process allOf compositions by merging parent schemas. Handle discriminator-based polymorphism for oneOf/anyOf. Resolve property conflicts in inheritance chains. Generate proper Go type embeddings from inheritance. Create inheritance tree representation for templates.",
            "id": 4,
            "status": "pending",
            "testStrategy": "",
            "title": "Create Schema Inheritance Handler"
          },
          {
            "dependencies": ["1.2", "1.4"],
            "description": "Design and implement structured storage format for parsed OpenAPI data optimized for template consumption",
            "details": "Create ParsedSpec struct with schemas, paths, operations, and x-codegen data. Implement schema registry with normalized types and relationships. Build operation catalog with grouped endpoints by tag/resource. Add metadata store for component descriptions and examples. Serialize to JSON/YAML for debugging and caching.",
            "id": 5,
            "status": "pending",
            "testStrategy": "",
            "title": "Build Structured Data Storage Format"
          }
        ],
        "testStrategy": "Unit test with sample OpenAPI specs including edge cases (circular refs, deep nesting). Validate against OpenAPI 3.1.1 spec compliance. Test error handling for malformed specs.",
        "title": "Create OpenAPI Parser Module"
      },
      {
        "dependencies": [1],
        "description": "Create a flexible template engine for generating code from OpenAPI specs using Go templates",
        "details": "Extend infrastructure/templates package to support multi-language targets. Create template loader that reads from tmpl directory. Implement template functions for type mapping, naming conventions, and code formatting. Support template inheritance and partials. Add caching for compiled templates.",
        "id": 2,
        "priority": "high",
        "status": "pending",
        "subtasks": [
          {
            "dependencies": [],
            "description": "Enhance the existing infrastructure/templates package loader to support multiple target languages",
            "details": "Modify the template loader in infrastructure/templates to accept language configuration parameters. Create a registry system that maps languages to their specific template directories (e.g., tmpl/go, tmpl/typescript, tmpl/python). Implement language-specific template resolution logic that falls back to common templates when language-specific ones are not available. Add configuration for language-specific file extensions and output paths.",
            "id": 1,
            "status": "pending",
            "testStrategy": "",
            "title": "Extend Template Loader for Multi-Language Support"
          },
          {
            "dependencies": ["2.1"],
            "description": "Build a template inheritance mechanism supporting base templates and extending templates",
            "details": "Create a base template parser that identifies template blocks and inheritance directives. Implement template extending functionality using Go template's block and define features. Build a template hierarchy resolver that handles multiple levels of inheritance. Add support for overriding specific blocks while inheriting others. Create template metadata tracking for dependency management.",
            "id": 2,
            "status": "pending",
            "testStrategy": "",
            "title": "Implement Template Inheritance System"
          },
          {
            "dependencies": [],
            "description": "Develop template helper functions for mapping OpenAPI types to target language types",
            "details": "Implement type mapper functions for common languages (Go, TypeScript, Python, Java). Create functions for primitive type conversion (string, integer, boolean, array, object). Add support for complex type mappings including enums, unions, and nullable types. Build format-specific mappings (date-time, uuid, email). Include collection type handling with proper generic syntax for each language.",
            "id": 3,
            "status": "pending",
            "testStrategy": "",
            "title": "Create Type Mapping Template Functions"
          },
          {
            "dependencies": ["2.1", "2.2"],
            "description": "Implement an efficient caching system for compiled templates to improve performance",
            "details": "Create an in-memory cache using sync.Map for thread-safe template storage. Implement cache key generation based on template path and language. Add cache invalidation logic triggered by template file modifications. Build template pre-compilation during initialization. Include cache metrics for monitoring hit/miss rates and performance gains.",
            "id": 4,
            "status": "pending",
            "testStrategy": "",
            "title": "Build Template Caching Layer"
          },
          {
            "dependencies": ["2.2"],
            "description": "Create a system for reusable template partials that can be included across templates",
            "details": "Design partial template directory structure (tmpl/partials/common, tmpl/partials/[language]). Implement partial loading and registration during template initialization. Create template functions for including partials with parameter passing. Build partial dependency tracking to ensure correct loading order. Add support for conditional partial inclusion based on configuration.",
            "id": 5,
            "status": "pending",
            "testStrategy": "",
            "title": "Implement Partial Template Support"
          },
          {
            "dependencies": [],
            "description": "Build template functions for converting names according to language-specific conventions",
            "details": "Implement case conversion functions (camelCase, PascalCase, snake_case, kebab-case). Create pluralization and singularization helpers. Build language-specific identifier validation and sanitization. Add acronym handling configuration (API vs Api). Implement reserved keyword checking and escaping for each target language.",
            "id": 6,
            "status": "pending",
            "testStrategy": "",
            "title": "Create Naming Convention Helpers"
          }
        ],
        "testStrategy": "Test template compilation and execution with mock data. Verify generated code syntax for each target language. Test template function helpers with various inputs.",
        "title": "Design Template Engine System"
      },
      {
        "dependencies": [1, 2],
        "description": "Build Go code generator with hexagonal architecture support for backend services",
        "details": "Create generators for: entities in core/entities, repositories in core/ports/repositories, service interfaces in application/services, HTTP handlers in adapters/http/handlers, DTOs in application/dto. Follow existing patterns in internal/codegen/generators.go. Map OpenAPI types to Go types, handle nullable fields with pointers.",
        "id": 3,
        "priority": "high",
        "status": "pending",
        "subtasks": [
          {
            "dependencies": [],
            "description": "Build generator for domain entities in core/entities following hexagonal architecture patterns",
            "details": "Implement entity generator that reads OpenAPI schemas and generates Go structs in internal/core/entities. Include struct tags for JSON/database mapping, validation tags, and constructor functions. Follow existing entity patterns like User, Organization, Pipeline entities. Generate value objects for complex fields.",
            "id": 1,
            "status": "pending",
            "testStrategy": "",
            "title": "Create Entity Generator for Core Domain"
          },
          {
            "dependencies": ["3.1"],
            "description": "Create generator for repository interfaces in core/ports/repositories",
            "details": "Generate repository interfaces with standard CRUD operations plus custom queries. Include context support, error handling, and transaction methods. Follow existing repository patterns in ports/repositories like UserRepository, PipelineRepository. Generate both the interface and method signatures based on OpenAPI operations.",
            "id": 2,
            "status": "pending",
            "testStrategy": "",
            "title": "Build Repository Interface Generator"
          },
          {
            "dependencies": ["3.1", "3.2"],
            "description": "Build generator for application service interfaces and implementations",
            "details": "Generate service interfaces in application/services following CQRS pattern. Create command and query handlers based on OpenAPI operations. Include dependency injection setup, error handling, and business logic scaffolding. Follow existing service patterns and integrate with the command/query bus architecture.",
            "id": 3,
            "status": "pending",
            "testStrategy": "",
            "title": "Implement Service Layer Generator"
          },
          {
            "dependencies": ["3.3", "3.5"],
            "description": "Develop generator for HTTP handlers in adapters/http/handlers",
            "details": "Generate HTTP handlers that implement OpenAPI operations. Include request validation, response serialization, error handling middleware integration. Follow existing handler patterns with proper status codes, content negotiation, and OpenAPI schema validation. Generate handler registration and routing setup.",
            "id": 4,
            "status": "pending",
            "testStrategy": "",
            "title": "Create HTTP Handler Generator"
          },
          {
            "dependencies": ["3.1"],
            "description": "Implement generator for Data Transfer Objects in application/dto",
            "details": "Generate DTOs for request/response payloads based on OpenAPI schemas. Include validation tags, JSON tags, and conversion methods between DTOs and domain entities. Implement mappers for transforming between layers. Follow existing DTO patterns with proper separation of concerns.",
            "id": 5,
            "status": "pending",
            "testStrategy": "",
            "title": "Build DTO Generator"
          },
          {
            "dependencies": [],
            "description": "Implement comprehensive type mapping system from OpenAPI types to Go types",
            "details": "Create type mapper that converts OpenAPI data types (string, number, integer, boolean, array, object) to appropriate Go types. Handle format specifiers (date-time, uuid, email). Map OpenAPI schemas to Go structs with proper imports. Support enum generation as constants. Handle nested objects and arrays.",
            "id": 6,
            "status": "pending",
            "testStrategy": "",
            "title": "Add OpenAPI to Go Type Mapping"
          },
          {
            "dependencies": ["3.6"],
            "description": "Add support for nullable fields using Go pointers and optional types",
            "details": "Detect nullable fields in OpenAPI schemas and generate pointer types. Implement null-safe getter/setter methods. Add JSON omitempty tags for optional fields. Generate validation for required vs optional fields. Handle nullable references and nested nullable objects properly.",
            "id": 7,
            "status": "pending",
            "testStrategy": "",
            "title": "Implement Nullable Field Handling"
          },
          {
            "dependencies": ["3.1", "3.2", "3.3", "3.4", "3.5"],
            "description": "Ensure generated code passes golangci-lint checks and follows Go best practices",
            "details": "Configure code generation templates to produce lint-compliant code. Add proper comments for exported types and functions. Ensure error handling follows Go conventions. Fix common linting issues like unused parameters, missing error checks. Generate code that passes all rules in .golangci.yaml configuration.",
            "id": 8,
            "status": "pending",
            "testStrategy": "",
            "title": "Add Golangci-lint Compliance"
          }
        ],
        "testStrategy": "Generate code from test OpenAPI spec and compile it. Test type mappings for all OpenAPI data types. Verify generated code follows Go conventions and passes golangci-lint.",
        "title": "Implement Go Code Generator"
      },
      {
        "dependencies": [1],
        "description": "Generate SQLC queries and schema from OpenAPI specifications",
        "details": "Parse OpenAPI schemas to generate PostgreSQL DDL in infrastructure/persistence/postgres/migrations. Create SQLC query files in infrastructure/persistence/postgres/queries. Map OpenAPI types to PostgreSQL types. Handle relationships via x-codegen extensions. Generate indexes based on query patterns.",
        "id": 4,
        "priority": "high",
        "status": "pending",
        "subtasks": [
          {
            "dependencies": [],
            "description": "Implement parser to convert OpenAPI schema definitions into PostgreSQL DDL statements",
            "details": "Create parser in internal/codegen that reads OpenAPI yaml files from api/components/schemas. Extract schema definitions and convert to CREATE TABLE statements. Handle data type mappings from OpenAPI types (string, integer, boolean, array, object) to PostgreSQL types (VARCHAR, INTEGER, BOOLEAN, JSONB). Process schema properties to generate column definitions with appropriate constraints (NOT NULL, UNIQUE). Store parsed DDL in memory structures for further processing.",
            "id": 1,
            "status": "pending",
            "testStrategy": "",
            "title": "Parse OpenAPI schemas to PostgreSQL DDL"
          },
          {
            "dependencies": ["4.1"],
            "description": "Create goose-compatible migration files from parsed DDL statements",
            "details": "Generate migration files in infrastructure/persistence/postgres/migrations following goose naming convention (YYYYMMDDHHMMSS_description.sql). Include -- +goose Up and -- +goose Down directives. Write CREATE TABLE statements in Up section. Generate corresponding DROP TABLE statements for Down section. Ensure proper ordering of tables based on foreign key dependencies. Create initial migration for base tables, subsequent migrations for modifications.",
            "id": 2,
            "status": "pending",
            "testStrategy": "",
            "title": "Generate migration files in goose format"
          },
          {
            "dependencies": ["4.1"],
            "description": "Generate SQLC query files with CRUD operations for each schema",
            "details": "Generate .sql files in infrastructure/persistence/postgres/queries directory. Create standard CRUD queries for each table: GetByID, List, Create, Update, Delete. Use SQLC annotations (-- name: QueryName :one/:many/:exec). Include pagination support for List queries using LIMIT and OFFSET. Add filtering capabilities based on common fields. Generate batch operations where applicable (CreateMany, UpdateMany). Follow existing query patterns in the codebase.",
            "id": 3,
            "status": "pending",
            "testStrategy": "",
            "title": "Create SQLC query files"
          },
          {
            "dependencies": [],
            "description": "Create comprehensive type mapping system between OpenAPI and PostgreSQL types",
            "details": "Map OpenAPI string formats (date-time, date, uuid, email) to appropriate PostgreSQL types (TIMESTAMPTZ, DATE, UUID, VARCHAR). Handle array types to PostgreSQL arrays or JSONB. Convert OpenAPI number/integer with format to DECIMAL, BIGINT, SMALLINT. Map object types to JSONB for nested structures. Process enum values to PostgreSQL CHECK constraints or custom types. Handle nullable fields with NULL/NOT NULL constraints. Support x-codegen extensions for custom type hints.",
            "id": 4,
            "status": "pending",
            "testStrategy": "",
            "title": "Implement type mapping OpenAPI to PostgreSQL"
          },
          {
            "dependencies": ["4.1", "4.4"],
            "description": "Process x-codegen extensions to generate table relationships and foreign keys",
            "details": "Parse x-codegen extensions from OpenAPI schemas for relationship definitions. Generate foreign key columns for one-to-many and many-to-one relationships. Create junction tables for many-to-many relationships with composite primary keys. Add CASCADE options based on x-codegen deletion rules. Generate relationship queries in SQLC (GetWithRelations, GetByForeignKey). Ensure referential integrity in migration order. Handle self-referential relationships for hierarchical data.",
            "id": 5,
            "status": "pending",
            "testStrategy": "",
            "title": "Handle relationship generation from x-codegen"
          },
          {
            "dependencies": ["4.3", "4.5"],
            "description": "Analyze query patterns to automatically generate database indexes",
            "details": "Analyze generated SQLC queries to identify frequently used WHERE clauses. Create indexes on foreign key columns for relationship queries. Generate composite indexes for multi-column filters. Add unique indexes for fields marked as unique in OpenAPI. Create partial indexes for soft-delete patterns (deleted_at IS NULL). Generate GIN/GIST indexes for JSONB columns used in queries. Include index creation in migration files after table creation. Add comments explaining index purpose.",
            "id": 6,
            "status": "pending",
            "testStrategy": "",
            "title": "Generate indexes from query patterns"
          },
          {
            "dependencies": ["4.5", "4.6"],
            "description": "Generate foreign key constraints with proper validation and error handling",
            "details": "Generate ALTER TABLE statements to add foreign key constraints after all tables are created. Validate referenced tables and columns exist before constraint creation. Handle circular dependencies with DEFERRABLE INITIALLY DEFERRED constraints. Generate meaningful constraint names following pattern fk_table_column_referenced. Add ON UPDATE and ON DELETE actions based on x-codegen specifications. Create migration rollback statements to drop constraints. Generate SQLC queries that respect constraint relationships. Add constraint violation error handling in generated code.",
            "id": 7,
            "status": "pending",
            "testStrategy": "",
            "title": "Add foreign key constraint generation"
          }
        ],
        "testStrategy": "Generate schema and verify with PostgreSQL. Test SQLC compilation of generated queries. Validate foreign key constraints and indexes.",
        "title": "Create SQLC Schema Generator"
      },
      {
        "dependencies": [],
        "description": "Create project entity and repository for managing code generation projects",
        "details": "Create Project entity with fields: ID, Name, OpenAPISpec (JSON), Settings, CreatedAt, UpdatedAt. Implement PostgreSQL repository using SQLC. Add project CRUD operations via HTTP handlers. Store OpenAPI specs and generation configurations. Track generation history.",
        "id": 5,
        "priority": "high",
        "status": "pending",
        "subtasks": [
          {
            "dependencies": [],
            "description": "Define Project entity with all required fields following existing domain patterns",
            "details": "Create Project entity in internal/core/entities with fields: ID (UUID), Name (string), OpenAPISpec (JSON), Settings (JSON), CreatedAt, UpdatedAt. Follow existing entity patterns from pipelines/runs. Create value objects for ProjectSettings and OpenAPISpec validation. Ensure entity implements proper validation methods.",
            "id": 1,
            "status": "pending",
            "testStrategy": "",
            "title": "Create Project Entity and Value Objects"
          },
          {
            "dependencies": ["5.1"],
            "description": "Create PostgreSQL repository using SQLC for Project persistence",
            "details": "Write SQL schema in deployments/docker/postgres/migrations for projects table. Define SQLC queries in internal/infrastructure/persistence/postgres/queries/projects.sql for CRUD operations. Generate SQLC code and implement ProjectRepository interface in internal/infrastructure/persistence/postgres. Include methods: Create, GetByID, Update, Delete, List with pagination.",
            "id": 2,
            "status": "pending",
            "testStrategy": "",
            "title": "Implement SQLC Repository for Projects"
          },
          {
            "dependencies": ["5.2"],
            "description": "Create REST API handlers for project CRUD operations",
            "details": "Define OpenAPI paths in api/paths/projects.yaml for GET/POST/PUT/DELETE /projects endpoints. Generate DTOs and handlers using codegen. Implement handler logic in internal/adapters/http/handlers connecting to repository. Add request validation and error handling following existing patterns.",
            "id": 3,
            "status": "pending",
            "testStrategy": "",
            "title": "Build Project HTTP Handlers and DTOs"
          },
          {
            "dependencies": ["5.3"],
            "description": "Add functionality to store and validate OpenAPI specifications within projects",
            "details": "Store OpenAPI specs as JSONB in PostgreSQL. Add validation logic to ensure valid OpenAPI 3.x specifications on upload. Implement versioning support for tracking spec changes. Create methods to extract and parse OpenAPI for code generation. Add size limits and security validation for uploaded specs.",
            "id": 4,
            "status": "pending",
            "testStrategy": "",
            "title": "Implement OpenAPI Spec Storage and Validation"
          },
          {
            "dependencies": ["5.4"],
            "description": "Implement system to track code generation history for each project",
            "details": "Create GenerationHistory entity with fields: ID, ProjectID, GeneratedAt, GenerationType, Status, Metadata. Add PostgreSQL table and SQLC queries for history records. Link generation runs to projects. Store generation artifacts references. Implement endpoints to query generation history by project with filtering and pagination.",
            "id": 5,
            "status": "pending",
            "testStrategy": "",
            "title": "Add Generation History Tracking"
          }
        ],
        "testStrategy": "Integration test with PostgreSQL using testcontainers. Test CRUD operations through API endpoints. Verify project state persistence.",
        "title": "Build Project Management System"
      },
      {
        "dependencies": [5],
        "description": "Create service for provisioning and managing Docker containers per project",
        "details": "Create ContainerService in application/services using Docker SDK. Implement container lifecycle: create, start, stop, remove. Use Alpine Linux base with Go, Node.js, Python pre-installed. Mount project directories as volumes. Set resource limits (CPU, memory). Track container state in Redis.",
        "id": 6,
        "priority": "high",
        "status": "pending",
        "subtasks": [
          {
            "dependencies": [],
            "description": "Set up the ContainerService in application/services with Docker SDK client initialization and configuration",
            "details": "Create internal/application/services/container_service.go. Initialize Docker client using github.com/docker/docker/client. Add configuration for Docker daemon connection (Unix socket or TCP). Implement error handling for Docker daemon connectivity. Create interfaces for container operations. Add logging using the shared logger package.",
            "id": 1,
            "status": "pending",
            "testStrategy": "",
            "title": "Create ContainerService structure and Docker SDK integration"
          },
          {
            "dependencies": ["6.1"],
            "description": "Build core container lifecycle operations: create, start, stop, remove with proper error handling",
            "details": "Implement CreateContainer method with container configuration options. Add StartContainer with health check waiting. Implement StopContainer with graceful shutdown timeout (30s default). Add RemoveContainer with force option for cleanup. Create RestartContainer combining stop/start. Add GetContainerStatus for state checking. Implement proper context handling for all operations.",
            "id": 2,
            "status": "pending",
            "testStrategy": "",
            "title": "Implement container lifecycle methods"
          },
          {
            "dependencies": [],
            "description": "Create Dockerfile for Alpine Linux base image with Go, Node.js, and Python pre-installed",
            "details": "Create deployments/docker/runtime/Dockerfile using Alpine 3.19. Install Go 1.22, Node.js 20 LTS, Python 3.11. Add common development tools (git, make, curl). Configure non-root user for container execution. Set up working directory structure. Optimize image layers for caching. Add health check command. Build and push to registry.",
            "id": 3,
            "status": "pending",
            "testStrategy": "",
            "title": "Build Alpine-based Docker image with runtimes"
          },
          {
            "dependencies": ["6.2"],
            "description": "Add functionality to mount project directories as volumes with proper permissions",
            "details": "Create volume mounting configuration in CreateContainer. Map project directory to /workspace in container. Set up read-write permissions for project files. Add optional read-only mounts for shared resources. Implement bind mount validation. Handle volume cleanup on container removal. Support both named volumes and bind mounts.",
            "id": 4,
            "status": "pending",
            "testStrategy": "",
            "title": "Implement volume mounting for projects"
          },
          {
            "dependencies": ["6.2"],
            "description": "Implement CPU and memory resource limits for containers with configurable defaults",
            "details": "Add resource configuration to ContainerService. Set CPU limits (default 2 cores, configurable). Set memory limits (default 2GB, configurable). Implement swap limit controls. Add PIDs limit to prevent fork bombs. Configure restart policies. Add resource monitoring methods. Store limits in project configuration.",
            "id": 5,
            "status": "pending",
            "testStrategy": "",
            "title": "Add resource limits and constraints"
          },
          {
            "dependencies": ["6.1", "6.2"],
            "description": "Implement container state persistence and tracking using Redis infrastructure",
            "details": "Create container state model with status, created_at, updated_at. Store in Redis with key pattern containers:{project_id}:{container_id}. Implement state transitions (creating, running, stopped, removing). Add TTL for stopped containers (24 hours). Create state recovery on service restart. Implement state change event publishing. Add cleanup for orphaned state entries.",
            "id": 6,
            "status": "pending",
            "testStrategy": "",
            "title": "Create Redis-based container state tracking"
          },
          {
            "dependencies": ["6.2"],
            "description": "Set up Docker networking for container isolation and communication",
            "details": "Create custom Docker network per project for isolation. Implement port mapping configuration for exposed services. Add inter-container communication within project network. Configure DNS resolution for container names. Support both bridge and host network modes. Add network cleanup on project deletion. Implement network security policies.",
            "id": 7,
            "status": "pending",
            "testStrategy": "",
            "title": "Implement container networking"
          },
          {
            "dependencies": ["6.2", "6.6", "6.7"],
            "description": "Create automated cleanup for orphaned containers and resources with scheduled maintenance",
            "details": "Implement cleanup service to remove stopped containers after TTL. Add orphaned container detection and removal. Create volume cleanup for deleted projects. Implement network cleanup for unused networks. Add scheduled maintenance job (runs every hour). Create manual cleanup commands. Add metrics for resource usage. Implement graceful shutdown handling.",
            "id": 8,
            "status": "pending",
            "testStrategy": "",
            "title": "Build cleanup and maintenance mechanisms"
          }
        ],
        "testStrategy": "Integration test with Docker API. Test container lifecycle operations. Verify resource limits enforcement. Test cleanup on project deletion.",
        "title": "Implement Docker Container Service"
      },
      {
        "dependencies": [6],
        "description": "Implement container orchestration for managing multiple project containers",
        "details": "Create orchestrator that manages container pool. Implement container scheduling and resource allocation. Add health checks and auto-restart. Handle container cleanup after idle timeout. Support concurrent container operations. Use Redis for distributed locking.",
        "id": 7,
        "priority": "medium",
        "status": "pending",
        "subtasks": [
          {
            "dependencies": [],
            "description": "Create the architectural design for the container pool management system",
            "details": "Design the container pool data structures and interfaces. Define pool sizing strategies (min/max containers, scaling policies). Create container state machine (idle, busy, draining, terminated). Design queue management for pending container requests. Define resource allocation strategies (CPU, memory limits). Document pool lifecycle and container transitions.",
            "id": 1,
            "status": "pending",
            "testStrategy": "",
            "title": "Design Container Pool Architecture"
          },
          {
            "dependencies": ["7.1"],
            "description": "Build the scheduling system for container allocation and task assignment",
            "details": "Implement scheduling algorithms (round-robin, least-loaded, priority-based). Create task queue with priority support. Build container selection logic based on resource availability. Implement request queuing when pool is exhausted. Add scheduling policies configuration. Create backpressure handling mechanisms.",
            "id": 2,
            "status": "pending",
            "testStrategy": "",
            "title": "Implement Container Scheduling Algorithm"
          },
          {
            "dependencies": ["7.1"],
            "description": "Create resource management and allocation for containers",
            "details": "Implement resource tracking per container (CPU, memory, disk). Build resource reservation system before container creation. Create resource limit enforcement using Docker constraints. Implement dynamic resource adjustment based on load. Add resource usage monitoring and reporting. Build resource cleanup on container termination.",
            "id": 3,
            "status": "pending",
            "testStrategy": "",
            "title": "Build Resource Allocation System"
          },
          {
            "dependencies": ["7.1"],
            "description": "Implement comprehensive health checking for managed containers",
            "details": "Create health check probes (liveness, readiness). Implement HTTP/TCP health check endpoints. Build health status aggregation across pool. Add configurable health check intervals and timeouts. Implement health state transitions and grace periods. Create health metrics collection and alerting hooks.",
            "id": 4,
            "status": "pending",
            "testStrategy": "",
            "title": "Add Health Check Monitoring"
          },
          {
            "dependencies": ["7.4"],
            "description": "Build automatic container restart functionality with failure handling",
            "details": "Implement restart policies (always, on-failure, unless-stopped). Create exponential backoff for restart attempts. Build crash loop detection and prevention. Implement restart counters and thresholds. Add restart event logging and notifications. Create manual restart override capabilities.",
            "id": 5,
            "status": "pending",
            "testStrategy": "",
            "title": "Create Auto-Restart Logic"
          },
          {
            "dependencies": ["7.1", "7.2"],
            "description": "Create automatic cleanup system for idle containers",
            "details": "Implement idle detection based on last activity timestamps. Create configurable idle timeout periods per container type. Build graceful shutdown with drain periods. Implement cleanup scheduling to avoid thundering herd. Add cleanup metrics and logging. Create cleanup exemption policies for critical containers.",
            "id": 6,
            "status": "pending",
            "testStrategy": "",
            "title": "Implement Idle Timeout Cleanup"
          },
          {
            "dependencies": ["7.2", "7.3"],
            "description": "Implement Redis-based distributed locking for orchestration operations",
            "details": "Implement Redis-based distributed locks using Redlock algorithm. Create lock acquisition with timeouts and retries. Build lock renewal for long-running operations. Implement deadlock detection and recovery. Add lock monitoring and debugging tools. Create lock namespacing for different operation types.",
            "id": 7,
            "status": "pending",
            "testStrategy": "",
            "title": "Add Distributed Locking with Redis"
          },
          {
            "dependencies": ["7.7"],
            "description": "Enable safe concurrent container operations across the pool",
            "details": "Implement concurrent container creation with rate limiting. Build parallel health checking across pool. Create concurrent resource allocation with conflict resolution. Implement bulk operations (start/stop multiple containers). Add operation queuing and batching. Create concurrency limits and throttling mechanisms.",
            "id": 8,
            "status": "pending",
            "testStrategy": "",
            "title": "Build Concurrent Operation Support"
          },
          {
            "dependencies": [
              "7.1",
              "7.2",
              "7.3",
              "7.4",
              "7.5",
              "7.6",
              "7.7",
              "7.8"
            ],
            "description": "Implement comprehensive metrics collection for the orchestration layer",
            "details": "Implement metrics for pool utilization and saturation. Create scheduling latency and throughput metrics. Build resource usage aggregation and trending. Add health check success/failure rates. Implement restart frequency and success metrics. Create detailed operational dashboards and alerts.",
            "id": 9,
            "status": "pending",
            "testStrategy": "",
            "title": "Create Orchestration Metrics"
          }
        ],
        "testStrategy": "Load test with multiple concurrent containers. Test auto-cleanup after timeout. Verify health check and restart logic. Test distributed locking with Redis.",
        "title": "Build Container Orchestration Layer"
      },
      {
        "dependencies": [6],
        "description": "Implement WebSocket server for real-time container communication",
        "details": "Extend adapters/http/server/websocket.go for container terminals. Use gorilla/websocket for WebSocket handling. Implement message routing between browser and container. Support multiple concurrent connections per project. Add authentication via JWT tokens.",
        "id": 8,
        "priority": "medium",
        "status": "pending",
        "subtasks": [
          {
            "dependencies": [],
            "description": "Enhance the existing WebSocket stub in adapters/http/server/websocket.go with gorilla/websocket implementation for terminal communication",
            "details": "Import and configure gorilla/websocket library. Extend the existing websocket.go stub to handle WebSocket upgrade requests. Implement basic connection lifecycle (connect, disconnect, error handling). Define WebSocket message types for terminal operations (input, output, resize, control). Create WebSocket handler registration with the HTTP server. Add proper logging for connection events.",
            "id": 1,
            "status": "pending",
            "testStrategy": "",
            "title": "Extend WebSocket Handler in websocket.go"
          },
          {
            "dependencies": ["8.1"],
            "description": "Create bidirectional message routing system between browser clients and container terminals",
            "details": "Define message protocol structure (JSON with type, payload, metadata). Implement message parser and serializer for terminal commands. Create routing logic to forward stdin from browser to container. Handle stdout/stderr from container to browser. Implement terminal resize events handling. Add message buffering for reliability. Create error message handling and propagation.",
            "id": 2,
            "status": "pending",
            "testStrategy": "",
            "title": "Implement Message Routing Protocol"
          },
          {
            "dependencies": ["8.1"],
            "description": "Implement JWT token validation for WebSocket connections to ensure secure access",
            "details": "Extract JWT from WebSocket connection request (query param or header). Validate JWT signature and expiration using existing auth infrastructure. Extract user/project context from JWT claims. Reject unauthorized connections with appropriate error codes. Store authenticated session information for connection lifecycle. Implement token refresh mechanism for long-lived connections. Add rate limiting per authenticated user.",
            "id": 3,
            "status": "pending",
            "testStrategy": "",
            "title": "Add JWT Authentication Middleware"
          },
          {
            "dependencies": ["8.2", "8.3"],
            "description": "Build connection pool to support multiple concurrent WebSocket connections per project",
            "details": "Create connection registry map keyed by project ID. Implement connection pool with configurable limits per project. Add connection tracking with unique session IDs. Handle connection multiplexing for same project. Implement broadcast mechanism for project-wide events. Create connection health checking with ping/pong. Add metrics for active connections per project.",
            "id": 4,
            "status": "pending",
            "testStrategy": "",
            "title": "Implement Concurrent Connection Management"
          },
          {
            "dependencies": ["8.4"],
            "description": "Implement robust connection lifecycle management with cleanup and recovery mechanisms",
            "details": "Implement graceful shutdown for WebSocket connections. Add cleanup goroutine to remove stale connections. Handle container termination and notify connected clients. Implement reconnection support with session recovery. Add connection timeout handling with configurable durations. Create resource cleanup on disconnect (goroutines, channels). Implement connection state persistence for recovery after server restart.",
            "id": 5,
            "status": "pending",
            "testStrategy": "",
            "title": "Build Connection Cleanup and Recovery"
          }
        ],
        "testStrategy": "Test WebSocket connection lifecycle. Verify message routing with mock containers. Test concurrent connections handling. Validate JWT authentication.",
        "title": "Create WebSocket Server"
      },
      {
        "dependencies": [8],
        "description": "Create web-based terminal interface for container access",
        "details": "Create React component using xterm.js in web/platform. Implement terminal emulator with ANSI support. Connect to WebSocket for bidirectional communication. Handle terminal resize events. Add copy/paste support. Style with existing Tailwind theme.",
        "id": 9,
        "priority": "medium",
        "status": "pending",
        "subtasks": [
          {
            "dependencies": [],
            "description": "Set up React component structure with xterm.js integration in web/platform",
            "details": "Install xterm.js and xterm-addon-fit packages. Create TerminalComponent.tsx in web/platform/src/components. Initialize xterm.Terminal instance with proper configuration (theme, cursor blink, font family). Set up component lifecycle hooks for terminal initialization and cleanup. Configure terminal options for scrollback buffer and keyboard handling.",
            "id": 1,
            "status": "pending",
            "testStrategy": "",
            "title": "Create Terminal React Component"
          },
          {
            "dependencies": ["9.1"],
            "description": "Create WebSocket client for bidirectional communication with backend",
            "details": "Create WebSocketService class to manage connection lifecycle. Implement reconnection logic with exponential backoff. Handle authentication token in WebSocket handshake. Set up message protocol for terminal data exchange. Implement heartbeat/ping-pong to maintain connection. Handle connection state changes and error scenarios.",
            "id": 2,
            "status": "pending",
            "testStrategy": "",
            "title": "Implement WebSocket Connection Handler"
          },
          {
            "dependencies": ["9.1"],
            "description": "Configure terminal to properly render ANSI escape sequences and colors",
            "details": "Configure xterm.js color theme matching system palette. Enable full ANSI/VT100 escape sequence parsing. Add support for 256 colors and true color sequences. Implement cursor movement and screen manipulation commands. Test with common CLI tools (vim, htop, colored output). Ensure proper handling of control characters.",
            "id": 3,
            "status": "pending",
            "testStrategy": "",
            "title": "Add ANSI Escape Sequence Support"
          },
          {
            "dependencies": ["9.1", "9.2"],
            "description": "Implement dynamic terminal resizing based on container dimensions",
            "details": "Use xterm-addon-fit to auto-fit terminal to container. Add ResizeObserver to detect container size changes. Send resize events through WebSocket to backend PTY. Implement debouncing for resize events to prevent flooding. Calculate rows/cols based on font metrics. Handle responsive layout changes and window resizing.",
            "id": 4,
            "status": "pending",
            "testStrategy": "",
            "title": "Handle Terminal Resize Events"
          },
          {
            "dependencies": ["9.1"],
            "description": "Add clipboard operations with proper security handling",
            "details": "Use xterm-addon-clipboard for native clipboard integration. Implement custom context menu for copy/paste actions. Add keyboard shortcuts (Ctrl+C/V with proper shell signal handling). Handle browser clipboard API permissions. Implement paste confirmation for security. Add visual feedback for selection and copy operations.",
            "id": 5,
            "status": "pending",
            "testStrategy": "",
            "title": "Implement Copy/Paste Functionality"
          },
          {
            "dependencies": ["9.1", "9.3", "9.4", "9.5"],
            "description": "Style terminal component using existing design system",
            "details": "Apply Tailwind classes for terminal container layout. Implement dark/light theme switching for terminal colors. Style terminal header with title and action buttons. Add loading states and connection indicators. Create responsive layout for mobile and desktop. Integrate with existing web/platform UI component library.",
            "id": 6,
            "status": "pending",
            "testStrategy": "",
            "title": "Apply Tailwind Styling and Theme"
          }
        ],
        "testStrategy": "E2E test terminal interaction. Test ANSI escape sequences rendering. Verify resize handling. Test copy/paste functionality.",
        "title": "Implement Web Terminal"
      },
      {
        "dependencies": [6],
        "description": "Create API for container file system operations",
        "details": "Implement REST endpoints for: list files, read file, write file, create/delete files. Use Docker SDK for file operations in containers. Add file watching for change notifications via WebSocket. Implement file permissions and size limits.",
        "id": 10,
        "priority": "medium",
        "status": "pending",
        "subtasks": [
          {
            "dependencies": [],
            "description": "Define OpenAPI specifications for file system operations including list, read, write, create, and delete endpoints",
            "details": "Create OpenAPI schema definitions in api/paths/ for file operations endpoints. Define request/response schemas for file metadata, content streaming, and directory listing. Include pagination for file lists, content-type handling for different file formats, and error response schemas. Follow existing API patterns in the codebase.",
            "id": 1,
            "status": "pending",
            "testStrategy": "",
            "title": "Design REST API endpoints for file operations"
          },
          {
            "dependencies": [],
            "description": "Create service layer for interacting with Docker container file systems using Docker SDK",
            "details": "Build service in internal/infrastructure/docker/ that wraps Docker SDK for file operations. Implement methods for CopyFromContainer, CopyToContainer, and ExecCreate for file manipulation. Handle container context switching and path resolution. Add connection pooling for Docker client instances.",
            "id": 2,
            "status": "pending",
            "testStrategy": "",
            "title": "Implement Docker SDK file operations service"
          },
          {
            "dependencies": ["10.1", "10.2"],
            "description": "Implement HTTP handlers that connect REST endpoints to Docker file operations",
            "details": "Create handlers in internal/adapters/http/handlers/ implementing the OpenAPI spec. Add request validation, error handling, and response formatting. Implement streaming for large file uploads/downloads. Include proper HTTP status codes and content negotiation.",
            "id": 3,
            "status": "pending",
            "testStrategy": "",
            "title": "Create file system API handlers"
          },
          {
            "dependencies": ["10.2"],
            "description": "Implement file change detection system for containers using fsnotify or Docker events",
            "details": "Create watcher service that monitors file changes in containers. Use Docker SDK's event stream API or implement exec-based file watching. Build event aggregation to prevent notification flooding. Handle watcher lifecycle management and cleanup.",
            "id": 4,
            "status": "pending",
            "testStrategy": "",
            "title": "Build file watching system with fsnotify"
          },
          {
            "dependencies": ["10.4"],
            "description": "Create WebSocket infrastructure for real-time file change notifications",
            "details": "Build WebSocket handler in internal/adapters/http/handlers/ for real-time updates. Implement subscription management for specific paths or containers. Add message queuing with Redis for reliable delivery. Create client reconnection logic and heartbeat mechanism.",
            "id": 5,
            "status": "pending",
            "testStrategy": "",
            "title": "Implement WebSocket notification system"
          },
          {
            "dependencies": ["10.3"],
            "description": "Implement file permission checks and size limit validation",
            "details": "Create middleware for permission validation based on user roles and container ownership. Implement file size limit checks before upload operations. Add file type validation and sanitization. Create configuration for limits in internal/infrastructure/config/. Include audit logging for file operations.",
            "id": 6,
            "status": "pending",
            "testStrategy": "",
            "title": "Add permissions and file validation system"
          }
        ],
        "testStrategy": "Test all CRUD operations on container files. Verify file watching notifications. Test permission enforcement and size limits.",
        "title": "Build File System API"
      },
      {
        "dependencies": [3],
        "description": "Build Claude API integration for AI-powered code refinement",
        "details": "Extend adapters/llm package with Claude client using Anthropic SDK. Implement context management for conversation history. Add prompt engineering for code generation tasks. Handle streaming responses for real-time updates. Store conversations in PostgreSQL.",
        "id": 11,
        "priority": "high",
        "status": "pending",
        "subtasks": [
          {
            "dependencies": [],
            "description": "Implement Claude API client in adapters/llm package using the Anthropic Go SDK, following existing patterns from OpenAI/Ollama implementations",
            "details": "Create new claude.go file in internal/adapters/llm. Implement Client interface with methods for chat completions. Add configuration for API key, model selection (claude-3-opus, claude-3-sonnet, etc.), and request parameters. Handle authentication and base request setup. Follow existing OpenAI client pattern for consistency.",
            "id": 1,
            "status": "pending",
            "testStrategy": "",
            "title": "Create Claude API Client with Anthropic SDK"
          },
          {
            "dependencies": ["11.1"],
            "description": "Build context management system for maintaining conversation history and managing context windows for Claude API calls",
            "details": "Create conversation manager in adapters/llm to track message history. Implement context window calculation for Claude models (200k tokens). Add message pruning strategies when approaching token limits. Create context assembly methods that combine system prompts, conversation history, and current request. Implement message role management (system, user, assistant).",
            "id": 2,
            "status": "pending",
            "testStrategy": "",
            "title": "Implement Conversation Context Management"
          },
          {
            "dependencies": ["11.1"],
            "description": "Develop specialized prompting system for code generation, refinement, and analysis tasks optimized for Claude",
            "details": "Create prompt templates for different code tasks (generation, refactoring, review, documentation). Implement dynamic prompt construction based on OpenAPI specs and project context. Add code-specific instructions for language best practices. Create prompt optimization for including relevant code examples and patterns. Build prompt validation to ensure quality inputs.",
            "id": 3,
            "status": "pending",
            "testStrategy": "",
            "title": "Add Code Generation Prompt Engineering"
          },
          {
            "dependencies": ["11.1", "11.2"],
            "description": "Implement streaming response processing for real-time updates from Claude API with proper error handling",
            "details": "Implement SSE (Server-Sent Events) handler for Claude streaming responses. Create response parser for incremental JSON chunks. Add buffering and reassembly for partial responses. Implement error recovery for stream interruptions. Create callbacks for UI updates during streaming. Handle rate limiting and retry logic for streaming connections.",
            "id": 4,
            "status": "pending",
            "testStrategy": "",
            "title": "Build Streaming Response Handler"
          },
          {
            "dependencies": ["11.2"],
            "description": "Design and implement database schema and repository for storing AI conversations and interaction history",
            "details": "Design conversations table schema with fields for session_id, messages, metadata, timestamps. Create SQLC queries for CRUD operations on conversations. Implement repository pattern following existing PostgreSQL patterns. Add indexes for efficient conversation retrieval. Create migration files using goose format. Implement conversation archival and cleanup strategies.",
            "id": 5,
            "status": "pending",
            "testStrategy": "",
            "title": "Create PostgreSQL Conversation Storage"
          }
        ],
        "testStrategy": "Mock Claude API responses for testing. Test conversation context management. Verify streaming response handling. Test error recovery and retries.",
        "title": "Integrate Claude AI API"
      },
      {
        "dependencies": [11],
        "description": "Build context management system for AI interactions",
        "details": "Create service to manage AI context including: OpenAPI spec, generated code, file system state, user modifications. Implement context window optimization. Add semantic chunking for large codebases. Cache frequently accessed context in Redis.",
        "id": 12,
        "priority": "medium",
        "status": "pending",
        "subtasks": [
          {
            "dependencies": [],
            "description": "Create the foundational data structures for storing and organizing AI context including OpenAPI specs, code artifacts, and file system state",
            "details": "Define Go structs in internal/core/entities for ContextItem, ContextWindow, and ContextCache. Create value objects for ContextType, ContextPriority, and ContextMetadata. Design interfaces in internal/core/ports/services for ContextManager. Include fields for OpenAPI references, generated code paths, modification timestamps, and semantic embeddings.",
            "id": 1,
            "status": "pending",
            "testStrategy": "",
            "title": "Design context data model and storage structures"
          },
          {
            "dependencies": ["12.1"],
            "description": "Build functionality to parse, store, and retrieve OpenAPI specifications as part of the AI context",
            "details": "Create OpenAPIContextProvider in internal/application/services implementing context inclusion for api/openapi.yaml and component files. Parse YAML/JSON specifications using existing parsers. Extract relevant schemas, paths, and operations based on current task. Store parsed spec in memory with efficient indexing. Add methods to retrieve specific API endpoints and schemas on demand.",
            "id": 2,
            "status": "pending",
            "testStrategy": "",
            "title": "Implement OpenAPI specification inclusion and parsing"
          },
          {
            "dependencies": ["12.1"],
            "description": "Implement system to track and include generated code files in the AI context with change detection",
            "details": "Build GeneratedCodeTracker in internal/application/services to monitor *.gen.go files and other generated artifacts. Use file system watchers to detect changes in generated code. Maintain mapping between OpenAPI definitions and generated code locations. Include code generation timestamps and versioning. Sync with codegen output directories automatically.",
            "id": 3,
            "status": "pending",
            "testStrategy": "",
            "title": "Add generated code tracking and synchronization"
          },
          {
            "dependencies": ["12.1"],
            "description": "Create comprehensive file system state tracking for project files and user modifications",
            "details": "Implement FileSystemContextProvider in internal/infrastructure/context using fsnotify for file watching. Track file modifications, additions, and deletions in real-time. Build project tree representation with file metadata and git status. Monitor user changes to distinguish from generated code. Create efficient diff mechanisms for tracking incremental changes.",
            "id": 4,
            "status": "pending",
            "testStrategy": "",
            "title": "Build file system state management and monitoring"
          },
          {
            "dependencies": ["12.2", "12.3", "12.4"],
            "description": "Develop algorithms to optimize context window usage based on relevance and token limits",
            "details": "Create ContextOptimizer in internal/application/services with token counting using tiktoken or similar. Implement relevance scoring based on file recency, dependency graph, and current task. Build pruning algorithms to fit within model context limits (8k, 32k, 128k tokens). Add priority queuing for most relevant context items. Include strategies for different model providers (OpenAI, Anthropic, etc.).",
            "id": 5,
            "status": "pending",
            "testStrategy": "",
            "title": "Implement context window optimization algorithms"
          },
          {
            "dependencies": ["12.5"],
            "description": "Implement intelligent code chunking using semantic analysis to handle large projects efficiently",
            "details": "Build SemanticChunker in internal/application/services using AST parsing for Go code. Implement function and type boundary detection for natural chunk points. Add embedding generation for semantic similarity search. Create chunk size optimization based on context window limits. Include cross-reference resolution to maintain code relationships. Support incremental re-chunking on file changes.",
            "id": 6,
            "status": "pending",
            "testStrategy": "",
            "title": "Add semantic chunking for large codebases"
          },
          {
            "dependencies": ["12.2", "12.3", "12.4", "12.6"],
            "description": "Implement Redis-based caching system for frequently accessed context with TTL management",
            "details": "Extend internal/infrastructure/redis/client.go with context caching methods. Implement cache key generation based on project ID and context type. Add TTL-based expiration for different context types (specs: 1h, code: 15m, state: 5m). Create cache warming on project initialization. Build cache invalidation on file changes. Add metrics for cache hit/miss rates. Implement batch operations for efficient retrieval.",
            "id": 7,
            "status": "pending",
            "testStrategy": "",
            "title": "Create Redis caching layer for context data"
          }
        ],
        "testStrategy": "Test context assembly with various project sizes. Verify context window optimization. Test caching effectiveness. Validate semantic chunking.",
        "title": "Create AI Context Manager"
      },
      {
        "dependencies": [3],
        "description": "Create AST parser for code modification without full regeneration",
        "details": "Use go/ast package for Go code parsing. Implement AST modification functions: add method, modify struct, update imports. Preserve formatting and comments. Support multiple languages via tree-sitter. Create unified AST interface.",
        "id": 13,
        "priority": "medium",
        "status": "pending",
        "subtasks": [
          {
            "dependencies": [],
            "description": "Set up core Go AST parsing infrastructure using go/ast package",
            "details": "Create base parser structure in internal/parsers/ast/. Implement file parsing with go/parser. Build AST traversal utilities. Handle package declarations and imports. Create node visitor pattern for AST walking. Set up error handling for malformed code.",
            "id": 1,
            "status": "pending",
            "testStrategy": "",
            "title": "Implement Go AST parser foundation"
          },
          {
            "dependencies": ["13.1"],
            "description": "Implement functions to modify Go AST nodes programmatically",
            "details": "Create AddMethod function to add methods to structs/interfaces. Implement ModifyStruct for adding/removing fields. Build UpdateImports for managing import declarations. Add function signature modification. Handle type declarations and constants. Ensure modifications maintain valid Go syntax.",
            "id": 2,
            "status": "pending",
            "testStrategy": "",
            "title": "Build AST modification functions for Go"
          },
          {
            "dependencies": ["13.2"],
            "description": "Preserve original formatting, comments, and code style during AST modifications",
            "details": "Use go/format for code formatting preservation. Implement comment mapping to AST nodes. Handle inline, block, and doc comments. Preserve original whitespace patterns. Maintain build tags and directives position. Create formatter configuration options.",
            "id": 3,
            "status": "pending",
            "testStrategy": "",
            "title": "Implement formatting and comment preservation"
          },
          {
            "dependencies": [],
            "description": "Add tree-sitter bindings for parsing non-Go languages",
            "details": "Integrate go-tree-sitter library. Add language parsers for TypeScript, Python, and Rust. Create language-specific AST node mappings. Implement query patterns for common operations. Handle language-specific syntax features. Build parser initialization and cleanup.",
            "id": 4,
            "status": "pending",
            "testStrategy": "",
            "title": "Integrate tree-sitter for multi-language support"
          },
          {
            "dependencies": ["13.1", "13.4"],
            "description": "Design language-agnostic AST interface for all supported languages",
            "details": "Define UnifiedAST interface in internal/parsers/ast/unified.go. Create node type abstractions (Function, Class, Variable). Implement language adapters for Go and tree-sitter ASTs. Build common operation methods (Find, Replace, Insert). Add AST serialization/deserialization. Create AST query language.",
            "id": 5,
            "status": "pending",
            "testStrategy": "",
            "title": "Create unified AST interface"
          },
          {
            "dependencies": ["13.3"],
            "description": "Support Go build tags and compiler directives in AST operations",
            "details": "Parse and preserve //go:build tags. Handle //go:generate directives. Support conditional compilation blocks. Maintain directive ordering and positioning. Validate build tag syntax. Handle platform-specific code sections.",
            "id": 6,
            "status": "pending",
            "testStrategy": "",
            "title": "Handle build tags and compiler directives"
          },
          {
            "dependencies": ["13.5"],
            "description": "Create diff generation for AST modifications to track changes",
            "details": "Build AST comparison algorithm. Generate structured diff output. Create patch application system. Support three-way merge for conflicts. Implement rollback capability. Add change visualization for debugging.",
            "id": 7,
            "status": "pending",
            "testStrategy": "",
            "title": "Implement AST diff generation"
          },
          {
            "dependencies": ["13.5", "13.6", "13.7"],
            "description": "Implement comprehensive validation and testing for AST operations",
            "details": "Create AST validation rules for each language. Implement syntax checking after modifications. Build test suite with edge cases. Add benchmark tests for performance. Test comment and formatting preservation. Validate multi-language interface consistency.",
            "id": 8,
            "status": "pending",
            "testStrategy": "",
            "title": "Add AST validation and testing"
          }
        ],
        "testStrategy": "Test AST parsing and modification for Go. Verify formatting preservation. Test edge cases like comments and build tags. Validate multi-language support.",
        "title": "Implement Code AST Parser"
      },
      {
        "dependencies": [11, 12, 13],
        "description": "Create engine for applying AI-suggested code modifications",
        "details": "Parse Claude responses for code modifications. Apply changes via AST manipulation. Validate modifications against OpenAPI spec. Implement rollback on validation failure. Track modification history for undo/redo.",
        "id": 14,
        "priority": "medium",
        "status": "pending",
        "subtasks": [
          {
            "dependencies": [],
            "description": "Implement parser for Claude API responses to extract code modification instructions",
            "details": "Create response parser module in internal/core/services/ai_refinement. Define structured format for Claude code modification responses. Extract code blocks, file paths, and modification instructions. Handle multiple response formats (inline edits, full replacements, new files). Implement error handling for malformed responses.",
            "id": 1,
            "status": "pending",
            "testStrategy": "",
            "title": "Parse Claude Response Format"
          },
          {
            "dependencies": ["14.1"],
            "description": "Build extraction engine to identify and categorize code changes from parsed responses",
            "details": "Create modification extractor in internal/core/services/ai_refinement. Categorize modifications (add, update, delete, replace). Extract line numbers and code ranges for targeted changes. Build modification descriptor objects with metadata. Handle multi-file modifications in single response.",
            "id": 2,
            "status": "pending",
            "testStrategy": "",
            "title": "Extract Code Modifications"
          },
          {
            "dependencies": ["14.2"],
            "description": "Implement AST manipulation engine for applying code modifications",
            "details": "Build AST modifier in internal/parsers using go/ast package. Parse Go code into AST representation. Apply modifications at AST node level. Preserve code formatting and comments. Generate modified code from updated AST. Handle TypeScript/JavaScript AST for frontend code.",
            "id": 3,
            "status": "pending",
            "testStrategy": "",
            "title": "Apply Changes via AST"
          },
          {
            "dependencies": ["14.3"],
            "description": "Create validation system to ensure modifications comply with OpenAPI specifications",
            "details": "Build OpenAPI validator in internal/core/services/validation. Validate modified code against current OpenAPI spec. Check type consistency, required fields, and constraints. Validate API endpoint signatures and responses. Generate validation report with specific violations. Integration with existing OpenAPI parser.",
            "id": 4,
            "status": "pending",
            "testStrategy": "",
            "title": "Validate Against OpenAPI Spec"
          },
          {
            "dependencies": ["14.4"],
            "description": "Build rollback system for reverting failed modifications",
            "details": "Create rollback manager in internal/core/services/ai_refinement. Implement file backup before modifications. Build atomic transaction wrapper for multi-file changes. Create rollback triggers on validation failures. Implement partial rollback for complex modifications. Add rollback status tracking and reporting.",
            "id": 5,
            "status": "pending",
            "testStrategy": "",
            "title": "Implement Rollback Mechanism"
          },
          {
            "dependencies": ["14.5"],
            "description": "Implement modification tracking and history management system",
            "details": "Create history store in internal/infrastructure/persistence. Define modification history entity with metadata. Track modification timestamps, authors, and AI prompts. Store before/after snapshots for each change. Implement history pruning and archival. Create history query interface for retrieval.",
            "id": 6,
            "status": "pending",
            "testStrategy": "",
            "title": "Build Modification History"
          },
          {
            "dependencies": ["14.6"],
            "description": "Implement undo/redo operations for modification history",
            "details": "Build undo/redo manager in internal/core/services/ai_refinement. Implement command pattern for reversible operations. Create undo stack with configurable depth. Build redo functionality for reversed operations. Add conflict detection for overlapping changes. Create API endpoints for undo/redo operations.",
            "id": 7,
            "status": "pending",
            "testStrategy": "",
            "title": "Add Undo/Redo Functionality"
          }
        ],
        "testStrategy": "Test modification parsing and application. Verify spec validation after changes. Test rollback mechanism. Validate modification history.",
        "title": "Build AI Refinement Engine"
      },
      {
        "dependencies": [1, 2],
        "description": "Build generator for React components from OpenAPI schemas",
        "details": "Generate TypeScript React components from schemas. Create form components for request bodies. Build display components for responses. Use React Hook Form for forms. Apply Tailwind styles from design system. Generate Storybook stories.",
        "id": 15,
        "priority": "medium",
        "status": "pending",
        "subtasks": [
          {
            "dependencies": [],
            "description": "Parse OpenAPI schemas and generate corresponding TypeScript type definitions with proper inheritance and composition",
            "details": "Parse OpenAPI specification from api/openapi.yaml. Extract schema definitions from components/schemas. Handle primitive types, arrays, objects, and references. Generate TypeScript interfaces with proper naming conventions. Handle nullable fields and optional properties. Support schema composition (allOf, oneOf, anyOf). Place generated interfaces in web/client/src/generated/types.",
            "id": 1,
            "status": "pending",
            "testStrategy": "",
            "title": "Map OpenAPI schemas to TypeScript interfaces"
          },
          {
            "dependencies": ["15.1"],
            "description": "Create form components for request bodies using React Hook Form with validation and error handling",
            "details": "Generate form components for POST/PUT/PATCH request bodies. Integrate React Hook Form for form state management. Map OpenAPI validation rules to React Hook Form validators. Handle nested object structures in forms. Generate field components based on schema property types. Include error message display components. Support file upload fields for multipart forms.",
            "id": 2,
            "status": "pending",
            "testStrategy": "",
            "title": "Generate form components with React Hook Form"
          },
          {
            "dependencies": ["15.1"],
            "description": "Build presentational components for rendering API response data with proper typing",
            "details": "Generate display components for response schemas. Create list components for array responses. Build detail view components for single objects. Handle polymorphic responses (different status codes). Generate loading and error state components. Support pagination components for list endpoints. Include data formatting utilities for dates and numbers.",
            "id": 3,
            "status": "pending",
            "testStrategy": "",
            "title": "Create display components for API responses"
          },
          {
            "dependencies": ["15.2", "15.3"],
            "description": "Integrate existing Tailwind design system from web/platform into generated components",
            "details": "Import Tailwind configuration from web/platform/tailwind.config.js. Apply consistent styling patterns from existing UI components. Use design system color palette and spacing. Implement responsive layouts using Tailwind breakpoints. Apply form styling consistent with web/ui components. Add hover and focus states for interactive elements. Ensure dark mode compatibility.",
            "id": 4,
            "status": "pending",
            "testStrategy": "",
            "title": "Apply Tailwind styles from design system"
          },
          {
            "dependencies": ["15.2", "15.3"],
            "description": "Create TypeScript prop definitions and default values for all generated components",
            "details": "Generate TypeScript prop interfaces for each component. Define default props for optional properties. Create prop validation using TypeScript strict mode. Generate custom hooks for component logic. Export component props for reusability. Handle generic component props for flexibility. Document prop types with JSDoc comments.",
            "id": 5,
            "status": "pending",
            "testStrategy": "",
            "title": "Generate prop types and component defaults"
          },
          {
            "dependencies": ["15.2", "15.3", "15.4"],
            "description": "Generate Storybook stories for visual testing and documentation of components",
            "details": "Generate .stories.tsx files for each component. Create story templates with mock data from schemas. Add controls for interactive prop testing. Generate stories for different component states. Include stories for error and loading states. Create composite stories showing component integration. Configure Storybook decorators for Tailwind styles.",
            "id": 6,
            "status": "pending",
            "testStrategy": "",
            "title": "Create Storybook stories for components"
          },
          {
            "dependencies": ["15.1", "15.5", "15.6"],
            "description": "Generate comprehensive documentation for all created React components",
            "details": "Generate README files for component usage. Create API documentation from prop types. Include code examples for common use cases. Generate component dependency graphs. Document form validation rules. Create migration guide from OpenAPI changes. Add inline JSDoc comments for all functions and components.",
            "id": 7,
            "status": "pending",
            "testStrategy": "",
            "title": "Add component documentation generation"
          }
        ],
        "testStrategy": "Compile generated TypeScript code. Test component rendering with React Testing Library. Verify form validation logic. Test Storybook story generation.",
        "title": "Create React Component Generator"
      },
      {
        "dependencies": [1],
        "description": "Generate TypeScript types and interfaces from OpenAPI specs",
        "details": "Map OpenAPI schemas to TypeScript interfaces. Handle union types for oneOf/anyOf. Generate enums from enum schemas. Create type guards for runtime validation. Support generic types for reusable components.",
        "id": 16,
        "priority": "medium",
        "status": "pending",
        "subtasks": [
          {
            "dependencies": [],
            "description": "Create core type mapping logic to convert OpenAPI schema types (string, number, boolean, array, object) to their TypeScript equivalents",
            "details": "Implement type mapper in internal/codegen that handles OpenAPI primitive types (string  string, integer  number, etc.) and complex types (array  T[], object  interface). Handle nullable types with union syntax (T | null). Support format hints like date-time  Date. Reference existing patterns in web/client/src/generated for consistency.",
            "id": 1,
            "status": "pending",
            "testStrategy": "",
            "title": "Map OpenAPI primitive and complex types to TypeScript"
          },
          {
            "dependencies": ["16.1"],
            "description": "Implement logic to generate TypeScript union and intersection types from OpenAPI's oneOf, anyOf, and allOf constructs",
            "details": "Parse oneOf schemas to generate discriminated unions with type guards. Convert anyOf to flexible union types. Handle allOf with TypeScript intersection types (&). Add discriminator property support for polymorphic types. Generate helper functions to narrow union types at runtime.",
            "id": 2,
            "status": "pending",
            "testStrategy": "",
            "title": "Handle union types for oneOf/anyOf/allOf schemas"
          },
          {
            "dependencies": ["16.1"],
            "description": "Create enum generator that converts OpenAPI enum definitions to TypeScript enums or const assertions",
            "details": "Detect enum properties in OpenAPI schemas and generate TypeScript enums for string/number values. Use const assertions for mixed-type enums. Handle x-enum-varnames extension for custom enum names. Generate reverse mappings for numeric enums. Create string literal union types as alternative to enums when appropriate.",
            "id": 3,
            "status": "pending",
            "testStrategy": "",
            "title": "Generate enums from OpenAPI enum schemas"
          },
          {
            "dependencies": ["16.1", "16.2", "16.3"],
            "description": "Generate type guard functions that validate data at runtime against the generated TypeScript types",
            "details": "Generate isType() guard functions for each interface using TypeScript's type predicate syntax. Create validation functions that check required properties, types, and constraints. Handle nested object validation recursively. Generate guards for union types that check discriminator fields. Include runtime checks for enum values.",
            "id": 4,
            "status": "pending",
            "testStrategy": "",
            "title": "Create runtime type guards and validators"
          },
          {
            "dependencies": ["16.1", "16.2"],
            "description": "Implement generic type parameters for commonly reused schema patterns like pagination, responses, and wrapper types",
            "details": "Detect reusable patterns in OpenAPI components (e.g., PagedResponse<T>, ApiResponse<T>). Generate TypeScript generics with appropriate type constraints. Handle generic type inference from schema references. Create utility types for common patterns (Partial, Required, Pick). Support nested generics for complex data structures.",
            "id": 5,
            "status": "pending",
            "testStrategy": "",
            "title": "Support generic types for reusable components"
          },
          {
            "dependencies": ["16.1", "16.2", "16.3", "16.4", "16.5"],
            "description": "Extract descriptions, examples, and constraints from OpenAPI schemas and generate comprehensive JSDoc comments",
            "details": "Parse description fields from OpenAPI schemas and format as JSDoc comments. Include @param tags for function parameters. Add @example blocks from schema examples. Document constraints like min/max values, patterns, and required fields. Include @deprecated tags for deprecated schemas. Generate @see tags for related types.",
            "id": 6,
            "status": "pending",
            "testStrategy": "",
            "title": "Add JSDoc comments from OpenAPI descriptions"
          }
        ],
        "testStrategy": "Compile generated TypeScript with strict mode. Test type inference with complex schemas. Verify runtime type guards. Test enum generation.",
        "title": "Implement TypeScript Type Generator"
      },
      {
        "dependencies": [1, 16],
        "description": "Generate type-safe API clients for multiple languages",
        "details": "Generate Axios-based TypeScript client. Create fetch wrapper with types. Implement request/response interceptors. Add retry logic and error handling. Generate SDK documentation. Support multiple auth methods.",
        "id": 17,
        "priority": "medium",
        "status": "pending",
        "subtasks": [
          {
            "dependencies": [],
            "description": "Create the core Axios client generator that produces type-safe API methods from OpenAPI specs",
            "details": "Build generator that reads OpenAPI paths and operations to create Axios-based client methods. Use existing web/client/src/generated as reference. Generate request/response types from schemas. Create base client configuration with default headers and base URL. Ensure proper TypeScript typing for all generated methods.",
            "id": 1,
            "status": "pending",
            "testStrategy": "",
            "title": "Generate Axios-based TypeScript client"
          },
          {
            "dependencies": [],
            "description": "Implement alternative fetch-based client generator for environments without Axios",
            "details": "Generate fetch-based API client as lightweight alternative. Implement typed request/response handling. Create wrapper functions for common HTTP methods (GET, POST, PUT, DELETE). Add proper error handling and response parsing. Ensure TypeScript type safety throughout.",
            "id": 2,
            "status": "pending",
            "testStrategy": "",
            "title": "Create fetch wrapper with types"
          },
          {
            "dependencies": ["17.1", "17.2"],
            "description": "Add interceptor system for both Axios and fetch clients to handle cross-cutting concerns",
            "details": "Create request interceptor interface for adding auth headers, request ID, and custom headers. Implement response interceptors for logging, error transformation, and response mapping. Support chaining multiple interceptors. Allow runtime configuration of interceptor behavior.",
            "id": 3,
            "status": "pending",
            "testStrategy": "",
            "title": "Implement request/response interceptors"
          },
          {
            "dependencies": ["17.1", "17.2"],
            "description": "Implement comprehensive retry mechanisms and error handling strategies",
            "details": "Add exponential backoff retry logic for failed requests. Implement circuit breaker pattern for failing endpoints. Create typed error classes for different HTTP status codes. Add timeout handling and request cancellation. Generate error recovery strategies based on API spec.",
            "id": 4,
            "status": "pending",
            "testStrategy": "",
            "title": "Add retry logic and error handling"
          },
          {
            "dependencies": ["17.3"],
            "description": "Generate authentication handlers for various auth schemes defined in OpenAPI",
            "details": "Parse OpenAPI security schemes (OAuth2, Bearer, API Key, Basic Auth). Generate auth configuration interfaces. Implement token refresh logic for OAuth2. Create auth provider abstraction for runtime auth switching. Handle auth errors and re-authentication flows.",
            "id": 5,
            "status": "pending",
            "testStrategy": "",
            "title": "Support multiple auth methods"
          },
          {
            "dependencies": ["17.1", "17.2", "17.3", "17.4", "17.5"],
            "description": "Create comprehensive documentation for the generated API clients",
            "details": "Generate TypeDoc comments from OpenAPI descriptions. Create README with usage examples for each client type. Document authentication setup and configuration. Generate API method reference with parameters and return types. Include code examples for common use cases and error handling.",
            "id": 6,
            "status": "pending",
            "testStrategy": "",
            "title": "Generate SDK documentation"
          }
        ],
        "testStrategy": "Test generated client against mock server. Verify type safety with TypeScript. Test auth methods and interceptors. Validate error handling.",
        "title": "Build API Client Generator"
      },
      {
        "dependencies": [6, 15],
        "description": "Build server for live preview of generated applications",
        "details": "Create preview server running in containers. Implement hot-reload via file watching. Proxy requests between frontend and backend. Handle CORS for development. Support multiple preview environments.",
        "id": 18,
        "priority": "medium",
        "status": "pending",
        "subtasks": [
          {
            "dependencies": [],
            "description": "Create Docker container configuration and orchestration setup for running preview servers",
            "details": "Create Dockerfile in deployments/docker for preview server container. Set up Docker Compose configuration for local development. Implement container lifecycle management using Docker SDK in internal/infrastructure/containers. Configure container networking for isolation between preview environments. Add resource limits and health checks for containers.",
            "id": 1,
            "status": "pending",
            "testStrategy": "",
            "title": "Set up container orchestration for preview server"
          },
          {
            "dependencies": ["18.1"],
            "description": "Build file watching mechanism to detect changes and trigger hot-reload in preview containers",
            "details": "Implement file watcher using fsnotify in internal/infrastructure/preview/watcher.go. Create debouncing mechanism to batch rapid file changes. Build reload command injection into running containers via Docker exec. Support watching multiple directories (generated code, templates, assets). Add ignore patterns for build artifacts and temporary files.",
            "id": 2,
            "status": "pending",
            "testStrategy": "",
            "title": "Implement file watching and hot-reload system"
          },
          {
            "dependencies": ["18.1"],
            "description": "Create reverse proxy to route requests between frontend and backend services in preview environment",
            "details": "Implement HTTP reverse proxy in internal/adapters/http/proxy using httputil.ReverseProxy. Configure dynamic routing based on path patterns (/api/* to backend, /* to frontend). Add request/response modification for development headers. Implement WebSocket proxying for real-time features. Create proxy configuration management in internal/infrastructure/config.",
            "id": 3,
            "status": "pending",
            "testStrategy": "",
            "title": "Build HTTP proxy for frontend-backend communication"
          },
          {
            "dependencies": ["18.3"],
            "description": "Implement CORS configuration to allow cross-origin requests in preview environments",
            "details": "Add CORS middleware in internal/infrastructure/http/middleware/cors.go. Configure dynamic origin allowlist based on preview URLs. Set appropriate headers for preflight requests (OPTIONS). Support credentials and custom headers for API requests. Make CORS rules configurable per preview environment.",
            "id": 4,
            "status": "pending",
            "testStrategy": "",
            "title": "Configure CORS handling for development"
          },
          {
            "dependencies": ["18.1", "18.2", "18.3"],
            "description": "Enable running multiple isolated preview environments simultaneously",
            "details": "Create preview environment manager in internal/application/services/preview.go. Implement port allocation strategy for multiple containers. Add environment isolation using Docker networks. Create environment state tracking in Redis. Support environment templates for different project types.",
            "id": 5,
            "status": "pending",
            "testStrategy": "",
            "title": "Implement multi-environment preview support"
          },
          {
            "dependencies": ["18.5"],
            "description": "Generate unique preview URLs and implement routing to correct preview environments",
            "details": "Generate unique preview URLs using project ID and random suffix. Implement subdomain-based routing (preview-abc123.archesai.local). Add URL mapping storage in Redis with TTL. Create nginx configuration for wildcard subdomain routing. Implement preview URL API endpoints in internal/adapters/http/handlers.",
            "id": 6,
            "status": "pending",
            "testStrategy": "",
            "title": "Add preview URL generation and routing"
          },
          {
            "dependencies": ["18.5", "18.6"],
            "description": "Build system for automatic cleanup of unused preview environments and resource management",
            "details": "Create background worker for preview cleanup in internal/application/commands/preview. Implement TTL-based expiration for inactive previews. Add manual cleanup API endpoints. Monitor and clean up orphaned containers and volumes. Implement preview environment metrics collection for resource usage.",
            "id": 7,
            "status": "pending",
            "testStrategy": "",
            "title": "Implement preview cleanup and lifecycle management"
          }
        ],
        "testStrategy": "Test preview server startup in container. Verify hot-reload on file changes. Test proxy configuration. Validate CORS handling.",
        "title": "Create Preview Server"
      },
      {
        "dependencies": [15, 18],
        "description": "Build interactive playground for testing generated components",
        "details": "Create React app for component testing. Implement prop editor with JSON schema forms. Add viewport resize for responsive testing. Include theme switcher for dark mode. Export playground configurations.",
        "id": 19,
        "priority": "low",
        "status": "pending",
        "subtasks": [
          {
            "dependencies": [],
            "description": "Set up the foundational React application structure for the component playground",
            "details": "Initialize React app in web/playground directory. Configure React Router for navigation between playground sections. Set up base layout with sidebar for component selection and main content area for preview. Integrate with existing web/ui components library. Configure Tailwind CSS to match platform styling.",
            "id": 1,
            "status": "pending",
            "testStrategy": "",
            "title": "Create React App Shell with Routing"
          },
          {
            "dependencies": ["19.1"],
            "description": "Implement dynamic form generation from component prop schemas",
            "details": "Create PropEditor component that accepts JSON schema definitions. Implement form field generators for different data types (string, number, boolean, array, object). Add validation based on schema constraints. Include reset and undo functionality. Style form controls to match platform design system.",
            "id": 2,
            "status": "pending",
            "testStrategy": "",
            "title": "Build JSON Schema Form for Props Editor"
          },
          {
            "dependencies": ["19.1"],
            "description": "Implement responsive preview functionality with device presets",
            "details": "Create ViewportControls component with preset device sizes (mobile, tablet, desktop). Implement draggable resize handles for custom dimensions. Add dimension display showing current width/height. Include rotation toggle for portrait/landscape modes. Ensure smooth resizing with proper iframe scaling.",
            "id": 3,
            "status": "pending",
            "testStrategy": "",
            "title": "Add Viewport Resizing Controls"
          },
          {
            "dependencies": ["19.1", "19.2"],
            "description": "Add theme switching capability for testing components in different visual contexts",
            "details": "Create ThemeProvider that wraps playground preview area. Implement theme switcher UI with light/dark/system options. Store theme preference in localStorage. Apply theme to both playground UI and component preview. Support custom theme configurations through JSON.",
            "id": 4,
            "status": "pending",
            "testStrategy": "",
            "title": "Implement Theme Switcher with Dark Mode"
          },
          {
            "dependencies": ["19.2", "19.3", "19.4"],
            "description": "Enable saving and sharing of playground configurations",
            "details": "Implement export functionality to save component props, viewport settings, and theme as JSON. Add import feature to load saved configurations. Create shareable URL generation with encoded config. Include copy-to-clipboard for configuration sharing. Add configuration history with local storage persistence.",
            "id": 5,
            "status": "pending",
            "testStrategy": "",
            "title": "Add Configuration Export/Import"
          }
        ],
        "testStrategy": "E2E test playground interactions. Test prop editing and validation. Verify responsive preview. Test theme switching.",
        "title": "Implement Component Playground"
      },
      {
        "dependencies": [15],
        "description": "Create customizable design system generator",
        "details": "Generate design tokens from configuration. Create CSS variables and Tailwind config. Build theme editor UI with live preview. Support color palette generation. Add typography and spacing scales.",
        "id": 20,
        "priority": "low",
        "status": "pending",
        "subtasks": [
          {
            "dependencies": [],
            "description": "Define configuration structure for design tokens including colors, typography, spacing, and other design primitives",
            "details": "Create TypeScript interfaces and validation schema for design token configuration. Define structure for colors (primary, secondary, neutral palettes), typography (font families, sizes, weights, line heights), spacing scales, border radii, shadows, and breakpoints. Store configuration in YAML/JSON format compatible with existing project structure.",
            "id": 1,
            "status": "pending",
            "testStrategy": "",
            "title": "Create design token configuration schema"
          },
          {
            "dependencies": ["20.1"],
            "description": "Implement generator to convert design token configuration into CSS variables and Tailwind config",
            "details": "Create generator in internal/codegen that reads design token configuration and outputs CSS custom properties file and Tailwind configuration. Generate CSS variables with proper naming conventions (--color-primary-500, --spacing-4, etc.). Create Tailwind preset that maps to CSS variables. Ensure compatibility with existing Tailwind setup in web/platform.",
            "id": 2,
            "status": "pending",
            "testStrategy": "",
            "title": "Build design token generator"
          },
          {
            "dependencies": ["20.1"],
            "description": "Create color scale generation from base colors with accessibility considerations",
            "details": "Implement algorithm to generate color scales (50-900) from base colors using HSL manipulation. Add support for semantic color tokens (success, warning, error, info). Calculate and ensure WCAG contrast ratios between foreground/background pairs. Support both light and dark mode palette generation. Include color harmony tools for complementary/analogous color suggestions.",
            "id": 3,
            "status": "pending",
            "testStrategy": "",
            "title": "Implement color palette generator"
          },
          {
            "dependencies": ["20.2", "20.3"],
            "description": "Create React component for visual theme editing with live preview",
            "details": "Build theme editor as React component in web/ui/src/components using existing component patterns. Include color pickers for palette customization, typography controls for font selection and scale adjustment, spacing scale editor with visual preview, and export functionality for configuration. Implement live preview showing theme changes on sample components. Use existing hooks and providers pattern from web/ui.",
            "id": 4,
            "status": "pending",
            "testStrategy": "",
            "title": "Build theme editor UI component"
          },
          {
            "dependencies": ["20.2"],
            "description": "Implement modular scale generators for typography and spacing with mathematical ratios",
            "details": "Create typography scale generator using modular scale ratios (major third, perfect fourth, golden ratio). Generate font sizes, line heights, and letter spacing values. Implement spacing scale generator with consistent multipliers. Add fluid typography support using CSS clamp() for responsive scaling. Ensure generated scales maintain vertical rhythm and visual hierarchy.",
            "id": 5,
            "status": "pending",
            "testStrategy": "",
            "title": "Add typography and spacing scale systems"
          }
        ],
        "testStrategy": "Test token generation and CSS output. Verify theme application in components. Test theme editor UI. Validate accessibility compliance.",
        "title": "Build Theme System"
      },
      {
        "dependencies": [4],
        "description": "Build database migration generator from OpenAPI changes",
        "details": "Detect schema changes between OpenAPI versions. Generate SQL migration files using goose format. Handle column additions, deletions, type changes. Create rollback migrations. Add migration validation before execution.",
        "id": 21,
        "priority": "medium",
        "status": "pending",
        "subtasks": [
          {
            "dependencies": [],
            "description": "Build component to detect differences between two OpenAPI schema versions",
            "details": "Parse and compare OpenAPI schemas from api/components/schemas. Identify added, removed, and modified entities. Detect field-level changes including type modifications, constraint changes, and relationship updates. Store diff results in structured format for migration generator consumption.",
            "id": 1,
            "status": "pending",
            "testStrategy": "",
            "title": "Create OpenAPI Schema Differ"
          },
          {
            "dependencies": ["21.1"],
            "description": "Create generator that produces goose-format SQL migration files from schema diffs",
            "details": "Generate SQL DDL statements in goose format for infrastructure/persistence/postgres/migrations. Create sequential migration files with proper timestamps. Handle CREATE TABLE for new entities, ALTER TABLE for modifications. Include goose up/down annotations. Map OpenAPI types to PostgreSQL types correctly.",
            "id": 2,
            "status": "pending",
            "testStrategy": "",
            "title": "Build Goose Migration Generator"
          },
          {
            "dependencies": ["21.2"],
            "description": "Handle adding and removing columns with proper defaults and data preservation",
            "details": "Generate ALTER TABLE ADD COLUMN statements with appropriate defaults. Handle NOT NULL constraints by providing safe defaults or migration steps. Create DROP COLUMN statements with safety checks. Preserve existing data during column modifications. Handle dependent indexes and constraints.",
            "id": 3,
            "status": "pending",
            "testStrategy": "",
            "title": "Implement Column Addition/Deletion Handler"
          },
          {
            "dependencies": ["21.2"],
            "description": "Generate safe type conversion migrations with data transformation",
            "details": "Detect type changes between schema versions. Generate safe type conversion SQL using temporary columns. Handle string to number, date format changes, enum modifications. Create data transformation functions when needed. Ensure zero data loss during type migrations.",
            "id": 4,
            "status": "pending",
            "testStrategy": "",
            "title": "Create Type Change Migration Logic"
          },
          {
            "dependencies": ["21.2", "21.3", "21.4"],
            "description": "Automatically create down migrations for every up migration",
            "details": "Generate inverse operations for each migration step. Create DROP TABLE for CREATE TABLE operations. Generate ADD COLUMN for DROP COLUMN with preserved data restoration. Handle type conversions in reverse direction. Ensure rollback migrations restore exact previous state.",
            "id": 5,
            "status": "pending",
            "testStrategy": "",
            "title": "Generate Rollback Migrations"
          },
          {
            "dependencies": ["21.2", "21.5"],
            "description": "Validate migrations before execution to prevent data loss",
            "details": "Check migration SQL syntax before execution. Validate foreign key constraints won't be violated. Detect potential data loss scenarios and warn. Test migrations against copy of schema. Generate dry-run report showing expected changes. Add rollback capability verification.",
            "id": 6,
            "status": "pending",
            "testStrategy": "",
            "title": "Add Pre-execution Validation System"
          }
        ],
        "testStrategy": "Test migration generation for schema changes. Verify migration execution with PostgreSQL. Test rollback functionality. Validate data preservation.",
        "title": "Create Migration System"
      },
      {
        "dependencies": [3],
        "description": "Generate CI/CD pipeline configurations for major providers",
        "details": "Generate GitHub Actions workflows for testing and deployment. Create GitLab CI configurations. Include Docker build and push steps. Add test execution and coverage reporting. Configure deployment to cloud providers.",
        "id": 22,
        "priority": "low",
        "status": "pending",
        "subtasks": [
          {
            "dependencies": [],
            "description": "Create templates and generator for GitHub Actions CI/CD workflows",
            "details": "Implement workflow generator using Go templates in internal/codegen. Create templates for common workflows: test runner (go test, npm test), build and release (goreleaser integration), Docker image build and push to registry, deployment workflows for different environments. Use existing .github/workflows as reference patterns. Generate workflows based on project configuration in arches.yaml.",
            "id": 1,
            "status": "pending",
            "testStrategy": "",
            "title": "Generate GitHub Actions Workflows"
          },
          {
            "dependencies": [],
            "description": "Build generator for GitLab CI/CD pipeline configurations",
            "details": "Create GitLab CI YAML generator parallel to GitHub Actions. Template .gitlab-ci.yml with stages: build, test, deploy. Map GitHub Actions concepts to GitLab CI equivalents (jobs, artifacts, environments). Support GitLab-specific features like merge request pipelines and environments. Reuse Docker and test configurations from GitHub Actions templates.",
            "id": 2,
            "status": "pending",
            "testStrategy": "",
            "title": "Create GitLab CI Configuration Generator"
          },
          {
            "dependencies": ["22.1", "22.2"],
            "description": "Implement Docker containerization steps for CI/CD pipelines",
            "details": "Generate Docker build steps using existing Dockerfile in deployments/docker. Create multi-stage build configurations for optimization. Add registry push steps for Docker Hub, GitHub Container Registry, and cloud provider registries (ECR, GCR, ACR). Include build caching and layer optimization. Generate docker-compose configurations for testing.",
            "id": 3,
            "status": "pending",
            "testStrategy": "",
            "title": "Add Docker Build and Registry Push Steps"
          },
          {
            "dependencies": ["22.1", "22.2"],
            "description": "Add comprehensive testing and coverage reporting to CI/CD pipelines",
            "details": "Generate test execution steps for Go (go test with race detection), TypeScript (Jest/Vitest), and E2E tests. Add coverage collection using go cover and frontend coverage tools. Integrate with coverage services (Codecov, Coveralls). Generate test result artifacts and reports. Include parallel test execution for performance.",
            "id": 4,
            "status": "pending",
            "testStrategy": "",
            "title": "Include Test Execution and Coverage Reporting"
          },
          {
            "dependencies": ["22.3", "22.4"],
            "description": "Generate deployment configurations for major cloud providers",
            "details": "Create deployment steps for AWS (ECS, EKS, Lambda), GCP (Cloud Run, GKE), and Azure (AKS, Container Instances). Generate Kubernetes manifests and Helm value overrides. Include environment-specific configurations (dev, staging, prod). Add secret management using cloud provider services. Generate terraform or infrastructure-as-code snippets for deployment.",
            "id": 5,
            "status": "pending",
            "testStrategy": "",
            "title": "Configure Cloud Provider Deployment Steps"
          }
        ],
        "testStrategy": "Validate generated YAML syntax. Test workflow execution in GitHub Actions. Verify Docker build steps. Test deployment configurations.",
        "title": "Implement CI/CD Generator"
      },
      {
        "dependencies": [3],
        "description": "Generate deployment configurations for cloud providers",
        "details": "Generate Kubernetes manifests with Helm charts. Create Docker Compose for development. Generate Terraform for infrastructure. Include environment configuration management. Add monitoring and logging setup.",
        "id": 23,
        "priority": "low",
        "status": "pending",
        "subtasks": [
          {
            "dependencies": [],
            "description": "Create templated Kubernetes manifests for deployments, services, and ingress",
            "details": "Build Go templates for generating Kubernetes manifests including Deployment, Service, Ingress, ConfigMap, and Secret resources. Use OpenAPI spec metadata to configure resource limits, replicas, and environment variables. Generate namespace-specific configurations. Include labels and selectors based on project metadata. Support multiple deployment strategies (rolling, blue-green).",
            "id": 1,
            "status": "pending",
            "testStrategy": "",
            "title": "Generate Kubernetes Manifests"
          },
          {
            "dependencies": ["23.1"],
            "description": "Build Helm charts with values files for different environments",
            "details": "Generate Helm chart structure with Chart.yaml, values.yaml, and templates directory. Create environment-specific values files (dev, staging, prod). Template deployment configurations using Helm functions. Include helpers for common patterns. Generate NOTES.txt for post-install instructions. Add support for Helm hooks and tests.",
            "id": 2,
            "status": "pending",
            "testStrategy": "",
            "title": "Create Helm Chart Generator"
          },
          {
            "dependencies": [],
            "description": "Generate Docker Compose configurations for local development",
            "details": "Create docker-compose.yaml with service definitions from OpenAPI spec. Include database, cache, and message queue services. Configure networks and volumes for data persistence. Generate .env files with environment variables. Add health checks and dependency ordering. Include development tools like hot-reload and debugging ports.",
            "id": 3,
            "status": "pending",
            "testStrategy": "",
            "title": "Build Docker Compose Generator"
          },
          {
            "dependencies": [],
            "description": "Create Terraform modules for cloud infrastructure provisioning",
            "details": "Generate Terraform modules for AWS, GCP, and Azure providers. Create modules for compute (EKS/GKE/AKS), networking (VPC/subnets), and data services (RDS/Cloud SQL). Include state backend configuration. Generate variable definitions from OpenAPI metadata. Add output values for resource references. Include terraform.tfvars templates.",
            "id": 4,
            "status": "pending",
            "testStrategy": "",
            "title": "Generate Terraform Modules"
          },
          {
            "dependencies": ["23.1", "23.2", "23.3", "23.4"],
            "description": "Implement configuration management for multiple environments",
            "details": "Generate environment-specific configuration files using Go templates. Create config maps for Kubernetes deployments. Generate .env files for Docker Compose. Build Terraform workspace configurations. Implement secret management integration (Vault/AWS Secrets Manager). Add configuration validation and schema checking.",
            "id": 5,
            "status": "pending",
            "testStrategy": "",
            "title": "Add Environment Configuration Management"
          },
          {
            "dependencies": ["23.1", "23.2"],
            "description": "Generate monitoring and logging configurations for deployments",
            "details": "Generate Prometheus ServiceMonitor resources for metrics collection. Create Grafana dashboard JSON from API endpoints. Configure structured logging with Fluentd/Fluent Bit. Generate OpenTelemetry collector configurations. Include alert rules based on SLOs. Add distributed tracing setup with Jaeger integration.",
            "id": 6,
            "status": "pending",
            "testStrategy": "",
            "title": "Include Monitoring and Logging Setup"
          }
        ],
        "testStrategy": "Validate Kubernetes manifest syntax. Test Helm chart rendering. Verify Docker Compose configuration. Test Terraform plan execution.",
        "title": "Build Deployment Generator"
      },
      {
        "dependencies": [3, 15],
        "description": "Generate comprehensive test suites for generated code",
        "details": "Generate unit tests using testify for Go. Create React Testing Library tests for components. Generate API integration tests. Add fixtures from OpenAPI examples. Include test coverage configuration.",
        "id": 24,
        "priority": "medium",
        "status": "pending",
        "subtasks": [
          {
            "dependencies": [],
            "description": "Build generator for Go unit tests using testify framework",
            "details": "Implement generator that parses Go source files in core, application, and infrastructure layers. Generate test files with _test.go suffix. Create testify suite setup with require and assert packages. Generate test cases for all exported functions and methods. Include table-driven tests for functions with multiple scenarios. Handle error cases and edge conditions. Generate test helpers for common setup/teardown operations.",
            "id": 1,
            "status": "pending",
            "testStrategy": "",
            "title": "Create Go Unit Test Generator"
          },
          {
            "dependencies": [],
            "description": "Create generator for React component tests using Testing Library",
            "details": "Parse React components in web/platform and web/ui directories. Generate test files with .test.tsx extension. Create render setup with proper providers (Theme, Router, Query). Generate tests for component props, user interactions, and state changes. Include accessibility tests using jest-axe. Generate snapshot tests for UI consistency. Handle async component behavior and loading states.",
            "id": 2,
            "status": "pending",
            "testStrategy": "",
            "title": "Build React Testing Library Test Generator"
          },
          {
            "dependencies": [],
            "description": "Generate integration tests for API endpoints from OpenAPI spec",
            "details": "Parse OpenAPI paths and operations to generate integration tests. Create test files in test/integration directory. Generate HTTP client setup using Go's httptest package. Create tests for all HTTP methods and status codes defined in OpenAPI. Include request/response validation against schemas. Generate tests for authentication and authorization flows. Handle multipart uploads and streaming responses.",
            "id": 3,
            "status": "pending",
            "testStrategy": "",
            "title": "Implement API Integration Test Generator"
          },
          {
            "dependencies": [],
            "description": "Create fixture generator that extracts examples from OpenAPI specifications",
            "details": "Parse OpenAPI schema examples and generate fixture files in test/fixtures. Create JSON/YAML fixtures for request/response bodies. Generate SQL fixtures for database seeding from schema definitions. Build fixture loader utilities for both Go and TypeScript tests. Include factory functions for dynamic fixture generation. Support fixture relationships and foreign key constraints. Generate edge case fixtures (empty, null, maximum values).",
            "id": 4,
            "status": "pending",
            "testStrategy": "",
            "title": "Generate Test Fixtures from OpenAPI Examples"
          },
          {
            "dependencies": ["24.1", "24.2", "24.3"],
            "description": "Set up comprehensive test coverage tracking and reporting",
            "details": "Configure Go coverage with go test -coverprofile and minimum thresholds. Set up Jest coverage for TypeScript/React with coverage reporters. Generate .codecov.yml for CI/CD integration. Create coverage badge generation scripts. Add make targets for coverage reports (HTML, text, JSON). Configure coverage exclusions for generated code. Set up coverage trend tracking and notifications.",
            "id": 5,
            "status": "pending",
            "testStrategy": "",
            "title": "Add Test Coverage Configuration"
          },
          {
            "dependencies": ["24.1"],
            "description": "Generate mocks using mockery for all interfaces",
            "details": "Parse Go interfaces from ports/repositories and ports/services. Generate mocks using mockery v3 configuration in .mockery.yaml. Create mocks in mocks_test.go files per package. Generate typed mock constructors with proper imports. Handle generic interfaces and complex type parameters. Create mock assertion helpers for common patterns. Ensure mocks are regenerated on interface changes.",
            "id": 6,
            "status": "pending",
            "testStrategy": "",
            "title": "Integrate Mockery for Mock Generation"
          },
          {
            "dependencies": ["24.3", "24.4"],
            "description": "Build generator for end-to-end test scenarios",
            "details": "Generate Playwright tests for critical user flows in web/platform. Create test scenarios from OpenAPI operation sequences. Generate Docker Compose setup for isolated E2E environment. Build page object models from React component structure. Generate test data setup and teardown scripts. Create visual regression tests for UI components. Include performance benchmarks and load test scenarios.",
            "id": 7,
            "status": "pending",
            "testStrategy": "",
            "title": "Create E2E Test Scenario Generator"
          }
        ],
        "testStrategy": "Execute generated tests and verify pass rate. Check test coverage metrics. Validate fixture generation. Test mock generation.",
        "title": "Create Test Suite Generator"
      },
      {
        "dependencies": [3, 15],
        "description": "Generate comprehensive documentation for generated code",
        "details": "Generate API documentation from OpenAPI spec using Redoc. Create component documentation with props tables. Generate README files with setup instructions. Add inline code comments. Create architecture diagrams.",
        "id": 25,
        "priority": "low",
        "status": "pending",
        "subtasks": [
          {
            "dependencies": [],
            "description": "Implement OpenAPI-based API documentation generation using the existing Redoc integration",
            "details": "Create Go functions to parse the OpenAPI spec from api/openapi.yaml. Generate static HTML documentation using Redoc's build tools. Configure Redoc themes to match Arches branding. Add endpoint search and filtering capabilities. Generate example requests/responses from OpenAPI schemas. Output documentation to docs/api-reference directory.",
            "id": 1,
            "status": "pending",
            "testStrategy": "",
            "title": "Generate API Documentation with Redoc"
          },
          {
            "dependencies": [],
            "description": "Build automated documentation for React components with props tables and usage examples",
            "details": "Parse TypeScript component files in web/platform/src/components and web/ui/src/components. Extract prop types using TypeScript compiler API. Generate markdown tables showing prop names, types, defaults, and descriptions. Create usage examples from test files. Generate component hierarchy diagrams. Output to docs/features/components.md.",
            "id": 2,
            "status": "pending",
            "testStrategy": "",
            "title": "Create Component Documentation Generator"
          },
          {
            "dependencies": [],
            "description": "Create comprehensive README files with setup instructions for each module",
            "details": "Generate main README.md with project overview, features, and quick start guide. Create package-specific READMEs for web/client, web/platform, and web/ui. Include installation instructions, environment setup, and configuration options. Add troubleshooting sections based on common issues. Generate CLI usage documentation from cobra commands.",
            "id": 3,
            "status": "pending",
            "testStrategy": "",
            "title": "Generate README Templates"
          },
          {
            "dependencies": ["25.1", "25.2"],
            "description": "Implement automated inline documentation for generated Go and TypeScript code",
            "details": "Add JSDoc comments to generated TypeScript files in web/client/src/generated. Generate GoDoc comments for internal/application/dto and internal/core packages. Include parameter descriptions and return value documentation. Add package-level documentation comments. Ensure comments follow language-specific conventions and formatting standards.",
            "id": 4,
            "status": "pending",
            "testStrategy": "",
            "title": "Add Inline Code Comments Generator"
          },
          {
            "dependencies": ["25.3"],
            "description": "Build system to generate architecture diagrams from codebase structure",
            "details": "Use Mermaid.js or PlantUML to generate diagrams programmatically. Create system architecture diagram from project-structure.xml. Generate database schema diagrams from SQL files. Create component dependency graphs from import statements. Generate API flow diagrams from OpenAPI paths. Output diagrams as SVG files to docs/architecture directory.",
            "id": 5,
            "status": "pending",
            "testStrategy": "",
            "title": "Create Architecture Diagram Generator"
          }
        ],
        "testStrategy": "Validate generated markdown syntax. Test documentation site build. Verify component prop documentation. Check diagram generation.",
        "title": "Implement Documentation Generator"
      },
      {
        "dependencies": [2],
        "description": "Create system for sharing and discovering code templates",
        "details": "Create template registry with metadata. Implement template versioning and updates. Add template rating and reviews. Build search and filtering UI. Support private team templates.",
        "id": 26,
        "priority": "low",
        "status": "pending",
        "subtasks": [
          {
            "dependencies": [],
            "description": "Create database schema and domain models for template registry with comprehensive metadata support",
            "details": "Design PostgreSQL schema for templates table with fields: ID, Name, Description, Version, Author, Category, Tags, TemplateData (JSONB), Downloads, CreatedAt, UpdatedAt. Create domain entities in core/entities for Template, TemplateVersion, and TemplateMetadata. Define value objects for semantic versioning, template categories, and license types. Implement SQLC queries for template CRUD operations.",
            "id": 1,
            "status": "pending",
            "testStrategy": "",
            "title": "Design Template Registry Schema"
          },
          {
            "dependencies": ["26.1"],
            "description": "Build semantic versioning support with version history and rollback capabilities",
            "details": "Create TemplateVersion table linking to templates with version number, changelog, compatibility info, and release notes. Implement semantic versioning validation using value objects. Add version comparison utilities and latest version resolution. Support version pinning and update notifications. Create migration scripts for version history tracking.",
            "id": 2,
            "status": "pending",
            "testStrategy": "",
            "title": "Implement Template Versioning System"
          },
          {
            "dependencies": ["26.1"],
            "description": "Create powerful search endpoints with full-text search and faceted filtering",
            "details": "Implement PostgreSQL full-text search indexes on template name, description, and tags. Create search query builder supporting filters by category, author, popularity, and date range. Add sorting options (relevance, downloads, rating, newest). Implement pagination with cursor-based navigation. Create OpenAPI endpoints at /api/v1/templates/search with query parameters.",
            "id": 3,
            "status": "pending",
            "testStrategy": "",
            "title": "Build Search and Filtering API"
          },
          {
            "dependencies": ["26.1"],
            "description": "Build social features for template quality feedback with ratings and reviews",
            "details": "Design TemplateRating and TemplateReview tables with user associations. Implement 5-star rating system with average calculation and rating count. Add review moderation workflow with status (pending, approved, rejected). Create endpoints for submitting, updating, and fetching reviews. Implement review helpfulness voting and spam detection.",
            "id": 4,
            "status": "pending",
            "testStrategy": "",
            "title": "Create Rating and Review System"
          },
          {
            "dependencies": ["26.2"],
            "description": "Implement secure template package upload, validation, and download with usage tracking",
            "details": "Create multipart upload endpoint for template packages (tar.gz format). Implement template validation pipeline checking structure, dependencies, and security. Store templates in S3-compatible storage with CDN support. Track download statistics per version and user. Generate signed URLs for private template access. Add virus scanning and malicious code detection.",
            "id": 5,
            "status": "pending",
            "testStrategy": "",
            "title": "Add Template Upload and Download Features"
          },
          {
            "dependencies": ["26.1", "26.5"],
            "description": "Build role-based access controls for private team templates and marketplace permissions",
            "details": "Create TemplateAccess table for private template permissions. Implement organization-level template sharing with team roles (owner, contributor, viewer). Add template visibility levels (public, private, organization). Build authorization middleware checking template access rights. Support template transfer between organizations. Create audit log for access changes.",
            "id": 6,
            "status": "pending",
            "testStrategy": "",
            "title": "Implement Access Control System"
          },
          {
            "dependencies": ["26.3", "26.4", "26.5", "26.6"],
            "description": "Create React components for browsing, searching, and managing templates in the marketplace",
            "details": "Build TemplateGrid component with card layout showing preview, stats, and rating. Create TemplateDetail page with version selector, documentation viewer, and download button. Implement SearchFilters sidebar with category tree and filter chips. Add TemplateUpload wizard with validation feedback. Build MyTemplates dashboard for managing published templates. Create responsive design with dark mode support.",
            "id": 7,
            "status": "pending",
            "testStrategy": "",
            "title": "Build Marketplace UI Components"
          }
        ],
        "testStrategy": "Test template upload and download. Verify versioning system. Test search functionality. Validate access controls.",
        "title": "Build Template Marketplace"
      },
      {
        "dependencies": [2, 3],
        "description": "Build extensible plugin architecture for custom generators",
        "details": "Define plugin interface for generators. Implement plugin loader with sandboxing. Support WASM plugins for security. Add plugin configuration system. Create plugin development SDK.",
        "id": 27,
        "priority": "low",
        "status": "pending",
        "subtasks": [
          {
            "dependencies": [],
            "description": "Design and implement the core plugin interface defining how plugins interact with the generator system",
            "details": "Create plugin.go interface in internal/core/ports defining Plugin, PluginMetadata, and PluginCapabilities. Define communication protocol using protobuf or JSON-RPC for plugin-host messaging. Establish plugin lifecycle methods (Init, Execute, Cleanup). Define input/output schemas for generator plugins. Document plugin API contract in api/components/schemas.",
            "id": 1,
            "status": "pending",
            "testStrategy": "",
            "title": "Define plugin interface and protocol"
          },
          {
            "dependencies": ["27.1"],
            "description": "Build the plugin loading mechanism and registry for managing plugin lifecycle",
            "details": "Create PluginLoader in internal/infrastructure/plugins/loader.go. Implement plugin discovery from configured paths. Build plugin registry for tracking loaded plugins. Add plugin validation and version compatibility checking. Implement lazy loading and caching mechanisms.",
            "id": 2,
            "status": "pending",
            "testStrategy": "",
            "title": "Implement plugin loader and registry"
          },
          {
            "dependencies": ["27.1"],
            "description": "Integrate WebAssembly runtime for secure plugin execution in isolated environment",
            "details": "Integrate wazero or wasmtime-go for WASM runtime. Create WASMRuntime wrapper in internal/infrastructure/plugins/wasm. Implement host functions for controlled system access. Set up memory and CPU limits for WASM modules. Add WASI support for file system operations.",
            "id": 3,
            "status": "pending",
            "testStrategy": "",
            "title": "Add WASM runtime for sandboxing"
          },
          {
            "dependencies": ["27.2"],
            "description": "Create configuration management for plugins including settings, permissions, and resources",
            "details": "Extend config system in internal/infrastructure/config for plugin settings. Define plugin manifest schema (plugin.yaml). Implement permission model for resource access. Add environment variable injection for plugins. Create configuration validation and hot-reload support.",
            "id": 4,
            "status": "pending",
            "testStrategy": "",
            "title": "Build plugin configuration system"
          },
          {
            "dependencies": ["27.1", "27.3"],
            "description": "Build SDK and tooling for plugin developers to create custom generators",
            "details": "Create Go SDK package in sdk/plugin with helper functions. Build plugin scaffold generator CLI tool. Add TypeScript/JavaScript SDK using WASM bindings. Create plugin testing framework with mocks. Generate plugin documentation from interfaces.",
            "id": 5,
            "status": "pending",
            "testStrategy": "",
            "title": "Create plugin SDK and development tools"
          },
          {
            "dependencies": ["27.2", "27.4"],
            "description": "Build plugin discovery, distribution, and management marketplace features",
            "details": "Create plugin repository client in internal/adapters/marketplace. Implement plugin versioning and dependency resolution. Add plugin signing and verification for security. Build plugin download and installation workflow. Create plugin rating and review system APIs.",
            "id": 6,
            "status": "pending",
            "testStrategy": "",
            "title": "Implement plugin marketplace integration"
          },
          {
            "dependencies": ["27.3", "27.4"],
            "description": "Build comprehensive security layer for plugin execution with resource isolation",
            "details": "Implement capability-based security model. Add resource quotas (CPU, memory, disk, network). Create audit logging for plugin operations. Implement plugin-to-plugin isolation. Add security scanning for uploaded plugins.",
            "id": 7,
            "status": "pending",
            "testStrategy": "",
            "title": "Implement security sandboxing and isolation"
          },
          {
            "dependencies": ["27.1", "27.7"],
            "description": "Create inter-plugin communication and event system for plugin coordination",
            "details": "Implement message passing between plugins and host. Create event bus for plugin notifications. Add shared state management with isolation. Build RPC mechanism for plugin services. Implement plugin hooks for generator pipeline.",
            "id": 8,
            "status": "pending",
            "testStrategy": "",
            "title": "Build plugin communication layer"
          },
          {
            "dependencies": ["27.6", "27.8"],
            "description": "Implement dependency resolution and management for plugins with other plugins",
            "details": "Create dependency graph resolver in internal/infrastructure/plugins/deps. Implement version constraint solving. Add circular dependency detection. Build plugin update mechanism with compatibility checks. Create dependency caching and offline support.",
            "id": 9,
            "status": "pending",
            "testStrategy": "",
            "title": "Add plugin dependency management"
          }
        ],
        "testStrategy": "Test plugin loading and execution. Verify sandboxing security. Test plugin communication. Validate configuration handling.",
        "title": "Create Plugin System"
      },
      {
        "dependencies": [3, 15],
        "description": "Build security vulnerability scanner for generated code",
        "details": "Integrate with security scanning tools like Snyk. Check for SQL injection vulnerabilities. Scan for XSS in frontend code. Validate authentication implementation. Check dependency vulnerabilities.",
        "id": 28,
        "priority": "medium",
        "status": "pending",
        "subtasks": [
          {
            "dependencies": [],
            "description": "Set up integration with Snyk API or similar security scanning tools",
            "details": "Configure Snyk API client with authentication. Set up scanning profiles for different code types (Go, TypeScript, SQL). Implement scanner interface to support multiple providers. Create configuration for scan sensitivity levels and rule sets.",
            "id": 1,
            "status": "pending",
            "testStrategy": "",
            "title": "Integrate Security Scanning Framework"
          },
          {
            "dependencies": ["28.1"],
            "description": "Build pattern matching and analysis for SQL injection vulnerabilities",
            "details": "Parse SQL queries from generated SQLC code. Detect unsafe string concatenation in queries. Check for parameterized query usage. Identify dynamic SQL construction patterns. Scan for user input validation in database operations.",
            "id": 2,
            "status": "pending",
            "testStrategy": "",
            "title": "Implement SQL Injection Detection"
          },
          {
            "dependencies": ["28.1"],
            "description": "Create cross-site scripting detection for frontend code",
            "details": "Scan React/TypeScript components for dangerous HTML rendering. Check for unsafe innerHTML usage. Validate input sanitization in forms. Detect unescaped user content in templates. Identify missing Content Security Policy headers.",
            "id": 3,
            "status": "pending",
            "testStrategy": "",
            "title": "Add XSS Vulnerability Scanner"
          },
          {
            "dependencies": ["28.1"],
            "description": "Analyze authentication implementation for security best practices",
            "details": "Check JWT token validation and expiration. Verify OAuth2 flow implementation. Scan for hardcoded credentials or API keys. Validate password hashing algorithms. Check session management and CSRF protection.",
            "id": 4,
            "status": "pending",
            "testStrategy": "",
            "title": "Validate Authentication Patterns"
          },
          {
            "dependencies": ["28.1"],
            "description": "Scan Go modules and npm packages for known vulnerabilities",
            "details": "Parse go.mod and package.json files for dependencies. Query vulnerability databases (CVE, NVD). Check for outdated packages with security patches. Identify license compliance issues. Generate dependency risk assessment scores.",
            "id": 5,
            "status": "pending",
            "testStrategy": "",
            "title": "Check Dependency Vulnerabilities"
          },
          {
            "dependencies": ["28.2", "28.3", "28.4", "28.5"],
            "description": "Create comprehensive security analysis reports in multiple formats",
            "details": "Generate HTML dashboard with vulnerability summary. Create JSON reports for CI/CD integration. Export SARIF format for IDE integration. Include severity ratings and CVSS scores. Add trend analysis and comparison with previous scans.",
            "id": 6,
            "status": "pending",
            "testStrategy": "",
            "title": "Generate Security Reports"
          },
          {
            "dependencies": ["28.6"],
            "description": "Provide actionable fixes and code patches for detected vulnerabilities",
            "details": "Generate code snippets for fixing SQL injection issues. Provide secure alternatives for XSS vulnerabilities. Suggest dependency updates with migration guides. Create automated pull requests with security fixes. Include links to security best practices documentation.",
            "id": 7,
            "status": "pending",
            "testStrategy": "",
            "title": "Add Remediation Suggestions"
          }
        ],
        "testStrategy": "Test vulnerability detection accuracy. Verify false positive rate. Test integration with scanning tools. Validate remediation suggestions.",
        "title": "Implement Security Scanner"
      },
      {
        "dependencies": [18],
        "description": "Create performance analysis tools for generated applications",
        "details": "Implement bundle size analysis for frontend. Add backend performance profiling. Create database query analyzer. Generate performance optimization suggestions. Add lighthouse integration for web vitals.",
        "id": 29,
        "priority": "low",
        "status": "pending",
        "subtasks": [
          {
            "dependencies": [],
            "description": "Create frontend bundle analyzer using webpack-bundle-analyzer for web assets",
            "details": "Integrate webpack-bundle-analyzer into the build process. Parse generated bundle stats from web/platform and web/client builds. Create analysis reports showing module sizes, dependency trees, and duplicate packages. Store bundle metrics in database for historical tracking. Generate JSON reports for programmatic access.",
            "id": 1,
            "status": "pending",
            "testStrategy": "",
            "title": "Implement Bundle Size Analysis"
          },
          {
            "dependencies": [],
            "description": "Integrate pprof for Go backend performance profiling and analysis",
            "details": "Add pprof endpoints to internal/adapters/http/server. Implement CPU, memory, goroutine, and mutex profiling collectors. Create profiling middleware to capture performance data during requests. Store profiling snapshots with timestamps. Add profile comparison functionality to identify regressions.",
            "id": 2,
            "status": "pending",
            "testStrategy": "",
            "title": "Add Backend Performance Profiling"
          },
          {
            "dependencies": [],
            "description": "Build query analysis tool for PostgreSQL performance monitoring",
            "details": "Implement query logging middleware in internal/infrastructure/persistence. Parse and analyze EXPLAIN ANALYZE output for slow queries. Track query execution times, row counts, and index usage. Identify N+1 queries and missing indexes. Generate query optimization recommendations using pg_stat_statements data.",
            "id": 3,
            "status": "pending",
            "testStrategy": "",
            "title": "Create Database Query Analyzer"
          },
          {
            "dependencies": ["29.1", "29.2", "29.3"],
            "description": "Create AI-powered optimization recommendation engine",
            "details": "Analyze collected metrics from bundle, backend, and database analyzers. Use internal/adapters/llm to generate context-aware optimization suggestions. Prioritize recommendations by potential impact. Create actionable fix templates for common issues. Store suggestions with implementation tracking.",
            "id": 4,
            "status": "pending",
            "testStrategy": "",
            "title": "Generate Performance Optimization Suggestions"
          },
          {
            "dependencies": [],
            "description": "Add Lighthouse CI integration for frontend performance metrics",
            "details": "Integrate Lighthouse CI into the build pipeline. Capture Core Web Vitals (LCP, FID, CLS) and performance scores. Run audits against preview server URLs from task 18. Store historical Lighthouse reports in storage. Set performance budgets and alert on regressions.",
            "id": 5,
            "status": "pending",
            "testStrategy": "",
            "title": "Integrate Lighthouse for Web Vitals"
          },
          {
            "dependencies": ["29.1", "29.2", "29.3", "29.4", "29.5"],
            "description": "Create unified dashboard for all performance metrics visualization",
            "details": "Build React dashboard component in web/platform/src/components. Display real-time and historical performance metrics. Create charts for bundle sizes, response times, query performance, and Web Vitals. Add performance trend analysis and regression detection. Export performance reports in PDF and JSON formats.",
            "id": 6,
            "status": "pending",
            "testStrategy": "",
            "title": "Build Performance Dashboard"
          }
        ],
        "testStrategy": "Test bundle size calculation accuracy. Verify profiling data collection. Test query analysis. Validate optimization suggestions.",
        "title": "Build Performance Analyzer"
      },
      {
        "dependencies": [5, 6],
        "description": "Build comprehensive admin dashboard for project management",
        "details": "Create React dashboard in web/platform using existing UI components. Show project metrics and generation history. Display container resource usage. Add user management interface. Include billing and usage analytics.",
        "id": 30,
        "priority": "medium",
        "status": "pending",
        "subtasks": [
          {
            "dependencies": [],
            "description": "Set up the base dashboard layout in web/platform using existing UI components from web/ui",
            "details": "Create main dashboard page component in web/platform/src/app/admin. Set up routing for admin dashboard. Implement responsive layout with sidebar navigation using existing layout components from web/ui. Add header with user info and logout. Configure dashboard route protection with authentication middleware.",
            "id": 1,
            "status": "pending",
            "testStrategy": "",
            "title": "Create dashboard layout structure"
          },
          {
            "dependencies": ["30.1"],
            "description": "Create React components to display project statistics and generation history",
            "details": "Create ProjectMetrics component showing total projects, active generations, success rates. Implement GenerationHistory table with pagination, sorting, and filtering. Add charts for generation trends using existing chart components. Connect to API endpoints for fetching metrics data. Display real-time generation status updates.",
            "id": 2,
            "status": "pending",
            "testStrategy": "",
            "title": "Build project metrics components"
          },
          {
            "dependencies": ["30.1"],
            "description": "Implement components to display Docker container resource usage and status",
            "details": "Create ResourceMonitor component for CPU, memory, and disk usage visualization. Implement container list view with status indicators (running, stopped, error). Add resource usage graphs with time-series data. Connect to container metrics API endpoints. Display container logs viewer with real-time streaming.",
            "id": 3,
            "status": "pending",
            "testStrategy": "",
            "title": "Add container resource monitoring"
          },
          {
            "dependencies": ["30.1"],
            "description": "Build user administration interface with CRUD operations",
            "details": "Create UserManagement component with user listing table. Implement user creation/editing forms with validation. Add role assignment and permissions management. Create user activity logs viewer. Implement bulk operations (activate, deactivate, delete). Add user search and filtering capabilities.",
            "id": 4,
            "status": "pending",
            "testStrategy": "",
            "title": "Implement user management interface"
          },
          {
            "dependencies": ["30.1", "30.2"],
            "description": "Build components for billing information and usage analytics visualization",
            "details": "Create BillingDashboard component with current plan and usage overview. Implement usage charts for API calls, storage, and compute time. Add invoice history table with download capability. Create cost breakdown by project and resource type. Implement usage alerts and limits configuration. Add export functionality for billing reports.",
            "id": 5,
            "status": "pending",
            "testStrategy": "",
            "title": "Create billing and usage analytics"
          },
          {
            "dependencies": ["30.2", "30.3", "30.4", "30.5"],
            "description": "Integrate WebSocket connection for live dashboard updates",
            "details": "Implement WebSocket client connection in dashboard using existing WebSocket server. Create real-time update handlers for metrics, container status, and generation progress. Add connection status indicator and auto-reconnect logic. Implement event-based updates for user activities and system alerts. Optimize re-rendering with selective component updates. Add fallback to polling for WebSocket connection failures.",
            "id": 6,
            "status": "pending",
            "testStrategy": "",
            "title": "Add real-time updates with WebSocket"
          }
        ],
        "testStrategy": "E2E test dashboard functionality. Test real-time metric updates. Verify user management operations. Test billing calculations.",
        "title": "Create Admin Dashboard"
      },
      {
        "dependencies": [1, 3],
        "description": "Fix the code generator to properly extract and generate Go structs for inline request and response schemas from OpenAPI specifications instead of referencing non-existent DTOs",
        "details": "The code generator needs to be updated to handle inline schemas defined directly in OpenAPI request/response bodies. The fix involves:\n\n1. **Enhance inline schema extraction in parsers/openapi.go**:\n   - Update ExtractOperations() to capture inline request body schemas (lines 168-199)\n   - Extract actual field definitions from inline schemas in request bodies\n   - Store inline schema definitions with generated names like 'RequestMagicLinkRequestBody'\n   - Handle inline response schemas similarly for 200/201 responses\n\n2. **Update generateOperationDTOs() in codegen/generators.go**:\n   - Parse inline request body schemas from OpenAPI spec when RequestBodySchema has 'RequestBody' suffix\n   - Extract fields from the inline schema using FieldExtractor\n   - Generate proper struct fields with correct Go types\n   - Handle nested objects and arrays in inline schemas\n\n3. **Modify the echo_server.tmpl template**:\n   - Generate inline structs directly in handler file when DTOs don't exist\n   - Add fallback logic to check if DTO exists before referencing it\n   - For inline schemas, generate the struct definition in place\n\n4. **Key files to modify**:\n   - internal/parsers/openapi.go: ExtractOperations() method to capture inline schemas\n   - internal/codegen/generators.go: generateOperationDTOs() to properly extract and generate inline schemas\n   - internal/codegen/tmpl/echo_server.tmpl: Add inline struct generation capability\n   - internal/codegen/tmpl/dto.tmpl: Ensure it can handle inline schema fields\n\nExample fix for requestMagicLink:\n- Parse inline schema from api/paths/auth_magic-link.yaml lines 11-36\n- Extract fields: identifier (string), deliveryMethod (string enum), redirectUrl (string)\n- Generate RequestMagicLinkRequestBody struct with these fields\n- Similarly for response: message (string), otpCode (string), expiresIn (int), token (MagicLinkToken ref)",
        "id": 31,
        "priority": "high",
        "status": "pending",
        "subtasks": [],
        "testStrategy": "1. Create test OpenAPI spec with inline request/response schemas\n2. Run code generator and verify DTOs are created for inline schemas\n3. Compile generated code and ensure no missing type references\n4. Verify requestMagicLink generates RequestMagicLinkRequestBody with correct fields\n5. Test with various inline schema types: simple objects, nested objects, arrays\n6. Ensure backward compatibility with referenced schemas ($ref)\n7. Run 'make generate' on the full project and verify all handlers compile\n8. Check that auth.gen.go properly imports and uses generated inline DTOs",
        "title": "Fix inline request/response schema code generation"
      }
    ]
  }
}
