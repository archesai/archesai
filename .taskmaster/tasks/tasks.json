{
  "main": {
    "metadata": {
      "created": "2025-09-25T05:02:25.596Z",
      "description": "Tasks for main context",
      "updated": "2025-09-29T05:31:07.864Z"
    },
    "tasks": [
      {
        "dependencies": [],
        "description": "Build a robust OpenAPI parser that validates specs and extracts schema information for code generation",
        "details": "Leverage existing parsers/openapi_schema.go and extend it to handle x-codegen extensions. Use speakeasy-api/openapi library for parsing. Implement validation for OpenAPI 3.1.1 specs, extract component schemas, paths, and operations. Handle refs resolution and schema inheritance. Store parsed data in structured format for template consumption.",
        "id": 1,
        "priority": "high",
        "status": "pending",
        "subtasks": [
          {
            "dependencies": [],
            "description": "Refactor and enhance the existing speakeasy-api/openapi integration in parsers/openapi_schema.go to support advanced parsing features",
            "details": "Review current implementation in parsers/openapi_schema.go. Upgrade speakeasy-api/openapi to latest version if needed. Add support for OpenAPI 3.1.1 specific features (webhooks, license object, JSON Schema 2020-12). Implement proper error handling with detailed validation messages. Create parser configuration options for strict/lenient modes.\n<info added on 2025-09-25T05:37:22.233Z>\nI'll analyze the codebase to understand the current implementation and the compilation errors in ref_resolver.go.Now let me check the errors.go file to understand the ParseError type:Now let me check the openapi_schema.go file to understand how these are being used:Now let me check how the speakeasy library defines the Paths type:Let me check the go.mod to see what version of speakeasy we're using:Now let me understand how the speakeasy library structures these types by looking at usage:Let me check how Paths is used in the OpenAPI struct:Now let me look at how GetOrZero is used with Paths and what the actual types involved are:Let me now check what the actual return type is from GetOrZero on paths:Now let me check ReferencedPathItem:Now I understand the issue. The `paths.GetOrZero()` returns a `*ReferencedPathItem` (which is an alias for `Reference[PathItem, *PathItem, *core.PathItem]`), not a `*PathItem`. Let me check the proper way to get the actual PathItem from it:Perfect! Now I understand. The issue is:\n1. Line 72: `err` is a `*ParseError` but we're trying to append it to `ParseErrors` which expects `*ParseError`\n2. Line 120: `doc.Paths` is already a `*openapi.Paths`, not a value, so we don't need to dereference it\n3. Line 275: `pathItem` from `GetOrZero` returns `*ReferencedPathItem`, but we need to get the actual `*PathItem` from it using `GetResolvedObject()` or similar method\n\nLet me check how other parts of the code handle ReferencedPathItem:Now I understand how to fix the compilation errors. Let me also check line 72 more closely:I see - the issue at line 72 is that `err` is already a `*ParseError`, and `r.errors` is `ParseErrors` which is `[]*ParseError`. The append is correct. The issue is the error type declaration at line 68 should be `*ParseError` but it's declared as `error`. Let me verify the actual variable declaration for `err`:\n\nLooking at line 58, `err` is declared as `error` interface. But then at line 68-71, we're assigning a `*ParseError` to it. The issue is that while a `*ParseError` satisfies the `error` interface, when we try to append `err` (which is typed as `error`) to `r.errors` (which expects `*ParseError`), Go sees a type mismatch.\n\nFix compilation errors in ref_resolver.go:\n\n**Line 72 & similar locations**: The variable `err` is declared as `error` interface but needs to be cast to `*ParseError` when appending to `r.errors`. Change pattern from `err = NewParseError(...)` and `r.errors = append(r.errors, err)` to either use a separate variable like `parseErr := NewParseError(...)` and append that, or type assert `err.(*ParseError)`.\n\n**Line 120**: The `doc.Paths` parameter is already a pointer (`*openapi.Paths`), but `resolvePathRef` expects `openapi.Paths` (value type). Need to dereference with `*doc.Paths` when passing to the function.\n\n**Line 275**: The `pathItem` returned from `paths.GetOrZero()` is a `*ReferencedPathItem` (which is `Reference[PathItem, *PathItem, *core.PathItem]`), not a `*PathItem`. Need to call `GetResolvedObject()` on the ReferencedPathItem to get the actual `*PathItem`: `pathItem.GetResolvedObject()`.\n\nAdditional fixes needed:\n- Update `resolvePathItemRef` function signature to accept `*ReferencedPathItem` instead of `*PathItem`, then call `GetResolvedObject()` inside the function\n- Or extract the PathItem before calling the function using `GetResolvedObject()`\n</info added on 2025-09-25T05:37:22.233Z>",
            "id": 1,
            "status": "in-progress",
            "testStrategy": "",
            "title": "Enhance Speakeasy Parser Integration"
          },
          {
            "dependencies": ["1.1"],
            "description": "Build specialized parser for x-codegen extensions that extracts code generation metadata from OpenAPI specs",
            "details": "Parse x-codegen extensions from components/schemas (repository type, indexes, relations). Extract x-codegen-config from info section for global settings. Handle x-codegen annotations on paths/operations for handler generation. Validate extension schema against api/components/schemas/xcodegen/CodegenConfig.yaml. Map extensions to internal codegen.TemplateInputs structure.",
            "id": 2,
            "status": "pending",
            "testStrategy": "",
            "title": "Implement x-codegen Extension Parser"
          },
          {
            "dependencies": ["1.1"],
            "description": "Implement comprehensive $ref resolution with circular reference detection and external reference support",
            "details": "Build ref resolver that handles local refs (#/components/schemas/User). Implement circular reference detection using visited node tracking. Support external file references (./external.yaml#/definitions/Model). Create ref cache to avoid repeated resolution. Generate dependency graph for schema relationships.",
            "id": 3,
            "status": "pending",
            "testStrategy": "",
            "title": "Add Reference Resolution System"
          },
          {
            "dependencies": ["1.3"],
            "description": "Build system to handle schema inheritance through allOf, oneOf, anyOf, and discriminator patterns",
            "details": "Process allOf compositions by merging parent schemas. Handle discriminator-based polymorphism for oneOf/anyOf. Resolve property conflicts in inheritance chains. Generate proper Go type embeddings from inheritance. Create inheritance tree representation for templates.",
            "id": 4,
            "status": "pending",
            "testStrategy": "",
            "title": "Create Schema Inheritance Handler"
          },
          {
            "dependencies": ["1.2", "1.4"],
            "description": "Design and implement structured storage format for parsed OpenAPI data optimized for template consumption",
            "details": "Create ParsedSpec struct with schemas, paths, operations, and x-codegen data. Implement schema registry with normalized types and relationships. Build operation catalog with grouped endpoints by tag/resource. Add metadata store for component descriptions and examples. Serialize to JSON/YAML for debugging and caching.",
            "id": 5,
            "status": "pending",
            "testStrategy": "",
            "title": "Build Structured Data Storage Format"
          }
        ],
        "testStrategy": "Unit test with sample OpenAPI specs including edge cases (circular refs, deep nesting). Validate against OpenAPI 3.1.1 spec compliance. Test error handling for malformed specs.",
        "title": "Create OpenAPI Parser Module"
      },
      {
        "dependencies": [1],
        "description": "Create a flexible template engine for generating code from OpenAPI specs using Go templates",
        "details": "Extend infrastructure/templates package to support multi-language targets. Create template loader that reads from tmpl directory. Implement template functions for type mapping, naming conventions, and code formatting. Support template inheritance and partials. Add caching for compiled templates.",
        "id": 2,
        "priority": "high",
        "status": "pending",
        "subtasks": [],
        "testStrategy": "Test template compilation and execution with mock data. Verify generated code syntax for each target language. Test template function helpers with various inputs.",
        "title": "Design Template Engine System"
      },
      {
        "dependencies": [1, 2],
        "description": "Build Go code generator with hexagonal architecture support for backend services",
        "details": "Create generators for: entities in core/entities, repositories in core/ports/repositories, service interfaces in application/services, HTTP handlers in adapters/http/handlers, DTOs in application/dto. Follow existing patterns in internal/codegen/generators.go. Map OpenAPI types to Go types, handle nullable fields with pointers.",
        "id": 3,
        "priority": "high",
        "status": "pending",
        "subtasks": [],
        "testStrategy": "Generate code from test OpenAPI spec and compile it. Test type mappings for all OpenAPI data types. Verify generated code follows Go conventions and passes golangci-lint.",
        "title": "Implement Go Code Generator"
      },
      {
        "dependencies": [1],
        "description": "Generate SQLC queries and schema from OpenAPI specifications",
        "details": "Parse OpenAPI schemas to generate PostgreSQL DDL in infrastructure/persistence/postgres/migrations. Create SQLC query files in infrastructure/persistence/postgres/queries. Map OpenAPI types to PostgreSQL types. Handle relationships via x-codegen extensions. Generate indexes based on query patterns.",
        "id": 4,
        "priority": "high",
        "status": "pending",
        "subtasks": [],
        "testStrategy": "Generate schema and verify with PostgreSQL. Test SQLC compilation of generated queries. Validate foreign key constraints and indexes.",
        "title": "Create SQLC Schema Generator"
      },
      {
        "dependencies": [],
        "description": "Create project entity and repository for managing code generation projects",
        "details": "Create Project entity with fields: ID, Name, OpenAPISpec (JSON), Settings, CreatedAt, UpdatedAt. Implement PostgreSQL repository using SQLC. Add project CRUD operations via HTTP handlers. Store OpenAPI specs and generation configurations. Track generation history.",
        "id": 5,
        "priority": "high",
        "status": "pending",
        "subtasks": [],
        "testStrategy": "Integration test with PostgreSQL using testcontainers. Test CRUD operations through API endpoints. Verify project state persistence.",
        "title": "Build Project Management System"
      },
      {
        "dependencies": [5],
        "description": "Create service for provisioning and managing Docker containers per project",
        "details": "Create ContainerService in application/services using Docker SDK. Implement container lifecycle: create, start, stop, remove. Use Alpine Linux base with Go, Node.js, Python pre-installed. Mount project directories as volumes. Set resource limits (CPU, memory). Track container state in Redis.",
        "id": 6,
        "priority": "high",
        "status": "pending",
        "subtasks": [],
        "testStrategy": "Integration test with Docker API. Test container lifecycle operations. Verify resource limits enforcement. Test cleanup on project deletion.",
        "title": "Implement Docker Container Service"
      },
      {
        "dependencies": [6],
        "description": "Implement container orchestration for managing multiple project containers",
        "details": "Create orchestrator that manages container pool. Implement container scheduling and resource allocation. Add health checks and auto-restart. Handle container cleanup after idle timeout. Support concurrent container operations. Use Redis for distributed locking.",
        "id": 7,
        "priority": "medium",
        "status": "pending",
        "subtasks": [],
        "testStrategy": "Load test with multiple concurrent containers. Test auto-cleanup after timeout. Verify health check and restart logic. Test distributed locking with Redis.",
        "title": "Build Container Orchestration Layer"
      },
      {
        "dependencies": [6],
        "description": "Implement WebSocket server for real-time container communication",
        "details": "Extend adapters/http/server/websocket.go for container terminals. Use gorilla/websocket for WebSocket handling. Implement message routing between browser and container. Support multiple concurrent connections per project. Add authentication via JWT tokens.",
        "id": 8,
        "priority": "medium",
        "status": "pending",
        "subtasks": [],
        "testStrategy": "Test WebSocket connection lifecycle. Verify message routing with mock containers. Test concurrent connections handling. Validate JWT authentication.",
        "title": "Create WebSocket Server"
      },
      {
        "dependencies": [8],
        "description": "Create web-based terminal interface for container access",
        "details": "Create React component using xterm.js in web/platform. Implement terminal emulator with ANSI support. Connect to WebSocket for bidirectional communication. Handle terminal resize events. Add copy/paste support. Style with existing Tailwind theme.",
        "id": 9,
        "priority": "medium",
        "status": "pending",
        "subtasks": [],
        "testStrategy": "E2E test terminal interaction. Test ANSI escape sequences rendering. Verify resize handling. Test copy/paste functionality.",
        "title": "Implement Web Terminal"
      },
      {
        "dependencies": [6],
        "description": "Create API for container file system operations",
        "details": "Implement REST endpoints for: list files, read file, write file, create/delete files. Use Docker SDK for file operations in containers. Add file watching for change notifications via WebSocket. Implement file permissions and size limits.",
        "id": 10,
        "priority": "medium",
        "status": "pending",
        "subtasks": [],
        "testStrategy": "Test all CRUD operations on container files. Verify file watching notifications. Test permission enforcement and size limits.",
        "title": "Build File System API"
      },
      {
        "dependencies": [3],
        "description": "Build Claude API integration for AI-powered code refinement",
        "details": "Extend adapters/llm package with Claude client using Anthropic SDK. Implement context management for conversation history. Add prompt engineering for code generation tasks. Handle streaming responses for real-time updates. Store conversations in PostgreSQL.",
        "id": 11,
        "priority": "high",
        "status": "pending",
        "subtasks": [],
        "testStrategy": "Mock Claude API responses for testing. Test conversation context management. Verify streaming response handling. Test error recovery and retries.",
        "title": "Integrate Claude AI API"
      },
      {
        "dependencies": [11],
        "description": "Build context management system for AI interactions",
        "details": "Create service to manage AI context including: OpenAPI spec, generated code, file system state, user modifications. Implement context window optimization. Add semantic chunking for large codebases. Cache frequently accessed context in Redis.",
        "id": 12,
        "priority": "medium",
        "status": "pending",
        "subtasks": [],
        "testStrategy": "Test context assembly with various project sizes. Verify context window optimization. Test caching effectiveness. Validate semantic chunking.",
        "title": "Create AI Context Manager"
      },
      {
        "dependencies": [3],
        "description": "Create AST parser for code modification without full regeneration",
        "details": "Use go/ast package for Go code parsing. Implement AST modification functions: add method, modify struct, update imports. Preserve formatting and comments. Support multiple languages via tree-sitter. Create unified AST interface.",
        "id": 13,
        "priority": "medium",
        "status": "pending",
        "subtasks": [],
        "testStrategy": "Test AST parsing and modification for Go. Verify formatting preservation. Test edge cases like comments and build tags. Validate multi-language support.",
        "title": "Implement Code AST Parser"
      },
      {
        "dependencies": [11, 12, 13],
        "description": "Create engine for applying AI-suggested code modifications",
        "details": "Parse Claude responses for code modifications. Apply changes via AST manipulation. Validate modifications against OpenAPI spec. Implement rollback on validation failure. Track modification history for undo/redo.",
        "id": 14,
        "priority": "medium",
        "status": "pending",
        "subtasks": [],
        "testStrategy": "Test modification parsing and application. Verify spec validation after changes. Test rollback mechanism. Validate modification history.",
        "title": "Build AI Refinement Engine"
      },
      {
        "dependencies": [1, 2],
        "description": "Build generator for React components from OpenAPI schemas",
        "details": "Generate TypeScript React components from schemas. Create form components for request bodies. Build display components for responses. Use React Hook Form for forms. Apply Tailwind styles from design system. Generate Storybook stories.",
        "id": 15,
        "priority": "medium",
        "status": "pending",
        "subtasks": [],
        "testStrategy": "Compile generated TypeScript code. Test component rendering with React Testing Library. Verify form validation logic. Test Storybook story generation.",
        "title": "Create React Component Generator"
      },
      {
        "dependencies": [1],
        "description": "Generate TypeScript types and interfaces from OpenAPI specs",
        "details": "Map OpenAPI schemas to TypeScript interfaces. Handle union types for oneOf/anyOf. Generate enums from enum schemas. Create type guards for runtime validation. Support generic types for reusable components.",
        "id": 16,
        "priority": "medium",
        "status": "pending",
        "subtasks": [],
        "testStrategy": "Compile generated TypeScript with strict mode. Test type inference with complex schemas. Verify runtime type guards. Test enum generation.",
        "title": "Implement TypeScript Type Generator"
      },
      {
        "dependencies": [1, 16],
        "description": "Generate type-safe API clients for multiple languages",
        "details": "Generate Axios-based TypeScript client. Create fetch wrapper with types. Implement request/response interceptors. Add retry logic and error handling. Generate SDK documentation. Support multiple auth methods.",
        "id": 17,
        "priority": "medium",
        "status": "pending",
        "subtasks": [],
        "testStrategy": "Test generated client against mock server. Verify type safety with TypeScript. Test auth methods and interceptors. Validate error handling.",
        "title": "Build API Client Generator"
      },
      {
        "dependencies": [6, 15],
        "description": "Build server for live preview of generated applications",
        "details": "Create preview server running in containers. Implement hot-reload via file watching. Proxy requests between frontend and backend. Handle CORS for development. Support multiple preview environments.",
        "id": 18,
        "priority": "medium",
        "status": "pending",
        "subtasks": [],
        "testStrategy": "Test preview server startup in container. Verify hot-reload on file changes. Test proxy configuration. Validate CORS handling.",
        "title": "Create Preview Server"
      },
      {
        "dependencies": [15, 18],
        "description": "Build interactive playground for testing generated components",
        "details": "Create React app for component testing. Implement prop editor with JSON schema forms. Add viewport resize for responsive testing. Include theme switcher for dark mode. Export playground configurations.",
        "id": 19,
        "priority": "low",
        "status": "pending",
        "subtasks": [],
        "testStrategy": "E2E test playground interactions. Test prop editing and validation. Verify responsive preview. Test theme switching.",
        "title": "Implement Component Playground"
      },
      {
        "dependencies": [15],
        "description": "Create customizable design system generator",
        "details": "Generate design tokens from configuration. Create CSS variables and Tailwind config. Build theme editor UI with live preview. Support color palette generation. Add typography and spacing scales.",
        "id": 20,
        "priority": "low",
        "status": "pending",
        "subtasks": [],
        "testStrategy": "Test token generation and CSS output. Verify theme application in components. Test theme editor UI. Validate accessibility compliance.",
        "title": "Build Theme System"
      },
      {
        "dependencies": [4],
        "description": "Build database migration generator from OpenAPI changes",
        "details": "Detect schema changes between OpenAPI versions. Generate SQL migration files using goose format. Handle column additions, deletions, type changes. Create rollback migrations. Add migration validation before execution.",
        "id": 21,
        "priority": "medium",
        "status": "pending",
        "subtasks": [],
        "testStrategy": "Test migration generation for schema changes. Verify migration execution with PostgreSQL. Test rollback functionality. Validate data preservation.",
        "title": "Create Migration System"
      },
      {
        "dependencies": [3],
        "description": "Generate CI/CD pipeline configurations for major providers",
        "details": "Generate GitHub Actions workflows for testing and deployment. Create GitLab CI configurations. Include Docker build and push steps. Add test execution and coverage reporting. Configure deployment to cloud providers.",
        "id": 22,
        "priority": "low",
        "status": "pending",
        "subtasks": [],
        "testStrategy": "Validate generated YAML syntax. Test workflow execution in GitHub Actions. Verify Docker build steps. Test deployment configurations.",
        "title": "Implement CI/CD Generator"
      },
      {
        "dependencies": [3],
        "description": "Generate deployment configurations for cloud providers",
        "details": "Generate Kubernetes manifests with Helm charts. Create Docker Compose for development. Generate Terraform for infrastructure. Include environment configuration management. Add monitoring and logging setup.",
        "id": 23,
        "priority": "low",
        "status": "pending",
        "subtasks": [],
        "testStrategy": "Validate Kubernetes manifest syntax. Test Helm chart rendering. Verify Docker Compose configuration. Test Terraform plan execution.",
        "title": "Build Deployment Generator"
      },
      {
        "dependencies": [3, 15],
        "description": "Generate comprehensive test suites for generated code",
        "details": "Generate unit tests using testify for Go. Create React Testing Library tests for components. Generate API integration tests. Add fixtures from OpenAPI examples. Include test coverage configuration.",
        "id": 24,
        "priority": "medium",
        "status": "pending",
        "subtasks": [],
        "testStrategy": "Execute generated tests and verify pass rate. Check test coverage metrics. Validate fixture generation. Test mock generation.",
        "title": "Create Test Suite Generator"
      },
      {
        "dependencies": [3, 15],
        "description": "Generate comprehensive documentation for generated code",
        "details": "Generate API documentation from OpenAPI spec using Redoc. Create component documentation with props tables. Generate README files with setup instructions. Add inline code comments. Create architecture diagrams.",
        "id": 25,
        "priority": "low",
        "status": "pending",
        "subtasks": [],
        "testStrategy": "Validate generated markdown syntax. Test documentation site build. Verify component prop documentation. Check diagram generation.",
        "title": "Implement Documentation Generator"
      },
      {
        "dependencies": [2],
        "description": "Create system for sharing and discovering code templates",
        "details": "Create template registry with metadata. Implement template versioning and updates. Add template rating and reviews. Build search and filtering UI. Support private team templates.",
        "id": 26,
        "priority": "low",
        "status": "pending",
        "subtasks": [],
        "testStrategy": "Test template upload and download. Verify versioning system. Test search functionality. Validate access controls.",
        "title": "Build Template Marketplace"
      },
      {
        "dependencies": [2, 3],
        "description": "Build extensible plugin architecture for custom generators",
        "details": "Define plugin interface for generators. Implement plugin loader with sandboxing. Support WASM plugins for security. Add plugin configuration system. Create plugin development SDK.",
        "id": 27,
        "priority": "low",
        "status": "pending",
        "subtasks": [],
        "testStrategy": "Test plugin loading and execution. Verify sandboxing security. Test plugin communication. Validate configuration handling.",
        "title": "Create Plugin System"
      },
      {
        "dependencies": [3, 15],
        "description": "Build security vulnerability scanner for generated code",
        "details": "Integrate with security scanning tools like Snyk. Check for SQL injection vulnerabilities. Scan for XSS in frontend code. Validate authentication implementation. Check dependency vulnerabilities.",
        "id": 28,
        "priority": "medium",
        "status": "pending",
        "subtasks": [],
        "testStrategy": "Test vulnerability detection accuracy. Verify false positive rate. Test integration with scanning tools. Validate remediation suggestions.",
        "title": "Implement Security Scanner"
      },
      {
        "dependencies": [18],
        "description": "Create performance analysis tools for generated applications",
        "details": "Implement bundle size analysis for frontend. Add backend performance profiling. Create database query analyzer. Generate performance optimization suggestions. Add lighthouse integration for web vitals.",
        "id": 29,
        "priority": "low",
        "status": "pending",
        "subtasks": [],
        "testStrategy": "Test bundle size calculation accuracy. Verify profiling data collection. Test query analysis. Validate optimization suggestions.",
        "title": "Build Performance Analyzer"
      },
      {
        "dependencies": [5, 6],
        "description": "Build comprehensive admin dashboard for project management",
        "details": "Create React dashboard in web/platform using existing UI components. Show project metrics and generation history. Display container resource usage. Add user management interface. Include billing and usage analytics.",
        "id": 30,
        "priority": "medium",
        "status": "pending",
        "subtasks": [],
        "testStrategy": "E2E test dashboard functionality. Test real-time metric updates. Verify user management operations. Test billing calculations.",
        "title": "Create Admin Dashboard"
      },
      {
        "dependencies": [1, 3],
        "description": "Fix the code generator to properly extract and generate Go structs for inline request and response schemas from OpenAPI specifications instead of referencing non-existent DTOs",
        "details": "The code generator needs to be updated to handle inline schemas defined directly in OpenAPI request/response bodies. The fix involves:\n\n1. **Enhance inline schema extraction in parsers/openapi.go**:\n   - Update ExtractOperations() to capture inline request body schemas (lines 168-199)\n   - Extract actual field definitions from inline schemas in request bodies\n   - Store inline schema definitions with generated names like 'RequestMagicLinkRequestBody'\n   - Handle inline response schemas similarly for 200/201 responses\n\n2. **Update generateOperationDTOs() in codegen/generators.go**:\n   - Parse inline request body schemas from OpenAPI spec when RequestBodySchema has 'RequestBody' suffix\n   - Extract fields from the inline schema using FieldExtractor\n   - Generate proper struct fields with correct Go types\n   - Handle nested objects and arrays in inline schemas\n\n3. **Modify the echo_server.tmpl template**:\n   - Generate inline structs directly in handler file when DTOs don't exist\n   - Add fallback logic to check if DTO exists before referencing it\n   - For inline schemas, generate the struct definition in place\n\n4. **Key files to modify**:\n   - internal/parsers/openapi.go: ExtractOperations() method to capture inline schemas\n   - internal/codegen/generators.go: generateOperationDTOs() to properly extract and generate inline schemas\n   - internal/codegen/tmpl/echo_server.tmpl: Add inline struct generation capability\n   - internal/codegen/tmpl/dto.tmpl: Ensure it can handle inline schema fields\n\nExample fix for requestMagicLink:\n- Parse inline schema from api/paths/auth_magic-link.yaml lines 11-36\n- Extract fields: identifier (string), deliveryMethod (string enum), redirectUrl (string)\n- Generate RequestMagicLinkRequestBody struct with these fields\n- Similarly for response: message (string), otpCode (string), expiresIn (int), token (MagicLinkToken ref)",
        "id": 31,
        "priority": "high",
        "status": "pending",
        "subtasks": [],
        "testStrategy": "1. Create test OpenAPI spec with inline request/response schemas\n2. Run code generator and verify DTOs are created for inline schemas\n3. Compile generated code and ensure no missing type references\n4. Verify requestMagicLink generates RequestMagicLinkRequestBody with correct fields\n5. Test with various inline schema types: simple objects, nested objects, arrays\n6. Ensure backward compatibility with referenced schemas ($ref)\n7. Run 'make generate' on the full project and verify all handlers compile\n8. Check that auth.gen.go properly imports and uses generated inline DTOs",
        "title": "Fix inline request/response schema code generation"
      }
    ]
  }
}
