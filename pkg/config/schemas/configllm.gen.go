// Code generated by archesai. DO NOT EDIT.

package schemas

import (
	"fmt"
	"strings"
)

// ConfigLLMType represents the enumeration of valid values for Type
type ConfigLLMType string

// Valid Type values
const (
	ConfigLLMTypeOllama ConfigLLMType = "ollama"
	ConfigLLMTypeOpenai ConfigLLMType = "openai"
)

// String returns the string representation
func (e ConfigLLMType) String() string {
	return string(e)
}

// IsValid checks if the value is valid
func (e ConfigLLMType) IsValid() bool {
	switch e {
	case ConfigLLMTypeOllama:
		return true
	case ConfigLLMTypeOpenai:
		return true
	default:
		return false
	}
}

// ParseConfigLLMType parses a string into the enum type
func ParseConfigLLMType(s string) (ConfigLLMType, error) {
	v := ConfigLLMType(s)
	if !v.IsValid() {
		return "", fmt.Errorf("invalid Type: %s", s)
	}
	return v, nil
}

// ConfigLLM represents Large Language Model configuration
type ConfigLLM struct {

	// Endpoint LLM service endpoint URL
	Endpoint *string `json:"endpoint,omitempty" yaml:"endpoint,omitempty"`

	// Token Authentication token for LLM service
	Token *string `json:"token,omitempty" yaml:"token,omitempty"`

	// Type LLM provider type
	Type ConfigLLMType `json:"type" yaml:"type"`
}

// NewConfigLLM creates a new immutable ConfigLLM value object.
// Value objects are immutable and validated upon creation.
func NewConfigLLM(
	endpoint *string,
	token *string,
	type_ ConfigLLMType,
) (ConfigLLM, error) {
	// Validate required fields
	if !type_.IsValid() {
		return ConfigLLM{}, fmt.Errorf("invalid Type: %s", type_)
	}
	return ConfigLLM{
		Endpoint: endpoint,
		Token:    token,
		Type:     type_,
	}, nil
}

// ZeroConfigLLM returns the zero value for ConfigLLM.
// This is useful for comparisons and as a default value.
func ZeroConfigLLM() ConfigLLM {
	return ConfigLLM{}
}

// GetEndpoint returns the Endpoint value.
// Value objects are immutable, so this returns a copy of the value.
func (v ConfigLLM) GetEndpoint() *string {
	return v.Endpoint
}

// GetToken returns the Token value.
// Value objects are immutable, so this returns a copy of the value.
func (v ConfigLLM) GetToken() *string {
	return v.Token
}

// GetType returns the Type value.
// Value objects are immutable, so this returns a copy of the value.
func (v ConfigLLM) GetType() ConfigLLMType {
	return v.Type
}

// Validate validates the ConfigLLM value object.
// Returns an error if any field fails validation.
func (v ConfigLLM) Validate() error {
	if !v.Type.IsValid() {
		return fmt.Errorf("invalid Type: %s", v.Type)
	}
	return nil
}

// IsZero returns true if this is the zero value.
func (v ConfigLLM) IsZero() bool {
	zero := ZeroConfigLLM()
	// Compare using string representation as a simple equality check
	return v.String() == zero.String()
}

// String returns a string representation of ConfigLLM
func (v ConfigLLM) String() string {
	var fields []string
	fields = append(fields, fmt.Sprintf("Endpoint: %v", v.Endpoint))
	fields = append(fields, fmt.Sprintf("Token: %v", v.Token))
	fields = append(fields, fmt.Sprintf("Type: %v", v.Type))
	return fmt.Sprintf("ConfigLLM{%s}", strings.Join(fields, ", "))
}
